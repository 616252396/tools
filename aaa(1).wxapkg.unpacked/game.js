define("index.js", function (require, module, exports) {
    window.screenOrientation = "sensor_landscape", loadLib("libs/laya.core.js"), loadLib("libs/laya.ui.js"), loadLib("libs/laya.d3.js"), loadLib("js/bundle.js");
});
define("js/bundle.js", function (require, module, exports) {
    !function () {
        "use strict";

        class RandomUtil {
        }

        RandomUtil.randomIntegerN2M = function (n, m) {
            return Math.floor(Math.random() * (m - n + 1) + n)
        }, RandomUtil.randomFloat = function (min, max) {
            var range = max - min;
            return min + Math.random() * range
        }, RandomUtil.probabilityCanHappen = function (num) {
            return RandomUtil.randomIntegerN2M(0, 100) <= num
        }, RandomUtil.probabilitys = function (parr) {
            var arr = 0, pres = ML.JQuery.clone(parr), probabilityCount = 0;
            for (let i = 0; i < pres.length; i++) probabilityCount += pres[i];
            100 != probabilityCount && console.error("所有概率值总和不等于100%");
            var nums = new Array;
            for (let i = 0; i < pres.length; i++) {
                const element = pres[i];
                for (let index = 0; index < element; index++) nums.push(arr);
                arr++
            }
            return nums[RandomUtil.randomIntegerN2M(0, 99)]
        }, RandomUtil.weight = function (weigths) {
            let flag = 0, total = 0, tempWeigths = ML.JQuery.clone(weigths);
            for (let i = 0; i < tempWeigths.length; i++) {
                total += tempWeigths[i]
            }
            let nums = [];
            for (let i = 0; i < tempWeigths.length; i++) {
                let weigth = tempWeigths[i];
                for (let j = 0; j < weigth; j++) nums.push(flag);
                flag++
            }
            return nums[RandomUtil.randomIntegerN2M(0, total - 1)]
        };

        class BestShowScene extends Laya.View {
            constructor() {
                super()
            }

            onOpened(data) {
                this._shareBtn.on(Laya.Event.CLICK, this, this._onShareClick), this._skipBtn.on(Laya.Event.CLICK, this, this._onSkipClick), this._rotateIcon.rotation = 0, this.upBgRotation = 0;
                let index = RandomUtil.randomIntegerN2M(1, 4);
                this._slogen.skin = "bestShow/title" + index + ".png"
            }

            onEnable() {
                Laya.timer.frameLoop(1, this, this.onUpdate)
            }

            onDisable() {
                Laya.timer.clearAll(this)
            }

            onUpdate() {
                this.upBgRotation += 2, this._rotateIcon.rotation = this.upBgRotation
            }

            _onShareClick() {
                console.log("bestShow share"), ML.wx.shareDefault()
            }

            _onSkipClick() {
                ml.game.quitGame()
            }
        }

        class CompleteScene extends Laya.View {
            constructor() {
                super()
            }

            onOpened(data) {
                if (console.log("data:", data), this.data = data, this.levelUp = !1, this.rankIndex = data.rank || 0, 2 == data.type) {
                    let players = ML.entity.getEntityGroup("Player").entityLogics;
                    this.rankIndex = players.length
                }
                let rankInfo = ML.config.getRankInfo(this.rankIndex);
                this._rankTitle.text = rankInfo.title, this._rankExpLabel.text = "+ " + rankInfo.rankScore, this._getGoldLabel.text = rankInfo.gold, this._videoGoldLabel.text = 3 * rankInfo.gold;
                let newRankScore = ML.user.addRankScore(rankInfo.rankScore), oldRankLv = ML.user.getRankLv(),
                    rankTitleInfo = ML.config.getRankTitleInfoByScore(newRankScore), newRankLv = rankTitleInfo.lv,
                    rankLvProgress = ML.config.getRankTitleProgress(newRankLv, newRankScore);
                this._rankImage.skin = rankTitleInfo.titleIcon, this._rankDes.text = rankTitleInfo.des, this._rankBar.width = 100 * rankLvProgress, oldRankLv != newRankLv && (this.levelUp = !0), this.rankTitleInfo = rankTitleInfo, this.rankInfo = rankInfo
            }

            onEnable() {
                this._getGoldBtn.on(Laya.Event.CLICK, this, this._onGetGoldClick)
            }

            onDisable() {
            }

            _onGetGoldClick() {
                ML.user.addGold(this.rankInfo.gold);
                let bestShow = 0 == this.rankIndex;
                this.levelUp ? Laya.Scene.open("levelUpView.scene", !0, {
                    rankInfo: this.rankTitleInfo,
                    bestShow: bestShow
                }) : bestShow ? Laya.Scene.open("bestShowView.scene") : ml.game.quitGame()
            }
        }

        class FailScene extends Laya.View {
            constructor() {
                super()
            }

            onAwake() {
                this._reviveBtn.on(Laya.Event.CLICK, this, this._onReviveCLick), this._reviveVideo.on(Laya.Event.CLICK, this, this._onReviveFreeCLick), this._skipBtn.on(Laya.Event.CLICK, this, this._onSkipClick), this._reviveGoldLabel.text = 300
            }

            onEnable() {
                this.countdown = 0, this.showCountdown(0), Laya.timer.loop(1e3, this, this._countdownLoop)
            }

            _countdownLoop() {
                if (this.countdown >= 5) return Laya.timer.clear(this, this._countdownLoop), void ml.game.overGame(2);
                this.countdown++, this.showCountdown(this.countdown)
            }

            showCountdown(num) {
                this._countdown.skin = ["fail/5.png", "fail/4.png", "fail/3.png", "fail/2.png", "fail/1.png"][num]
            }

            _onReviveCLick() {
                if (ML.user.UserData.gold < 300) return ML.wx.showToast("金币不足"), void console.log("金币不足");
                Laya.Scene.close("failView.scene"), ML.user.addGold(-300), ml.player.revive(), this.close(), ml.game.revive()
            }

            _onReviveFreeCLick() {
            }

            _onSkipClick() {
                ml.game.overGame(2)
            }

            onDisable() {
                Laya.timer.clear(this, this._countdownLoop)
            }
        }

        class Tools {
        }

        Tools.Deg2Rad = .01745329, Tools.Rad2Deg = 57.29578, Tools.GUID = function (len, radix) {
            var i, r, chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), uuid = [];
            if (radix = radix || chars.length, len) for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random() * radix]; else for (uuid[8] = uuid[13] = uuid[18] = uuid[23] = "-", uuid[14] = "4", i = 0; i < 36; i++) uuid[i] || (r = 0 | 16 * Math.random(), uuid[i] = chars[19 == i ? 3 & r | 8 : r]);
            return uuid.join("")
        }, Tools.RandomSort = function (arr) {
            return arr.sort(() => Math.random() > .5 ? -1 : 1)
        }, Tools.IsNumber = function (obj) {
            return obj === +obj
        }, Tools.Random = function (min, max) {
            var range = max - min, rand = Math.random();
            return min + Math.floor(rand * range)
        }, Tools.RandomOne = function (arr) {
            return arr && 0 != arr.length ? arr[Tools.Random(0, arr.length)] : null
        }, Tools.Clamp = function (value, min, max) {
            return value <= min ? min : value >= max ? max : value
        };

        class GameScene extends Laya.View {
            constructor() {
                super()
            }

            onAwake() {
                this.rSpeedx = 100, this.rSpeedy = 200, this.curxR = 0, this.curyR = 0, this.fingerOrignalx = this._finger.x, this.fingerOrignaly = this._finger.y, ml.gameView = this, Laya.loader.load(["res/comp/border3.png"], Laya.Handler.create(this, this.setup))
            }

            setup() {
                let mask = new Laya.Sprite;
                mask.graphics.drawTexture(Laya.loader.getRes("res/comp/border3.png")), this._scoreBar.mask = mask
            }

            onEnable() {
                ml.game.pauseGame(), ML.event.on("onStageMouseDown", this, this.onStageMouseDown), ML.event.on("PlayerLevelUp", this, this.onPlayerLevelUp), this.showTip = !0, Laya.timer.frameLoop(1, this, this.onUpdate), Laya.timer.loop(500, this, this.setCountdown), this.startCountdown = 0, this.showStartCountdown(0), Laya.timer.loop(500, this, this._startCountdown), this._levelUpTip.visible = !1
            }

            onDisable() {
                Laya.timer.clearAll(this)
            }

            onStageMouseDown() {
                this._tipImage.visible = !1, this.showTip = !1
            }

            onPlayerLevelUp(player) {
                this._levelUpTip.visible = !0, Laya.timer.once(1e3, this, () => {
                    this._levelUpTip.visible = !1
                })
            }

            _startCountdown() {
                if (this.startCountdown >= 4) return Laya.timer.clear(this, this._startCountdown), this._startCountdownIcon.visible = !1, void ml.game.resumeGame();
                this.startCountdown++, this.showStartCountdown(this.startCountdown)
            }

            showStartCountdown(num) {
                this._startCountdownIcon.skin = ["game/3.png", "game/2.png", "game/1.png", "game/go.png"][num]
            }

            setCountdown() {
                if (this._countdownLabel.text = ml.game.mode.getCountdownStr(), ml.player) {
                    this._scoreLabel.text = ml.player.score;
                    let score = ML.config.getLevelScoreInGame(ml.player.levelData.lv + 1);
                    this._scoreBar.width = score ? ml.player.score / score * 151 : 151
                }
            }

            onUpdate() {
                if (!this.showTip) return void Laya.timer.clear(this, this.onUpdate);
                this.curxR += .016 * this.rSpeedx, this.curyR += .016 * this.rSpeedy;
                let x = 145 * Math.cos(this.curxR / Tools.Rad2Deg), y = 55 * Math.sin(this.curyR / Tools.Rad2Deg);
                this._finger.pos(this.fingerOrignalx + x, this.fingerOrignaly + y)
            }
        }

        class HomeScene extends Laya.View {
            constructor() {
                super()
            }

            onEnable() {
                ml.homeView = this, this._startBtn.on(Laya.Event.CLICK, this, this._startClick), this._moreGameBtn.on(Laya.Event.CLICK, this, this._moreClick), this._shareBtn.on(Laya.Event.CLICK, this, this._shareClick), this._goldLabel.text = ML.user.getGold()
            }

            onDisable() {
            }

            _startClick() {
                ML.audio.playEffect("kill"), ml.game.loadGame()
            }

            _moreClick() {
            }

            _shareClick() {
            }
        }

        class LevelUpScene extends Laya.View {
            constructor() {
                super()
            }

            onOpened(data) {
                this.data = data, this._shareBtn.on(Laya.Event.CLICK, this, this._onShareClick), this._skipBtn.on(Laya.Event.CLICK, this, this._onSkipClick), this._levelIcon.skin = data.rankInfo.titleIcon, this._rotateIcon.rotation = 0, this.upBgRotation = 0
            }

            onEnable() {
                Laya.timer.frameLoop(1, this, this.onUpdate), ML.audio.playEffect("rankUp")
            }

            onDisable() {
                Laya.timer.clearAll(this)
            }

            onUpdate() {
                this.upBgRotation += 2, this._rotateIcon.rotation = this.upBgRotation
            }

            _onShareClick() {
                ML.wx.shareDefault()
            }

            _onSkipClick() {
                this.bestShow ? Laya.Scene.open("bestShowView.scene") : ml.game.quitGame()
            }
        }

        class NicknameUtil {
        }

        NicknameUtil.RandomNickname = function () {
            return Tools.RandomOne(["黑大叔", "仁青卓玛", "谢明秋", "刘碧仙", "开心就好", "小雨淅淅", "啊英", "田老六", "丽丽", "永恒", "老汪", "秀丽媤化妆品～小郭", "校长真2", "老孟", "流星雨", "等待", "雷", "平凡的人", "心雨", "施卫兵", "芬", "彼岸花开", "雪儿", "别把疼你的人弄丢了", "蒋慧", "泽泽", "?lex?", "浩浩", "小胖", "快乐", "倒行逆施", "王雅滢", "屮", "jakey", "买吐孙", "庸展", "赶时髦di老妈", "陈", "小宝贝", "老俞", "cui li", "姚春杰", "娟", "朱玉华", "小小", "文陀", "詹益芳", "宝宝", "潘", "六六", "社会人慕夏", "王梓硕的奶奶", "我本无名", "君君", "知足长乐", "ZHAO", "树桂", "记事本", "jtmjmj", "许浩泽", "老魏", "唯心", "点亮梦想", "蔷薇", "Vivi", "冬梅", "黄秀容", "开心", "Lucia", "景金", "毛艳梅", "李小木", "美珍", "回忆", "朱志明", "福财", "王晨", "石岩者", "webber", "hymainbowbow", "朱玉红", "龚竹秀", "张老大", "财源广进", "废材在燃烧", "坚持@_@", "邬润花", "金银花", "日光微暖夏亦凉", "三分霸气，七分温柔", "李建枝", "王心良", "爱发脾气的光头谦", "为了自己", "温柔的背后", "幸福安康", "世华", "思钱想厚", "A花开花落", "花好月圆", "LKF", "裕容", "香益芬芳", "Aimee", "伍良生", "杨蒙豪", "金苹果", "baht  lik man", "燕", "落幕", "陈雅静", "余正生", "橘梨纱", "奔奔", "郑育峰电信2", "昊宝贝", "珠宝", "时间都去哪儿了", "快乐宝贝", "陈小桃", "新的一天", "顺其自然", "明天更好", "茉莉花", "珍宝", "肖永国", "恒兰", "王国贤", "阿康", "六妹", "乐呵儿呵儿?", "清泉", "Kevin", "红梅", "李二姐", "涂均", "A 标识 平面 影视", "追梦齐飞", "心為誰碎", "石头", "怺忄亘の薆", "paradox", "Cherry@开心网", "茜～", "阿桑奇的喵要饿死了", "啊关关", "追风少年", "涛", "蔡姐", "126779", "RUAnROng", "妈桥", "YiYi麻麻", "随心", "Let_Go", "猫叔", "家", "明如琥珀", "张勤", "周", "转角记", "勿忘初心", "雄鹰", "长歌", "欢天喜地", "Jack 陳", "兰博基尼", "小熊熊", "张妤", "叶锦阶4。", "金花", "蓝碟恋", "白浩然", "胖胖甜", "杨俊", "萍水相蓬", "葛永华", "小鱼儿", "秋水一帆", "老朋友", "咖啡污", "tanha yigit", "黄德周", "雪中飞", "水泉", "飞越梦想", "绍怀", "完美", "kiki", "阿飞", "梅", "老何", "转折点", "许氏青菜专业种植户", "聚宝盆", "杨婧依", "花好月圆", "ma", "李玻", "清风明月", "品源丨小吴", "罗家老汉", "政童", "睿迈电器", "睿迈电器", "紫依", "清静晓月", "迷茫", "黄鑫芳", "随梦而飞", "鸡蛋汉堡", "燕", "ambition", "忠", "小何", "渐行渐远", "沈Azrael", "Aaron", "海洋", "卫平", "兰花", "幸福一家", "喜之郎", "丽燕", "快樂一生", "十五、月不圆", "笑", "徐梓皓", "一晨", "献丽", "南帝北丐", "沉默停在半空", "恩泽", "缘份天空", "【陈先生】", "甜甜", "清", "快乐宝贝", "秋天里的花", "宸宸佑佑的奶奶", "青玉", "椰子汁", "醒", "Mr 陈", "脸红 炽热", "丽丽", "谢小红", "痛苦的回忆", "乔小乔", "黄少勇", "从头在来", "紅紅", "琴", "猪仔"])
        }, NicknameUtil.randomHead = function () {
            return Tools.RandomOne(["https://wx.qlogo.cn/mmopen/vi_32/xbFh8dFmFeKibmBePyzicCPUzQttfcPOiaVv5uXGib0Vlz39FH0szekaGrPREfyay7rAKySFHu41L27mn2OtEFwqlQ/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6r39SYmez0gleukR2KyOItp1ASicVQCcGqAfvtLZEKA6GKzsNuHgiaVg2LbeO7voqo4wV6Qw4LknA/132", "https://wx.qlogo.cn/mmopen/vi_32/9viawLZRJqN8FR2pk3t7yhYorpBeYxZiabNcgRqnpdjCw3iab5BchG42mPcA6PR2P9OxgyM0X1iaUQS6YgEt8UfTqA/132", "https://wx.qlogo.cn/mmopen/vi_32/0SfeYOesAM6oIcbYibas3Lsvfl1qic19LkVETqIBuQibaPzrqlia6yr97PYt2xsIUGdz97qXaYsFiaOHoCicFMolNCcQ/132", "https://wx.qlogo.cn/mmopen/vi_32/ETiatEj1TGib1Wa1PdNbo9h66JhxGn5wpT64ymdibaMK4f5csia8OibMN6bKPMaw3u9NqqibKnk5Jibdxf6j9keuicMQoQ/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6bYv3mZzEEB4iaeb137hColCU3weLOjAW9adrnV7nC1xTdYME8R01bfF7uOnjc7wSdhKa6jTia73w/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYZIjajTjXiaeeX9gmG4mmT5ic1NMbiasLDLZMp7bfC2f2YSavj82nlYcT3jo2KML4DzWXAxibkUib9uw/132", "https://wx.qlogo.cn/mmopen/vi_32/mt49O2iadRbwgSzUg1Qy0wOv4QzNAMJhaJkS1Qk8Bu4gsx2FHYMVKWn71yqqubrKxlzBTP2z7HG6bGjb2icS9nbw/132", "https://wx.qlogo.cn/mmopen/vi_32/Cscefc9GHhdYHxtl3GzAKgLc5r2pTTfxjjXpk8I15DuPmJFsR548qxN2Lhiap20eN5VBwlHicQkALUnMtqT1112A/132", "https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoibSf0obWpV09qWiaURVkyFpYB088KhOKSx8nZyZQiaPvt6mK0xzeB6wExljPrGttCqXxw5GE6Uds2w/132", "https://wx.qlogo.cn/mmopen/vi_32/d59XAAVRFJe3EazOmOpibsQFTCXupE4stPxp7Qicy7vwRnRsp9IpnraJyCUSQ2yCDNrodf1sJicOjJEN0dDHC8onA/132", "https://wx.qlogo.cn/mmopen/vi_32/6yQsJXY1Sl3plMAKNuslHwzic7eickdx4NaSefbgWHYEOCEMkssDfwrt3ulWmbZXtW1qyXeBwvYSjFjVP8OyNupw/132", "https://wx.qlogo.cn/mmopen/vi_32/6F352TrXJjsTJfwNNdbIiczJUFjGSG97yuyjVTdVN1Kib6PELXBSf6807ianZ6cicvesef8KIQbGYNQgcvOorJzruA/132", "https://wx.qlogo.cn/mmopen/vi_32/2xJGicMezY4OthsOiaIIF4QtZAlACTc3HP2yNibqARHAyZxNfViagYiavQmgqwCcQN3NnmCfH1wUjkKJKwhsSCWmliag/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL010a7ZoTTzia9mZCeC9kUEwyJu7822hZ7C11iab6Jva5wNFWeRrGKLia19kbDJgrzn6IQfSFIOiaz4Q/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ1YU8BibcSSkXjsKgj8PG0CEx9zDm5SAiaSCRDWnkdYXvbrqJvFicS1ZC0jJxWWPLOP38KLr5xibibuGA/132", "https://wx.qlogo.cn/mmopen/vi_32/ibkP4RGoxicFDnQY7AcVB7hev6FVY2wIw6ZcSIzVjMxicwS2HwGCfsq4lQUJ6iaEcRR7jM8b75cgnqpZYhMUiaMPy6Q/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLq3vkzKIPkpsa0ZWcAZnZy3hDowqjLeO3NibjJUvvDR5slfBBIgficyhqXvNyicLHakvVic5AB1xowGA/132", "https://wx.qlogo.cn/mmopen/vi_32/OEHgwTKjpOLoJcXU7ia5zkufwnrUwcCyRQTPHta71g1dR5orxdWMvzHibIUUicX8LZ0MCibtTSgjoEylMS6KPdsVow/132", "https://wx.qlogo.cn/mmopen/vi_32/odssFUNsUz4FnvIzk41G7CNehicwkxCKqhbhazprGodS90ug7pkq9vbv79vZic09ZD2W3NIRuSQ1rE0WwRxRdZ8w/132", "https://wx.qlogo.cn/mmopen/vi_32/55JMqCtSp7cJoSxGd7PSVPGbndczZ48XaMn2KZ4o0tia67WBVkj25j1PrgeUyk0iagiaKWQz1Uz4Xfe02PW41VFuA/132", "https://wx.qlogo.cn/mmopen/vi_32/SXXGNrFASwZf7Dr1k7WLzsHZDbK0Glc6H0wKepOcibUGaja8XuZCBF33r2bUhMwdsr69XIQiceiaPdIiavkhwyiaJlw/132", "https://wx.qlogo.cn/mmopen/vi_32/zw6uzCUliaak8P3WqX580BmaoH69MYibZScyvA2oib87Tot1MzVbWKeAb8picJdauJlRic9MhWxhLU3RKwCtVE8hPDg/132", "https://wx.qlogo.cn/mmopen/vi_32/CrhET5lYkOOyPRvhG3ibdDtShJk2UmwqyibbC9XT9ypzlbAOPttr3ysTMDV9H20ahBPGickxBxJDibNAQvwDNjzenQ/132", "https://wx.qlogo.cn/mmopen/vi_32/w7GlNWmVAwJoNxqwSwJHJsicMQmUrPicmZibKQfgPr4nyLPPKa9k0rDmlMLWYSoHAvEWYJUkicrcWSFLv6XwPpyemg/132", "https://wx.qlogo.cn/mmopen/vi_32/JPcCJiabb9uMV1kEWknw2iaZ2oD3o2e5brK1YFwgdqzBoDyfibY9hu3hzjOPic6iaHHib3MPYM0RPOgJ8pTehicCzwxfg/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLECf8usseL8C4M9d2b1t9Da5SJkUWkmp7jyqiciaEMNDqKiaFMFyneRU8QzMfvUOmBJUiaE13iauOFqtQ/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJFkZ1CdGLb8Q00rRuPFPicsShMtMlRWhHKdybHVcrSHib7hnic16BvicXZJ1ZZqmF3vPGosmw1FqnV2A/132", "https://wx.qlogo.cn/mmopen/vi_32/TL8ialqhxvhXMJmkhHZ3VHu0KmzAInjicvtJ2gL852TPPibY4ibnecScjaJhyFnjGE7iclYk69nogml6taMiblZQJ6EQ/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBzo0I0BqdFInCC96vcBdVIHTicW2iavWZepGuWhaQ3Rja2omcmTYXDthrrsWOarNszS89ZtChOzqA/132", "https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eokSpicZYkXcibOhbiafYhXKxrNkiboW3ZdqSVicbNnvTIpnCqxt0d4wb8dD9q3EqD25FTd7QGcvAWxbgw/132", "https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoQjGRrNB4VymJX07yE2bzdOJXJnVcP9rib9GAyYDKKpM23hQib8mr23PJsBibHjyAFBqPIKlj5I1MJw/132", "https://wx.qlogo.cn/mmopen/vi_32/R6ecFZVGQCfpGbUZyUaKYRB2fyNticP9AWOgf4dMsJwWE6tEwnV7MIrAdxdAC1VllkR34MvurBJ2AsN0Vfibs6Lw/132", "https://wx.qlogo.cn/mmopen/vi_32/DvDIiamGL2iaCBhca1hEqfiaG3xm6zPSIHbl7bicP3ia0dMd5W2jgh47ToUyN0ib41fAMlW7FEPMLb84bIshNwRFK3bA/132", "https://wx.qlogo.cn/mmopen/vi_32/xBTu1ROC2LlxA3nsQgoM0dia9X6vISGXjsxK13BNytTnAoI8jicltiaEdz26MXxwfB6bdxyc1Fqn1q2ticFic2bAtiaw/132", "https://wx.qlogo.cn/mmopen/vi_32/qhfU2nHHpLeCEnZMBCDLnAich0vKgKz30zOmGyJ8SMQibau4Ow35T2AEN7rjUC5ib0VAhEbjpKGrHgC16D1z47DPA/132", "https://wx.qlogo.cn/mmopen/vi_32/L2qia0iawPhLz6puUqLAqVWRWxTxEsFKvia0PPiaSe1zWXaxESDbhjWxiaic89icxvAfz0PZUBzSdIwKEibxJRw576Q4Aw/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJiaZlM5Jfa8nXuCOW5j4Hv72Y0r2wdbHDib5xHibH5Vcj2dL276bhtfDMzyb0O65iceVpzGxkTSnw79g/132", "https://wx.qlogo.cn/mmopen/vi_32/tLR3zJF8c9POyQeft5r3tt2JFUDfKPyMY8gp95iaYLDQCxCZiaoMp5qcbUocNPxv58Xc8qoScFuF5JfSqxicDRBQQ/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJrj9bk0ecCA5xy5I6vdfo1Df5NDVgOkFIx0lD8tzeTHRjJxBpT6ZC3pqmibTaMGZiaxKdEKnowRQyw/132", "https://wx.qlogo.cn/mmopen/vi_32/icJDL3EAdV2pbbopJiblJOWZ0PHgtyeibiaIUd9ecC2zMy1iayQ9nyxV1XocxMUeiadtOZfKxaB0JYg6FLsWt1DETT6w/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0c3nkicWaVicq0ibbUVxkOcn3YpGFFwjf9qWIicpnPHaicXLBdInVHchgSLmMn1qcz3vicVYvAmL7V7icQ9diaCwIsdAw/132", "https://wx.qlogo.cn/mmopen/vi_32/8sDmOyt5lVFiceNPicznkPG8Tiaiak6jrEfg8d2NNAsaKmZolNcnfDBericZaFITbVm0a87CNicvgbAjicArPdoNk7mNA/132", "https://wx.qlogo.cn/mmopen/vi_32/gtmosZEWBnlUYib5ZTmZLtHZIUVnFZkEYyiahRK5caFpY6UiaPEbg2dPeKl1hQiaicTeLmFN0ibicdQsMHESfgZuyPdZQ/132", "https://wx.qlogo.cn/mmopen/vi_32/kxeGtlHbibtcNZtlibnAlTNDIQVRobJUkicHGKK9lTM4sU0uiaT09HjWKib2yiarvnibS6fSfpqFbAic3qQRpYKne9LQgQ/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKt9b85SH8StThEJXfEG2FC9sw5iagk2zxOwZn17o8iajHiamJ9QQYZhwEd3mKOswgXVKVsPfBBflkBg/132", "https://wx.qlogo.cn/mmopen/vi_32/KasygrS1icyGlic81SEyxlsMPQiaywgIbDmBQQZOIiaS625HAoxCnKFEvHRiawHicBkgH7wicWQa2OKTAFJ8O0rBnW0vQ/132", "https://wx.qlogo.cn/mmopen/vi_32/Khib24NT8AwHmo03NTF9t2fAn1lFeA2QfmmXyTwPmRBTquPibXLgY06SRKZdxY637PIxG7R7edgtqGgdU2VFiaoeA/132", "https://wx.qlogo.cn/mmopen/vi_32/vibqjpJr4OJdFXYGGEA7YEWqU5ssNy2ZrSFCdsJeGCPuo4bY4Wp6gOsIfibDRhYKxcWOb8CuUXoHH6FXhrZbkWUA/132", "https://wx.qlogo.cn/mmopen/vi_32/IYKdeRDSg35zjVoPVHhC3c3ibLrkcNCO2deWdKarVYC5Z9LOTdB5DB0Rct6pAD6KYBhzEoaOh0skyicvecNVESIg/132", "https://wx.qlogo.cn/mmopen/vi_32/iadic5ssR7t1qpMFVKKadDsqp2DPwWa4c5tdUaj60HCoeZpjdKeQP9dfPVCeibWGE5kKsk7PlGGb07OxZuhgOprEw/132", "https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83equmwhev0OCVDd6WON1HTXEnPouiaMOapUHV9YickAENvkARf6lJCvBm6k8ib3GmIcLmEqnrC54n2oMw/132", "https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEI34Ntb0O96JK0l2UKVVzQJsLOuuZyU47w77UdyQOPE6VdxDMnsc4AjrS5sCtwNicR63fQOwukTVDg/132", "https://wx.qlogo.cn/mmopen/vi_32/oiaibx9eiaErlBhPicTq201ISyrZBWMBicHFFkq2xEZgHURXicz8jYXOmKu8iaEibT3LksZoaiaBGwURYrRpmI3ELL6btCw/132", "https://wx.qlogo.cn/mmopen/vi_32/WPtGnofABQ8W2cUjLQ3IsXK9DFlYxnb8GUBTPRGqECo0vSQxodu6c4kdSTol7oiaFvL543QJF4s1buYOTzFHEfg/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKgib1t3HbjYXZnu7cribPJLHsiccjSFSpLl0QRDUcYtjTKWCTE0fib16Bl4LgcTagxcaXqwEicn5f41iaA/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7y20jxxAnsVSGSLrHd9YApRsFk4ia9CTyicVonJDHX0Bk3VODKd4A7OHop7yyBRrH3Y43TCj7XTaQ/132", "https://wx.qlogo.cn/mmopen/vi_32/pHUYJiadiblHDVwhUMeaiah6o8412n0fpYQYCSWFe7B27rElk6Jm54YpGfRFwXDYFOGpDW58ChoEDcdMKeFFiaygDA/132", "https://wx.qlogo.cn/mmopen/vi_32/kxeGtlHbibtcNZtlibnAlTNPmicZ01eOnFVicSEHKc0Q5b1qD2pGzKMBc59HYnOeOibhiaJRTic5A6XGoMuicnCq10b02w/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJHkQf5zykwJznBVFUBXibV6JAMQic8JrXfQIpgMdoEmMaZhgI7Q6KwCrRUgWY3cScSSWxcJL0ucloQ/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ094VJbgampnaFXDbbudkApk8qLHA9J6Ic9ibQmQCRuqJ5jOB5oAKgDrKWeNNfIhQScC2d9hbl67A/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJN2FbcWFCdZD1H8RzibBO2FLr1UPLFy7IvxEFxVR1vWjtIbxWPzfN3WdLxoYEGpA8gUofrZ6UDcyw/132", "http://woool.live/static/upload/icon/default_avatar.png", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJdpP1nBrLF2T7QU37W6SwRlQMAC9NMeMZLg5HibKfRnwADvib81qtpNm76wuxvPdgJD6Fv2vYSD2sA/132", "https://wx.qlogo.cn/mmopen/vi_32/9KtufLJwicicSWBrZ7L9dyKAlP8dvvRncxUibPzDUdibHibMo4h66As0WBCUsKskX1H0I5hXrawJ2t0LaAcNGmEomXQ/132", "https://wx.qlogo.cn/mmopen/vi_32/Tt5BFw9ZgQ9riccsuhr6Ns5uvqh9ZhoTI1TaicujWQvC8NGsKUibZG9rKJVl4B4vYaPfomaQN8r8BBn7AfodtsOdQ/132", "https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoibUyT6aTmlpVYCys6UXNmHeE9icj8pSaJva8Z1kLS3WUH97crTBFxD5IFGMFl8B1foUzXLEq3OQxg/132", "https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eou2FuYV5HfFRJ8JMYONiceXU51j6K9a96XAYuOcQCdq5iaocCKCTMaicWsyvmLoKdAhtr20ScbT9IrQ/132", "https://wx.qlogo.cn/mmopen/vi_32/INFKy6IXPNswsB5EhGyysuye5h1XbUEujk4bicnMdmsrgBIzCBwlPviaeS4daKsCSImoblgfT9fWiaaHvLHNOsQkA/132", "https://wx.qlogo.cn/mmopen/vi_32/6tsEcLOlIk3aITYvkBWp5Ph7epCmEpFPyaa9vPaBjb2Kbuz38sAFph9X352q8HSMVDTuSFPq4HxYicC2DTV1wrg/132", "https://wx.qlogo.cn/mmopen/vi_32/4SbKIyJ66Xia1x7ahjWpPn2uWcibqEgVlCBrnBdIbdd06VfHYk8ia0yrIhJiaN0h4bKc8hNI1Vzic69mY8Ldusvxvvw/132", "https://wx.qlogo.cn/mmopen/vi_32/axcpGKjAaLjvDjTdQDB7icJAznT1rquOzGMtSzBxScQ09bN4ia00OFAT702HIicf7iaibckUc5etr4jzf3xAFiazUQiaw/132", "https://wx.qlogo.cn/mmopen/vi_32/ptib9Z1dlF3fShGkHATQQ15RtX4mS1ecZtclZQIzzdFzM7NEFbUPF9ibR2ZqycicmbYpLkNUaqTIf6DCXE8icmKGIQ/132", "https://wx.qlogo.cn/mmopen/vi_32/LAO10xaBUsvcXm7mnwwpaFoyh7FRAicWjfszr8I7iaFWToficnjJsWCDNVUqHZyjNsZNOjQS6jVSYGCdIFNT7ePTg/132", "https://wx.qlogo.cn/mmopen/vi_32/icib7KkKKEo3qSkrib4epxeAZXfIiahYQ99TryAgSRgzSfeVUem1aiab5cDZHmRCiaKxhOzUiarY1qse0Y3fodamkJMzQ/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIpuibzKNmhug4dianicKmUACDhPrpXFz1ltwvibt0ubhia3dKRGFTY8sibfD6MiaCfLHFOgp7crQ8dp7S2g/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJg0W7IVzQ5gGRnA3r7yUSdG3eEXGzXblw42KWASE2Q9pTscmmOrBcPSsXVHrD7K6o3dJGj6lGQ6A/132", "https://wx.qlogo.cn/mmopen/vi_32/kGNHftKLNytgoNPXV3mSYicCOMN5qud66CpGS4LGxh9bfpmzXaAHoOtBsC0aG3M8HHicia3rSYd7NkCEdNibJuvVZg/132", "https://wx.qlogo.cn/mmopen/vi_32/HEJwF0llQUuEK7ZdUD2cYjodiaWX6ria9iaq8DtQMIgu7W8cM9WticWPtqhzPicS46QkjB8c9icibibJ4PB6CuaRI1kX8Q/132", "https://wx.qlogo.cn/mmopen/vi_32/y50lsmPoArb8py304cZbAh1iaO2lbGZuKpD2kTdXR8iaZYOSgs2W6bl2rp9w4UAg7cNtqhVgyn81g0sfBeAk4CPg/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJt1TFpc58rhePiaTriahcT8HTop6Cw5OxeicFk7NZXjzE5B0CZBL2aCrITiamDs1julMQT8JUaZ6F2UQ/132", "https://wx.qlogo.cn/mmopen/vi_32/ZRs2N9GyxfTPMglefFIsdT27lb7d8rvfphiaZ2bNoHiaZNFNbB2d6XsJYT2RmZtaaTrFfobDGoHn2GzAWKUWSUaw/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKxvPNAEjjILedn2EL7shojLCLKUSbgSC3luRmiaicpVLF1JZNyKt6zu68SFHBzaVg9crllhlibLy81w/132", "https://wx.qlogo.cn/mmopen/vi_32/FSk6ksZtTSD1c2u39XIEKAhbVP8JlicvREn9W8ycvX3TMmr0gkC0SOb8aLkvXDSx5yjx62OHy6qFia8WjQT3mv5g/132", "https://wx.qlogo.cn/mmopen/vi_32/pUfgO2leRemzNf0A88NHy1vbcLicW2dfCrjTOGIOqqUI4DndkTpwbWwFpY9KbkC6FQMIJiamDMep0g0DsCjGCnjw/132", "https://wx.qlogo.cn/mmopen/vi_32/eWrjDmvzpRyut5njLOIG4hLebfsyBiaQBxnTcFKvtjZ6icgYEKh0jeXydFdJ7meudIBvnicibUJ5FgLLABoicAuCP2g/132", "https://wx.qlogo.cn/mmopen/vi_32/ZkVsrAclqxMibwdl83uYialZh4vzlrhXbWEicWxS1VnoREJiaiazTrHiac7PYFLYgGibhChRoPmfQLyHZmeSFh2kYOAsg/132", "https://wx.qlogo.cn/mmopen/vi_32/nXthkldwuKcoG6LrycbEqac5Bsktks5GbPUpNL2d5SXZbfbpaj5lMDAfHOCjsHclicSyFbd2aBQic8Ajp2mcN5rg/132", "https://wx.qlogo.cn/mmopen/vi_32/Q7hxH5vXPGWeib8fGlcEjIOQyUibMojZAGd7hPyy4mx1I4Sic5tfquAEqqu15xtPzbBqQ9xibepZn8f6g075DCqibbA/132", "https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eos44qwgq3KRm8Tw8mALUKziafJiaTd4W9C5MM7Vkagk82j8t3FRasibE0sTNsz49bulp2IWMOwVfZaQ/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKGK5esxAR4dBsfusiaRtENuDob6UyCqvgBxTiaThyRud0RQQvflGkoYn72D5hJfHRQTgQqfFvYczYA/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLYMEPPrXDnqFXzqcLICX9hQwbeJST3NcT6vCXTPllsuQCRJuok7EibZQOKC5ZHNIaGVosLrBic6Cvw/132", "https://wx.qlogo.cn/mmopen/vi_32/tkQibibaoMsMY0VwWc435juFHicqibHMqeUvdSonoxUA5XxVRykf8t4aZBuQLL6T08OiaLEoT4qk6ffLXvu8JQjuLkg/132", "https://wx.qlogo.cn/mmopen/vi_32/xpH0X9yd3fialFm1PGfK4pCOjCbILoq0ksaHbqgZ4h6k48QpEsf9jEJpg71Wa8OpdAge0x2npxU7SOAmPPmvmvQ/132", "https://wx.qlogo.cn/mmopen/vi_32/qmLbFxxNnib8iclqejKPMB4YMlvdG2NicK7QiadxHOUW5AluVavxZgkOnIQ9ibYez39cR9z4ZrXxFytvBq2gqWoIuQg/132", "https://wx.qlogo.cn/mmopen/vi_32/pKOja6NdBcKkswujYQrdibhl3zDgxDRXQ41ibD0M6cvG00ib7TNCLQVYib8mZUicQ1Wt1uCCE5wa6wt9bpPicALe91gQ/132", "https://wx.qlogo.cn/mmopen/vi_32/NOywaoYFcJC6hJeicsrhMv4y9ZnyUFJ8lzsv8XUx3xghZYWbicg4PcIjQ1NvyCYicbOwg1m5nSmcF4Udib52ibUeKwg/132", "https://wx.qlogo.cn/mmopen/vi_32/c9xpiakQ3OC2OXanj3K2ts3gL7iam9G4RShOvAEQ05PtUibGdEF9FH6d3TeBrccRn5Z1Bk1s8DCwgVPvzJp7DJfAQ/132", "https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLJxibPuRib5xAFjdIjgNqulkZ9RyFCV1Xt48rYZ4ksAztxuHQ3dv0DyCQLr75oRqLqe01Wz2msDO8w/132", "https://wx.qlogo.cn/mmopen/vi_32/BZDzibYsnYdnuUXfuLQJzcktRubb8S79TuOcc0GSPLKjFGibYPMTdSaWN12P8H4IFYng3rS3YwC6XNO3T5G2SItw/132"])
        };

        class LoadingScene extends Laya.View {
            constructor() {
                super()
            }

            onEnable() {
                this.imgs = [this._img1, this._img2, this._img3, this._img4, this._img5, this._img6], this.imgIndex = 0, this.minLoadingTime = 1e3, this.timeToken = 0, this.isLoaded = !1, this.isTimeout = !1, this.curValue = 0, this.complete = !1, ML.event.on("gameScene_loading", this, this._loading), ML.event.on("gameScene_load", this, this._loaded), Laya.timer.frameLoop(1, this, this._onUpdate), ML.gameScene.loadScene()
            }

            onDisable() {
                ML.event.off("gameScene_loading", this, this._loading), ML.event.off("gameScene_load", this, this._loaded), Laya.timer.clearAll(this)
            }

            _onUpdate() {
                if (this.complete) return;
                this.timeToken += Laya.timer.delta, this.timeToken >= this.minLoadingTime && (this.isTimeout = !0);
                let v = this.timeToken / this.minLoadingTime;
                this.isLoaded ? this.isTimeout && (this.timeToken = .85 * this.minLoadingTime, this.isTimeout = !1) : v >= .85 && (v = .85), v >= 1 && (v = 1, this.complete = !0, this.close(), ml.game.startGame()), 100 * parseInt(v) % 15 == 0 && this.imgIndex <= 5 && (this.imgs[this.imgIndex].skin = NicknameUtil.randomHead(), this.imgIndex++), this._loadingBar.width = 391 * v
            }

            _loading(value) {
                this.curValue = value
            }

            _loaded() {
                this.isLoaded = !0
            }
        }

        class MLConfig {
        }

        function QuadTree(bound, level = 0, maxObjects = 10) {
            this.bounds = bound || {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }, this.objects = [], this.nodes = [], level = level || 0, maxObjects = maxObjects || 20;
            this.clear = function () {
                for (let i = 0; i < this.nodes.length; i++) this.nodes[i].clear();
                this.nodes = []
            }, this.getAllObjects = function (returnedObjects) {
                for (let i = 0; i < this.nodes.length; i++) this.nodes[i].getAllObjects(returnedObjects);
                for (let i = 0, len = this.objects.length; i < len; i++) returnedObjects.push(this.objects[i]);
                return returnedObjects
            }, this.findObjects = function (returnedObjects, obj) {
                if (void 0 === obj) return void console.log("UNDEFINED OBJECT");
                let index = this.getIndex(obj);
                if (-1 != index && this.nodes.length) this.nodes[index].findObjects(returnedObjects, obj); else if (-1 == index) for (let i = 0; i < this.nodes.length; i++) this.nodes[i].findObjects(returnedObjects, obj);
                for (let i = 0, len = this.objects.length; i < len; i++) returnedObjects.push(this.objects[i]);
                return returnedObjects
            }, this.insert = function (obj) {
                if (void 0 !== obj) if (obj instanceof Array) for (let i = 0, len = obj.length; i < len; i++) this.insert(obj[i]); else {
                    if (this.nodes.length) {
                        let index = this.getIndex(obj);
                        if (-1 != index) return void this.nodes[index].insert(obj)
                    }
                    if (this.objects.push(obj), obj.entity.treeNode = this, this.objects.length > maxObjects && level < 5) {
                        null == this.nodes[0] && this.split();
                        let i = 0;
                        for (; i < this.objects.length;) {
                            let index = this.getIndex(this.objects[i]);
                            -1 != index ? this.nodes[index].insert(this.objects.splice(i, 1)[0]) : i++
                        }
                    }
                }
            }, this.isInner = function (obj) {
                let top = obj.y + obj.height / 2 <= this.bounds.y + this.bounds.height / 2,
                    bottom = obj.y - obj.height / 2 >= this.bounds.y - this.bounds.height / 2,
                    left = obj.x - obj.width / 2 >= this.bounds.x - this.bounds.height / 2,
                    right = obj.x + obj.width / 2 <= this.bounds.x + this.bounds.height / 2;
                return top && bottom && left && right
            }, this.getIndex = function (obj) {
                let index = -1, centerX = this.bounds.x, centerY = this.bounds.y,
                    top = obj.y - obj.height / 2 >= centerY, bottom = obj.y + obj.height / 2 <= centerY,
                    left = obj.x + obj.width / 2 <= centerX, right = obj.x - obj.width / 2 >= centerX;
                return top ? right ? index = 0 : left && (index = 1) : bottom && (left ? index = 2 : right && (index = 3)), index
            }, this.split = function () {
                let subWidth = this.bounds.width / 2 | 0, subHeight = this.bounds.height / 2 | 0;
                this.nodes[0] = new QuadTree({
                    x: this.bounds.x + subWidth / 2,
                    y: this.bounds.y + subHeight / 2,
                    width: subWidth,
                    height: subHeight
                }, level + 1), this.nodes[1] = new QuadTree({
                    x: this.bounds.x - subWidth / 2,
                    y: this.bounds.y + subHeight / 2,
                    width: subWidth,
                    height: subHeight
                }, level + 1), this.nodes[2] = new QuadTree({
                    x: this.bounds.x - subWidth / 2,
                    y: this.bounds.y - subHeight / 2,
                    width: subWidth,
                    height: subHeight
                }, level + 1), this.nodes[3] = new QuadTree({
                    x: this.bounds.x + subWidth / 2,
                    y: this.bounds.y - subHeight / 2,
                    width: subWidth,
                    height: subHeight
                }, level + 1)
            }, this.refresh = function (root) {
                let i, objs = this.objects;
                for (root = root || this, i = objs.length - 1; i >= 0; i--) {
                    let obj = objs[i];
                    if (obj.enable = !0, !obj) continue;
                    if (obj.destroy) {
                        objs.splice(i, 1), obj.enable = !1;
                        continue
                    }
                    if (obj.isStatic) continue;
                    let index = this.getIndex(obj), isinner = this.isInner(obj);
                    -1 !== index && isinner ? this.nodes.length && this.nodes[index].insert(objs.splice(i, 1)[0]) : this !== root && root.insert(objs.splice(i, 1)[0])
                }
                for (i = 0; i < this.nodes.length; i++) this.nodes[i].refresh(root)
            }
        }

        MLConfig.assetsVersion = "1_5", MLConfig.useLocalAssets = !1, MLConfig.shareSuccessInterval = 2, MLConfig.entityGroups = [{
            groupName: "Default",
            poolSize: 60,
            autoReleaseInterval: 60
        }, {groupName: "Player", poolSize: 12, autoReleaseInterval: 60}, {
            groupName: "People",
            poolSize: 100,
            autoReleaseInterval: 60
        }, {groupName: "BoomParticle", poolSize: 10, autoReleaseInterval: 60}];

        class CameraFollow extends Laya.Script {
            constructor() {
                super(), this.target = null
            }

            init(target) {
                this.target = target, this.targetPos = this.owner.transform.position.clone(), this.dir = new Laya.Vector3(0, 1.5, -1)
            }

            onEnable() {
                this.owner.transform.rotationEuler = new Laya.Vector3(-50, 180, 0), console.log("camera ", this.owner.transform.rotationEuler)
            }

            onDisable() {
            }

            onLateUpdate() {
                if (this.target && this.target.entity) {
                    let pos = this.owner.transform.position, h = this.target.entity.levelData.cameraH, tx = .2,
                        p = this.target.transform.position;
                    this.targetPos.x = 1.4 * this.dir.x * h + p.x, this.targetPos.y = 1.4 * this.dir.y * h, this.targetPos.z = 1.4 * this.dir.z * h + p.z, pos.x = pos.x + tx * (this.targetPos.x - pos.x), pos.y = pos.y + tx * (this.targetPos.y - pos.y), pos.z = pos.z + tx * (this.targetPos.z - pos.z), this.owner.transform.position = pos
                }
            }
        }

        class Constant {
        }

        Constant.MapWidth = 200, Constant.MapHeight = 200;

        class DefaultGameMode {
            constructor() {
                this.gameTime = 90, this.currentGameTime = this.gameTime, this.lastMousePos = new Laya.Vector2(0, 0), this.moveDir = new Laya.Vector2(0, 1)
            }

            onInit(data) {
            }

            onStart(data) {
                this.reviveCount = 0, ml.game.resumeGame(), this.showPeopleInterval = 5e3, this.showPeopleIntervalAdditive = 0, this.gameovered = !1, Laya.Scene.open("gameView.scene"), this.showGameEntity(), ML.audio.playBgm()
            }

            onUpdate(dt) {
                if (!this.gameovered) if (this.currentGameTime <= 0) ml.game.overGame({type: 1}); else if (ml.quadTree && ml.quadTree.refresh(), this._countdown(Laya.timer.delta / 1e3), this.showPeopleIntervalAdditive += dt, this.showPeopleIntervalAdditive >= this.showPeopleInterval) {
                    if (this.showPeopleIntervalAdditive = 0, ML.entity.getEntityGroup("People").entityLogics.length <= 30) for (let j = 0; j < 6; j++) {
                        let peopleData = {
                            position: this.randomPositionRoundPlayer(),
                            w: 1,
                            h: 1,
                            camp: 2,
                            nickname: "p" + j
                        };
                        peopleData.food = ML.config.getFoodData(0), ML.entity.showPeople(peopleData)
                    }
                    if (ML.entity.getEntityGroup("Player").entityLogics.length <= 5) {
                        let playerData = {
                            position: this.randomPosition(),
                            w: 4,
                            h: 4,
                            camp: 1,
                            nickname: NicknameUtil.RandomNickname()
                        };
                        ml.aiPlayer = ML.entity.showAIPlayer(playerData)
                    }
                }
            }

            onRevive() {
                this.reviveCount++, ml.game.resumeGame()
            }

            onGameover(data) {
                1 === data && ML.audio.playEffect("finish"), this.gameovered = !0, ml.game.pauseGame(), ML.event.emit("OnGameover", data), Laya.Scene.open("completeView.scene", !0, {
                    rank: this.getSelfRankIndex(),
                    type: data
                })
            }

            onQuit(data) {
                Laya.Scene.closeAll(), ML.entity.hideAllEntity(), ML.gameScene.unloadScene(), ml.game.initGame(), ML.audio.stopBgm(), ML.user.saveUser()
            }

            onStageMouseDown(e) {
                this.lastMousePos.x = e.stageX, this.lastMousePos.y = e.stageY
            }

            onStageMouseMove(e) {
                let x = e.stageX, y = e.stageY;
                this.moveDir.x = x, this.moveDir.y = y, Laya.Vector2.MLSub(this.lastMousePos, this.moveDir, this.moveDir), Laya.Vector2.MLNornalize(this.moveDir), 0 != Laya.Vector2.MLLength(this.moveDir) && ml.player.move(this.moveDir)
            }

            onStageMouseUp(e) {
                this.lastMousePos.x = 0, this.lastMousePos.y = 0
            }

            showGameEntity() {
                let playerData = {position: new Laya.Vector3(-10, 0, -25), w: 5, h: 5, camp: 1, nickname: "自己"};
                ml.player = ML.entity.showPlayer(playerData), ml.cameraFollow = ml.camera.getComponent(CameraFollow), ml.cameraFollow || (ml.cameraFollow = ml.camera.addComponent(CameraFollow)), ml.cameraFollow.init(ml.player.owner);
                for (let i = 0; i < 5; i++) {
                    let playerData = {
                        position: this.randomPosition(),
                        w: 4,
                        h: 4,
                        camp: 1,
                        nickname: NicknameUtil.RandomNickname()
                    };
                    ml.aiPlayer = ML.entity.showAIPlayer(playerData)
                }
                for (let j = 0; j < 30; j++) {
                    let peopleData = {
                        position: this.randomPositionRoundPlayer(),
                        w: 1,
                        h: 1,
                        camp: 2,
                        nickname: "p" + j
                    };
                    peopleData.food = ML.config.getFoodData(0), ML.entity.showPeople(peopleData)
                }
            }

            _countdown(dt) {
                this.currentGameTime -= dt, this.currentGameTime < 0 && (this.currentGameTime = 0)
            }

            getCountdownStr() {
                let m = Math.floor(this.currentGameTime / 60), s = Math.ceil(this.currentGameTime % 60);
                return m < 0 && (m = 0), s < 10 && (s = "0" + s), m + ":" + s
            }

            randomPosition() {
                let mapW = Constant.MapWidth / 2, mapH = Constant.MapHeight / 2;
                return new Laya.Vector3(RandomUtil.randomIntegerN2M(mapW, -mapW), 0, RandomUtil.randomIntegerN2M(mapH, -mapH))
            }

            randomPositionRoundPlayer() {
                let pos = ml.player.owner.transform.position;
                return new Laya.Vector3(RandomUtil.randomIntegerN2M(20, -20) + pos.x, 0, RandomUtil.randomIntegerN2M(20, -20) + pos.z)
            }

            onPlayerDead(killer, player) {
                if (killer && killer.killNum++, ML.event.emit("onPLayerDead", {
                    killer: killer,
                    bekill: player
                }), killer === ml.player && ML.audio.playEffect("kill"), player === ml.player) {
                    if (this.reviveCount >= 1) return void ml.game.overGame(2);
                    Laya.Scene.open("failView.scene", !1)
                }
            }

            getRankList() {
                let players = ML.entity.getEntityGroup("Player").entityLogics;
                return players.sort((a, b) => b.score - a.score), players
            }

            getSelfRankIndex() {
                let ranklist = this.getRankList();
                for (let i = 0; i < ranklist.length; i++) {
                    if (ranklist[i] === ml.player) return i
                }
            }
        }

        class Maingame extends Laya.Script {
            constructor() {
                super(), this.gameCount++
            }

            onAwake() {
            }

            onEnable() {
            }

            onDisable() {
            }

            initGame() {
                this.mode = new DefaultGameMode, this.mode.onInit(), Laya.Scene.open("homeView.scene")
            }

            loadGame() {
                Laya.Scene.open("loadingView.scene")
            }

            startGame(data) {
                Laya.stage.addChildAt(ml.scene3D, 0), this.gameCount++, this.gameStart = !0, this.mode.onStart(data)
            }

            pauseGame() {
                this.gameStart = !1, ML.entity.pause()
            }

            resumeGame() {
                this.gameStart = !0, ML.entity.resume()
            }

            revive() {
                this.mode.onRevive()
            }

            overGame(data) {
                this.gameStart = !1, this.mode.onGameover(data)
            }

            quitGame(data) {
                this.mode.onQuit(data)
            }

            onUpdate() {
                this.gameStart && this.mode.onUpdate(Laya.timer.delta)
            }

            onStageMouseDown(e) {
                this.gameStart && (this.mode.onStageMouseDown(e), ML.event.emit("onStageMouseDown", e))
            }

            onStageMouseMove(e) {
                this.gameStart && this.mode.onStageMouseMove(e)
            }

            onStageMouseUp(e) {
                this.gameStart && this.mode.onStageMouseUp(e)
            }
        }

        class QuadTreeEntity extends Laya.Script3D {
            constructor() {
                super(), this.treeInfo = {x: 0, y: 0, width: 0, height: 0, destroy: !1, isStatic: !1, entity: null}
            }

            insert2QuadTree() {
                this.treeInfo.x = this.owner.transform.position.x, this.treeInfo.y = this.owner.transform.position.z, this.treeInfo.entity = this, ml.quadTree.insert(this.treeInfo)
            }

            upadtetreeInfo() {
                this.treeInfo.x = this.owner.transform.position.x, this.treeInfo.y = this.owner.transform.position.z
            }

            removeFromQuad() {
                this.treeInfo.destroy = !0
            }
        }

        class BasePlayerEntity extends QuadTreeEntity {
            constructor() {
                super(), this.dir = new Laya.Vector2(0, 0), this.speed = 6, this.currentSpeed = this.speed, this.color = new Laya.Vector3(255, 255, 255), this.reviveScore = 0, this.killNum = 0, this.material = null, this.a = 30, this.curDir = new Laya.Vector2(0, 0), this.delaytimeToRun = 2e3, this.currentAnim = 0, this.nameHUD = null, this.nameHUDPos = new Laya.Vector3(0, 0, 0)
            }

            onAwake() {
                this.collidered = !1, this.score = 0, this.dead = !1
            }

            onShow(data) {
                this.data = data, this.collidered = !1, this.score = 0, this.dead = !1, this.animator = this.owner.getComponent(Laya.Animator), this.animator.play("run"), this.owner.transform.position = this.data.position, this._createNameHUD(), this.addScore(0), this.changeColor(), this.insert2QuadTree()
            }

            onEnable() {
                ML.event.on("OnGameover", this, this.onGameover)
            }

            onDisable() {
                this.nameHUD && this.nameHUD.removeSelf(), ML.event.off("OnGameover", this, this.onGameover)
            }

            onHide() {
                this.nameHUD && this.nameHUD.removeSelf()
            }

            onGameover() {
                this.nameHUD && this.nameHUD.removeSelf()
            }

            onMLUpdate(dt) {
                this.dead || this.destroyed || (this.updatePosition(dt), this.upadtetreeInfo(), this.checkCollider(), this._updateHUD())
            }

            upadtetreeInfo() {
                this.treeInfo.width = this.levelData.size * this.data.w, this.treeInfo.height = this.levelData.size * this.data.h, super.upadtetreeInfo()
            }

            updatePosition(dt) {
                let mapW = Constant.MapWidth / 2, mapH = Constant.MapHeight / 2;
                this.currentSpeed < this.speed && (this.currentSpeed += this.a * dt / 1e3), this.currentSpeed >= this.speed && (this.currentSpeed = this.speed);
                this.curDir.x = this.curDir.x + .3 * (this.dir.x - this.curDir.x), this.curDir.y = this.curDir.y + .3 * (this.dir.y - this.curDir.y);
                let pos = this.owner.transform.position;
                pos.x += this.currentSpeed * this.curDir.x * dt / 1e3, pos.z += this.currentSpeed * this.curDir.y * dt / 1e3, (Math.abs(pos.z) > mapH - this.data.h || Math.abs(pos.x) >= mapW - this.data.w) && (pos.z = Tools.Clamp(pos.z, -mapH + this.data.h / 2, mapH - this.data.h / 2), pos.x = Tools.Clamp(pos.x, -mapW + this.data.w / 2, mapW - this.data.w / 2), this.onColliderMapBorder()), this.owner.transform.position = pos;
                let degress = this.RotationForP(this.curDir), r = this.owner.transform.rotationEuler;
                r.y = degress, this.owner.transform.rotationEuler = r
            }

            RotationForP(p) {
                let degress = Math.atan2(p.y, p.x);
                return degress = 90 - degress * (180 / Math.PI)
            }

            checkCollider() {
                let objs = [];
                if (!this.destroyed && (ml.quadTree.findObjects(objs, this.treeInfo), objs.length)) for (let i = 0; i < objs.length; i++) {
                    let obj = objs[i];
                    if (obj.entity === this) continue;
                    if (obj.entity.data.camp, obj.destroy) continue;
                    if (!this.owner) return;
                    let pos1 = this.owner.transform.position, pos2 = obj.entity.owner.transform.position,
                        dx = Math.abs(pos1.x - pos2.x), dz = Math.abs(pos1.z - pos2.z),
                        difx = (this.treeInfo.width + obj.width) / 2, difz = (this.treeInfo.height + obj.height) / 2;
                    dx <= difx && dz <= difz && (1 == obj.entity.data.camp ? this.handlePlayerCollider(obj.entity) : 0 == obj.entity.data.camp ? this.handleStaticCollider(obj.entity) : 2 == obj.entity.data.camp && this.handlePeopleCollider(obj.entity))
                }
            }

            handlePlayerCollider(entity) {
                if (this.entityId > entity.entityId) return;
                if (this.collidered) return;
                let lvOther = entity.levelData.lv, lvSelf = this.levelData.lv;
                lvOther < lvSelf ? entity.onDead(this) : lvOther > lvSelf && this.onDead(entity), this.collidered = !0, Laya.timer.frameOnce(10, this, () => {
                    this.collidered = !1
                })
            }

            handleStaticCollider(entity) {
                entity.beAttack(this.levelData.power) > 0 ? this.currentSpeed = -10 : this.addScore(entity.getScore())
            }

            handlePeopleCollider(entity) {
                entity.beAttack(this.levelData.power) > 0 ? this.currentSpeed = -10 : this.addScore(entity.getScore())
            }

            addScore(score) {
                this.nameHUD && (this.nameHUD.text = this.data.nickname + "\n等级" + (this.levelData.lv + 1))
            }

            changeToRun() {
                this.animator.crossFade("run", .2)
            }

            changeColor() {
                let mesh = this.getMesh();
                if (!mesh) return;
                let mat = mesh.material, color = mat.albedoColor, x = RandomUtil.randomIntegerN2M(0, 255),
                    y = RandomUtil.randomIntegerN2M(0, 255), z = RandomUtil.randomIntegerN2M(0, 255);
                color.x = x / 255, color.y = y / 255, color.z = z / 255, mat.albedoColor = color, mesh.material = mat
            }

            getMesh() {
                let mesh = this.owner.skinnedMeshRenderer;
                if (!mesh) {
                    let children = this.owner._children;
                    if (0 == children.length) return null;
                    for (let i = 0; i < children.length; i++) {
                        if (mesh = children[i].skinnedMeshRenderer) return mesh
                    }
                }
                return mesh
            }

            onDead(killer) {
                this.dead = !0, this.removeFromQuad(), this.animator.crossFade("die", .3), this.nameHUD && this.nameHUD.removeSelf()
            }

            onColliderMapBorder() {
            }

            _updateHUD() {
                let playerPos = this.owner.transform.position;
                ml.camera.viewport.project(playerPos, ml.camera.projectionViewMatrix, this.nameHUDPos);
                let x = this.nameHUDPos.x / Laya.stage.clientScaleX, y = this.nameHUDPos.y / Laya.stage.clientScaleY;
                this.nameHUD && this.nameHUD.pos(x, y)
            }

            _createNameHUD() {
                let name = new Laya.Label;
                name.color = "#ffffff", name.fontSize = 34, name.stroke = 5, name.strokeColor = "#000000", name.anchorX = .5, name.anchorY = 0, this.nameHUD = name, Laya.stage.addChild(this.nameHUD)
            }
        }

        class PlayerEntity extends BasePlayerEntity {
            constructor() {
                super(), this.staticHpHUDPos = new Laya.Vector3(0, 0, 0)
            }

            onShow(data) {
                super.onShow(data), this._createHPHUD()
            }

            onUpdate() {
                super.onUpdate()
            }

            onHide() {
                super.onHide(), this.staticHpProgress.removeSelf()
            }

            revive() {
                Laya.timer.clear(this, this._disActive), this.dead = !1, this.owner.active = !0, Laya.timer.once(2e3, this, () => {
                    this.treeInfo.destroy = !1, this.insert2QuadTree()
                }), this._createNameHUD(), this.addScore(0), this.animator.play("run"), this.collidered = !1
            }

            addScore(score) {
                this.score += score;
                let oldLv = this.levelData ? this.levelData.lv : 0;
                this.levelData = ML.config.getLevelValueInGaming(this.score);
                let newLv = this.levelData.lv;
                this.speed = this.levelData.speed;
                let size = this.levelData.size;
                this.owner.transform.setWorldLossyScale(new Laya.Vector3(size, size, size)), super.addScore(score), newLv > oldLv && (ML.event.emit("PlayerLevelUp", this), ML.audio.playEffect("levelUp"))
            }

            handleStaticCollider(entity) {
                super.handleStaticCollider(entity);
                let value = entity.data.food.hp / entity.data.food.maxHp, pos = entity.owner.transform.position;
                ml.camera.viewport.project(pos, ml.camera.projectionViewMatrix, this.staticHpHUDPos);
                let x = this.staticHpHUDPos.x / Laya.stage.clientScaleX,
                    y = this.staticHpHUDPos.y / Laya.stage.clientScaleY;
                this._updateStaticHp(x, y, value), value <= 0 && (ML.entity.showBoomParticle({
                    position: entity.owner.transform.position,
                    size: entity.data.food.lv || 1
                }), entity._showPeople()), Laya.timer.clearAll(this), Laya.timer.once(1500, this, () => {
                    this.staticHpProgress.visible = !1
                }), ML.audio.playEffect("building")
            }

            handlePeopleCollider(entity) {
                super.handlePeopleCollider(entity), ML.audio.playEffect("eat")
            }

            onDead(killer) {
                super.onDead(killer), ml.game.mode.onPlayerDead(killer, this), Laya.timer.once(2e3, this, this._disActive)
            }

            _disActive() {
                this.owner.active = !1
            }

            move(dir) {
                this.dir.x = dir.x, this.dir.y = dir.y
            }

            _createHPHUD() {
                let border = new Laya.Image("game/border5.png");
                border.width = 60, border.height = 20, border.pos(1e4, 1e5), this.staticHpProgress = border;
                let bar = new Laya.Image("game/border4.png");
                bar.width = 60, bar.height = 20, this.staticBar = bar, border.addChild(bar), Laya.stage.addChild(this.staticHpProgress)
            }

            _updateStaticHp(x, y, v) {
                this.staticHpProgress.visible = v > 0, this.staticHpProgress.pos(x, y), this.staticBar.width = 50 * v
            }

            randomPositionRoundStatic(entity) {
                let pos = entity.owner.transform.position;
                return new Laya.Vector3(RandomUtil.randomIntegerN2M(5, -5) + pos.x, 0, RandomUtil.randomIntegerN2M(5, -5) + pos.z)
            }
        }

        class StaticEntity extends QuadTreeEntity {
            constructor() {
                super(), this.checkInterval = 1e3, this.checkIntervalAddtive = 1e3
            }

            onEnable() {
                this.dead = !1, this.checkIntervalAddtive = 0, this.rSpeedX = 0, this.rSpeedY = 0, this.rSpeedZ = 0, this.ra = -190, this.SpeedY = 30, this.staticY = this.owner.transform.position.y
            }

            onDisable() {
            }

            onUpdate() {
                this.dead && this._updateFly(Laya.timer.delta / 1e3)
            }

            _updateFly(dt) {
                let meshs = this.getMesh();
                for (let i = 0; i < meshs.length; i++) {
                    let delay = RandomUtil.randomIntegerN2M(0, 200);
                    Laya.timer.once(delay, this, () => {
                        const mesh = meshs[i];
                        let enluer = mesh._owner.transform.rotationEuler,
                            rSpeedX = RandomUtil.randomIntegerN2M(60, 180);
                        RandomUtil.randomIntegerN2M(60, 180), RandomUtil.randomIntegerN2M(60, 180);
                        enluer.x += rSpeedX * dt, enluer.y += rSpeedX * dt, enluer.z += rSpeedX * dt, mesh._owner.transform.rotationEuler = enluer;
                        let pos = mesh._owner.transform.position;
                        pos.y += 20 * dt, mesh._owner.transform.position = pos
                    })
                }
                Laya.timer.once(3e3, this, () => {
                    ML.entity.hideEntity(this)
                })
            }

            beAttack(power) {
                return this.data.food.hp -= power, this.data.food.hp <= 0 && (this.dead = !0, this.removeFromQuad()), this.data.food.hp
            }

            getScore() {
                return this.data.food.exp
            }

            _showPeople() {
                if (!(ML.entity.getEntityGroup("People").entityLogics.length >= 50)) for (let j = 0; j < 5; j++) {
                    let peopleData = {
                        position: this.randomPositionRoundStatic(this),
                        w: 1,
                        h: 1,
                        camp: 2,
                        nickname: "p" + j
                    };
                    peopleData.food = ML.config.getFoodData(0), ML.entity.showPeople(peopleData)
                }
            }

            randomPositionRoundStatic(entity) {
                let pos = entity.owner.transform.position;
                return new Laya.Vector3(RandomUtil.randomIntegerN2M(5, -5) + pos.x, 0, RandomUtil.randomIntegerN2M(5, -5) + pos.z)
            }

            getMesh() {
                let meshs = [], mesh = this.owner.meshRenderer;
                if (mesh) meshs.push(mesh); else {
                    let children = this.owner._children;
                    if (0 == children.length) return null;
                    for (let i = 0; i < children.length; i++) {
                        (mesh = children[i].meshRenderer) && meshs.push(mesh)
                    }
                }
                return meshs
            }
        }

        class AIPlayerEntity extends BasePlayerEntity {
            constructor() {
                super(), this.changeDirIntervalAdd = 0, this.changeDirInterval = 2e3
            }

            onShow(data) {
                super.onShow(data)
            }

            onEnable() {
                super.onEnable()
            }

            onDisable() {
                super.onDisable()
            }

            onUpdate() {
                super.onUpdate(), this.changeDirIntervalAdd += Laya.timer.delta, this.changeDirIntervalAdd >= this.changeDirInterval && (this.changeDirIntervalAdd = 0, this.changeDirInterval = RandomUtil.randomIntegerN2M(1e3, 4e3), this.changeDir())
            }

            addScore(score) {
                score *= 3, this.score += score, this.levelData = ML.config.getLevelValueInGaming(this.score), this.speed = this.levelData.speed;
                let size = this.levelData.size;
                this.owner.transform.setWorldLossyScale(new Laya.Vector3(size, size, size)), super.addScore(score)
            }

            onColliderMapBorder() {
                super.onColliderMapBorder(), this.bordered || (this.neagteDir(), this.bordered = !0, setTimeout(() => {
                    this.bordered = !1
                }, 500))
            }

            onDead(killer) {
                super.onDead(killer), ml.game.mode.onPlayerDead(killer, this), Laya.timer.once(2e3, this, () => {
                    ML.entity.hideEntity(this)
                })
            }

            neagteDir() {
                this.dir.x *= -1, this.dir.y *= -1
            }

            changeDir() {
                let pos1 = this.owner.transform.position, pos2 = ml.player.owner.transform.position,
                    dx = pos1.x - pos2.x, dz = pos1.z - pos2.z, x = 0, y = 0;
                if (Math.sqrt(dx * dx + dz * dz) >= 50) {
                    let a = this.owner.transform.position, b = ml.player.owner.transform.position;
                    x = b.x - a.x, y = b.z - a.z
                } else x = RandomUtil.randomIntegerN2M(-1, 1), y = RandomUtil.randomIntegerN2M(-1, 1);
                0 == x && 0 == y || (this.dir.x = x, this.dir.y = y, Laya.Vector2.MLNornalize(this.dir))
            }
        }

        class PeopleEntity extends QuadTreeEntity {
            constructor() {
                super(), this.dir = new Laya.Vector2(0, 0), this.speed = 3, this.currentSpeed = this.speed, this.curDir = new Laya.Vector2(0, 0), this.changeDirIntervalAdd = 0, this.changeDirInterval = 2e3
            }

            onShow(data) {
                this.data = data, this.animator = this.owner.getComponent(Laya.Animator), this.animator.play("run"), this.owner.transform.position = this.data.position, this.insert2QuadTree(), this.changeDir()
            }

            onEnable() {
            }

            onDisable() {
            }

            onHide() {
                this.removeFromQuad()
            }

            beAttack(power) {
                return this.data.food.hp -= power, this.data.food.hp <= 0 && (this.dead = !0), ML.entity.hideEntity(this), this.data.food.hp
            }

            getScore() {
                return this.data.food.exp
            }

            insert2QuadTree() {
                this.treeInfo.width = this.data.w, this.treeInfo.height = this.data.h, super.insert2QuadTree()
            }

            onMLUpdate(dt) {
                this.destroyed || (this.updatePosition(dt), this.upadtetreeInfo(), this.changeDirIntervalAdd += Laya.timer.delta, this.changeDirIntervalAdd >= this.changeDirInterval && (this.changeDirIntervalAdd = 0, this.changeDirInterval = RandomUtil.randomIntegerN2M(1e3, 4e3), this.changeDir(), this.checkDistanceWithPlayer()))
            }

            checkDistanceWithPlayer() {
                let pos = ml.player.owner.transform.position, slf = this.owner.transform.position, dx = pos.x - slf.x,
                    dz = pos.z - slf.z;
                Math.sqrt(dx * dx + dz * dz) >= 30 && ML.entity.hideEntity(this)
            }

            upadtetreeInfo() {
                super.upadtetreeInfo()
            }

            updatePosition(dt) {
                let mapW = Constant.MapWidth / 2, mapH = Constant.MapHeight / 2;
                this.currentSpeed < this.speed && (this.currentSpeed += this.a * dt / 1e3), this.currentSpeed >= this.speed && (this.currentSpeed = this.speed);
                this.curDir.x = this.curDir.x + .15 * (this.dir.x - this.curDir.x), this.curDir.y = this.curDir.y + .15 * (this.dir.y - this.curDir.y);
                let pos = this.owner.transform.position;
                pos.x += this.currentSpeed * this.curDir.x * dt / 1e3, pos.z += this.currentSpeed * this.curDir.y * dt / 1e3, (Math.abs(pos.z) > mapH - this.data.h || Math.abs(pos.x) >= mapW - this.data.w) && (pos.z = Tools.Clamp(pos.z, -mapH + this.data.h / 2, mapH - this.data.h / 2), pos.x = Tools.Clamp(pos.x, -mapW + this.data.w / 2, mapW - this.data.w / 2), this.onColliderMapBorder()), this.owner.transform.position = pos;
                let degress = this.RotationForP(this.curDir), r = this.owner.transform.rotationEuler;
                r.y = degress, this.owner.transform.rotationEuler = r
            }

            checkCollider() {
                let objs = [];
                if (!this.destroyed && (ml.quadTree.findObjects(objs, this.treeInfo), objs.length)) {
                    let staticEntity = null;
                    for (let i = 0; i < objs.length; i++) {
                        let obj = objs[i];
                        if (obj.entity === this) continue;
                        if (obj.destroy) continue;
                        if (!this.owner) return;
                        let pos1 = this.owner.transform.position, pos2 = obj.entity.owner.transform.position,
                            dx = pos1.x - pos2.x, dz = pos1.z - pos2.z;
                        Math.sqrt(dx * dx + dz * dz) <= 10 && (1 == obj.entity.data.camp ? this.handlePlayerCollider(obj.entity) : 0 == obj.entity.data.camp && (staticEntity = obj.entity))
                    }
                }
            }

            handleStaticCollider(staticEntity) {
            }

            handlePlayerCollider(playerEntity) {
                let pos1 = this.owner.transform.position, pos2 = playerEntity.owner.transform.position,
                    x = pos1.x - pos2.x, y = pos1.z = pos2.z;
                this.dir.x = x, this.dir.y = y, Laya.Vector2.MLNornalize(this.dir)
            }

            RotationForP(p) {
                let degress = Math.atan2(p.y, p.x);
                return degress = 90 - degress * (180 / Math.PI)
            }

            onColliderMapBorder() {
                this.bordered || (this.neagteDir(), this.bordered = !0, setTimeout(() => {
                    this.bordered = !1
                }, 500))
            }

            neagteDir() {
                this.dir.x *= -1, this.dir.y *= -1
            }

            changeDir() {
                let x = RandomUtil.randomIntegerN2M(-1, 1), y = RandomUtil.randomIntegerN2M(-1, 1);
                0 == x && 0 == y || (this.dir.x = x, this.dir.y = y, Laya.Vector2.MLNornalize(this.dir))
            }

            changeColor() {
                if (this.changed) return;
                this.changed = !0;
                let mesh = this.getMesh();
                if (!mesh) return;
                let mat = mesh.material, color = mat.albedoColor;
                color.x = 1, color.y = 0, color.z = 0, mat.albedoColor = color, mesh.material = mat, setTimeout(() => {
                    if (!this.owner) return;
                    this.changed = !1;
                    let mat = mesh.material, color = mat.albedoColor;
                    color.x = 1, color.y = 1, color.z = 1, mat.albedoColor = color, mesh = mat
                }, 500)
            }

            getMesh() {
                let mesh = this.owner.skinnedMeshRenderer;
                if (!mesh) {
                    let children = this.owner._children;
                    if (0 == children.length) return null;
                    for (let i = 0; i < children.length; i++) {
                        if (mesh = children[i].skinnedMeshRenderer) return mesh
                    }
                }
                return mesh
            }
        }

        class ParticleEntity extends Laya.Script {
            constructor() {
                super()
            }

            onShow(data) {
                this.owner.transform.position = data.position, this.owner.transform.setWorldLossyScale(new Laya.Vector3(data.size, data.size, data.size)), this.particle = this.owner.particleSystem, this.particle.play(), Laya.timer.once(1e3, this, () => {
                    ML.entity.hideEntity(this)
                })
            }

            onEnable() {
            }

            onDisable() {
            }
        }

        let self = null;

        class EntityExtension extends Laya.Script {
            constructor() {
                super(), self = this, this.SCENES2 = null, this.player = null, this.people = null, this.boomParticle = null, ML.entity.showPlayer = self._showPlayer, ML.entity.showAIPlayer = self._showAIPlayer, ML.entity.showPeople = self._showPeople, ML.entity.showBoomParticle = self._showBoomParticle
            }

            set() {
                ml.scene3D = this.SCENES2, ml.scene3DUI = new Laya.Scene3D, ml.camera = ml.scene3D.getChildByName("Camera"), this.player = ml.scene3D.getChildByName("player_bwl"), this.people = ml.scene3D.getChildByName("people"), this.boomParticle = ml.scene3D.getChildByName("particleBoom"), this.player.removeSelf(), this.people.removeSelf(), this.boomParticle.removeSelf(), this.initQuadTree();
                for (let i = 0; i < 3; i++) {
                    self._showBoomParticle()
                }
                for (let j = 0; j < 40; j++) {
                    self._showPeople()
                }
                Laya.timer.frameOnce(1, this, () => {
                    ML.entity.hideAllEntity(null, "BoomParticle"), ML.entity.hideAllEntity(null, "People")
                })
            }

            initQuadTree() {
                ml.quadTree = new QuadTree({x: 0, y: 0, width: Constant.MapWidth, height: Constant.MapHeight});
                let children = ml.scene3D._children;
                for (let i = 0; i < children.length; i++) {
                    let child = children[i], name = child.name, data = {camp: 0};
                    if (0 != name.indexOf("car")) if (0 != name.indexOf("house")) ; else {
                        let ii = this.split(name), quad = child.addComponent(StaticEntity);
                        data.food = ML.config.getFoodData(ii.lv), quad.data = data, quad.treeInfo.width = ii.width, quad.treeInfo.height = ii.height, quad.treeInfo.isStatic = !0, quad.insert2QuadTree()
                    } else {
                        let ii = this.split(name, 3, 7), quad = child.addComponent(StaticEntity);
                        data.food = ML.config.getFoodData(1), quad.data = data, quad.treeInfo.width = ii.width, quad.treeInfo.height = ii.height, quad.treeInfo.isStatic = !0, quad.insert2QuadTree()
                    }
                }
            }

            split(name, w = null, h = null) {
                let ps = name.split("-");
                return {
                    name: ps[0],
                    width: w || parseInt(ps[1]),
                    height: h || parseInt(ps[2]),
                    lv: parseInt(ps[3]) || 2
                }
            }

            _showPlayer(data) {
                return ML.entity.showEntity(self.player, PlayerEntity, ml.scene3D, data, "Player")
            }

            _showAIPlayer(data) {
                return ML.entity.showEntity(self.player, AIPlayerEntity, ml.scene3D, data, "Player")
            }

            _showPeople(data) {
                return data = data || {position: new Laya.Vector3(1e3, 1e5, 1e5)}, ML.entity.showEntity(self.people, PeopleEntity, ml.scene3D, data, "People")
            }

            _showBoomParticle(data) {
                return data = data || {
                    position: new Laya.Vector3(1e3, 1e5, 1e5),
                    size: 1
                }, ML.entity.showEntity(self.boomParticle, ParticleEntity, ml.scene3D, data, "BoomParticle")
            }

            _showUIPlayer(data) {
                return ML.entity.showEntity(self.player, PlayerEntity, ml.scene3D, data, "Player")
            }
        }

        class ResourceLoader {
        }

        ResourceLoader.assetsDirectory = function () {
            return window.wx && !MLConfig.useLocalAssets ? window.wx.env.USER_DATA_PATH + "/assets" + MLConfig.assetsVersion : "res"
        }, ResourceLoader.deleteAssets = function () {
            var fileManager = window.wx.getFileSystemManager(), assetsDir = window.wx.env.USER_DATA_PATH;
            let currentAssets = "assets" + MLConfig.assetsVersion;
            fileManager.readdir({
                dirPath: assetsDir, success: f => {
                    let files = f.files;
                    for (let i = 0; i < files.length; i++) {
                        let d = files[i];
                        d !== currentAssets && (0 == d.indexOf("assets") && fileManager.rmdir({
                            dirPath: wx.env.USER_DATA_PATH + "/" + d,
                            recursive: !0
                        }))
                    }
                }
            })
        }, ResourceLoader.downloadAssets = function () {
            window.wx;
            var fileManager = window.wx.getFileSystemManager();
            let assetsVersion = MLConfig.assetsVersion, directory = this.assetsDirectory();
            return console.log("assets directory: " + directory), new Promise((r, s) => {
                fileManager.access({
                    path: directory, success: res => {
                        r(res)
                    }, fail: () => {
                        s("assets directory not exist. download...")
                    }
                })
            }).then(res => {
                console.log("assets directory exist. load assets..."), ML.event.emit("unzipComplete", null)
            }).catch(msg => (console.log(msg), new Promise((r, s) => {
                window.wx.downloadFile({
                    url: ML.api.downloadAssetsUrl, success: function (res) {
                        r(res), console.log("assets download success, ver: " + assetsVersion)
                    }, fail: function () {
                        s(), console.error("assets download fail")
                    }
                }).onProgressUpdate(res => {
                    let progress = res.progress.toFixed(2);
                    ML.event.emit("fileDownload", progress)
                })
            }).then(res => {
                var filePath = res.tempFilePath;
                fileManager.unzip({
                    zipFilePath: filePath,
                    targetPath: window.wx.env.USER_DATA_PATH,
                    success: function (res) {
                        console.log("assets unzip success, ver: " + assetsVersion), ML.event.emit("unzipComplete", null)
                    },
                    fail: function (res) {
                        console.error("assets unzip fail")
                    }
                })
            })))
        };

        class SplashScene extends Laya.View {
            constructor() {
                super()
            }

            onEnable() {
                if (!ml.game) {
                    let node = new Laya.Node;
                    ml.game = node.addComponent(Maingame), node.name = "myGame", Laya.stage.addChild(node)
                }
                ML.event.on("gameScene_unzipComplete", this, this._unzipComplete), ML.event.on("gameScene_downloading", this, this._downloading), ML.event.on("gameScene_loading", this, this._loading), ML.event.on("gameScene_load", this, this._loaded), this.download()
            }

            onDisable() {
                ML.event.off("gameScene_unzipComplete", this, this._unzipComplete), ML.event.off("gameScene_downloading", this, this._downloading), ML.event.off("gameScene_loading", this, this._loading), ML.event.off("gameScene_load", this, this._loaded)
            }

            download() {
                window.wx ? ML.gameScene.downloadScene() : this.loadScene()
            }

            loadScene() {
                ML.gameScene.loadScene()
            }

            _unzipComplete() {
                this.loadScene()
            }

            _downloading(value) {
                this._loadingLabel.text = "正在下载资源" + value + "%", this._loadingBar.width = 470 * value / 100
            }

            _loading(value) {
                this._loadingLabel.text = "正在加载资源" + parseInt(100 * value) + "%", this._loadingBar.width = 470 * value
            }

            _loaded() {
                this.close(), ml.game.initGame()
            }
        }

        new class {
            constructor() {
                console.log("---------------ex"), Laya.Node.prototype.getComponentsInChildren = function (clsName) {
                    let list = [];
                    for (let i = 0, m = this._children.length; i < m; i++) {
                        const child = this._children[i];
                        if (0 != child._children.length) {
                            let comps = child.getComponentsInChildren(clsName);
                            list = list.concat(comps)
                        } else {
                            let comps = child.getComponents(clsName);
                            list = list.concat(comps)
                        }
                    }
                    return list
                }, Laya.Vector2.MLSub = function (a, b, c) {
                    c.x = a.x - b.x, c.y = a.y - b.y
                }, Laya.Vector2.MLNornalize = function (o) {
                    let x = o.x, y = o.y, len = x * x + y * y;
                    len > 0 && (len = 1 / Math.sqrt(len), o.x = x * len, o.y = y * len)
                }, Laya.Vector3.MLNornalize = function (o) {
                }, Laya.Vector2.MLLength = function (o) {
                    let x = o.x, y = o.y;
                    return Math.sqrt(x * x + y * y)
                }, Laya.Vector2.MLScale = function (o, s) {
                    o.x *= s, o.y *= s
                }
            }
        };
        var gameEntry = new class {
            constructor() {
                window.ML = this, this.totalTime = 0, window.ml = window.ml || {}
            }

            regisiterModule(module) {
                console.log("regisiterModule"), ML[module.moduleName] = module
            }
        };

        class ModuleBase extends Laya.Script {
            constructor() {
                super(), this.moduleName = "base"
            }

            onAwake() {
                gameEntry.regisiterModule(this)
            }

            onEnable() {
            }

            onDisable() {
            }
        }

        class EventNodule extends ModuleBase {
            constructor() {
                super(), this.moduleName = "event"
            }

            emit(name, data) {
                this.owner.event(name, data)
            }

            on(name, caller, callback) {
                this.owner.on(name, caller, callback)
            }

            once(name, caller, callback) {
                this.owner.once(name, caller, callback)
            }

            off(name, caller, callback) {
                this.owner.off(name, caller, callback)
            }
        }

        class MLDictionary {
            constructor() {
                this._size = 0, this.data = {}
            }

            size() {
                return this._size
            }

            clear() {
                this.data = {}, this._size = 0
            }

            add(k, v) {
                this.containKey(k) || this._size++, this.data[k] = v
            }

            remove(k) {
                this.containKey(k) && delete this.data[k] && this._size--
            }

            valueForKey(k) {
                return this.containKey(k) ? this.data[k] : null
            }

            keyForValue(v) {
                for (var prop in this.data) if (this.data[prop] === v) return prop;
                return null
            }

            getAllKeys() {
                var keys = [];
                for (var prop in this.data) keys.push(prop);
                return keys
            }

            getAllValues() {
                var values = [];
                for (var prop in this.data) values.push(this.data[prop]);
                return values
            }

            containKey(k) {
                return k in this.data
            }
        }

        class EntityGroup {
            constructor() {
                this.entityLogics = [], this.groupData = arguments[0], this._paused = !1, this._timeScale = 1
            }

            addEntityLogic(entityLogic) {
                entityLogic.entityGroup = this, this.entityLogics.push(entityLogic)
            }

            removeEntityLogic(entityLogic) {
                let index = this.entityLogics.indexOf(entityLogic);
                this.entityLogics.splice(index, 1)
            }

            pause() {
                this._paused = !0
            }

            resume() {
                this._paused = !1
            }

            setTimeScale(scale) {
                this._timeScale = scale
            }

            onUpdate(dt) {
                if (!this._paused && 0 != this.entityLogics.length) for (let i = 0; i < this.entityLogics.length; i++) {
                    let entityLogic = this.entityLogics[i];
                    entityLogic.owner.active, entityLogic.onMLUpdate && entityLogic.onMLUpdate(dt * this._timeScale)
                }
            }

            showEntity(id, prefab, entityType, parentNode, data) {
                let entityLogic = this._showEntity(prefab, entityType);
                return entityLogic.entityId = id, parentNode.addChild(entityLogic.owner), entityLogic.willShow && entityLogic.willShow(data), entityLogic.owner.active = !0, this.addEntityLogic(entityLogic), entityLogic.onShow && entityLogic.onShow(data), entityLogic
            }

            hideEntity(entityLogic, data) {
                this._hideEntity(entityLogic, data)
            }

            hideAllEntity(data) {
                for (; this.entityLogics.length > 0;) {
                    let entityLogic = this.entityLogics[0];
                    ML.entity.hideEntity(entityLogic, data)
                }
            }

            _showEntity(prefab, entityType) {
                let name = prefab.name, entityNode = this._getOrNewEntityPool(name).get();
                null == entityNode && (entityNode = this._createEntity(prefab, entityType));
                let entity = entityNode.addComponent(entityType);
                return entity.parentEntityLogic = null, entity.childrenEntityLogic = [], entity.onShow = entity.onShow || null, entityNode.entity = entity, entity.__active = !0, entity
            }

            _hideEntity(entityLogic, data) {
                if (!entityLogic.__active) return;
                entityLogic.__active = !1;
                let node = entityLogic.owner, pool = this._getOrNewEntityPool(entityLogic.owner.name);
                entityLogic.willHide && entityLogic.willHide(data), node.active = !1, this.removeEntityLogic(entityLogic), entityLogic.onHide && entityLogic.onHide(data), node.removeSelf(), entityLogic.destroy(), entityLogic = null, node.entity = null, pool.put(node)
            }

            _createEntity(prefab, entityType) {
                return prefab.clone()
            }

            _getOrNewEntityPool(name) {
                return ML.entityPool.getOrCreatePool(name, this.groupData.poolSize, this.groupData.autoReleaseInterval)
            }
        }

        class EntityModule extends ModuleBase {
            constructor() {
                super(), this.moduleName = "entity", this.entityGroups = new MLDictionary, this._serializeId = 0, this.itmeScale = 1, this.initEntityGroups()
            }

            onUpdate() {
                if (!this.paused) for (let key in this.entityGroups.data) {
                    this.entityGroups.data[key].onUpdate(Laya.timer.delta * this.itmeScale)
                }
            }

            setTimeScale(scale, group = null) {
                if (group) {
                    this.getEntityGroup(group).setTimeScale(scale)
                } else this.itmeScale = scale
            }

            pause() {
                this.paused = !0
            }

            resume() {
                this.paused = !1
            }

            initEntityGroups() {
                let entityGroupDatas = MLConfig.entityGroups;
                for (let i = 0; i < entityGroupDatas.length; i++) {
                    let entityGroupData = entityGroupDatas[i];
                    this.createEntityGroup(entityGroupData)
                }
            }

            createEntityGroup(entityGroupData) {
                let group = new EntityGroup(entityGroupData);
                this.entityGroups.add(entityGroupData.groupName, group)
            }

            getEntityGroup(name) {
                let group = this.entityGroups.valueForKey(name);
                return group || console.error("不存在该实体组：", name), group
            }

            showEntity(prefab, entityType, parentNode, data, groupName = "Default") {
                return this.getEntityGroup(groupName).showEntity(this._serializeId--, prefab, entityType, parentNode, data)
            }

            hideEntity(entityLogic, data) {
                if (!entityLogic.__active) return;
                let childrenEntityLogic = entityLogic.childrenEntityLogic;
                for (; childrenEntityLogic.length > 0;) {
                    let logic = childrenEntityLogic[0];
                    this.hideEntity(logic, data)
                }
                this.detachedEntity(entityLogic), entityLogic.entityGroup.hideEntity(entityLogic, data)
            }

            hideAllEntity(data, groupName = null) {
                if (groupName) {
                    this.getEntityGroup(groupName).hideAllEntity(data)
                } else for (let key in this.entityGroups.data) {
                    this.entityGroups.data[key].hideAllEntity(data)
                }
            }

            attachToEntity(entityLogic, parentEntityLogic, targetNode = null, userData = null) {
                null == targetNode && (targetNode = parentEntityLogic.owner), this.detachedEntity(entityLogic), targetNode.addChild(entityLogic.owner), parentEntityLogic.childrenEntityLogic.push(entityLogic), parentEntityLogic.onAttached && parentEntityLogic.onAttached(entityLogic, targetNode, userData), entityLogic.parentEntityLogic = parentEntityLogic, entityLogic.onAttachTo && entityLogic.onAttachTo(parentEntityLogic, targetNode, userData)
            }

            detachedEntity(entityLogic, userData = null) {
                let parentEntityLogic = entityLogic.parentEntityLogic;
                if (!parentEntityLogic) return;
                let index = parentEntityLogic.childrenEntityLogic.indexOf(entityLogic);
                parentEntityLogic.childrenEntityLogic.splice(index, 1), parentEntityLogic.onDetached && parentEntityLogic.onDetached(entityLogic, userData), entityLogic.parentEntityLogic = null, entityLogic.owner.removeSelf(), entityLogic.onDetachFrom && entityLogic.onDetachFrom(parentEntityLogic, userData)
            }
        }

        class EntityPool {
            constructor() {
                this.entitys = [], this.poolName = arguments[0], this.size = arguments[1], this.releaseInterval = arguments[2], this._intervalOfLoopToRelease = 2, this._intervalAdditivesOfLoopToRelease = 0
            }

            size() {
                return this.entitys.length
            }

            clear() {
                let count = this.entitys.length;
                for (let i = 0; i < count; i++) this.entitys[i].destroy();
                this.entitys.length = 0
            }

            put(entity) {
                this.entitys.length >= this.size ? entity.destroy() : entity && -1 === this.entitys.indexOf(entity) && (entity.___mlAuto_Raleased = !1, entity.___mlPool_PutDate = ML.totalTime, this.entitys.push(entity))
            }

            get() {
                if (0 == this.entitys.length) return null;
                let last = this.entitys.length - 1, entity = this.entitys[last];
                return entity.___mlPool_PutDate = null, this.entitys.splice(last, 1), entity
            }

            onUpdate(dt) {
            }

            _loopEntitysShouldRelease() {
                if (0 == this.entitys.length) return;
                let nowDate = ML.totalTime;
                for (let index = 0; index < this.entitys.length; index++) {
                    let entity = this.entitys[index];
                    if (entity.___mlPool_PutDate) {
                        if (!(nowDate - entity.___mlPool_PutDate >= this.releaseInterval)) return;
                        {
                            entity.___mlAuto_Raleased = !0;
                            let i = this.entitys.indexOf(entity);
                            this.entitys.splice(i, 1), entity && entity.destroy(), index--
                        }
                    }
                }
            }
        }

        class EntityPoolModule extends ModuleBase {
            constructor() {
                super(), this.moduleName = "entityPool", this.entityPools = new MLDictionary
            }

            getOrCreatePool(name, size = 30, releaseInterval = 30) {
                let entityPool = this.getEntityPool(name);
                return entityPool || (entityPool = this.createEntityPool(name, size, releaseInterval)), entityPool
            }

            createEntityPool(name, size, releaseInterval) {
                let entityPool = new EntityPool(name, size, releaseInterval);
                return this.entityPools.add(name, entityPool), entityPool
            }

            getEntityPool(name) {
                return this._findEntityPool(name)
            }

            _findEntityPool(name) {
                return this.entityPools.valueForKey(name)
            }

            onUpdate() {
                let dt = Laya.timer.delta / 1e3;
                for (let key in this.entityPools.data) {
                    this.entityPools.data[key].onUpdate(dt)
                }
            }
        }

        let onResizeCallback = null;

        class WxBanner {
            constructor() {
            }

            init(bannerId, width = 300, onResize = null) {
                this.bannerId = bannerId, this.bannerWidth = width, this.showCount = 0, onResizeCallback = onResize, this.prepare()
            }

            show() {
                window.wx && this.banner.show()
            }

            prepare() {
                if (!window.wx) return;
                let self = this, windowWidth = ML.wx.getSystemInfoSync().windowWidth;
                windowWidth < this.bannerWidth && (this.bannerWidth = windowWidth), this.banner && (this.banner.offResize(self._onResize), this.banner.offError(self._onError)), this.banner = this._createBannerAd(this.bannerId, this.bannerWidth), this.banner.onResize(self._onResize.bind(self)), this.banner.onError(self._onError)
            }

            _onResize(size) {
                let self = this;
                onResizeCallback && onResizeCallback(self, self.banner, size)
            }

            _onError(msg, code) {
                console.log("banner___error", msg)
            }

            hide() {
                window.wx && this.banner && (this.banner.hide(), this.banner.destroy(), this.prepare())
            }

            _createBannerAd(adUnitId, width) {
                if (!window.wx) return;
                if (ML.wx.getSystemInfoSync().SDKVersion < "2.0.4") return;
                return wx.createBannerAd({adUnitId: adUnitId, adIntervals: 30, style: {left: 0, top: 0, width: width}})
            }
        }

        class WxAdModule extends ModuleBase {
            constructor() {
                super(), this.moduleName = "wxAD", this.bannerId = "adunit-09c53a6dd242797b", this.defaultVidoeId = "adunit-53777cdfc537609a", this.screenId = "adunit-53777cdfc537609a"
            }

            onEnable() {
                this.bannerMaxHeight = ML.wx.isIphoneX() ? 277 : 209, window.wx && (this.banner = this._initBanner(this.bannerId, 200, 0, null), this._initScreenAd())
            }

            onDisable() {
            }

            _initBanner(bannerId, width, yOffset, callback = null) {
                let banner = new WxBanner;
                banner.yOffset = yOffset;
                let self = this;
                return banner.init(bannerId, width, function (banner, ad, size) {
                    let realSize = self._bottomCenterBanner(ad, size, banner.yOffset);
                    callback && callback(realSize)
                }), banner
            }

            _bottomCenterBanner(banner, size, yOffset) {
                let wxsys = ML.wx.getSystemInfoSync(), windowWidth = wxsys.windowWidth,
                    windowHeight = wxsys.windowHeight, bottomOffset = ML.wx.isIphoneX() ? 30 : 0,
                    raW = Laya.stage.width / windowWidth, raH = Laya.stage.height / windowHeight;
                banner.style.height = size.height, banner.style.width = size.width, banner.style.left = (windowWidth - size.width) / 2, banner.style.top = windowHeight - size.height - bottomOffset - yOffset;
                let realHeight = (size.height + bottomOffset) * raH, realWidth = size.width * raW;
                return new Laya.Vector2(realWidth, realHeight)
            }

            showBanner() {
                window.wx && this.banner && this.banner.show()
            }

            hideBanner() {
                window.wx && this.banner && this.banner.hide()
            }

            _initScreenAd() {
                wx.createInterstitialAd && (this.interstitialAd = wx.createInterstitialAd({adUnitId: this.screenId}))
            }

            showScreen() {
                this.interstitialAd && this.interstitialAd.show().catch(err => {
                    console.error(err)
                })
            }
        }

        class WXModule extends ModuleBase {
            constructor() {
                super(), this.moduleName = "wx", this.Auth_UserInfo = "scope.userInfo", this.Auth_UserLocal = "scope.userLocation", this.appKey = "039f64e5f38b427ab601dfe451474d9e", this.baseUrl = "https://game.woool.live/api", this.staticUrl = "https://game.woool.live", this.shareCardsUrl = this.baseUrl + "/shareCard/getShareCardByAppKey", this.defaultShareInfo = null
            }

            onAwake() {
                super.onAwake(), this.share_clickTime = null, this.currentShareCallback = null, this.shareSuccessInterval = MLConfig.shareSuccessInterval, this.shareFail = !1, this.showShareMenuWithTicket(!0), this._regisiterLifecycle(), this.updateProgram(), this.requestShareCard(), this.regisiterWXShareCallback("我的记录只能我自己打破，其他人，遥望就好！", "")
            }

            getLaunchOption() {
                if (window.wx) return wx.getLaunchOptionsSync()
            }

            getSystemInfoSync() {
                if (window.wx) return wx.getSystemInfoSync()
            }

            isIphoneX() {
                if (!window.wx) return;
                let sysInfo = this.getSystemInfoSync(), screenHeight = sysInfo.screenHeight,
                    ratioWH = sysInfo.screenWidth / screenHeight;
                return ratioWH <= .5 || ratioWH >= 2
            }

            isIos() {
                if (!window.wx) return !0;
                return this.getSystemInfoSync().system.toLowerCase().indexOf("ios") >= 0
            }

            vibrateShort() {
                window.wx && wx.vibrateShort()
            }

            setClipboardData(data, success, fail) {
                window.wx && wx.setClipboardData({
                    data: data, success: function (res) {
                        success(res)
                    }, fail: function (res) {
                        fail(res)
                    }
                })
            }

            postMessage(data) {
                window.wx && wx.getOpenDataContext().postMessage(data)
            }

            navigatTomini(obj) {
                window.wx && wx.navigateToMiniProgram(obj)
            }

            updateProgram() {
                let self = this;
                if (window.wx && "function" == typeof wx.getUpdateManager) {
                    const updateManager = wx.getUpdateManager();
                    updateManager.onCheckForUpdate(function (res) {
                    }), updateManager.onUpdateReady(function (res) {
                        console.log("有新版本", res), self.showModal("发现新版本", "新版本已经准备好!", !1, function (res) {
                            updateManager.applyUpdate()
                        })
                    }), updateManager.onUpdateFailed(function () {
                    })
                }
            }

            showModal(title, content, showCancel, confirm) {
                window.wx && wx.showModal({
                    title: title, content: content, showCancel: showCancel, success(res) {
                        res.confirm ? confirm && confirm(!0) : res.cancel && confirm && confirm(!1)
                    }
                })
            }

            showToast(title, toastType = "none", mask = !1) {
                window.wx && wx.showToast({title: title, icon: toastType, duration: 2e3, mask: mask})
            }

            requestShareCard() {
                if (!window.wx) return;
                let self = this;
                this.request(this.shareCardsUrl, {appKey: this.appKey}, "GET").then(r => {
                    r && r.data && r.data.length > 0 && r.data.forEach(item => {
                        "default" == item.scene && (self.regisiterWXShareCallback(item.title, item.image_url, null), self.defaultShareInfo = item)
                    })
                }).catch(() => {
                    self.defaultShareInfo.title = "我的记录只能我自己打破，其他人，遥望就好！", self.defaultShareInfo.image_url = "", self.regisiterWXShareCallback("我的记录只能我自己打破，其他人，遥望就好！", "")
                })
            }

            showShareMenuWithTicket(ticket) {
                window.wx && wx.showShareMenu({withShareTicket: ticket})
            }

            regisiterWXShareCallback(title, imageUrl, query = null) {
                let self = this;
                window.wx && wx.onShareAppMessage(() => {
                    return self._buildShareInfo(title, imageUrl, query)
                })
            }

            shareDefault() {
                this.share(this.defaultShareInfo.title, this.defaultShareInfo.image_url, null, () => {
                })
            }

            share(title, imageUrl, query, callback) {
                window.wx || callback(!0), this.currentShareCallback = callback, this.share_clickTime = Date.now(), this._share(title, imageUrl, query)
            }

            _share(title, imageUrl, query = null) {
                if (!window.wx) return;
                let shareInfo = this._buildShareInfo(title, imageUrl, query);
                wx.shareAppMessage(shareInfo)
            }

            _buildShareInfo(title, imageUrl, query) {
                return {title: title, imageUrl: imageUrl, query: query}
            }

            _onSimulateShareBack() {
                null != this.currentShareCallback && null != this.share_clickTime && (Date.now() - this.share_clickTime >= 1e3 * this.shareSuccessInterval ? this.currentShareCallback(!0) : this.currentShareCallback(!1), this.currentShareCallback = null, this.share_clickTime = null)
            }

            login(success, fail) {
                window.wx ? wx.login({
                    success(res) {
                        res.code ? success && success(res.code) : fail && fail(res.errMsg)
                    }
                }) : fail(-1e3)
            }

            authOrGetUserInfo(userInfoCb, settingCb = null) {
                if (!window.wx) return void console.log("非微信環境");
                let self = this, wxbtn = null;
                this.hasAuthUserInfo(function (isAuth) {
                    console.log("授权信息", isAuth), isAuth ? (settingCb && settingCb(!0), self.getUserInfo(function (userInfo) {
                        console.log("获取用户信息：", userInfo), userInfoCb(userInfo)
                    }, function (error) {
                        userInfoCb(null)
                    })) : (wxbtn = self.showUserInfoButton(function (userInfo) {
                        userInfoCb(userInfo), console.log("授权获取用户信息：", userInfo)
                    }), settingCb && settingCb(!1, wxbtn))
                }, function (error) {
                    wxbtn = self.showUserInfoButton(function (userInfo) {
                        userInfoCb(userInfo), console.log("授权获取用户信息：", userInfo)
                    }), settingCb && settingCb(!1, wxbtn)
                })
            }

            getUserInfo(success, fail) {
                window.wx ? wx.getUserInfo({
                    success: function (res) {
                        success(res.userInfo)
                    }, fail: function (res) {
                        fail(res)
                    }
                }) : fail(-1e3)
            }

            showUserInfoButton(callback) {
                if (!window.wx) return;
                let obj = {type: "text", text: "", style: this._initLoginButton()}, btn = wx.createUserInfoButton(obj);
                return btn.onTap(function (res) {
                    "getUserInfo:ok" == res.errMsg ? callback(res.userInfo) : callback(null), btn.hide()
                }), btn.show(), btn
            }

            hasAuthUserInfo(success, fail) {
                this.getAuthSetting(this.Auth_UserInfo, success, fail)
            }

            getAuthSetting(code, success, fail = null) {
                window.wx ? wx.getSetting({
                    success: function (res) {
                        success(res.authSetting[code])
                    }, fail: function (error) {
                        fail && fail(error)
                    }
                }) : fail(null)
            }

            _regisiterLifecycle() {
                if (!window.wx) return;
                let self = this;
                wx.onShow(function (res) {
                    self._onShowCallback(res)
                }), wx.onHide(function () {
                    self._onHideCallback()
                })
            }

            _onShowCallback(res) {
                this._onSimulateShareBack()
            }

            _onHideCallback() {
            }

            _initLoginButton() {
                if (!window.wx) return;
                let wxsys = wx.getSystemInfoSync(), x = wxsys.screenWidth / 4, y = wxsys.screenHeight / 4,
                    h = wxsys.screenHeight;
                return {
                    left: x,
                    top: y,
                    width: wxsys.screenWidth,
                    height: h,
                    lineHeight: 40,
                    type: "text",
                    textAlign: "center",
                    fontSize: 28,
                    borderRadius: 5,
                    textAlign: "center"
                }
            }

            request(url, data, method, header = null) {
                return window.wx ? new Promise((r, s) => {
                    window.wx.request({
                        url: url, data: data, header: header, method: method, success: res => {
                            r(res.data)
                        }, fail: () => {
                            s()
                        }
                    })
                }) : new Promise((r, s) => {
                    s("非微信环境")
                })
            }
        }

        class JQuery {
        }

        JQuery.extend = function () {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1,
                length = arguments.length, deep = !1;
            for ("boolean" == typeof target && (deep = target, target = arguments[1] || {}, i = 2), length === i && (target = this, --i); i < length; i++) if (null != (options = arguments[i])) for (name in options) src = target[name], target !== (copy = options[name]) && (deep && copy && (ML.JQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, clone = src && Array.isArray(src) ? src : []) : clone = src && ML.JQuery.isPlainObject(src) ? src : {}, target[name] = ML.JQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
            return target
        }, JQuery.clone = function (obj) {
            var buf;
            if (obj instanceof Array) {
                buf = [];
                for (var i = obj.length; i--;) buf[i] = JQuery.clone(obj[i]);
                return buf
            }
            if (obj instanceof Object) {
                for (var k in buf = {}, obj) buf[k] = JQuery.clone(obj[k]);
                return buf
            }
            return obj
        };

        class UserModule extends ModuleBase {
            constructor() {
                super(), this.moduleName = "user", this._userData = null
            }

            get UserData() {
                return null != this._userData ? this._userData : (this._userData = this._initUserFromLocalStorage(), null != this._userData ? this._userData : (this._userData = this._default(), this._userData))
            }

            _initUserFromLocalStorage() {
                let localData = this.getObjectFromLocalStorage("User");
                return localData ? JQuery.extend(this._default(), localData) : this._default()
            }

            _default() {
                return {
                    uuid: Tools.GUID(8, 36),
                    openId: "",
                    nickname: "",
                    gold: 0,
                    gender: 0,
                    imageUrl: "",
                    city: "",
                    country: "",
                    province: "",
                    level: 0,
                    score: 0,
                    roleModel: "default",
                    appKey: "",
                    ver: 0,
                    rankScore: 0,
                    rankLv: 0
                }
            }

            win() {
                this.saveUser()
            }

            saveUser() {
                let s = JSON.stringify(this.UserData);
                localStorage.setItem("User", s)
            }

            addGold(gold) {
                Tools.IsNumber(gold) && (this.UserData.gold += gold)
            }

            getGold() {
                return this.UserData.gold
            }

            addScore(score) {
                score < 0 && (score = 0);
                let tScore = this.UserData.score + score;
                this.UserData.score = tScore
            }

            addRankScore(score) {
                score < 0 && (score = 0);
                let tScore = this.UserData.rankScore + score;
                return this.UserData.rankScore = tScore, tScore
            }

            setRankLv(lv) {
                this.UserData.rankLv = lv
            }

            getRankLv() {
                return this.UserData.rankLv
            }

            getValueFromLocalStorage(key, _default) {
                let v = localStorage.getItem(key);
                return v || (_default || null)
            }

            getObjectFromLocalStorage(key, _default) {
                let v = this.getValueFromLocalStorage(key, _default);
                return v ? JSON.parse(v) : {}
            }
        }

        class SingleAdButton extends Laya.Script {
            constructor() {
                super(), this._singleAdButton = null, this.refreshInterval = 4e3, this.refreshIntervalAdditive = 0
            }

            onEnable() {
            }

            onUpdate() {
                this._singleAdButton && (this.refreshIntervalAdditive += Laya.timer.delta, this.refreshIntervalAdditive >= this.refreshInterval && (this.refreshIntervalAdditive = 0, this.reload()))
            }

            onDisable() {
            }

            _onSingleAdButtonClick() {
                this.currentItem && (ML.qy.adClick(this.currentItem, this.data.onFail), this.reload())
            }

            init(dataSource, data) {
                this.data = data, this.dataSource = dataSource, this._singleAdButton = new Laya.Image, this._singleAdButton.skin = data.bg, this._singleAdButton.anchorX = .5, this._singleAdButton.anchorY = .5, this._singleAdButton.centerX = 0, this._singleAdButton.centerY = 0, this._singleAdButton.on("click", this, this._onSingleAdButtonClick), this.owner.addChild(this._singleAdButton), this.icon = new Laya.Image, this.icon.size(data.iconWidth, data.iconHeight), this.icon.top = 30, this.icon.centerX = 3, this._singleAdButton.addChild(this.icon), this.title = new Laya.Label, this.title.fontSize = 20, this.title.color = "#B5B5B4", this.title.bottom = 28, this.title.left = 40, this._singleAdButton.addChild(this.title), this.reload()
            }

            reload() {
                let item = Tools.RandomOne(this.dataSource.result);
                if (!item || !item.logo) return;
                let logo = ML.qy._randomLogoUrl(item.logo), self = this;
                Laya.loader.load(logo, Laya.Handler.create(this, res => {
                    self && self.owner && !self.owner.destroyed && self.icon && (self.icon.skin = logo)
                })), this.title.text = item.title, this.currentItem = item
            }
        }

        class AdCarousel extends Laya.Script {
            constructor() {
                super(), this.left = !0, this.mouseOver = !1, this.slideDelay = 2e3, this.currentDelay = 1e3, this.startDelay = !1
            }

            onEnable() {
                this.owner.on(Laya.Event.MOUSE_OVER, this, this._onMouseOver), this.owner.on(Laya.Event.MOUSE_OUT, this, this._onMouseOut)
            }

            onDisable() {
            }

            _onMouseOver() {
                this.mouseOver = !0
            }

            _onMouseOut() {
                this.mouseOver = !1
            }

            onUpdate() {
                if (!this.mouseOver && this.list) return this.startDelay ? (this.currentDelay -= Laya.timer.delta, void (this.currentDelay <= 0 && (this.startDelay = !1, this.currentDelay = this.slideDelay))) : void (this.left ? (this.list.scrollBar.value -= 1, this.list.scrollBar.value <= 0 && (this.left = !1, this.startDelay = !0)) : (this.list.scrollBar.value += 1, this.list.scrollBar.value >= this.list.scrollBar.max && (this.left = !0, this.startDelay = !0)))
            }

            init(dataSource, data) {
                this.dataSource = dataSource, this.data = data;
                let bg = new Laya.Image(data.bg);
                bg.centerX = 0, bg.centerY = 0, bg.width = Laya.stage.width, this.owner.addChild(bg), this.list = ML.qy._createList(AdCarouselItem, dataSource.result.length, 1, 10, 0, 2), this.list.selectHandler = new Laya.Handler(this, this.onSelected), this.list.renderHandler = new Laya.Handler(this, this.updateItem), this.list.width = Laya.stage.width - 20, this.list.centerY = 0, this.list.centerX = 0, this.list.right = 10, bg.addChild(this.list), this.reload()
            }

            reload() {
                this.list.array = this.dataSource.result
            }

            onSelected(index) {
                ML.qy.adClick(this.list.array[index], this.data.onFail), this.list._selectedIndex = -1, console.log("ssssss:", this.list.array[index]), this.reload()
            }

            updateItem(cell, index) {
                let item = cell.dataSource;
                if (!item || !item.logo) return;
                let logo = ML.qy._randomLogoUrl(item.logo);
                cell.setImg(logo)
            }
        }

        class AdCarouselItem extends Laya.Box {
            constructor() {
                super(), this.init()
            }

            init() {
                this.size(120, 120), this.img = new Laya.Image, this.img.size(120, 120), this.img.centerX = 0, this.img.centerY = 0, this.addChild(this.img)
            }

            setImg(url) {
                let self = this;
                Laya.loader.load(url, Laya.Handler.create(this, res => {
                    self && self.destroy && (self.img.skin = url)
                }))
            }
        }

        class AdMorePlay extends Laya.Script {
            constructor() {
                super(), this.left = !0, this.mouseOver = !1, this.slideDelay = 2e3, this.currentDelay = 1e3, this.startDelay = !1
            }

            onEnable() {
                this.owner.on(Laya.Event.MOUSE_OVER, this, this._onMouseOver), this.owner.on(Laya.Event.MOUSE_OUT, this, this._onMouseOut)
            }

            onDisable() {
            }

            _onMouseOver() {
                this.mouseOver = !0
            }

            _onMouseOut() {
                this.mouseOver = !1
            }

            onUpdate() {
                if (!this.mouseOver && this.list) return this.startDelay ? (this.currentDelay -= Laya.timer.delta, void (this.currentDelay <= 0 && (this.startDelay = !1, this.currentDelay = this.slideDelay))) : void (this.left ? (this.list.scrollBar.value -= 1, this.list.scrollBar.value <= 0 && (this.left = !1, this.startDelay = !0)) : (this.list.scrollBar.value += 1, this.list.scrollBar.value >= this.list.scrollBar.max && (this.left = !0, this.startDelay = !0)))
            }

            _closeClick() {
                ML.qy.hideAdView(this)
            }

            init(dataSource, data) {
                this.dataSource = dataSource, this.data = data;
                let greyBg = new Laya.Image(data.grey);
                greyBg.centerX = 0, greyBg.centerY = 0, greyBg.width = Laya.stage.width, greyBg.height = Laya.stage.height, greyBg.on("click", this, this._closeClick), this.owner.addChild(greyBg);
                let bg = new Laya.Image(data.bg);
                bg.centerX = 0, bg.centerY = 0, this.owner.addChild(bg);
                let close = new Laya.Image(data.btnBg);
                close.left = 30, close.top = 40, close.on("click", this, this._closeClick), bg.addChild(close), this.list = ML.qy._createList(AdMoreItem, 3, 4, 10, 10, 1), this.list.selectHandler = new Laya.Handler(this, this.onSelected), this.list.renderHandler = new Laya.Handler(this, this.updateItem), this.list.width = 600, this.list.height = 870, this.list.centerX = 20, this.list.top = 110, this.owner.addChild(this.list), this.reload()
            }

            reload() {
                this.list.array = this.dataSource.result
            }

            onSelected(index) {
                ML.qy.adClick(this.list.array[index], this.data.onFail), this.list._selectedIndex = -1, console.log("ssssss:", this.list.array[index]), this.reload()
            }

            updateItem(cell, index) {
                let item = cell.dataSource;
                if (!item || !item.logo) return;
                let logo = ML.qy._randomLogoUrl(item.logo);
                cell.setImg(logo), cell.setText(item.title)
            }
        }

        class AdMoreItem extends Laya.Box {
            constructor() {
                super(), this.init()
            }

            init() {
                this.size(180, 210), this.img = new Laya.Image, this.img.size(180, 180), this.img.centerX = 0, this.img.top = 0, this.addChild(this.img), this.gtitle = new Laya.Label("ssss"), this.gtitle.color = "#ffffff", this.gtitle.fontSize = 24, this.gtitle.bottom = 0, this.gtitle.centerX = 0, this.addChild(this.gtitle)
            }

            setImg(url) {
                let self = this;
                Laya.loader.load(url, Laya.Handler.create(this, res => {
                    self && self.destroy && (self.img.skin = url)
                }))
            }

            setText(text) {
                this.gtitle.text = text
            }
        }

        class AdGameover extends Laya.Script {
            constructor() {
                super(), this.left = !0, this.mouseOver = !1, this.slideDelay = 2e3, this.currentDelay = 1e3, this.startDelay = !1
            }

            onEnable() {
                this.owner.on(Laya.Event.MOUSE_OVER, this, this._onMouseOver), this.owner.on(Laya.Event.MOUSE_OUT, this, this._onMouseOut)
            }

            onDisable() {
            }

            _onMouseOver() {
                this.mouseOver = !0
            }

            _onMouseOut() {
                this.mouseOver = !1
            }

            onUpdate() {
                if (!this.mouseOver && this.list) return this.startDelay ? (this.currentDelay -= Laya.timer.delta, void (this.currentDelay <= 0 && (this.startDelay = !1, this.currentDelay = this.slideDelay))) : void (this.left ? (this.list.scrollBar.value -= 1, this.list.scrollBar.value <= 0 && (this.left = !1, this.startDelay = !0)) : (this.list.scrollBar.value += 1, this.list.scrollBar.value >= this.list.scrollBar.max && (this.left = !0, this.startDelay = !0)))
            }

            init(dataSource, data) {
                this.dataSource = dataSource, this.data = data;
                let bg = new Laya.Image(data.bg);
                bg.centerX = 0, bg.centerY = 0, this.owner.addChild(bg), this.list = ML.qy._createList(AdGameoverItem, 4, 2, 10, 0, 1), this.list.selectHandler = new Laya.Handler(this, this.onSelected), this.list.renderHandler = new Laya.Handler(this, this.updateItem), this.list.width = 600, this.list.height = 360, this.list.centerX = 10, this.list.top = 110, this.owner.addChild(this.list), this.reload()
            }

            reload() {
                this.list.array = this.dataSource.result
            }

            onSelected(index) {
                ML.qy.adClick(this.list.array[index], this.data.onFail), this.list._selectedIndex = -1, console.log("ssssss:", this.list.array[index]), this.reload()
            }

            updateItem(cell, index) {
                let item = cell.dataSource;
                if (!item || !item.logo) return;
                let logo = ML.qy._randomLogoUrl(item.logo);
                cell.setImg(logo), cell.setText(item.title)
            }
        }

        class AdGameoverItem extends Laya.Box {
            constructor() {
                super(), this.init()
            }

            init() {
                this.size(135, 180), this.img = new Laya.Image, this.img.size(135, 135), this.img.centerX = 0, this.img.top = 0, this.addChild(this.img), this.gtitle = new Laya.Label("ssss"), this.gtitle.color = "#ffffff", this.gtitle.fontSize = 24, this.gtitle.bottom = 5, this.gtitle.centerX = 0, this.addChild(this.gtitle)
            }

            setImg(url) {
                this.img.skin = url
            }

            setText(text) {
                this.gtitle.text = text
            }
        }

        class AdExport extends Laya.Script {
            constructor() {
                super(), this.left = !0, this.mouseOver = !1, this.slideDelay = 2e3, this.currentDelay = 1e3, this.startDelay = !1
            }

            onEnable() {
                ML.wxAD.hideBanner(), this.owner.on(Laya.Event.MOUSE_OVER, this, this._onMouseOver), this.owner.on(Laya.Event.MOUSE_OUT, this, this._onMouseOut)
            }

            onDisable() {
                ML.qy.hideAdView(this.fri), this.data.close && this.data.close()
            }

            _onMouseOver() {
                this.mouseOver = !0
            }

            _onMouseOut() {
                this.mouseOver = !1
            }

            onUpdate() {
                if (!this.mouseOver && this.list) return this.startDelay ? (this.currentDelay -= Laya.timer.delta, void (this.currentDelay <= 0 && (this.startDelay = !1, this.currentDelay = this.slideDelay))) : void (this.left ? (this.list.scrollBar.value -= 1, this.list.scrollBar.value <= 0 && (this.left = !1, this.startDelay = !0)) : (this.list.scrollBar.value += 1, this.list.scrollBar.value >= this.list.scrollBar.max && (this.left = !0, this.startDelay = !0)))
            }

            _closeClick() {
                ML.qy.hideAdView(this)
            }

            init(dataSource, data) {
                this.offsetY = ML.wx.isIphoneX() ? 50 : 0, this.dataSource = dataSource, this.data = data, this.fri = ML.qy.showAdFriend(), this.fri.owner.top += this.offsetY;
                let greyBg = new Laya.Image(data.bg);
                greyBg.centerX = 0, greyBg.centerY = 0, greyBg.width = Laya.stage.width, greyBg.height = Laya.stage.height, this.owner.addChild(greyBg);
                let haoyouTitle = new Laya.Image(data.haoyouTitle);
                haoyouTitle.top = 110 + this.offsetY, haoyouTitle.left = 40, this.owner.addChild(haoyouTitle);
                let tuijianTitle = new Laya.Image(data.tuijianTitle);
                tuijianTitle.top = 310 + this.offsetY, tuijianTitle.left = 40, this.owner.addChild(tuijianTitle);
                let close = new Laya.Image(data.btn);
                close.top = 20 + this.offsetY, close.left = 30, close.on("click", this, this._closeClick), greyBg.addChild(close), this.list = ML.qy._createList(AdExportItem, 2, 4, 0, 26, 1), this.list.selectHandler = new Laya.Handler(this, this.onSelected), this.list.renderHandler = new Laya.Handler(this, this.updateItem), this.list.width = Laya.stage.width - 60, this.list.bottom = 100, this.list.centerX = 0, this.list.top = 360 + this.offsetY, greyBg.addChild(this.list), this.reload()
            }

            reload() {
                this.list.array = this.dataSource.result
            }

            onSelected(index) {
                ML.qy.adClick(this.list.array[index], this.data.onFail, this.data.onSuccess), this.list._selectedIndex = -1, console.log("ssssss:", this.list.array[index]), this.reload()
            }

            updateItem(cell, index) {
                let item = cell.dataSource;
                if (!item || !item.logo) return;
                let logo = ML.qy._randomLogoUrl(item.logo), playerNum = RandomUtil.randomIntegerN2M(1e5, 8e5) + "人在玩";
                cell.setBg(this.data.itemBg), cell.setImg(logo), cell.setText(item.title, playerNum)
            }
        }

        class AdExportItem extends Laya.Box {
            constructor() {
                super(), this.init()
            }

            init() {
                this.size(346, 356), this.bg = new Laya.Image, this.bg.height = this.height, this.bg.width = this.width, this.bg.centerX = 0, this.bg.centerY = 0, this.addChild(this.bg), this.img = new Laya.Image, this.img.size(270, 270), this.img.centerX = 0, this.img.top = 20, this.addChild(this.img), this.gtitle = new Laya.Label("ssss"), this.gtitle.color = "#404040", this.gtitle.fontSize = 22, this.gtitle.bottom = 30, this.gtitle.left = 40, this.addChild(this.gtitle), this.playerNum = new Laya.Label, this.playerNum.fontSize = 22, this.playerNum.color = "#EA3F1B", this.playerNum.bottom = 30, this.playerNum.right = 40, this.addChild(this.playerNum)
            }

            setBg(skin) {
                this.bg.skin = skin
            }

            setImg(url) {
                let self = this;
                Laya.loader.load(url, Laya.Handler.create(this, res => {
                    self && self.destroy && (self.img.skin = url)
                }))
            }

            setText(text, playerNum) {
                this.gtitle.text = text, this.playerNum.text = playerNum
            }
        }

        class QyModule extends ModuleBase {
            constructor() {
                super(), this.moduleName = "qy", this.adViewId = 0, this.adViews = [], this.AD_bgGreySkin = "ui/grey30.png", this.AD_SingleBgSkin = "ui/tryplay.png", this.AD_CarouselSkin = "ui/carouselbg.png", this.AD_MorePlaySkin = "ui/morePlay_bg.png", this.AD_MorePlayBtn = "ui/close.png", this.AD_GameoverSkin = "ui/haoyouwan.png", this.AD_ExportSkin = "ui/daochubg.jpg", this.AD_ExportTitle = "ui/daochu_tuijian.png", this.AD_ExportItemSkin = "ui/daochu_itembg.png", this.AD_ExportBtnSkin = "ui/daochu_fanhui.png", this.AD_ExportHaoyouSkin = "ui/daochu_haoyoubg.png", this.AD_ExportHaoyouTitle = "ui/daochu_haoyouzaiwan.png", this._config = [], this._qyswDomain = "https://shangwu.2960.net", this._qytjDomain = "https://tj.2960.net", this.cache = {
                    slider: {result: []},
                    singleIcon: {result: []},
                    carousel: {result: []},
                    gameover: {result: []},
                    dialog: {result: []},
                    dialogFriendGames: {result: []}
                }
            }

            onEnable() {
                this.init()
            }

            init() {
                let self = this;
                if (self._config = [{
                    name: "slider",
                    key: "b2ea3d1f762a0dcfdfa616e6fb25119b",
                    data: []
                }, {name: "singleIcon", key: "93a29dd2b947ee0572686db51e45486c", data: []}, {
                    name: "carousel",
                    key: "cebf4d801a59d63b6a56e3b3b6d4e88c",
                    data: []
                }, {name: "gameover", key: "6dccf617c034242f06f275e893cd001e", data: []}, {
                    name: "dialog",
                    key: "c66d70c8753712e3565b5841d678ad7f",
                    data: []
                }, {name: "dialogFriendGames", key: "e7bee1c15166d85ce50749a7f20c43db", data: []}, {
                    name: "revive",
                    key: "c134b67de7881e95632df5019b010b85",
                    data: []
                }], !window.wx) {
                    let testData = [{
                        appid: "wx4fbc709c03523c0d",
                        logo: ["https://img.2960.net/2019-08-06/129f821be99f996d30c8cc57dbf7eea0.png"],
                        title: "几何风暴"
                    }, {
                        appid: "wxccad312b6eb6d15f",
                        logo: ["https://img.2960.net/2019-08-06/dca32ac117dae6d96080151622b9ebea.png"],
                        title: "几何风暴"
                    }, {
                        appid: "wx56929af85b4ee605",
                        logo: ["https://img.2960.net/2019-08-06/5a138ed07be51e4fa9b20900a61b976a.png"],
                        title: "几何风暴"
                    }, {
                        appid: "wxc83cf066206e8d5f",
                        logo: ["https://img.2960.net/2019-08-06/e9bc201c4813c887403e36bb6dfe8402.png"],
                        title: "几何风暴"
                    }, {
                        appid: "wx1cd174e398e50d0b",
                        logo: ["https://img.2960.net/2019-08-06/c97275cd397e63de950f7494e7b3ef00.png"],
                        title: "几何风暴"
                    }, {
                        appid: "wxa4668e10c31f77c0",
                        logo: ["https://img.2960.net/2019-08-06/7b3f0adbac29079dba7a40ac628fd1df.png"],
                        title: "几何风暴"
                    }, {
                        appid: "wxaa07a343502af86c",
                        logo: ["https://img.2960.net/2019-08-06/ad445412a0bb84ce92081d78588d4097.png"],
                        title: "几何风暴"
                    }, {
                        appid: "wx5bcd76a8aa2089f1",
                        logo: ["https://img.2960.net/2019-08-06/b7499e5ae018eec269827bb341493f99.jpg"],
                        title: "几何风暴"
                    }, {
                        appid: "wx4afb4917e558d198",
                        logo: ["https://img.2960.net/2019-08-06/eae9615bf03a5f8c96a12a326fa9e937.png"],
                        title: "几何风暴"
                    }, {
                        appid: "wxeee627401171c2a3",
                        logo: ["https://img.2960.net/2019-08-06/9132ca95d9e7be8f18df77b24ccc9388.png"],
                        title: "几何风暴"
                    }];
                    return self.cache.slider = {result: testData}, self.cache.singleIcon = {result: testData}, self.cache.carousel = {result: testData}, self.cache.gameover = {result: testData}, self.cache.dialog = {result: testData}, self.cache.dialogFriendGames = {result: testData}, new Promise((r, s) => {
                        r()
                    })
                }
                return self.initQyConfig()
            }

            showSingleAdView(data = null) {
                data = data || {
                    bg: this.AD_SingleBgSkin, onFail: () => {
                        console.log("跳转失败"), this.showAdExport()
                    }, onSuccess: () => {
                    }, right: 0, top: 600, width: 280, height: 200, iconWidth: 200, iconHeight: 200
                };
                let comp = this.createAdView(SingleAdButton, data.width, data.height);
                return comp.owner.right = data.right, comp.owner.top = data.top, comp.init(this.cache.singleIcon, data), comp
            }

            showAdCarousel(data = null) {
                data = data || {
                    bg: this.AD_CarouselSkin, onFail: () => {
                        console.log("跳转失败"), this.showAdExport()
                    }, onSuccess: () => {
                    }, center: !1, width: Laya.stage.width, height: 120, iconWidth: 120, iconHeight: 120
                };
                let comp = this.createAdView(AdCarousel, data.width, data.height);
                return comp.owner.centerX = 0, comp.owner.bottom = 10, comp.init(this.cache.carousel, data), comp
            }

            showAdMorePlay(data = null) {
                data = data || {
                    onFail: () => {
                        console.log("跳转失败"), this.showAdExport()
                    },
                    onSuccess: () => {
                    },
                    bg: this.AD_MorePlaySkin,
                    btnBg: this.AD_MorePlayBtn,
                    grey: this.AD_bgGreySkin,
                    width: 600,
                    height: 990
                };
                let comp = this.createAdView(AdMorePlay, data.width, data.height);
                return comp.owner.centerX = 0, comp.owner.centerY = 0, comp.init(this.cache.slider, data), comp
            }

            showAdGameover(data = null) {
                data = data || {
                    onFail: () => {
                        console.log("跳转失败"), this.showAdExport()
                    }, onSuccess: () => {
                    }, bg: this.AD_GameoverSkin, width: 639, height: 481
                };
                let comp = this.createAdView(AdGameover, data.width, data.height);
                return comp.owner.centerX = 0, comp.owner.centerY = 130, comp.init(this.cache.gameover, data), comp
            }

            showAdExport(data = null, close = null) {
                data = data || {
                    onFail: () => {
                        console.log("跳转失败")
                    },
                    onSuccess: () => {
                    },
                    bg: this.AD_ExportSkin,
                    btn: this.AD_ExportBtnSkin,
                    itemBg: this.AD_ExportItemSkin,
                    haoyouTitle: this.AD_ExportHaoyouTitle,
                    tuijianTitle: this.AD_ExportTitle,
                    close: close
                };
                let comp = this.createAdView(AdExport, data.width, data.height);
                return comp.owner.centerX = 0, comp.owner.centerY = 0, comp.width = Laya.stage.width, comp.height = Laya.stage.height, comp.init(this.cache.dialog, data), comp
            }

            showAdFriend(data = null) {
                data = data || {
                    bg: this.AD_ExportHaoyouSkin, onFail: () => {
                        console.log("跳转失败")
                    }, onSuccess: () => {
                    }, center: !0, width: Laya.stage.width - 60, height: 120, iconWidth: 120, iconHeight: 120
                };
                let comp = this.createAdView(AdCarousel, data.width, data.height);
                return comp.owner.centerX = 0, comp.owner.top = 160, comp.init(this.cache.dialogFriendGames, data), comp
            }

            createAdView(compoent, width = 0, height = 0) {
                this.adViewId++;
                let box = new Laya.Box;
                box.size(width, height);
                let comp = box.addComponent(compoent);
                return comp.__adViewId = this.adViewId, Laya.stage.addChild(comp.owner), comp.owner.zOrder = 100 + this.adViewId, this.adViews.push(comp), comp
            }

            hideAdView(ad) {
                if (!ad) return;
                let index = this.adViews.indexOf(ad);
                -1 != index && (this.adViews.splice(index, 1), ad.owner && ad.owner.destroy())
            }

            adClick(args, failFunction, successFunction) {
                window.wx && (args.appId = args.appid || args, failFunction && (args.fail = failFunction), successFunction && (args.success = successFunction), args.complete = (() => {
                }), window.wx.h_ToMinProgram(args))
            }

            _randomLogoUrl(urls) {
                return "[object Array]" === Object.prototype.toString.call(urls) ? Tools.RandomOne(urls) : urls
            }

            _createList(itemRender, repeatX, repeatY, spaceX, spaceY, scrollDir) {
                let list = new Laya.List;
                return list.itemRender = itemRender, list.repeatX = repeatX, list.repeatY = repeatY, list.spaceX = spaceX, list.spaceY = spaceY, 1 == scrollDir ? list.vScrollBarSkin = "" : list.hScrollBarSkin = "", list.selectEnable = !0, list
            }

            initQyConfig() {
                if (!window.wx) return;
                let self = this, keyArray = [];
                self._config.forEach(a => keyArray.push(a.key));
                let keys = keyArray.join(","), isIos = ML.wx.isIos();
                return new Promise((r, s) => {
                    AdvManager.getIconButtons(keys, d => {
                        r(d)
                    })
                }).then(results => {
                    for (let i = 0; i < self._config.length; i++) {
                        let item = self._config[i];
                        if (isIos && results[item.key] && (results[item.key] = results[item.key].filter(a => "wxeee627401171c2a3" != a.appid)), item.data = results[item.key], self.cache[item.name]) {
                            self.cache[item.name].result = results[item.key];
                            for (let j = 0; j < self.cache[item.name].result.length; j++) self.cache[item.name].result[j].logo = self.cache[item.name].result[j].logo_url;
                            for (let i = 0; i < 2; i++) {
                                JQuery.clone(self.cache[item.name].result).forEach(a => self.cache[item.name].result.push(a))
                            }
                        }
                    }
                    self.adViews.forEach(a => a.reload())
                })
            }
        }

        class ApiModule extends ModuleBase {
            constructor() {
                super(), this.releaseVersion = "1.0.0", this.moduleName = "api", this.appkey = "", this.downloadDomain = "https://game.woool.live/assets/konglong", this.downloadAssetsUrl = this.downloadDomain + "/assets" + MLConfig.assetsVersion + ".zip"
            }

            onEnable() {
            }

            onDisable() {
            }
        }

        class ConfigModule extends ModuleBase {
            constructor() {
                super(), this.moduleName = "config", this.configMode = 0, this.attr_Speed = 1, this.attr_Power = 2, this.attr_Grow = 3
            }

            onEnable() {
                this.attrUpConfig = {
                    speed: [{lv: 0, value: 1, cost: 200}],
                    power: [],
                    grow: []
                }, this.growConfig = {
                    up: [{lv: 0, speed: 10, power: 1, size: 1, cameraH: 13, exp: 0}, {
                        lv: 1,
                        speed: 11,
                        power: 1.4,
                        size: 1.2,
                        cameraH: 15,
                        exp: 50
                    }, {lv: 2, speed: 11, power: 1.6, size: 1.6, cameraH: 18, exp: 100}, {
                        lv: 3,
                        speed: 11,
                        power: 2,
                        size: 1.8,
                        cameraH: 20,
                        exp: 200
                    }, {lv: 4, speed: 12, power: 2.5, size: 2, cameraH: 23, exp: 400}, {
                        lv: 5,
                        speed: 12,
                        power: 3,
                        size: 2.5,
                        cameraH: 25,
                        exp: 800
                    }, {lv: 5, speed: 12, power: 4, size: 3, cameraH: 27, exp: 1500}]
                }, this.foodData = [{lv: 0, exp: 2, maxHp: 1, hp: 1}, {lv: 1, exp: 10, maxHp: 1, hp: 1}, {
                    lv: 2,
                    exp: 10,
                    maxHp: 3,
                    hp: 3
                }, {lv: 3, exp: 15, maxHp: 8, hp: 8}, {
                    lv: 4,
                    exp: 50,
                    maxHp: 40,
                    hp: 40
                }], this.ranktitleData = [{
                    lv: 0,
                    title: "青铜",
                    des: "青铜互啄",
                    exp: 0,
                    titleIcon: "rankIcon/qingtong.png"
                }, {lv: 1, title: "白银", des: "不屈白银", exp: 10, titleIcon: "rankIcon/baiyin.png"}, {
                    lv: 2,
                    title: "黄金",
                    des: "荣耀黄金",
                    exp: 25,
                    titleIcon: "rankIcon/huangjin.png"
                }, {lv: 3, title: "钻石", des: "璀璨钻石", exp: 100, titleIcon: "rankIcon/zhuanshi.png"}, {
                    lv: 4,
                    title: "大师",
                    des: "超凡大师",
                    exp: 200,
                    titleIcon: "rankIcon/dashi.png"
                }, {
                    lv: 5,
                    title: "王者",
                    des: "最强王者",
                    exp: 300,
                    titleIcon: "rankIcon/wangzhe.png"
                }], this.rankData = [{lv: 0, title: "第一名", gold: 500, rankScore: 5}, {
                    lv: 1,
                    title: "第二名",
                    gold: 400,
                    rankScore: 4
                }, {lv: 2, title: "第三名", gold: 300, rankScore: 3}, {
                    lv: 3,
                    title: "第四名",
                    gold: 200,
                    rankScore: 2
                }, {lv: 4, title: "第五名", gold: 100, rankScore: 1}, {
                    lv: 5,
                    title: "第六名",
                    gold: 100,
                    rankScore: 1
                }, {lv: 6, title: "第七名", gold: 100, rankScore: 1}, {
                    lv: 7,
                    title: "第八名",
                    gold: 100,
                    rankScore: 1
                }, {lv: 8, title: "第九名", gold: 100, rankScore: 1}, {
                    lv: 9,
                    title: "第十名",
                    gold: 100,
                    rankScore: 1
                }, {lv: 10, title: "第十一名", gold: 100, rankScore: 1}]
            }

            getFoodData(level) {
                return JQuery.clone(this.foodData[level])
            }

            getLevelValueInGaming(exp) {
                let lvData = null;
                for (let i = 0; i < this.growConfig.up.length; i++) {
                    let config = this.growConfig.up[i];
                    exp >= config.exp && (lvData = config)
                }
                return JQuery.clone(lvData)
            }

            getLevelScoreInGame(lv) {
                return this.growConfig.up.length < lv + 1 ? null : this.growConfig.up[lv].exp
            }

            getAttrData(level = 0, type = 1) {
                switch (type) {
                    case this.attr_Speed:
                        return JQuery.clone(this.getArrtSpeed(level));
                    case this.attr_Power:
                        return JQuery.clone(this.getArrtPower(level));
                    case this.attr_Grow:
                        return JQuery.clone(this.getArrtGrow(level))
                }
            }

            getArrtSpeed(level) {
                return 0 == this.configMode ? this.attrUpConfig.speed[level] : {
                    lv: level,
                    value: 1 + .1 * levl,
                    cost: 100 * Math.pow(2, level)
                }
            }

            getArrtPower(level) {
                return 0 == this.configMode ? this.attrUpConfig.power[level] : {
                    lv: level,
                    value: 1 + .1 * levl,
                    cost: 100 * Math.pow(2, level)
                }
            }

            getArrtGrow(level) {
                return 0 == this.configMode ? this.attrUpConfig.grow[level] : {
                    lv: level,
                    value: 1 + .1 * levl,
                    cost: 100 * Math.pow(2, level)
                }
            }

            getRankTitleInfoByScore(score) {
                let lvData = null;
                for (let i = 0; i < this.ranktitleData.length; i++) {
                    let config = this.ranktitleData[i];
                    score >= config.exp && (lvData = config)
                }
                return JQuery.clone(lvData)
            }

            getRankTitleProgress(lv, score) {
                if (lv >= this.ranktitleData.length - 1) return 1;
                return score / this.ranktitleData[lv + 1].exp
            }

            getRankInfo(rank) {
                return rank >= this.rankData.length - 1 && (rank = this.rankData.length - 1), this.rankData[rank]
            }
        }

        class GameSceneModule extends ModuleBase {
            constructor() {
                super(), this.moduleName = "gameScene", this.assetsDirectory = "res/unity/", this.d3Assets = ["SCENES2"]
            }

            get d3AssetPaths() {
                let result = [];
                return this.d3Assets.forEach(a => {
                    result.push(this.assetsDirectory + a + ".ls")
                }), result
            }

            onEnable() {
                ML.event.on("fileDownload", this, this._download), ML.event.on("unzipComplete", this, this._unzipComplete)
            }

            downloadScene() {
                ResourceLoader.downloadAssets(), ResourceLoader.deleteAssets()
            }

            loadScene() {
                this.unloadScene();
                Laya.loader.create(this.d3AssetPaths, Laya.Handler.create(this, this._complete), Laya.Handler.create(this, this._loading))
            }

            unloadScene() {
                ml.scene3D && ml.scene3D.destroy()
            }

            _unzipComplete() {
                this.assetsDirectory = window.wx.env.USER_DATA_PATH + "/assets" + MLConfig.assetsVersion + "/unity/", ML.event.emit("gameScene_unzipComplete", null)
            }

            _download(value) {
                ML.event.emit("gameScene_downloading", value)
            }

            _loading(value) {
                ML.event.emit("gameScene_loading", value)
            }

            _complete() {
                this._initEntityExtension(), Laya.timer.once(5, this, () => {
                    ML.event.emit("gameScene_load", null)
                })
            }

            _initEntityExtension() {
                let entityExtension = new EntityExtension, paths = this.d3AssetPaths;
                for (let i = 0; i < this.d3Assets.length; i++) {
                    entityExtension[this.d3Assets[i]] = Laya.loader.getRes(paths[i])
                }
                entityExtension.set(), ml.entityExtension = entityExtension
            }
        }

        class AudioModule extends ModuleBase {
            constructor() {
                super(), this.moduleName = "audio"
            }

            onAwake() {
                super.onAwake(), this.cachedAudioInstance = [], window.wx && (this._bgm = window.wx.createInnerAudioContext(), this._effect = window.wx.createInnerAudioContext()), this._config = [{
                    name: "bgm",
                    src: "CrowdChaos.mp3"
                }, {name: "building", src: "Destruction.mp3"}, {name: "finish", src: "Finish.mp3"}, {
                    name: "eat",
                    src: "Eat.mp3"
                }, {name: "foot", src: "footstep2.mp3"}, {name: "levelUp", src: "LevelUp.mp3"}, {
                    name: "kill",
                    src: "Dinosaur.mp3"
                }, {name: "rankUp", src: "RankUp.mp3"}, {name: "menu", src: "MenuClick.mp3"}]
            }

            onEnable() {
            }

            onDisable() {
            }

            _getAudioInstance() {
                let audio = null;
                return audio = this.cachedAudioInstance.length > 0 ? this.cachedAudioInstance.pop() : window.wx.createInnerAudioContext()
            }

            playBgm(name) {
                this._play("_bgm", "bgm")
            }

            stopBgm() {
                window.wx && this._bgm.stop()
            }

            playEffect(name) {
                let item = this._config.filter(a => a.name == name)[0];
                if (!window.wx) return;
                let context = window.wx.createInnerAudioContext();
                context.src = this._audioDirectory + item.src, context.loop = !1, context.play()
            }

            playCoin() {
                if (!window.wx) return;
                let item = this._config.filter(a => "coin" == a.name)[0], context = window.wx.createInnerAudioContext();
                context.src = this._audioDirectory + item.src, context.loop = !1, context.play(), console.log("play: " + item.src)
            }

            _play(context, name, loop = !0) {
                if (!window.wx) return;
                let item = this._config.filter(a => a.name == name)[0];
                this[context].src = this._audioDirectory + item.src, this[context].loop = loop, this[context].play()
            }

            get _audioDirectory() {
                return "/res/audio/"
            }
        }

        class MLLaunch extends Laya.Script {
            constructor() {
                super()
            }

            onAwake() {
                this.baseNode = this.init(), console.log("MLFramework init"), this.addModule(EventNodule), this.addModule(EntityModule), this.addModule(EntityPoolModule), this.addModule(WXModule), this.addModule(WxAdModule), this.addModule(UserModule), this.addModule(QyModule), this.addModule(ApiModule), this.addModule(ConfigModule), this.addModule(GameSceneModule), this.addModule(AudioModule)
            }

            onEnable() {
            }

            onUpdate() {
                ML.totalTime += Laya.timer.delta
            }

            onDisable() {
            }

            init() {
                let node = new Laya.Node;
                return node.name = "MLFramework", Laya.stage.addChild(node)
            }

            addModule(moduleCls) {
                let node = new Laya.Node, module = node.addComponent(moduleCls);
                node.name = module.moduleName, this.baseNode.addChild(node)
            }
        }

        class GameConfig {
            static init() {
                let reg = Laya.ClassUtils.regClass;
                reg("game/scene/BestShowScene.js", BestShowScene), reg("game/scene/CompleteScene.js", CompleteScene), reg("game/scene/FailScene.js", FailScene), reg("game/scene/GameScene.js", GameScene), reg("game/scene/HomeScene.js", HomeScene), reg("game/scene/LevelUpScene.js", LevelUpScene), reg("game/scene/LoadingScene.js", LoadingScene), reg("game/scene/SplashScene.js", SplashScene), reg("framework/MLLaunch.js", MLLaunch)
            }
        }

        GameConfig.width = 750, GameConfig.height = 1334, GameConfig.scaleMode = "fixedwidth", GameConfig.screenMode = "vertical", GameConfig.alignV = "top", GameConfig.alignH = "left", GameConfig.startScene = "splash.scene", GameConfig.sceneRoot = "", GameConfig.debug = !1, GameConfig.stat = !1, GameConfig.physicsDebug = !1, GameConfig.exportSceneToJson = !0, GameConfig.init();
        new class {
            constructor() {
                window.Laya3D ? Laya3D.init(GameConfig.width, GameConfig.height) : Laya.init(GameConfig.width, GameConfig.height, Laya.WebGL), Laya.Physics && Laya.Physics.enable(), Laya.DebugPanel && Laya.DebugPanel.enable(), Laya.stage.scaleMode = GameConfig.scaleMode, Laya.stage.screenMode = GameConfig.screenMode, Laya.stage.alignV = GameConfig.alignV, Laya.stage.alignH = GameConfig.alignH, Laya.URL.exportSceneToJson = GameConfig.exportSceneToJson, (GameConfig.debug || "true" == Laya.Utils.getQueryString("debug")) && Laya.enableDebugPanel(), GameConfig.physicsDebug && Laya.PhysicsDebugDraw && Laya.PhysicsDebugDraw.enable(), GameConfig.stat && Laya.Stat.show(), Laya.alertGlobalError = !0, Laya.ResourceVersion.enable("version.json", Laya.Handler.create(this, this.onVersionLoaded), Laya.ResourceVersion.FILENAME_VERSION)
            }

            onVersionLoaded() {
                Laya.AtlasInfoManager.enable("fileconfig.json", Laya.Handler.create(this, this.onConfigLoaded))
            }

            onConfigLoaded() {
                GameConfig.startScene && Laya.Scene.open(GameConfig.startScene)
            }
        }
    }();
});
define("libs/laya.core.js", function (require, module, exports) {
    window.Laya = function (exports) {
        "use strict";

        class Config {
        }

        Config.animationInterval = 50, Config.isAntialias = !1, Config.isAlpha = !1, Config.premultipliedAlpha = !0, Config.isStencil = !0, Config.preserveDrawingBuffer = !1, Config.webGL2D_MeshAllocMaxMem = !0, Config.is2DPixelArtGame = !1, Config.useWebGL2 = !0, Config.useRetinalCanvas = !1, window.Config = Config;

        class ILaya {
            static regClass(c) {
                ILaya.__classMap[c.name] = c
            }
        }

        ILaya.Laya = null, ILaya.Timer = null, ILaya.WorkerLoader = null, ILaya.Dragging = null, ILaya.GraphicsBounds = null, ILaya.Sprite = null, ILaya.TextRender = null, ILaya.TextAtlas = null, ILaya.timer = null, ILaya.systemTimer = null, ILaya.startTimer = null, ILaya.updateTimer = null, ILaya.lateTimer = null, ILaya.physicsTimer = null, ILaya.stage = null, ILaya.Loader = null, ILaya.loader = null, ILaya.TTFLoader = null, ILaya.SoundManager = null, ILaya.WebAudioSound = null, ILaya.AudioSound = null, ILaya.ShaderCompile = null, ILaya.ClassUtils = null, ILaya.SceneUtils = null, ILaya.Context = null, ILaya.Render = null, ILaya.MouseManager = null, ILaya.Text = null, ILaya.Browser = null, ILaya.WebGL = null, ILaya.Pool = null, ILaya.Utils = null, ILaya.Graphics = null, ILaya.Submit = null, ILaya.Stage = null, ILaya.Resource = null, ILaya.__classMap = {};

        class Pool {
            static getPoolBySign(sign) {
                return Pool._poolDic[sign] || (Pool._poolDic[sign] = [])
            }

            static clearBySign(sign) {
                Pool._poolDic[sign] && (Pool._poolDic[sign].length = 0)
            }

            static recover(sign, item) {
                item[Pool.POOLSIGN] || (item[Pool.POOLSIGN] = !0, Pool.getPoolBySign(sign).push(item))
            }

            static recoverByClass(instance) {
                if (instance) {
                    var className = instance.__className || instance.constructor._$gid;
                    className && Pool.recover(className, instance)
                }
            }

            static _getClassSign(cla) {
                var className = cla.__className || cla._$gid;
                return className || (cla._$gid = className = Pool._CLSID + "", Pool._CLSID++), className
            }

            static createByClass(cls) {
                return Pool.getItemByClass(Pool._getClassSign(cls), cls)
            }

            static getItemByClass(sign, cls) {
                if (!Pool._poolDic[sign]) return new cls;
                var pool = Pool.getPoolBySign(sign);
                if (pool.length) {
                    var rst = pool.pop();
                    rst[Pool.POOLSIGN] = !1
                } else rst = new cls;
                return rst
            }

            static getItemByCreateFun(sign, createFun, caller = null) {
                var pool = Pool.getPoolBySign(sign), rst = pool.length ? pool.pop() : createFun.call(caller);
                return rst[Pool.POOLSIGN] = !1, rst
            }

            static getItem(sign) {
                var pool = Pool.getPoolBySign(sign), rst = pool.length ? pool.pop() : null;
                return rst && (rst[Pool.POOLSIGN] = !1), rst
            }
        }

        Pool._CLSID = 0, Pool.POOLSIGN = "__InPool", Pool._poolDic = {};

        class AlphaCmd {
            static create(alpha) {
                var cmd = Pool.getItemByClass("AlphaCmd", AlphaCmd);
                return cmd.alpha = alpha, cmd
            }

            recover() {
                Pool.recover("AlphaCmd", this)
            }

            run(context, gx, gy) {
                context.alpha(this.alpha)
            }

            get cmdID() {
                return AlphaCmd.ID
            }
        }

        AlphaCmd.ID = "Alpha";

        class DrawCircleCmd {
            static create(x, y, radius, fillColor, lineColor, lineWidth, vid) {
                var cmd = Pool.getItemByClass("DrawCircleCmd", DrawCircleCmd);
                return cmd.x = x, cmd.y = y, cmd.radius = radius, cmd.fillColor = fillColor, cmd.lineColor = lineColor, cmd.lineWidth = lineWidth, cmd.vid = vid, cmd
            }

            recover() {
                this.fillColor = null, this.lineColor = null, Pool.recover("DrawCircleCmd", this)
            }

            run(context, gx, gy) {
                context._drawCircle(this.x + gx, this.y + gy, this.radius, this.fillColor, this.lineColor, this.lineWidth, this.vid)
            }

            get cmdID() {
                return DrawCircleCmd.ID
            }
        }

        DrawCircleCmd.ID = "DrawCircle";

        class DrawCurvesCmd {
            static create(x, y, points, lineColor, lineWidth) {
                var cmd = Pool.getItemByClass("DrawCurvesCmd", DrawCurvesCmd);
                return cmd.x = x, cmd.y = y, cmd.points = points, cmd.lineColor = lineColor, cmd.lineWidth = lineWidth, cmd
            }

            recover() {
                this.points = null, this.lineColor = null, Pool.recover("DrawCurvesCmd", this)
            }

            run(context, gx, gy) {
                context.drawCurves(this.x + gx, this.y + gy, this.points, this.lineColor, this.lineWidth)
            }

            get cmdID() {
                return DrawCurvesCmd.ID
            }
        }

        DrawCurvesCmd.ID = "DrawCurves";

        class DrawImageCmd {
            static create(texture, x, y, width, height) {
                var cmd = Pool.getItemByClass("DrawImageCmd", DrawImageCmd);
                return cmd.texture = texture, texture._addReference(), cmd.x = x, cmd.y = y, cmd.width = width, cmd.height = height, cmd
            }

            recover() {
                this.texture._removeReference(), this.texture = null, Pool.recover("DrawImageCmd", this)
            }

            run(context, gx, gy) {
                context.drawTexture(this.texture, this.x + gx, this.y + gy, this.width, this.height)
            }

            get cmdID() {
                return DrawImageCmd.ID
            }
        }

        DrawImageCmd.ID = "DrawImage";

        class DrawLineCmd {
            static create(fromX, fromY, toX, toY, lineColor, lineWidth, vid) {
                var cmd = Pool.getItemByClass("DrawLineCmd", DrawLineCmd);
                return cmd.fromX = fromX, cmd.fromY = fromY, cmd.toX = toX, cmd.toY = toY, cmd.lineColor = lineColor, cmd.lineWidth = lineWidth, cmd.vid = vid, cmd
            }

            recover() {
                Pool.recover("DrawLineCmd", this)
            }

            run(context, gx, gy) {
                context._drawLine(gx, gy, this.fromX, this.fromY, this.toX, this.toY, this.lineColor, this.lineWidth, this.vid)
            }

            get cmdID() {
                return DrawLineCmd.ID
            }
        }

        DrawLineCmd.ID = "DrawLine";

        class DrawLinesCmd {
            static create(x, y, points, lineColor, lineWidth, vid) {
                var cmd = Pool.getItemByClass("DrawLinesCmd", DrawLinesCmd);
                return cmd.x = x, cmd.y = y, cmd.points = points, cmd.lineColor = lineColor, cmd.lineWidth = lineWidth, cmd.vid = vid, cmd
            }

            recover() {
                this.points = null, this.lineColor = null, Pool.recover("DrawLinesCmd", this)
            }

            run(context, gx, gy) {
                context._drawLines(this.x + gx, this.y + gy, this.points, this.lineColor, this.lineWidth, this.vid)
            }

            get cmdID() {
                return DrawLinesCmd.ID
            }
        }

        DrawLinesCmd.ID = "DrawLines";

        class DrawPathCmd {
            static create(x, y, paths, brush, pen) {
                var cmd = Pool.getItemByClass("DrawPathCmd", DrawPathCmd);
                return cmd.x = x, cmd.y = y, cmd.paths = paths, cmd.brush = brush, cmd.pen = pen, cmd
            }

            recover() {
                this.paths = null, this.brush = null, this.pen = null, Pool.recover("DrawPathCmd", this)
            }

            run(context, gx, gy) {
                context._drawPath(this.x + gx, this.y + gy, this.paths, this.brush, this.pen)
            }

            get cmdID() {
                return DrawPathCmd.ID
            }
        }

        DrawPathCmd.ID = "DrawPath";

        class DrawPieCmd {
            static create(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth, vid) {
                var cmd = Pool.getItemByClass("DrawPieCmd", DrawPieCmd);
                return cmd.x = x, cmd.y = y, cmd.radius = radius, cmd._startAngle = startAngle, cmd._endAngle = endAngle, cmd.fillColor = fillColor, cmd.lineColor = lineColor, cmd.lineWidth = lineWidth, cmd.vid = vid, cmd
            }

            recover() {
                this.fillColor = null, this.lineColor = null, Pool.recover("DrawPieCmd", this)
            }

            run(context, gx, gy) {
                context._drawPie(this.x + gx, this.y + gy, this.radius, this._startAngle, this._endAngle, this.fillColor, this.lineColor, this.lineWidth, this.vid)
            }

            get cmdID() {
                return DrawPieCmd.ID
            }

            get startAngle() {
                return 180 * this._startAngle / Math.PI
            }

            set startAngle(value) {
                this._startAngle = value * Math.PI / 180
            }

            get endAngle() {
                return 180 * this._endAngle / Math.PI
            }

            set endAngle(value) {
                this._endAngle = value * Math.PI / 180
            }
        }

        DrawPieCmd.ID = "DrawPie";

        class DrawPolyCmd {
            static create(x, y, points, fillColor, lineColor, lineWidth, isConvexPolygon, vid) {
                var cmd = Pool.getItemByClass("DrawPolyCmd", DrawPolyCmd);
                return cmd.x = x, cmd.y = y, cmd.points = points, cmd.fillColor = fillColor, cmd.lineColor = lineColor, cmd.lineWidth = lineWidth, cmd.isConvexPolygon = isConvexPolygon, cmd.vid = vid, cmd
            }

            recover() {
                this.points = null, this.fillColor = null, this.lineColor = null, Pool.recover("DrawPolyCmd", this)
            }

            run(context, gx, gy) {
                context._drawPoly(this.x + gx, this.y + gy, this.points, this.fillColor, this.lineColor, this.lineWidth, this.isConvexPolygon, this.vid)
            }

            get cmdID() {
                return DrawPolyCmd.ID
            }
        }

        DrawPolyCmd.ID = "DrawPoly";

        class DrawRectCmd {
            static create(x, y, width, height, fillColor, lineColor, lineWidth) {
                var cmd = Pool.getItemByClass("DrawRectCmd", DrawRectCmd);
                return cmd.x = x, cmd.y = y, cmd.width = width, cmd.height = height, cmd.fillColor = fillColor, cmd.lineColor = lineColor, cmd.lineWidth = lineWidth, cmd
            }

            recover() {
                this.fillColor = null, this.lineColor = null, Pool.recover("DrawRectCmd", this)
            }

            run(context, gx, gy) {
                context.drawRect(this.x + gx, this.y + gy, this.width, this.height, this.fillColor, this.lineColor, this.lineWidth)
            }

            get cmdID() {
                return DrawRectCmd.ID
            }
        }

        DrawRectCmd.ID = "DrawRect";

        class Matrix {
            constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0, nums = 0) {
                if (this._bTransform = !1, null != Matrix._createFun) return Matrix._createFun(a, b, c, d, tx, ty, nums);
                this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty, this._checkTransform()
            }

            identity() {
                return this.a = this.d = 1, this.b = this.tx = this.ty = this.c = 0, this._bTransform = !1, this
            }

            _checkTransform() {
                return this._bTransform = 1 !== this.a || 0 !== this.b || 0 !== this.c || 1 !== this.d
            }

            setTranslate(x, y) {
                return this.tx = x, this.ty = y, this
            }

            translate(x, y) {
                return this.tx += x, this.ty += y, this
            }

            scale(x, y) {
                return this.a *= x, this.d *= y, this.c *= x, this.b *= y, this.tx *= x, this.ty *= y, this._bTransform = !0, this
            }

            rotate(angle) {
                var cos = Math.cos(angle), sin = Math.sin(angle), a1 = this.a, c1 = this.c, tx1 = this.tx;
                return this.a = a1 * cos - this.b * sin, this.b = a1 * sin + this.b * cos, this.c = c1 * cos - this.d * sin, this.d = c1 * sin + this.d * cos, this.tx = tx1 * cos - this.ty * sin, this.ty = tx1 * sin + this.ty * cos, this._bTransform = !0, this
            }

            skew(x, y) {
                var tanX = Math.tan(x), tanY = Math.tan(y), a1 = this.a, b1 = this.b;
                return this.a += tanY * this.c, this.b += tanY * this.d, this.c += tanX * a1, this.d += tanX * b1, this
            }

            invertTransformPoint(out) {
                var a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, tx1 = this.tx, n = a1 * d1 - b1 * c1,
                    a2 = d1 / n, b2 = -b1 / n, c2 = -c1 / n, d2 = a1 / n, tx2 = (c1 * this.ty - d1 * tx1) / n,
                    ty2 = -(a1 * this.ty - b1 * tx1) / n;
                return out.setTo(a2 * out.x + c2 * out.y + tx2, b2 * out.x + d2 * out.y + ty2)
            }

            transformPoint(out) {
                return out.setTo(this.a * out.x + this.c * out.y + this.tx, this.b * out.x + this.d * out.y + this.ty)
            }

            transformPointN(out) {
                return out.setTo(this.a * out.x + this.c * out.y, this.b * out.x + this.d * out.y)
            }

            getScaleX() {
                return 0 === this.b ? this.a : Math.sqrt(this.a * this.a + this.b * this.b)
            }

            getScaleY() {
                return 0 === this.c ? this.d : Math.sqrt(this.c * this.c + this.d * this.d)
            }

            invert() {
                var a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, tx1 = this.tx, n = a1 * d1 - b1 * c1;
                return this.a = d1 / n, this.b = -b1 / n, this.c = -c1 / n, this.d = a1 / n, this.tx = (c1 * this.ty - d1 * tx1) / n, this.ty = -(a1 * this.ty - b1 * tx1) / n, this
            }

            setTo(a, b, c, d, tx, ty) {
                return this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty, this
            }

            concat(matrix) {
                var a = this.a, c = this.c, tx = this.tx;
                return this.a = a * matrix.a + this.b * matrix.c, this.b = a * matrix.b + this.b * matrix.d, this.c = c * matrix.a + this.d * matrix.c, this.d = c * matrix.b + this.d * matrix.d, this.tx = tx * matrix.a + this.ty * matrix.c + matrix.tx, this.ty = tx * matrix.b + this.ty * matrix.d + matrix.ty, this
            }

            static mul(m1, m2, out) {
                var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty, ba = m2.a, bb = m2.b,
                    bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
                return 0 !== bb || 0 !== bc ? (out.a = aa * ba + ab * bc, out.b = aa * bb + ab * bd, out.c = ac * ba + ad * bc, out.d = ac * bb + ad * bd, out.tx = ba * atx + bc * aty + btx, out.ty = bb * atx + bd * aty + bty) : (out.a = aa * ba, out.b = ab * bd, out.c = ac * ba, out.d = ad * bd, out.tx = ba * atx + btx, out.ty = bd * aty + bty), out
            }

            static mul16(m1, m2, out) {
                var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty, ba = m2.a, bb = m2.b,
                    bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
                return 0 !== bb || 0 !== bc ? (out[0] = aa * ba + ab * bc, out[1] = aa * bb + ab * bd, out[4] = ac * ba + ad * bc, out[5] = ac * bb + ad * bd, out[12] = ba * atx + bc * aty + btx, out[13] = bb * atx + bd * aty + bty) : (out[0] = aa * ba, out[1] = ab * bd, out[4] = ac * ba, out[5] = ad * bd, out[12] = ba * atx + btx, out[13] = bd * aty + bty), out
            }

            scaleEx(x, y) {
                var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
                0 !== bb || 0 !== bc ? (this.a = x * ba, this.b = x * bb, this.c = y * bc, this.d = y * bd) : (this.a = x * ba, this.b = 0 * bd, this.c = 0 * ba, this.d = y * bd), this._bTransform = !0
            }

            rotateEx(angle) {
                var cos = Math.cos(angle), sin = Math.sin(angle), ba = this.a, bb = this.b, bc = this.c, bd = this.d;
                0 !== bb || 0 !== bc ? (this.a = cos * ba + sin * bc, this.b = cos * bb + sin * bd, this.c = -sin * ba + cos * bc, this.d = -sin * bb + cos * bd) : (this.a = cos * ba, this.b = sin * bd, this.c = -sin * ba, this.d = cos * bd), this._bTransform = !0
            }

            clone() {
                var dec = Matrix.create();
                return dec.a = this.a, dec.b = this.b, dec.c = this.c, dec.d = this.d, dec.tx = this.tx, dec.ty = this.ty, dec._bTransform = this._bTransform, dec
            }

            copyTo(dec) {
                return dec.a = this.a, dec.b = this.b, dec.c = this.c, dec.d = this.d, dec.tx = this.tx, dec.ty = this.ty, dec._bTransform = this._bTransform, dec
            }

            toString() {
                return this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.tx + "," + this.ty
            }

            destroy() {
                this.recover()
            }

            recover() {
                Pool.recover("Matrix", this.identity())
            }

            static create() {
                return Pool.getItemByClass("Matrix", Matrix)
            }
        }

        Matrix.EMPTY = new Matrix, Matrix.TEMP = new Matrix, Matrix._createFun = null;

        class Point {
            constructor(x = 0, y = 0) {
                this.x = x, this.y = y
            }

            static create() {
                return Pool.getItemByClass("Point", Point)
            }

            setTo(x, y) {
                return this.x = x, this.y = y, this
            }

            reset() {
                return this.x = this.y = 0, this
            }

            recover() {
                Pool.recover("Point", this.reset())
            }

            distance(x, y) {
                return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y))
            }

            toString() {
                return this.x + "," + this.y
            }

            normalize() {
                var d = Math.sqrt(this.x * this.x + this.y * this.y);
                if (d > 0) {
                    var id = 1 / d;
                    this.x *= id, this.y *= id
                }
            }

            copy(point) {
                return this.setTo(point.x, point.y)
            }
        }

        Point.TEMP = new Point, Point.EMPTY = new Point;

        class Rectangle {
            constructor(x = 0, y = 0, width = 0, height = 0) {
                this.x = x, this.y = y, this.width = width, this.height = height
            }

            get right() {
                return this.x + this.width
            }

            get bottom() {
                return this.y + this.height
            }

            setTo(x, y, width, height) {
                return this.x = x, this.y = y, this.width = width, this.height = height, this
            }

            reset() {
                return this.x = this.y = this.width = this.height = 0, this
            }

            recover() {
                this != Rectangle.TEMP && this != Rectangle.EMPTY ? Pool.recover("Rectangle", this.reset()) : console.log("recover Temp or Empty:", this)
            }

            static create() {
                return Pool.getItemByClass("Rectangle", Rectangle)
            }

            copyFrom(source) {
                return this.x = source.x, this.y = source.y, this.width = source.width, this.height = source.height, this
            }

            contains(x, y) {
                return !(this.width <= 0 || this.height <= 0) && (x >= this.x && x < this.right && y >= this.y && y < this.bottom)
            }

            intersects(rect) {
                return !(rect.x > this.x + this.width || rect.x + rect.width < this.x || rect.y > this.y + this.height || rect.y + rect.height < this.y)
            }

            intersection(rect, out = null) {
                return this.intersects(rect) ? (out || (out = new Rectangle), out.x = Math.max(this.x, rect.x), out.y = Math.max(this.y, rect.y), out.width = Math.min(this.right, rect.right) - out.x, out.height = Math.min(this.bottom, rect.bottom) - out.y, out) : null
            }

            union(source, out = null) {
                return out || (out = new Rectangle), this.clone(out), source.width <= 0 || source.height <= 0 ? out : (out.addPoint(source.x, source.y), out.addPoint(source.right, source.bottom), this)
            }

            clone(out = null) {
                return out || (out = new Rectangle), out.x = this.x, out.y = this.y, out.width = this.width, out.height = this.height, out
            }

            toString() {
                return this.x + "," + this.y + "," + this.width + "," + this.height
            }

            equals(rect) {
                return !(!rect || rect.x !== this.x || rect.y !== this.y || rect.width !== this.width || rect.height !== this.height)
            }

            addPoint(x, y) {
                return this.x > x && (this.width += this.x - x, this.x = x), this.y > y && (this.height += this.y - y, this.y = y), this.width < x - this.x && (this.width = x - this.x), this.height < y - this.y && (this.height = y - this.y), this
            }

            _getBoundPoints() {
                var rst = Rectangle._temB;
                return rst.length = 0, 0 == this.width || 0 == this.height ? rst : (rst.push(this.x, this.y, this.x + this.width, this.y, this.x, this.y + this.height, this.x + this.width, this.y + this.height), rst)
            }

            static _getBoundPointS(x, y, width, height) {
                var rst = Rectangle._temA;
                return rst.length = 0, 0 == width || 0 == height ? rst : (rst.push(x, y, x + width, y, x, y + height, x + width, y + height), rst)
            }

            static _getWrapRec(pointList, rst = null) {
                if (!pointList || pointList.length < 1) return rst ? rst.setTo(0, 0, 0, 0) : Rectangle.TEMP.setTo(0, 0, 0, 0);
                rst = rst || Rectangle.create();
                var i, minX, maxX, minY, maxY, len = pointList.length, tPoint = Point.TEMP;
                for (maxX = maxY = -(minX = minY = 99999), i = 0; i < len; i += 2) tPoint.x = pointList[i], tPoint.y = pointList[i + 1], minX = minX < tPoint.x ? minX : tPoint.x, minY = minY < tPoint.y ? minY : tPoint.y, maxX = maxX > tPoint.x ? maxX : tPoint.x, maxY = maxY > tPoint.y ? maxY : tPoint.y;
                return rst.setTo(minX, minY, maxX - minX, maxY - minY)
            }

            isEmpty() {
                return this.width <= 0 || this.height <= 0
            }
        }

        Rectangle.EMPTY = new Rectangle, Rectangle.TEMP = new Rectangle, Rectangle._temB = [], Rectangle._temA = [];

        class LayaGL {
        }

        LayaGL.ARRAY_BUFFER_TYPE_DATA = 0, LayaGL.ARRAY_BUFFER_TYPE_CMD = 1, LayaGL.ARRAY_BUFFER_REF_REFERENCE = 0, LayaGL.ARRAY_BUFFER_REF_COPY = 1, LayaGL.UPLOAD_SHADER_UNIFORM_TYPE_ID = 0, LayaGL.UPLOAD_SHADER_UNIFORM_TYPE_DATA = 1;

        class Handler {
            constructor(caller = null, method = null, args = null, once = !1) {
                this.once = !1, this._id = 0, this.setTo(caller, method, args, once)
            }

            setTo(caller, method, args, once) {
                return this._id = Handler._gid++, this.caller = caller, this.method = method, this.args = args, this.once = once, this
            }

            run() {
                if (null == this.method) return null;
                var id = this._id, result = this.method.apply(this.caller, this.args);
                return this._id === id && this.once && this.recover(), result
            }

            runWith(data) {
                if (null == this.method) return null;
                var id = this._id;
                if (null == data) var result = this.method.apply(this.caller, this.args); else result = this.args || data.unshift ? this.args ? this.method.apply(this.caller, this.args.concat(data)) : this.method.apply(this.caller, data) : this.method.call(this.caller, data);
                return this._id === id && this.once && this.recover(), result
            }

            clear() {
                return this.caller = null, this.method = null, this.args = null, this
            }

            recover() {
                this._id > 0 && (this._id = 0, Handler._pool.push(this.clear()))
            }

            static create(caller, method, args = null, once = !0) {
                return Handler._pool.length ? Handler._pool.pop().setTo(caller, method, args, once) : new Handler(caller, method, args, once)
            }
        }

        Handler._pool = [], Handler._gid = 1;

        class EventDispatcher {
            hasListener(type) {
                return !!(this._events && this._events[type])
            }

            event(type, data = null) {
                if (!this._events || !this._events[type]) return !1;
                var listeners = this._events[type];
                if (listeners.run) listeners.once && delete this._events[type], null != data ? listeners.runWith(data) : listeners.run(); else {
                    for (var i = 0, n = listeners.length; i < n; i++) {
                        var listener = listeners[i];
                        listener && (null != data ? listener.runWith(data) : listener.run()), listener && !listener.once || (listeners.splice(i, 1), i--, n--)
                    }
                    0 === listeners.length && this._events && delete this._events[type]
                }
                return !0
            }

            on(type, caller, listener, args = null) {
                return this._createListener(type, caller, listener, args, !1)
            }

            once(type, caller, listener, args = null) {
                return this._createListener(type, caller, listener, args, !0)
            }

            _createListener(type, caller, listener, args, once, offBefore = !0) {
                offBefore && this.off(type, caller, listener, once);
                var handler = EventHandler.create(caller || this, listener, args, once);
                this._events || (this._events = {});
                var events = this._events;
                return events[type] ? events[type].run ? events[type] = [events[type], handler] : events[type].push(handler) : events[type] = handler, this
            }

            off(type, caller, listener, onceOnly = !1) {
                if (!this._events || !this._events[type]) return this;
                var listeners = this._events[type];
                if (null != listeners) if (listeners.run) caller && listeners.caller !== caller || null != listener && listeners.method !== listener || onceOnly && !listeners.once || (delete this._events[type], listeners.recover()); else {
                    for (var count = 0, i = 0, n = listeners.length; i < n; i++) {
                        var item = listeners[i];
                        item ? !item || caller && item.caller !== caller || null != listener && item.method !== listener || onceOnly && !item.once || (count++, listeners[i] = null, item.recover()) : count++
                    }
                    count === n && delete this._events[type]
                }
                return this
            }

            offAll(type = null) {
                var events = this._events;
                if (!events) return this;
                if (type) this._recoverHandlers(events[type]), delete events[type]; else {
                    for (var name in events) this._recoverHandlers(events[name]);
                    this._events = null
                }
                return this
            }

            offAllCaller(caller) {
                if (caller && this._events) for (var name in this._events) this.off(name, caller, null);
                return this
            }

            _recoverHandlers(arr) {
                if (arr) if (arr.run) arr.recover(); else for (var i = arr.length - 1; i > -1; i--) arr[i] && (arr[i].recover(), arr[i] = null)
            }

            isMouseEvent(type) {
                return EventDispatcher.MOUSE_EVENTS[type] || !1
            }
        }

        EventDispatcher.MOUSE_EVENTS = {
            rightmousedown: !0,
            rightmouseup: !0,
            rightclick: !0,
            mousedown: !0,
            mouseup: !0,
            mousemove: !0,
            mouseover: !0,
            mouseout: !0,
            click: !0,
            doubleclick: !0
        };

        class EventHandler extends Handler {
            constructor(caller, method, args, once) {
                super(caller, method, args, once)
            }

            recover() {
                this._id > 0 && (this._id = 0, EventHandler._pool.push(this.clear()))
            }

            static create(caller, method, args = null, once = !0) {
                return EventHandler._pool.length ? EventHandler._pool.pop().setTo(caller, method, args, once) : new EventHandler(caller, method, args, once)
            }
        }

        EventHandler._pool = [];

        class URL {
            constructor(url) {
                this._url = URL.formatURL(url), this._path = URL.getPath(url)
            }

            get url() {
                return this._url
            }

            get path() {
                return this._path
            }

            static set basePath(value) {
                URL._basePath = ILaya.Laya._getUrlPath(), URL._basePath = URL.formatURL(value)
            }

            static get basePath() {
                return URL._basePath
            }

            static formatURL(url) {
                if (!url) return "null path";
                if (url.indexOf(":") > 0) return url;
                if (null != URL.customFormat && (url = URL.customFormat(url)), url.indexOf(":") > 0) return url;
                var char1 = url.charAt(0);
                if ("." === char1) return URL._formatRelativePath(URL._basePath + url);
                if ("~" === char1) return URL.rootPath + url.substring(1);
                if ("d" === char1) {
                    if (0 === url.indexOf("data:image")) return url
                } else if ("/" === char1) return url;
                return URL._basePath + url
            }

            static _formatRelativePath(value) {
                for (var parts = value.split("/"), i = 0, len = parts.length; i < len; i++) ".." == parts[i] && (parts.splice(i - 1, 2), i -= 2);
                return parts.join("/")
            }

            static getPath(url) {
                var ofs = url.lastIndexOf("/");
                return ofs > 0 ? url.substr(0, ofs + 1) : ""
            }

            static getFileName(url) {
                var ofs = url.lastIndexOf("/");
                return ofs > 0 ? url.substr(ofs + 1) : url
            }

            static getAdptedFilePath(url) {
                if (!URL.exportSceneToJson || !url) return url;
                var i, len, tArr;
                for (len = URL._adpteTypeList.length, i = 0; i < len; i++) tArr = URL._adpteTypeList[i], url = url.replace(tArr[0], tArr[1]);
                return url
            }
        }

        URL.version = {}, URL.exportSceneToJson = !1, URL._basePath = "", URL.rootPath = "", URL.customFormat = function (url) {
            var newUrl = URL.version[url];
            return !window.conch && newUrl && (url += "?v=" + newUrl), url
        }, URL._adpteTypeList = [[".scene3d", ".json"], [".scene", ".json"], [".taa", ".json"], [".prefab", ".json"]];

        class Resource extends EventDispatcher {
            constructor() {
                super(), this._id = 0, this._url = null, this._cpuMemory = 0, this._gpuMemory = 0, this._destroyed = !1, this._referenceCount = 0, this.lock = !1, this.name = null, this._id = ++Resource._uniqueIDCounter, this._destroyed = !1, this._referenceCount = 0, Resource._idResourcesMap[this.id] = this, this.lock = !1
            }

            static get cpuMemory() {
                return Resource._cpuMemory
            }

            static get gpuMemory() {
                return Resource._gpuMemory
            }

            static _addCPUMemory(size) {
                Resource._cpuMemory += size
            }

            static _addGPUMemory(size) {
                Resource._gpuMemory += size
            }

            static _addMemory(cpuSize, gpuSize) {
                Resource._cpuMemory += cpuSize, Resource._gpuMemory += gpuSize
            }

            static getResourceByID(id) {
                return Resource._idResourcesMap[id]
            }

            static getResourceByURL(url, index = 0) {
                return Resource._urlResourcesMap[url][index]
            }

            static destroyUnusedResources() {
                for (var k in Resource._idResourcesMap) {
                    var res = Resource._idResourcesMap[k];
                    res.lock || 0 !== res._referenceCount || res.destroy()
                }
            }

            get id() {
                return this._id
            }

            get url() {
                return this._url
            }

            get cpuMemory() {
                return this._cpuMemory
            }

            get gpuMemory() {
                return this._gpuMemory
            }

            get destroyed() {
                return this._destroyed
            }

            get referenceCount() {
                return this._referenceCount
            }

            _setCPUMemory(value) {
                var offsetValue = value - this._cpuMemory;
                this._cpuMemory = value, Resource._addCPUMemory(offsetValue)
            }

            _setGPUMemory(value) {
                var offsetValue = value - this._gpuMemory;
                this._gpuMemory = value, Resource._addGPUMemory(offsetValue)
            }

            _setCreateURL(url) {
                var resList;
                (url = URL.formatURL(url), this._url !== url) && (this._url && ((resList = Resource._urlResourcesMap[this._url]).splice(resList.indexOf(this), 1), 0 === resList.length && delete Resource._urlResourcesMap[this._url]), url && ((resList = Resource._urlResourcesMap[url]) || (Resource._urlResourcesMap[url] = resList = []), resList.push(this)), this._url = url)
            }

            _addReference(count = 1) {
                this._referenceCount += count
            }

            _removeReference(count = 1) {
                this._referenceCount -= count
            }

            _clearReference() {
                this._referenceCount = 0
            }

            _recoverResource() {
            }

            _disposeResource() {
            }

            _activeResource() {
            }

            destroy() {
                var resList;
                this._destroyed || (this._destroyed = !0, this.lock = !1, this._disposeResource(), delete Resource._idResourcesMap[this.id], this._url && ((resList = Resource._urlResourcesMap[this._url]) && (resList.splice(resList.indexOf(this), 1), 0 === resList.length && delete Resource._urlResourcesMap[this._url]), ILaya.Loader.getRes(this._url) == this && delete ILaya.Loader.loadedMap[this._url]))
            }
        }

        Resource._uniqueIDCounter = 0, Resource._idResourcesMap = {}, Resource._urlResourcesMap = {}, Resource._cpuMemory = 0, Resource._gpuMemory = 0;

        class Bitmap extends Resource {
            get width() {
                return this._width
            }

            set width(width) {
                this._width = width
            }

            get height() {
                return this._height
            }

            set height(height) {
                this._height = height
            }

            constructor() {
                super(), this._width = -1, this._height = -1
            }

            _getSource() {
                throw"Bitmap: must override it."
            }
        }

        class WebGLContext {
            static __init__() {
                var gl = LayaGL.instance;
                WebGLContext._depthFunc = gl.LESS, WebGLContext._sFactor = gl.ONE, WebGLContext._dFactor = gl.ZERO, WebGLContext._srcAlpha = gl.ONE, WebGLContext._dstAlpha = gl.ZERO, WebGLContext._activedTextureID = gl.TEXTURE0, WebGLContext._glTextureIDs = [gl.TEXTURE0, gl.TEXTURE1, gl.TEXTURE2, gl.TEXTURE3, gl.TEXTURE4, gl.TEXTURE5, gl.TEXTURE6, gl.TEXTURE7]
            }

            static useProgram(gl, program) {
                return WebGLContext._useProgram !== program && (gl.useProgram(program), WebGLContext._useProgram = program, !0)
            }

            static setDepthTest(gl, value) {
                value !== WebGLContext._depthTest && (WebGLContext._depthTest = value, value ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST))
            }

            static setDepthMask(gl, value) {
                value !== WebGLContext._depthMask && (WebGLContext._depthMask = value, gl.depthMask(value))
            }

            static setDepthFunc(gl, value) {
                value !== WebGLContext._depthFunc && (WebGLContext._depthFunc = value, gl.depthFunc(value))
            }

            static setBlend(gl, value) {
                value !== WebGLContext._blend && (WebGLContext._blend = value, value ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND))
            }

            static setBlendFunc(gl, sFactor, dFactor) {
                (sFactor !== WebGLContext._sFactor || dFactor !== WebGLContext._dFactor) && (WebGLContext._sFactor = WebGLContext._srcAlpha = sFactor, WebGLContext._dFactor = WebGLContext._dstAlpha = dFactor, gl.blendFunc(sFactor, dFactor))
            }

            static setBlendFuncSeperate(gl, srcRGB, dstRGB, srcAlpha, dstAlpha) {
                srcRGB === WebGLContext._sFactor && dstRGB === WebGLContext._dFactor && srcAlpha === WebGLContext._srcAlpha && dstAlpha === WebGLContext._dstAlpha || (WebGLContext._sFactor = srcRGB, WebGLContext._dFactor = dstRGB, WebGLContext._srcAlpha = srcAlpha, WebGLContext._dstAlpha = dstAlpha, gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha))
            }

            static setCullFace(gl, value) {
                value !== WebGLContext._cullFace && (WebGLContext._cullFace = value, value ? gl.enable(gl.CULL_FACE) : gl.disable(gl.CULL_FACE))
            }

            static setFrontFace(gl, value) {
                value !== WebGLContext._frontFace && (WebGLContext._frontFace = value, gl.frontFace(value))
            }

            static activeTexture(gl, textureID) {
                WebGLContext._activedTextureID !== textureID && (gl.activeTexture(textureID), WebGLContext._activedTextureID = textureID)
            }

            static bindTexture(gl, target, texture) {
                WebGLContext._activeTextures[WebGLContext._activedTextureID - gl.TEXTURE0] !== texture && (gl.bindTexture(target, texture), WebGLContext._activeTextures[WebGLContext._activedTextureID - gl.TEXTURE0] = texture)
            }

            static __init_native() {
                if (ILaya.Render.supportWebGLPlusRendering) {
                    var webGLContext = WebGLContext;
                    webGLContext.activeTexture = webGLContext.activeTextureForNative, webGLContext.bindTexture = webGLContext.bindTextureForNative
                }
            }

            static useProgramForNative(gl, program) {
                return gl.useProgram(program), !0
            }

            static setDepthTestForNative(gl, value) {
                value ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST)
            }

            static setDepthMaskForNative(gl, value) {
                gl.depthMask(value)
            }

            static setDepthFuncForNative(gl, value) {
                gl.depthFunc(value)
            }

            static setBlendForNative(gl, value) {
                value ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND)
            }

            static setBlendFuncForNative(gl, sFactor, dFactor) {
                gl.blendFunc(sFactor, dFactor)
            }

            static setCullFaceForNative(gl, value) {
                value ? gl.enable(gl.CULL_FACE) : gl.disable(gl.CULL_FACE)
            }

            static setFrontFaceForNative(gl, value) {
                gl.frontFace(value)
            }

            static activeTextureForNative(gl, textureID) {
                gl.activeTexture(textureID)
            }

            static bindTextureForNative(gl, target, texture) {
                gl.bindTexture(target, texture)
            }

            static bindVertexArrayForNative(gl, vertexArray) {
                gl.bindVertexArray(vertexArray)
            }
        }

        WebGLContext.mainContext = null, WebGLContext._activeTextures = new Array(8), WebGLContext._useProgram = null, WebGLContext._depthTest = !0, WebGLContext._depthMask = !0, WebGLContext._blend = !1, WebGLContext._cullFace = !1;

        class BaseTexture extends Bitmap {
            constructor(format, mipMap) {
                super(), this._wrapModeU = BaseTexture.WARPMODE_REPEAT, this._wrapModeV = BaseTexture.WARPMODE_REPEAT, this._filterMode = BaseTexture.FILTERMODE_BILINEAR, this._readyed = !1, this._width = -1, this._height = -1, this._format = format, this._mipmap = mipMap, this._anisoLevel = 1, this._glTexture = LayaGL.instance.createTexture()
            }

            get mipmap() {
                return this._mipmap
            }

            get format() {
                return this._format
            }

            get wrapModeU() {
                return this._wrapModeU
            }

            set wrapModeU(value) {
                this._wrapModeU !== value && (this._wrapModeU = value, -1 !== this._width && this._setWarpMode(LayaGL.instance.TEXTURE_WRAP_S, value))
            }

            get wrapModeV() {
                return this._wrapModeV
            }

            set wrapModeV(value) {
                this._wrapModeV !== value && (this._wrapModeV = value, -1 !== this._height && this._setWarpMode(LayaGL.instance.TEXTURE_WRAP_T, value))
            }

            get filterMode() {
                return this._filterMode
            }

            set filterMode(value) {
                value !== this._filterMode && (this._filterMode = value, -1 !== this._width && -1 !== this._height && this._setFilterMode(value))
            }

            get anisoLevel() {
                return this._anisoLevel
            }

            set anisoLevel(value) {
                value !== this._anisoLevel && (this._anisoLevel = Math.max(1, Math.min(16, value)), -1 !== this._width && -1 !== this._height && this._setAnisotropy(value))
            }

            get mipmapCount() {
                return this._mipmapCount
            }

            get defaulteTexture() {
                throw"BaseTexture:must override it."
            }

            _getFormatByteCount() {
                switch (this._format) {
                    case BaseTexture.FORMAT_R8G8B8:
                        return 3;
                    case BaseTexture.FORMAT_R8G8B8A8:
                        return 4;
                    case BaseTexture.FORMAT_ALPHA8:
                        return 1;
                    default:
                        throw"Texture2D: unknown format."
                }
            }

            _isPot(size) {
                return 0 == (size & size - 1)
            }

            _getGLFormat() {
                var glFormat, gl = LayaGL.instance, gpu = LayaGL.layaGPUInstance;
                switch (this._format) {
                    case BaseTexture.FORMAT_R8G8B8:
                        glFormat = gl.RGB;
                        break;
                    case BaseTexture.FORMAT_R8G8B8A8:
                        glFormat = gl.RGBA;
                        break;
                    case BaseTexture.FORMAT_ALPHA8:
                        glFormat = gl.ALPHA;
                        break;
                    case BaseTexture.FORMAT_DXT1:
                        if (!gpu._compressedTextureS3tc) throw"BaseTexture: not support DXT1 format.";
                        glFormat = gpu._compressedTextureS3tc.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        break;
                    case BaseTexture.FORMAT_DXT5:
                        if (!gpu._compressedTextureS3tc) throw"BaseTexture: not support DXT5 format.";
                        glFormat = gpu._compressedTextureS3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                        break;
                    case BaseTexture.FORMAT_ETC1RGB:
                        if (!gpu._compressedTextureEtc1) throw"BaseTexture: not support ETC1RGB format.";
                        glFormat = gpu._compressedTextureEtc1.COMPRESSED_RGB_ETC1_WEBGL;
                        break;
                    case BaseTexture.FORMAT_PVRTCRGB_2BPPV:
                        if (!gpu._compressedTexturePvrtc) throw"BaseTexture: not support PVRTCRGB_2BPPV format.";
                        glFormat = gpu._compressedTexturePvrtc.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        break;
                    case BaseTexture.FORMAT_PVRTCRGBA_2BPPV:
                        if (!gpu._compressedTexturePvrtc) throw"BaseTexture: not support PVRTCRGBA_2BPPV format.";
                        glFormat = gpu._compressedTexturePvrtc.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                        break;
                    case BaseTexture.FORMAT_PVRTCRGB_4BPPV:
                        if (!gpu._compressedTexturePvrtc) throw"BaseTexture: not support PVRTCRGB_4BPPV format.";
                        glFormat = gpu._compressedTexturePvrtc.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        break;
                    case BaseTexture.FORMAT_PVRTCRGBA_4BPPV:
                        if (!gpu._compressedTexturePvrtc) throw"BaseTexture: not support PVRTCRGBA_4BPPV format.";
                        glFormat = gpu._compressedTexturePvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        break;
                    default:
                        throw"BaseTexture: unknown texture format."
                }
                return glFormat
            }

            _setFilterMode(value) {
                var gl = LayaGL.instance;
                switch (WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture), value) {
                    case BaseTexture.FILTERMODE_POINT:
                        this._mipmap ? gl.texParameteri(this._glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST) : gl.texParameteri(this._glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST), gl.texParameteri(this._glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        break;
                    case BaseTexture.FILTERMODE_BILINEAR:
                        this._mipmap ? gl.texParameteri(this._glTextureType, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST) : gl.texParameteri(this._glTextureType, gl.TEXTURE_MIN_FILTER, gl.LINEAR), gl.texParameteri(this._glTextureType, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        break;
                    case BaseTexture.FILTERMODE_TRILINEAR:
                        this._mipmap ? gl.texParameteri(this._glTextureType, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR) : gl.texParameteri(this._glTextureType, gl.TEXTURE_MIN_FILTER, gl.LINEAR), gl.texParameteri(this._glTextureType, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        break;
                    default:
                        throw new Error("BaseTexture:unknown filterMode value.")
                }
            }

            _setWarpMode(orientation, mode) {
                var gl = LayaGL.instance;
                if (WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture), this._isPot(this._width) && this._isPot(this._height)) switch (mode) {
                    case BaseTexture.WARPMODE_REPEAT:
                        gl.texParameteri(this._glTextureType, orientation, gl.REPEAT);
                        break;
                    case BaseTexture.WARPMODE_CLAMP:
                        gl.texParameteri(this._glTextureType, orientation, gl.CLAMP_TO_EDGE)
                } else gl.texParameteri(this._glTextureType, orientation, gl.CLAMP_TO_EDGE)
            }

            _setAnisotropy(value) {
                var anisotropic = LayaGL.layaGPUInstance._extTextureFilterAnisotropic;
                if (anisotropic) {
                    value = Math.max(value, 1);
                    var gl = LayaGL.instance;
                    WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture), value = Math.min(gl.getParameter(anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT), value), gl.texParameterf(this._glTextureType, anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, value)
                }
            }

            _disposeResource() {
                this._glTexture && (LayaGL.instance.deleteTexture(this._glTexture), this._glTexture = null, this._setGPUMemory(0))
            }

            _getSource() {
                return this._readyed ? this._glTexture : null
            }

            generateMipmap() {
                this._isPot(this.width) && this._isPot(this.height) && LayaGL.instance.generateMipmap(this._glTextureType)
            }
        }

        BaseTexture.WARPMODE_REPEAT = 0, BaseTexture.WARPMODE_CLAMP = 1, BaseTexture.FILTERMODE_POINT = 0, BaseTexture.FILTERMODE_BILINEAR = 1, BaseTexture.FILTERMODE_TRILINEAR = 2, BaseTexture.FORMAT_R8G8B8 = 0, BaseTexture.FORMAT_R8G8B8A8 = 1, BaseTexture.FORMAT_ALPHA8 = 2, BaseTexture.FORMAT_DXT1 = 3, BaseTexture.FORMAT_DXT5 = 4, BaseTexture.FORMAT_ETC1RGB = 5, BaseTexture.FORMAT_PVRTCRGB_2BPPV = 9, BaseTexture.FORMAT_PVRTCRGBA_2BPPV = 10, BaseTexture.FORMAT_PVRTCRGB_4BPPV = 11, BaseTexture.FORMAT_PVRTCRGBA_4BPPV = 12, BaseTexture.RENDERTEXTURE_FORMAT_RGBA_HALF_FLOAT = 14, BaseTexture.FORMAT_DEPTH_16 = 0, BaseTexture.FORMAT_STENCIL_8 = 1, BaseTexture.FORMAT_DEPTHSTENCIL_16_8 = 2, BaseTexture.FORMAT_DEPTHSTENCIL_NONE = 3;

        class Texture2D extends BaseTexture {
            constructor(width = 0, height = 0, format = BaseTexture.FORMAT_R8G8B8A8, mipmap = !0, canRead = !1) {
                super(format, mipmap);
                var gl = LayaGL.instance;
                if (this._glTextureType = gl.TEXTURE_2D, this._width = width, this._height = height, this._canRead = canRead, this._setWarpMode(gl.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(gl.TEXTURE_WRAP_T, this._wrapModeV), this._setFilterMode(this._filterMode), this._setAnisotropy(this._anisoLevel), this._mipmap) {
                    this._mipmapCount = Math.max(Math.ceil(Math.log2(width)) + 1, Math.ceil(Math.log2(height)) + 1);
                    for (var i = 0; i < this._mipmapCount; i++) this._setPixels(null, i, Math.max(width >> i, 1), Math.max(height >> i, 1));
                    this._setGPUMemory(width * height * 4 * (1 + 1 / 3))
                } else this._mipmapCount = 1, this._setGPUMemory(width * height * 4)
            }

            static __init__() {
                var pixels = new Uint8Array(3);
                pixels[0] = 128, pixels[1] = 128, pixels[2] = 128, Texture2D.grayTexture = new Texture2D(1, 1, BaseTexture.FORMAT_R8G8B8, !1, !1), Texture2D.grayTexture.setPixels(pixels), Texture2D.grayTexture.lock = !0, pixels[0] = 255, pixels[1] = 255, pixels[2] = 255, Texture2D.whiteTexture = new Texture2D(1, 1, BaseTexture.FORMAT_R8G8B8, !1, !1), Texture2D.whiteTexture.setPixels(pixels), Texture2D.whiteTexture.lock = !0, pixels[0] = 0, pixels[1] = 0, pixels[2] = 0, Texture2D.blackTexture = new Texture2D(1, 1, BaseTexture.FORMAT_R8G8B8, !1, !1), Texture2D.blackTexture.setPixels(pixels), Texture2D.blackTexture.lock = !0
            }

            static _parse(data, propertyParams = null, constructParams = null) {
                var texture = constructParams ? new Texture2D(constructParams[0], constructParams[1], constructParams[2], constructParams[3], constructParams[4]) : new Texture2D(0, 0);
                switch (propertyParams && (texture.wrapModeU = propertyParams.wrapModeU, texture.wrapModeV = propertyParams.wrapModeV, texture.filterMode = propertyParams.filterMode, texture.anisoLevel = propertyParams.anisoLevel), texture._format) {
                    case BaseTexture.FORMAT_R8G8B8:
                    case BaseTexture.FORMAT_R8G8B8A8:
                        texture.loadImageSource(data);
                        break;
                    case BaseTexture.FORMAT_DXT1:
                    case BaseTexture.FORMAT_DXT5:
                    case BaseTexture.FORMAT_ETC1RGB:
                    case BaseTexture.FORMAT_PVRTCRGB_2BPPV:
                    case BaseTexture.FORMAT_PVRTCRGBA_2BPPV:
                    case BaseTexture.FORMAT_PVRTCRGB_4BPPV:
                    case BaseTexture.FORMAT_PVRTCRGBA_4BPPV:
                        texture.setCompressData(data);
                        break;
                    default:
                        throw"Texture2D:unkonwn format."
                }
                return texture
            }

            static load(url, complete) {
                ILaya.loader.create(url, complete, null, ILaya.Loader.TEXTURE2D)
            }

            get defaulteTexture() {
                return Texture2D.grayTexture
            }

            _setPixels(pixels, miplevel, width, height) {
                var gl = LayaGL.instance, textureType = this._glTextureType, glFormat = this._getGLFormat();
                WebGLContext.bindTexture(gl, textureType, this._glTexture), this.format === BaseTexture.FORMAT_R8G8B8 ? (gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1), gl.texImage2D(textureType, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels), gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4)) : gl.texImage2D(textureType, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels)
            }

            _calcualatesCompressedDataSize(format, width, height) {
                switch (format) {
                    case BaseTexture.FORMAT_DXT1:
                    case BaseTexture.FORMAT_ETC1RGB:
                        return (width + 3 >> 2) * (height + 3 >> 2) * 8;
                    case BaseTexture.FORMAT_DXT5:
                        return (width + 3 >> 2) * (height + 3 >> 2) * 16;
                    case BaseTexture.FORMAT_PVRTCRGB_4BPPV:
                    case BaseTexture.FORMAT_PVRTCRGBA_4BPPV:
                        return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);
                    case BaseTexture.FORMAT_PVRTCRGB_2BPPV:
                    case BaseTexture.FORMAT_PVRTCRGBA_2BPPV:
                        return Math.floor((Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8);
                    default:
                        return 0
                }
            }

            _pharseDDS(arrayBuffer) {
                var header = new Int32Array(arrayBuffer, 0, 31);
                if (542327876 != header[0]) throw"Invalid magic number in DDS header";
                if (!(4 & header[20])) throw"Unsupported format, must contain a FourCC code";
                var compressedFormat = header[21];
                switch (this._format) {
                    case BaseTexture.FORMAT_DXT1:
                        if (827611204 !== compressedFormat) throw"the FourCC code is not same with texture format.";
                        break;
                    case BaseTexture.FORMAT_DXT5:
                        if (894720068 !== compressedFormat) throw"the FourCC code is not same with texture format.";
                        break;
                    default:
                        throw"unknown texture format."
                }
                var mipLevels = 1;
                if (131072 & header[2]) {
                    if (mipLevels = Math.max(1, header[7]), !this._mipmap) throw"the mipmap is not same with Texture2D."
                } else if (this._mipmap) throw"the mipmap is not same with Texture2D.";
                var width = header[4], height = header[3];
                this._width = width, this._height = height;
                var dataOffset = header[1] + 4;
                this._upLoadCompressedTexImage2D(arrayBuffer, width, height, mipLevels, dataOffset, 0)
            }

            _pharseKTX(arrayBuffer) {
                var id = new Uint8Array(arrayBuffer, 0, 12);
                if (171 != id[0] || 75 != id[1] || 84 != id[2] || 88 != id[3] || 32 != id[4] || 49 != id[5] || 49 != id[6] || 187 != id[7] || 13 != id[8] || 10 != id[9] || 26 != id[10] || 10 != id[11]) throw"Invalid fileIdentifier in KTX header";
                var header = new Int32Array(id.buffer, id.length, 13);
                switch (header[4]) {
                    case LayaGL.layaGPUInstance._compressedTextureEtc1.COMPRESSED_RGB_ETC1_WEBGL:
                        this._format = BaseTexture.FORMAT_ETC1RGB;
                        break;
                    default:
                        throw"unknown texture format."
                }
                var mipLevels = header[11], width = header[6], height = header[7];
                this._width = width, this._height = height;
                var dataOffset = 64 + header[12];
                this._upLoadCompressedTexImage2D(arrayBuffer, width, height, mipLevels, dataOffset, 4)
            }

            _pharsePVR(arrayBuffer) {
                var header = new Int32Array(arrayBuffer, 0, 13);
                if (55727696 != header[0]) throw"Invalid magic number in PVR header";
                switch (header[2]) {
                    case 0:
                        this._format = BaseTexture.FORMAT_PVRTCRGB_2BPPV;
                        break;
                    case 2:
                        this._format = BaseTexture.FORMAT_PVRTCRGB_4BPPV;
                        break;
                    case 1:
                        this._format = BaseTexture.FORMAT_PVRTCRGBA_2BPPV;
                        break;
                    case 3:
                        this._format = BaseTexture.FORMAT_PVRTCRGBA_4BPPV;
                        break;
                    default:
                        throw"Texture2D:unknown PVR format."
                }
                var mipLevels = header[11], width = header[7], height = header[6];
                this._width = width, this._height = height;
                var dataOffset = header[12] + 52;
                this._upLoadCompressedTexImage2D(arrayBuffer, width, height, mipLevels, dataOffset, 0)
            }

            _upLoadCompressedTexImage2D(data, width, height, miplevelCount, dataOffset, imageSizeOffset) {
                var gl = LayaGL.instance, textureType = this._glTextureType;
                WebGLContext.bindTexture(gl, textureType, this._glTexture);
                for (var glFormat = this._getGLFormat(), offset = dataOffset, i = 0; i < miplevelCount; i++) {
                    offset += imageSizeOffset;
                    var mipDataSize = this._calcualatesCompressedDataSize(this._format, width, height),
                        mipData = new Uint8Array(data, offset, mipDataSize);
                    gl.compressedTexImage2D(textureType, i, glFormat, width, height, 0, mipData), width = Math.max(width >> 1, 1), height = Math.max(height >> 1, 1), offset += mipDataSize
                }
                var memory = offset;
                this._setGPUMemory(memory), this._readyed = !0, this._activeResource()
            }

            loadImageSource(source, premultiplyAlpha = !1) {
                var gl = LayaGL.instance, width = source.width, height = source.height;
                this._width = width, this._height = height, this._isPot(width) && this._isPot(height) || (this._mipmap = !1), this._setWarpMode(gl.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(gl.TEXTURE_WRAP_T, this._wrapModeV), this._setFilterMode(this._filterMode), WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture);
                var glFormat = this._getGLFormat();
                ILaya.Render.isConchApp ? (source.setPremultiplyAlpha && source.setPremultiplyAlpha(premultiplyAlpha), gl.texImage2D(this._glTextureType, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source)) : (premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), gl.texImage2D(this._glTextureType, 0, glFormat, glFormat, gl.UNSIGNED_BYTE, source), premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1)), this._mipmap ? (gl.generateMipmap(this._glTextureType), this._setGPUMemory(width * height * 4 * (1 + 1 / 3))) : this._setGPUMemory(width * height * 4), this._canRead && (ILaya.Render.isConchApp ? this._pixels = new Uint8Array(source._nativeObj.getImageData(0, 0, width, height)) : (ILaya.Browser.canvas.size(width, height), ILaya.Browser.canvas.clear(), ILaya.Browser.context.drawImage(source, 0, 0, width, height), this._pixels = new Uint8Array(ILaya.Browser.context.getImageData(0, 0, width, height).data.buffer))), this._readyed = !0, this._activeResource()
            }

            setPixels(pixels, miplevel = 0) {
                if (!pixels) throw"Texture2D:pixels can't be null.";
                var width = Math.max(this._width >> miplevel, 1), height = Math.max(this._height >> miplevel, 1),
                    pixelsCount = width * height * this._getFormatByteCount();
                if (pixels.length < pixelsCount) throw"Texture2D:pixels length should at least " + pixelsCount + ".";
                this._setPixels(pixels, miplevel, width, height), this._canRead && (this._pixels = pixels), this._readyed = !0, this._activeResource()
            }

            setSubPixels(x, y, width, height, pixels, miplevel = 0) {
                if (!pixels) throw"Texture2D:pixels can't be null.";
                var gl = LayaGL.instance, textureType = this._glTextureType;
                WebGLContext.bindTexture(gl, textureType, this._glTexture);
                var glFormat = this._getGLFormat();
                this._format === BaseTexture.FORMAT_R8G8B8 ? (gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1), gl.texSubImage2D(textureType, miplevel, x, y, width, height, glFormat, gl.UNSIGNED_BYTE, pixels), gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4)) : gl.texSubImage2D(textureType, miplevel, x, y, width, height, glFormat, gl.UNSIGNED_BYTE, pixels), this._readyed = !0, this._activeResource()
            }

            setCompressData(data) {
                switch (this._format) {
                    case BaseTexture.FORMAT_DXT1:
                    case BaseTexture.FORMAT_DXT5:
                        this._pharseDDS(data);
                        break;
                    case BaseTexture.FORMAT_ETC1RGB:
                        this._pharseKTX(data);
                        break;
                    case BaseTexture.FORMAT_PVRTCRGB_2BPPV:
                    case BaseTexture.FORMAT_PVRTCRGBA_2BPPV:
                    case BaseTexture.FORMAT_PVRTCRGB_4BPPV:
                    case BaseTexture.FORMAT_PVRTCRGBA_4BPPV:
                        this._pharsePVR(data);
                        break;
                    default:
                        throw"Texture2D:unkonwn format."
                }
            }

            _recoverResource() {
            }

            getPixels() {
                if (this._canRead) return this._pixels;
                throw new Error("Texture2D: must set texture canRead is true.")
            }
        }

        Texture2D.TEXTURE2D = "TEXTURE2D", Texture2D.grayTexture = null, Texture2D.whiteTexture = null, Texture2D.blackTexture = null;

        class BaseShader extends Resource {
            constructor() {
                super()
            }
        }

        class RenderState2D {
            static mat2MatArray(mat, matArray) {
                var m = mat, m4 = matArray;
                return m4[0] = m.a, m4[1] = m.b, m4[2] = RenderState2D.EMPTYMAT4_ARRAY[2], m4[3] = RenderState2D.EMPTYMAT4_ARRAY[3], m4[4] = m.c, m4[5] = m.d, m4[6] = RenderState2D.EMPTYMAT4_ARRAY[6], m4[7] = RenderState2D.EMPTYMAT4_ARRAY[7], m4[8] = RenderState2D.EMPTYMAT4_ARRAY[8], m4[9] = RenderState2D.EMPTYMAT4_ARRAY[9], m4[10] = RenderState2D.EMPTYMAT4_ARRAY[10], m4[11] = RenderState2D.EMPTYMAT4_ARRAY[11], m4[12] = m.tx, m4[13] = m.ty, m4[14] = RenderState2D.EMPTYMAT4_ARRAY[14], m4[15] = RenderState2D.EMPTYMAT4_ARRAY[15], matArray
            }

            static restoreTempArray() {
                RenderState2D.TEMPMAT4_ARRAY[0] = 1, RenderState2D.TEMPMAT4_ARRAY[1] = 0, RenderState2D.TEMPMAT4_ARRAY[4] = 0, RenderState2D.TEMPMAT4_ARRAY[5] = 1, RenderState2D.TEMPMAT4_ARRAY[12] = 0, RenderState2D.TEMPMAT4_ARRAY[13] = 0
            }

            static clear() {
                RenderState2D.worldScissorTest = !1, RenderState2D.worldAlpha = 1
            }
        }

        RenderState2D._MAXSIZE = 99999999, RenderState2D.EMPTYMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], RenderState2D.TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY, RenderState2D.worldMatrix = new Matrix, RenderState2D.matWVP = null, RenderState2D.worldAlpha = 1, RenderState2D.worldScissorTest = !1, RenderState2D.width = 0, RenderState2D.height = 0;

        class RenderTexture2D extends BaseTexture {
            constructor(width, height, format = BaseTexture.FORMAT_R8G8B8, depthStencilFormat = BaseTexture.FORMAT_DEPTH_16) {
                super(format, !1), this._mgrKey = 0, this._glTextureType = LayaGL.instance.TEXTURE_2D, this._width = width, this._height = height, this._depthStencilFormat = depthStencilFormat, this._create(width, height), this.lock = !0
            }

            static get currentActive() {
                return RenderTexture2D._currentActive
            }

            get depthStencilFormat() {
                return this._depthStencilFormat
            }

            get defaulteTexture() {
                return Texture2D.grayTexture
            }

            getIsReady() {
                return !0
            }

            get sourceWidth() {
                return this._width
            }

            get sourceHeight() {
                return this._height
            }

            get offsetX() {
                return 0
            }

            get offsetY() {
                return 0
            }

            _create(width, height) {
                var gl = LayaGL.instance;
                this._frameBuffer = gl.createFramebuffer(), WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture);
                var glFormat = this._getGLFormat();
                if (gl.texImage2D(this._glTextureType, 0, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, null), this._setGPUMemory(width * height * 4), gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, 0), this._depthStencilFormat !== BaseTexture.FORMAT_DEPTHSTENCIL_NONE) switch (this._depthStencilBuffer = gl.createRenderbuffer(), gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthStencilBuffer), this._depthStencilFormat) {
                    case BaseTexture.FORMAT_DEPTH_16:
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._depthStencilBuffer);
                        break;
                    case BaseTexture.FORMAT_STENCIL_8:
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, width, height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._depthStencilBuffer);
                        break;
                    case BaseTexture.FORMAT_DEPTHSTENCIL_16_8:
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._depthStencilBuffer)
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, null), gl.bindRenderbuffer(gl.RENDERBUFFER, null), this._setWarpMode(gl.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(gl.TEXTURE_WRAP_T, this._wrapModeV), this._setFilterMode(this._filterMode), this._setAnisotropy(this._anisoLevel), this._readyed = !0, this._activeResource()
            }

            generateMipmap() {
                this._isPot(this.width) && this._isPot(this.height) ? (this._mipmap = !0, LayaGL.instance.generateMipmap(this._glTextureType), this._setFilterMode(this._filterMode), this._setGPUMemory(this.width * this.height * 4 * (1 + 1 / 3))) : (this._mipmap = !1, this._setGPUMemory(this.width * this.height * 4))
            }

            static pushRT() {
                RenderTexture2D.rtStack.push({
                    rt: RenderTexture2D._currentActive,
                    w: RenderState2D.width,
                    h: RenderState2D.height
                })
            }

            static popRT() {
                var gl = LayaGL.instance, top = RenderTexture2D.rtStack.pop();
                top && (RenderTexture2D._currentActive != top.rt && (LayaGL.instance.bindFramebuffer(gl.FRAMEBUFFER, top.rt ? top.rt._frameBuffer : null), RenderTexture2D._currentActive = top.rt), gl.viewport(0, 0, top.w, top.h), RenderState2D.width = top.w, RenderState2D.height = top.h)
            }

            start() {
                var gl = LayaGL.instance;
                LayaGL.instance.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer), this._lastRT = RenderTexture2D._currentActive, RenderTexture2D._currentActive = this, this._readyed = !0, gl.viewport(0, 0, this._width, this._height), this._lastWidth = RenderState2D.width, this._lastHeight = RenderState2D.height, RenderState2D.width = this._width, RenderState2D.height = this._height, BaseShader.activeShader = null
            }

            end() {
                var gl = LayaGL.instance;
                gl.bindFramebuffer(gl.FRAMEBUFFER, null), RenderTexture2D._currentActive = null, this._readyed = !0
            }

            restore() {
                var gl = LayaGL.instance;
                this._lastRT != RenderTexture2D._currentActive && (LayaGL.instance.bindFramebuffer(gl.FRAMEBUFFER, this._lastRT ? this._lastRT._frameBuffer : null), RenderTexture2D._currentActive = this._lastRT), this._readyed = !0, gl.viewport(0, 0, this._lastWidth, this._lastHeight), RenderState2D.width = this._lastWidth, RenderState2D.height = this._lastHeight, BaseShader.activeShader = null
            }

            clear(r = 0, g = 0, b = 0, a = 1) {
                var gl = LayaGL.instance;
                gl.clearColor(r, g, b, a);
                var clearFlag = gl.COLOR_BUFFER_BIT;
                switch (this._depthStencilFormat) {
                    case gl.DEPTH_COMPONENT16:
                        clearFlag |= gl.DEPTH_BUFFER_BIT;
                        break;
                    case gl.STENCIL_INDEX8:
                        clearFlag |= gl.STENCIL_BUFFER_BIT;
                        break;
                    case gl.DEPTH_STENCIL:
                        clearFlag |= gl.DEPTH_BUFFER_BIT, clearFlag |= gl.STENCIL_BUFFER_BIT
                }
                gl.clear(clearFlag)
            }

            getData(x, y, width, height) {
                if (ILaya.Render.isConchApp && 2 == window.conchConfig.threadMode) throw"native 2 thread mode use getDataAsync";
                var gl = LayaGL.instance;
                if (gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer), !(gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE)) return gl.bindFramebuffer(gl.FRAMEBUFFER, null), null;
                var pixels = new Uint8Array(this._width * this._height * 4), glFormat = this._getGLFormat();
                return gl.readPixels(x, y, width, height, glFormat, gl.UNSIGNED_BYTE, pixels), gl.bindFramebuffer(gl.FRAMEBUFFER, null), pixels
            }

            getDataAsync(x, y, width, height, callBack) {
                var gl = LayaGL.instance;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer), gl.readPixelsAsync(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, function (data) {
                    callBack(new Uint8Array(data))
                }), gl.bindFramebuffer(gl.FRAMEBUFFER, null)
            }

            recycle() {
            }

            _disposeResource() {
                if (this._frameBuffer) {
                    var gl = LayaGL.instance;
                    gl.deleteTexture(this._glTexture), gl.deleteFramebuffer(this._frameBuffer), gl.deleteRenderbuffer(this._depthStencilBuffer), this._glTexture = null, this._frameBuffer = null, this._depthStencilBuffer = null, this._setGPUMemory(0)
                }
            }
        }

        RenderTexture2D.rtStack = [], RenderTexture2D.defuv = [0, 0, 1, 0, 1, 1, 0, 1], RenderTexture2D.flipyuv = [0, 1, 1, 1, 1, 0, 0, 0];

        class WebGLRTMgr {
            static getRT(w, h) {
                return h |= 0, (w |= 0) >= 1e4 && console.error("getRT error! w too big"), new RenderTexture2D(w, h, BaseTexture.FORMAT_R8G8B8A8, -1)
            }

            static releaseRT(rt) {
                rt._disposeResource()
            }
        }

        WebGLRTMgr.dict = {};

        class BlendMode {
            static _init_(gl) {
                BlendMode.fns = [BlendMode.BlendNormal, BlendMode.BlendAdd, BlendMode.BlendMultiply, BlendMode.BlendScreen, BlendMode.BlendOverlay, BlendMode.BlendLight, BlendMode.BlendMask, BlendMode.BlendDestinationOut], BlendMode.targetFns = [BlendMode.BlendNormalTarget, BlendMode.BlendAddTarget, BlendMode.BlendMultiplyTarget, BlendMode.BlendScreenTarget, BlendMode.BlendOverlayTarget, BlendMode.BlendLightTarget, BlendMode.BlendMask, BlendMode.BlendDestinationOut]
            }

            static BlendNormal(gl) {
                WebGLContext.setBlendFunc(gl, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
            }

            static BlendAdd(gl) {
                WebGLContext.setBlendFunc(gl, gl.ONE, gl.DST_ALPHA)
            }

            static BlendMultiply(gl) {
                WebGLContext.setBlendFunc(gl, gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA)
            }

            static BlendScreen(gl) {
                WebGLContext.setBlendFunc(gl, gl.ONE, gl.ONE)
            }

            static BlendOverlay(gl) {
                WebGLContext.setBlendFunc(gl, gl.ONE, gl.ONE_MINUS_SRC_COLOR)
            }

            static BlendLight(gl) {
                WebGLContext.setBlendFunc(gl, gl.ONE, gl.ONE)
            }

            static BlendNormalTarget(gl) {
                WebGLContext.setBlendFunc(gl, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
            }

            static BlendAddTarget(gl) {
                WebGLContext.setBlendFunc(gl, gl.ONE, gl.DST_ALPHA)
            }

            static BlendMultiplyTarget(gl) {
                WebGLContext.setBlendFunc(gl, gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA)
            }

            static BlendScreenTarget(gl) {
                WebGLContext.setBlendFunc(gl, gl.ONE, gl.ONE)
            }

            static BlendOverlayTarget(gl) {
                WebGLContext.setBlendFunc(gl, gl.ONE, gl.ONE_MINUS_SRC_COLOR)
            }

            static BlendLightTarget(gl) {
                WebGLContext.setBlendFunc(gl, gl.ONE, gl.ONE)
            }

            static BlendMask(gl) {
                WebGLContext.setBlendFunc(gl, gl.ZERO, gl.SRC_ALPHA)
            }

            static BlendDestinationOut(gl) {
                WebGLContext.setBlendFunc(gl, gl.ZERO, gl.ZERO)
            }
        }

        BlendMode.activeBlendFunction = null, BlendMode.NAMES = ["normal", "add", "multiply", "screen", "overlay", "light", "mask", "destination-out"], BlendMode.TOINT = {
            normal: 0,
            add: 1,
            multiply: 2,
            screen: 3,
            overlay: 4,
            light: 5,
            mask: 6,
            "destination-out": 7,
            lighter: 1
        }, BlendMode.NORMAL = "normal", BlendMode.ADD = "add", BlendMode.MULTIPLY = "multiply", BlendMode.SCREEN = "screen", BlendMode.OVERLAY = "overlay", BlendMode.LIGHT = "light", BlendMode.MASK = "mask", BlendMode.DESTINATIONOUT = "destination-out", BlendMode.LIGHTER = "lighter", BlendMode.fns = [], BlendMode.targetFns = [];

        class ShaderDefinesBase {
            constructor(name2int, int2name, int2nameMap) {
                this._value = 0, this._name2int = name2int, this._int2name = int2name, this._int2nameMap = int2nameMap
            }

            add(value) {
                return this._value |= "string" == typeof value ? this._name2int[value] : value, this._value
            }

            addInt(value) {
                return this._value |= value, this._value
            }

            remove(value) {
                return this._value &= "string" == typeof value ? ~this._name2int[value] : ~value, this._value
            }

            isDefine(def) {
                return (this._value & def) === def
            }

            getValue() {
                return this._value
            }

            setValue(value) {
                this._value = value
            }

            toNameDic() {
                var r = this._int2nameMap[this._value];
                return r || ShaderDefinesBase._toText(this._value, this._int2name, this._int2nameMap)
            }

            static _reg(name, value, _name2int, _int2name) {
                _name2int[name] = value, _int2name[value] = name
            }

            static _toText(value, _int2name, _int2nameMap) {
                var r = _int2nameMap[value];
                if (r) return r;
                for (var o = {}, d = 1, i = 0; i < 32 && !((d = 1 << i) > value); i++) if (value & d) {
                    var name = _int2name[d];
                    name && (o[name] = "")
                }
                return _int2nameMap[value] = o, o
            }

            static _toInt(names, _name2int) {
                for (var words = names.split("."), num = 0, i = 0, n = words.length; i < n; i++) {
                    var value = _name2int[words[i]];
                    if (!value) throw new Error("Defines to int err:" + names + "/" + words[i]);
                    num |= value
                }
                return num
            }
        }

        class ShaderDefines2D extends ShaderDefinesBase {
            constructor() {
                super(ShaderDefines2D.__name2int, ShaderDefines2D.__int2name, ShaderDefines2D.__int2nameMap)
            }

            static __init__() {
                ShaderDefines2D.reg("TEXTURE2D", ShaderDefines2D.TEXTURE2D), ShaderDefines2D.reg("PRIMITIVE", ShaderDefines2D.PRIMITIVE), ShaderDefines2D.reg("GLOW_FILTER", ShaderDefines2D.FILTERGLOW), ShaderDefines2D.reg("BLUR_FILTER", ShaderDefines2D.FILTERBLUR), ShaderDefines2D.reg("COLOR_FILTER", ShaderDefines2D.FILTERCOLOR), ShaderDefines2D.reg("COLOR_ADD", ShaderDefines2D.COLORADD), ShaderDefines2D.reg("WORLDMAT", ShaderDefines2D.WORLDMAT), ShaderDefines2D.reg("FILLTEXTURE", ShaderDefines2D.FILLTEXTURE), ShaderDefines2D.reg("FSHIGHPRECISION", ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION), ShaderDefines2D.reg("MVP3D", ShaderDefines2D.MVP3D)
            }

            static reg(name, value) {
                this._reg(name, value, ShaderDefines2D.__name2int, ShaderDefines2D.__int2name)
            }

            static toText(value, int2name, int2nameMap) {
                return this._toText(value, int2name, int2nameMap)
            }

            static toInt(names) {
                return this._toInt(names, ShaderDefines2D.__name2int)
            }
        }

        ShaderDefines2D.TEXTURE2D = 1, ShaderDefines2D.PRIMITIVE = 4, ShaderDefines2D.FILTERGLOW = 8, ShaderDefines2D.FILTERBLUR = 16, ShaderDefines2D.FILTERCOLOR = 32, ShaderDefines2D.COLORADD = 64, ShaderDefines2D.WORLDMAT = 128, ShaderDefines2D.FILLTEXTURE = 256, ShaderDefines2D.SKINMESH = 512, ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION = 1024, ShaderDefines2D.MVP3D = 2048, ShaderDefines2D.NOOPTMASK = ShaderDefines2D.FILTERGLOW | ShaderDefines2D.FILTERBLUR | ShaderDefines2D.FILTERCOLOR | ShaderDefines2D.FILLTEXTURE, ShaderDefines2D.__name2int = {}, ShaderDefines2D.__int2name = [], ShaderDefines2D.__int2nameMap = [];

        class Stat {
            static show(x = 0, y = 0) {
                Stat._StatRender.show(x, y)
            }

            static enable() {
                Stat._StatRender.enable()
            }

            static hide() {
                Stat._StatRender.hide()
            }

            static clear() {
                Stat.trianglesFaces = Stat.renderBatches = Stat.savedRenderBatches = Stat.shaderCall = Stat.spriteRenderUseCacheCount = Stat.frustumCulling = Stat.octreeNodeCulling = Stat.canvasNormal = Stat.canvasBitmap = Stat.canvasReCache = 0
            }

            static set onclick(fn) {
                Stat._StatRender.set_onclick(fn)
            }
        }

        Stat.FPS = 0, Stat.loopCount = 0, Stat.shaderCall = 0, Stat.renderBatches = 0, Stat.savedRenderBatches = 0, Stat.trianglesFaces = 0, Stat.spriteCount = 0, Stat.spriteRenderUseCacheCount = 0, Stat.frustumCulling = 0, Stat.octreeNodeCulling = 0, Stat.canvasNormal = 0, Stat.canvasBitmap = 0, Stat.canvasReCache = 0, Stat.renderSlow = !1, Stat._fpsData = [], Stat._timer = 0, Stat._count = 0, Stat._StatRender = null;

        class StringKey {
            constructor() {
                this._strsToID = {}, this._idToStrs = [], this._length = 0
            }

            add(str) {
                var index = this._strsToID[str];
                return null != index ? index : (this._idToStrs[this._length] = str, this._strsToID[str] = this._length++)
            }

            getID(str) {
                var index = this._strsToID[str];
                return null == index ? -1 : index
            }

            getName(id) {
                var str = this._idToStrs[id];
                return null == str ? void 0 : str
            }
        }

        class Shader extends BaseShader {
            constructor(vs, ps, saveName = null, nameMap = null, bindAttrib = null) {
                if (super(), this._attribInfo = null, this.customCompile = !1, this._curActTexIndex = 0, this.tag = {}, this._program = null, this._params = null, this._paramsMap = {}, !vs || !ps) throw"Shader Error";
                this._attribInfo = bindAttrib, this._id = ++Shader._count, this._vs = vs, this._ps = ps, this._nameMap = nameMap || {}, null != saveName && (Shader.sharders[saveName] = this), this.recreateResource(), this.lock = !0
            }

            static getShader(name) {
                return Shader.sharders[name]
            }

            static create(vs, ps, saveName = null, nameMap = null, bindAttrib = null) {
                return new Shader(vs, ps, saveName, nameMap, bindAttrib)
            }

            static withCompile(nameID, define, shaderName, createShader) {
                if (shaderName && Shader.sharders[shaderName]) return Shader.sharders[shaderName];
                var pre = Shader._preCompileShader[Shader.SHADERNAME2ID * nameID];
                if (!pre) throw new Error("withCompile shader err!" + nameID);
                return pre.createShader(define, shaderName, createShader, null)
            }

            static withCompile2D(nameID, mainID, define, shaderName, createShader, bindAttrib = null) {
                if (shaderName && Shader.sharders[shaderName]) return Shader.sharders[shaderName];
                var pre = Shader._preCompileShader[Shader.SHADERNAME2ID * nameID + mainID];
                if (!pre) throw new Error("withCompile shader err!" + nameID + " " + mainID);
                return pre.createShader(define, shaderName, createShader, bindAttrib)
            }

            static addInclude(fileName, txt) {
                ILaya.ShaderCompile.addInclude(fileName, txt)
            }

            static preCompile(nameID, vs, ps, nameMap) {
                var id = Shader.SHADERNAME2ID * nameID;
                Shader._preCompileShader[id] = new ILaya.ShaderCompile(vs, ps, nameMap)
            }

            static preCompile2D(nameID, mainID, vs, ps, nameMap) {
                var id = Shader.SHADERNAME2ID * nameID + mainID;
                Shader._preCompileShader[id] = new ILaya.ShaderCompile(vs, ps, nameMap)
            }

            recreateResource() {
                this._compile(), this._setGPUMemory(0)
            }

            _disposeResource() {
                WebGLContext.mainContext.deleteShader(this._vshader), WebGLContext.mainContext.deleteShader(this._pshader), WebGLContext.mainContext.deleteProgram(this._program), this._vshader = this._pshader = this._program = null, this._params = null, this._paramsMap = {}, this._setGPUMemory(0), this._curActTexIndex = 0
            }

            _compile() {
                if (this._vs && this._ps && !this._params) {
                    var result;
                    this._reCompile = !0, this._params = [], this.customCompile && (result = ILaya.ShaderCompile.preGetParams(this._vs, this._ps));
                    var one, i, n, gl = WebGLContext.mainContext;
                    this._program = gl.createProgram(), this._vshader = Shader._createShader(gl, this._vs, gl.VERTEX_SHADER), this._pshader = Shader._createShader(gl, this._ps, gl.FRAGMENT_SHADER), gl.attachShader(this._program, this._vshader), gl.attachShader(this._program, this._pshader);
                    var attribDescNum = this._attribInfo ? this._attribInfo.length : 0;
                    for (i = 0; i < attribDescNum; i += 2) gl.bindAttribLocation(this._program, this._attribInfo[i + 1], this._attribInfo[i]);
                    if (gl.linkProgram(this._program), !this.customCompile && !gl.getProgramParameter(this._program, gl.LINK_STATUS)) throw gl.getProgramInfoLog(this._program);
                    var nUniformNum = this.customCompile ? result.uniforms.length : gl.getProgramParameter(this._program, gl.ACTIVE_UNIFORMS);
                    for (i = 0; i < nUniformNum; i++) {
                        var uniform = this.customCompile ? result.uniforms[i] : gl.getActiveUniform(this._program, i);
                        (one = {
                            vartype: "uniform",
                            glfun: null,
                            ivartype: 1,
                            location: gl.getUniformLocation(this._program, uniform.name),
                            name: uniform.name,
                            type: uniform.type,
                            isArray: !1,
                            isSame: !1,
                            preValue: null,
                            indexOfParams: 0
                        }).name.indexOf("[0]") > 0 && (one.name = one.name.substr(0, one.name.length - 3), one.isArray = !0, one.location = gl.getUniformLocation(this._program, one.name)), this._params.push(one)
                    }
                    for (i = 0, n = this._params.length; i < n; i++) switch ((one = this._params[i]).indexOfParams = i, one.index = 1, one.value = [one.location, null], one.codename = one.name, one.name = this._nameMap[one.codename] ? this._nameMap[one.codename] : one.codename, this._paramsMap[one.name] = one, one._this = this, one.uploadedValue = [], one.type) {
                        case gl.INT:
                            one.fun = one.isArray ? this._uniform1iv : this._uniform1i;
                            break;
                        case gl.FLOAT:
                            one.fun = one.isArray ? this._uniform1fv : this._uniform1f;
                            break;
                        case gl.FLOAT_VEC2:
                            one.fun = one.isArray ? this._uniform_vec2v : this._uniform_vec2;
                            break;
                        case gl.FLOAT_VEC3:
                            one.fun = one.isArray ? this._uniform_vec3v : this._uniform_vec3;
                            break;
                        case gl.FLOAT_VEC4:
                            one.fun = one.isArray ? this._uniform_vec4v : this._uniform_vec4;
                            break;
                        case gl.SAMPLER_2D:
                            one.fun = this._uniform_sampler2D;
                            break;
                        case gl.SAMPLER_CUBE:
                            one.fun = this._uniform_samplerCube;
                            break;
                        case gl.FLOAT_MAT4:
                            one.glfun = gl.uniformMatrix4fv, one.fun = this._uniformMatrix4fv;
                            break;
                        case gl.BOOL:
                            one.fun = this._uniform1i;
                            break;
                        case gl.FLOAT_MAT2:
                        case gl.FLOAT_MAT3:
                        default:
                            throw new Error("compile shader err!")
                    }
                }
            }

            static _createShader(gl, str, type) {
                var shader = gl.createShader(type);
                return gl.shaderSource(shader, str), gl.compileShader(shader), gl.getShaderParameter(shader, gl.COMPILE_STATUS) ? shader : (console.log(gl.getShaderInfoLog(shader)), null)
            }

            getUniform(name) {
                return this._paramsMap[name]
            }

            _uniform1f(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value ? (WebGLContext.mainContext.uniform1f(one.location, uploadedValue[0] = value), 1) : 0
            }

            _uniform1fv(one, value) {
                if (value.length < 4) {
                    var uploadedValue = one.uploadedValue;
                    return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3] ? (WebGLContext.mainContext.uniform1fv(one.location, value), uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3], 1) : 0
                }
                return WebGLContext.mainContext.uniform1fv(one.location, value), 1
            }

            _uniform_vec2(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] ? (WebGLContext.mainContext.uniform2f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]), 1) : 0
            }

            _uniform_vec2v(one, value) {
                if (value.length < 2) {
                    var uploadedValue = one.uploadedValue;
                    return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3] ? (WebGLContext.mainContext.uniform2fv(one.location, value), uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3], 1) : 0
                }
                return WebGLContext.mainContext.uniform2fv(one.location, value), 1
            }

            _uniform_vec3(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] ? (WebGLContext.mainContext.uniform3f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]), 1) : 0
            }

            _uniform_vec3v(one, value) {
                return WebGLContext.mainContext.uniform3fv(one.location, value), 1
            }

            _uniform_vec4(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3] ? (WebGLContext.mainContext.uniform4f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]), 1) : 0
            }

            _uniform_vec4v(one, value) {
                return WebGLContext.mainContext.uniform4fv(one.location, value), 1
            }

            _uniformMatrix2fv(one, value) {
                return WebGLContext.mainContext.uniformMatrix2fv(one.location, !1, value), 1
            }

            _uniformMatrix3fv(one, value) {
                return WebGLContext.mainContext.uniformMatrix3fv(one.location, !1, value), 1
            }

            _uniformMatrix4fv(one, value) {
                return WebGLContext.mainContext.uniformMatrix4fv(one.location, !1, value), 1
            }

            _uniform1i(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value ? (WebGLContext.mainContext.uniform1i(one.location, uploadedValue[0] = value), 1) : 0
            }

            _uniform1iv(one, value) {
                return WebGLContext.mainContext.uniform1iv(one.location, value), 1
            }

            _uniform_ivec2(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] ? (WebGLContext.mainContext.uniform2i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]), 1) : 0
            }

            _uniform_ivec2v(one, value) {
                return WebGLContext.mainContext.uniform2iv(one.location, value), 1
            }

            _uniform_vec3i(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] ? (WebGLContext.mainContext.uniform3i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]), 1) : 0
            }

            _uniform_vec3vi(one, value) {
                return WebGLContext.mainContext.uniform3iv(one.location, value), 1
            }

            _uniform_vec4i(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3] ? (WebGLContext.mainContext.uniform4i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]), 1) : 0
            }

            _uniform_vec4vi(one, value) {
                return WebGLContext.mainContext.uniform4iv(one.location, value), 1
            }

            _uniform_sampler2D(one, value) {
                var gl = WebGLContext.mainContext, uploadedValue = one.uploadedValue;
                return null == uploadedValue[0] ? (uploadedValue[0] = this._curActTexIndex, gl.uniform1i(one.location, this._curActTexIndex), WebGLContext.activeTexture(gl, gl.TEXTURE0 + this._curActTexIndex), WebGLContext.bindTexture(gl, gl.TEXTURE_2D, value), this._curActTexIndex++, 1) : (WebGLContext.activeTexture(gl, gl.TEXTURE0 + uploadedValue[0]), WebGLContext.bindTexture(gl, gl.TEXTURE_2D, value), 0)
            }

            _uniform_samplerCube(one, value) {
                var gl = WebGLContext.mainContext, uploadedValue = one.uploadedValue;
                return null == uploadedValue[0] ? (uploadedValue[0] = this._curActTexIndex, gl.uniform1i(one.location, this._curActTexIndex), WebGLContext.activeTexture(gl, gl.TEXTURE0 + this._curActTexIndex), WebGLContext.bindTexture(gl, gl.TEXTURE_CUBE_MAP, value), this._curActTexIndex++, 1) : (WebGLContext.activeTexture(gl, gl.TEXTURE0 + uploadedValue[0]), WebGLContext.bindTexture(gl, gl.TEXTURE_CUBE_MAP, value), 0)
            }

            _noSetValue(one) {
                console.log("no....:" + one.name)
            }

            uploadOne(name, value) {
                WebGLContext.useProgram(WebGLContext.mainContext, this._program);
                var one = this._paramsMap[name];
                one.fun.call(this, one, value)
            }

            uploadTexture2D(value) {
                var CTX = WebGLContext;
                CTX._activeTextures[0] !== value && (CTX.bindTexture(WebGLContext.mainContext, LayaGL.instance.TEXTURE_2D, value), CTX._activeTextures[0] = value)
            }

            upload(shaderValue, params = null) {
                BaseShader.activeShader = BaseShader.bindShader = this;
                var gl = WebGLContext.mainContext;
                WebGLContext.useProgram(gl, this._program), this._reCompile ? (params = this._params, this._reCompile = !1) : params = params || this._params;
                for (var one, value, n = params.length, shaderCall = 0, i = 0; i < n; i++) null !== (value = shaderValue[(one = params[i]).name]) && (shaderCall += one.fun.call(this, one, value));
                Stat.shaderCall += shaderCall
            }

            uploadArray(shaderValue, length, _bufferUsage) {
                BaseShader.activeShader = this, BaseShader.bindShader = this, WebGLContext.useProgram(WebGLContext.mainContext, this._program);
                this._params;
                for (var value, one, shaderCall = 0, i = length - 2; i >= 0; i -= 2) (one = this._paramsMap[shaderValue[i]]) && null != (value = shaderValue[i + 1]) && (_bufferUsage && _bufferUsage[one.name] && _bufferUsage[one.name].bind(), shaderCall += one.fun.call(this, one, value));
                Stat.shaderCall += shaderCall
            }

            getParams() {
                return this._params
            }

            setAttributesLocation(attribDesc) {
                this._attribInfo = attribDesc
            }
        }

        Shader._count = 0, Shader._preCompileShader = {}, Shader.SHADERNAME2ID = 2e-4, Shader.nameKey = new StringKey, Shader.sharders = new Array(32);

        class Shader2X extends Shader {
            constructor(vs, ps, saveName = null, nameMap = null, bindAttrib = null) {
                super(vs, ps, saveName, nameMap, bindAttrib), this._params2dQuick2 = null, this._shaderValueWidth = 0, this._shaderValueHeight = 0
            }

            _disposeResource() {
                super._disposeResource(), this._params2dQuick2 = null
            }

            upload2dQuick2(shaderValue) {
                this.upload(shaderValue, this._params2dQuick2 || this._make2dQuick2())
            }

            _make2dQuick2() {
                if (!this._params2dQuick2) {
                    this._params2dQuick2 = [];
                    for (var one, params = this._params, i = 0, n = params.length; i < n; i++) "size" !== (one = params[i]).name && this._params2dQuick2.push(one)
                }
                return this._params2dQuick2
            }

            static create(vs, ps, saveName = null, nameMap = null, bindAttrib = null) {
                return new Shader2X(vs, ps, saveName, nameMap, bindAttrib)
            }
        }

        class Value2D {
            constructor(mainID, subID) {
                this.defines = new ShaderDefines2D, this.size = [0, 0], this.alpha = 1, this.ALPHA = 1, this.subID = 0, this.ref = 1, this._cacheID = 0, this.clipMatDir = [ILaya.Context._MAXSIZE, 0, 0, ILaya.Context._MAXSIZE], this.clipMatPos = [0, 0], this.clipOff = [0, 0], this.mainID = mainID, this.subID = subID, this.textureHost = null, this.texture = null, this.color = null, this.colorAdd = null, this.u_mmat2 = null, this._cacheID = mainID | subID, this._inClassCache = Value2D._cache[this._cacheID], mainID > 0 && !this._inClassCache && (this._inClassCache = Value2D._cache[this._cacheID] = [], this._inClassCache._length = 0), this.clear()
            }

            static _initone(type, classT) {
                Value2D._typeClass[type] = classT, Value2D._cache[type] = [], Value2D._cache[type]._length = 0
            }

            static __init__() {
            }

            setValue(value) {
            }

            _ShaderWithCompile() {
                return Shader.withCompile2D(0, this.mainID, this.defines.toNameDic(), this.mainID | this.defines._value, Shader2X.create, this._attribLocation)
            }

            upload() {
                var renderstate2d = RenderState2D;
                RenderState2D.worldMatrix4 === RenderState2D.TEMPMAT4_ARRAY || this.defines.addInt(ShaderDefines2D.WORLDMAT), this.mmat = renderstate2d.worldMatrix4, RenderState2D.matWVP && (this.defines.addInt(ShaderDefines2D.MVP3D), this.u_MvpMatrix = RenderState2D.matWVP.elements);
                var sd = Shader.sharders[this.mainID | this.defines._value] || this._ShaderWithCompile();
                sd._shaderValueWidth !== renderstate2d.width || sd._shaderValueHeight !== renderstate2d.height ? (this.size[0] = renderstate2d.width, this.size[1] = renderstate2d.height, sd._shaderValueWidth = renderstate2d.width, sd._shaderValueHeight = renderstate2d.height, sd.upload(this, null)) : sd.upload(this, sd._params2dQuick2 || sd._make2dQuick2())
            }

            setFilters(value) {
                if (this.filters = value, value) for (var f, n = value.length, i = 0; i < n; i++) (f = value[i]) && (this.defines.add(f.type), f.action.setValue(this))
            }

            clear() {
                this.defines._value = this.subID + (ILaya.WebGL.shaderHighPrecision ? ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION : 0), this.clipOff[0] = 0
            }

            release() {
                --this.ref < 1 && (this._inClassCache && (this._inClassCache[this._inClassCache._length++] = this), this.clear(), this.filters = null, this.ref = 1, this.clipOff[0] = 0)
            }

            static create(mainType, subType) {
                var types = Value2D._cache[mainType | subType];
                return types._length ? types[--types._length] : new Value2D._typeClass[mainType | subType](subType)
            }
        }

        Value2D._cache = [], Value2D._typeClass = [], Value2D.TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

        class SubmitKey {
            constructor() {
                this.clear()
            }

            clear() {
                this.submitType = -1, this.blendShader = this.other = 0
            }

            copyFrom(src) {
                this.other = src.other, this.blendShader = src.blendShader, this.submitType = src.submitType
            }

            copyFrom2(src, submitType, other) {
                this.other = other, this.submitType = submitType
            }

            equal3_2(next, submitType, other) {
                return this.submitType === submitType && this.other === other && this.blendShader === next.blendShader
            }

            equal4_2(next, submitType, other) {
                return this.submitType === submitType && this.other === other && this.blendShader === next.blendShader
            }

            equal_3(next) {
                return this.submitType === next.submitType && this.blendShader === next.blendShader
            }

            equal(next) {
                return this.other === next.other && this.submitType === next.submitType && this.blendShader === next.blendShader
            }
        }

        class SubmitCMD {
            constructor() {
                this._ref = 1, this._key = new SubmitKey
            }

            renderSubmit() {
                return this.fun.apply(this._this, this.args), 1
            }

            getRenderType() {
                return 0
            }

            releaseRender() {
                if (--this._ref < 1) {
                    var pool = SubmitCMD.POOL;
                    pool[pool._length++] = this
                }
            }

            static create(args, fun, thisobj) {
                var o = SubmitCMD.POOL._length ? SubmitCMD.POOL[--SubmitCMD.POOL._length] : new SubmitCMD;
                return o.fun = fun, o.args = args, o._this = thisobj, o._ref = 1, o._key.clear(), o
            }
        }

        SubmitCMD.POOL = [], SubmitCMD.POOL._length = 0;

        class Filter {
            constructor() {
            }

            get type() {
                return -1
            }
        }

        Filter.BLUR = 16, Filter.COLOR = 32, Filter.GLOW = 8, Filter._filter = function (sprite, context, x, y) {
            var webglctx = context, next = this._next;
            if (next) {
                var filters = sprite.filters, len = filters.length;
                if (1 == len && filters[0].type == Filter.COLOR) return context.save(), context.setColorFilter(filters[0]), next._fun.call(next, sprite, context, x, y), void context.restore();
                var b, svCP = Value2D.create(ShaderDefines2D.TEXTURE2D, 0), p = Point.TEMP, tMatrix = webglctx._curMat,
                    mat = Matrix.create();
                tMatrix.copyTo(mat);
                var tPadding = 0, tHalfPadding = 0, source = null, out = sprite._cacheStyle.filterCache || null;
                if (out && 0 == sprite.getRepaint()) {
                    if ((sprite._cacheStyle.hasGlowFilter || !1) && (tPadding = 50, tHalfPadding = 25), (b = sprite.getBounds()).width <= 0 || b.height <= 0) return;
                    b.width += tPadding, b.height += tPadding, p.x = b.x * mat.a + b.y * mat.c, p.y = b.y * mat.d + b.x * mat.b, b.x = p.x, b.y = p.y, p.x = b.width * mat.a + b.height * mat.c, p.y = b.height * mat.d + b.width * mat.b, b.width = p.x, b.height = p.y
                } else {
                    sprite._isHaveGlowFilter() && (tPadding = 50, tHalfPadding = 25), (b = new Rectangle).copyFrom(sprite.getSelfBounds()), b.x += sprite.x, b.y += sprite.y, b.x -= sprite.pivotX + 4, b.y -= sprite.pivotY + 4;
                    var tSX = b.x, tSY = b.y;
                    if (b.width += tPadding + 8, b.height += tPadding + 8, p.x = b.x * mat.a + b.y * mat.c, p.y = b.y * mat.d + b.x * mat.b, b.x = p.x, b.y = p.y, p.x = b.width * mat.a + b.height * mat.c, p.y = b.height * mat.d + b.width * mat.b, b.width = p.x, b.height = p.y, b.width <= 0 || b.height <= 0) return;
                    out && WebGLRTMgr.releaseRT(out), source = WebGLRTMgr.getRT(b.width, b.height);
                    var outRT = out = WebGLRTMgr.getRT(b.width, b.height);
                    sprite._getCacheStyle().filterCache = out, webglctx.pushRT(), webglctx.useRT(source);
                    var tX = sprite.x - tSX + tHalfPadding, tY = sprite.y - tSY + tHalfPadding;
                    next._fun.call(next, sprite, context, tX, tY), webglctx.useRT(outRT);
                    for (var i = 0; i < len; i++) {
                        0 != i && (webglctx.useRT(source), webglctx.drawTarget(outRT, 0, 0, b.width, b.height, Matrix.TEMP.identity(), svCP, null, BlendMode.TOINT.overlay), webglctx.useRT(outRT));
                        var fil = filters[i];
                        switch (fil.type) {
                            case Filter.BLUR:
                            case Filter.GLOW:
                                fil._glRender && fil._glRender.render(source, context, b.width, b.height, fil);
                                break;
                            case Filter.COLOR:
                                webglctx.setColorFilter(fil), webglctx.drawTarget(source, 0, 0, b.width, b.height, Matrix.EMPTY.identity(), Value2D.create(ShaderDefines2D.TEXTURE2D, 0)), webglctx.setColorFilter(null)
                        }
                    }
                    webglctx.popRT()
                }
                if (x = x - tHalfPadding - sprite.x, y = y - tHalfPadding - sprite.y, p.setTo(x, y), mat.transformPoint(p), x = p.x + b.x, y = p.y + b.y, webglctx._drawRenderTexture(out, x, y, b.width, b.height, Matrix.TEMP.identity(), 1, RenderTexture2D.defuv), source) {
                    var submit = SubmitCMD.create([source], function (s) {
                        s.destroy()
                    }, this);
                    source = null, context.addRenderObject(submit)
                }
                mat.destroy()
            }
        };

        class Utils {
            static toRadian(angle) {
                return angle * Utils._pi2
            }

            static toAngle(radian) {
                return radian * Utils._pi
            }

            static toHexColor(color) {
                if (color < 0 || isNaN(color)) return null;
                for (var str = color.toString(16); str.length < 6;) str = "0" + str;
                return "#" + str
            }

            static getGID() {
                return Utils._gid++
            }

            static concatArray(source, array) {
                if (!array) return source;
                if (!source) return array;
                var i, len = array.length;
                for (i = 0; i < len; i++) source.push(array[i]);
                return source
            }

            static clearArray(array) {
                return array ? (array.length = 0, array) : array
            }

            static copyArray(source, array) {
                if (source || (source = []), !array) return source;
                source.length = array.length;
                var i, len = array.length;
                for (i = 0; i < len; i++) source[i] = array[i];
                return source
            }

            static getGlobalRecByPoints(sprite, x0, y0, x1, y1) {
                var newLTPoint, newRBPoint;
                newLTPoint = Point.create().setTo(x0, y0), newLTPoint = sprite.localToGlobal(newLTPoint), newRBPoint = Point.create().setTo(x1, y1), newRBPoint = sprite.localToGlobal(newRBPoint);
                var rst = Rectangle._getWrapRec([newLTPoint.x, newLTPoint.y, newRBPoint.x, newRBPoint.y]);
                return newLTPoint.recover(), newRBPoint.recover(), rst
            }

            static getGlobalPosAndScale(sprite) {
                return Utils.getGlobalRecByPoints(sprite, 0, 0, 1, 1)
            }

            static bind(fun, scope) {
                return fun.bind(scope)
            }

            static updateOrder(array) {
                if (!array || array.length < 2) return !1;
                for (var j, key, c, i = 1, len = array.length; i < len;) {
                    for (c = array[j = i], key = array[j]._zOrder; --j > -1 && array[j]._zOrder > key;) array[j + 1] = array[j];
                    array[j + 1] = c, i++
                }
                return !0
            }

            static transPointList(points, x, y) {
                var i, len = points.length;
                for (i = 0; i < len; i += 2) points[i] += x, points[i + 1] += y
            }

            static parseInt(str, radix = 0) {
                var result = parseInt(str, radix);
                return isNaN(result) ? 0 : result
            }

            static getFileExtension(path) {
                Utils._extReg.lastIndex = path.lastIndexOf(".");
                var result = Utils._extReg.exec(path);
                return result && result.length > 1 ? result[1].toLowerCase() : null
            }

            static getTransformRelativeToWindow(coordinateSpace, x, y) {
                var stage = Utils.gStage, globalTransform = Utils.getGlobalPosAndScale(coordinateSpace),
                    canvasMatrix = stage._canvasTransform.clone(), canvasLeft = canvasMatrix.tx,
                    canvasTop = canvasMatrix.ty;
                canvasMatrix.rotate(-Math.PI / 180 * stage.canvasDegree), canvasMatrix.scale(stage.clientScaleX, stage.clientScaleY);
                var tx, ty, domScaleX, domScaleY, perpendicular = stage.canvasDegree % 180 != 0;
                return perpendicular ? (tx = y + globalTransform.y, ty = x + globalTransform.x, tx *= canvasMatrix.d, ty *= canvasMatrix.a, 90 == stage.canvasDegree ? (tx = canvasLeft - tx, ty += canvasTop) : (tx += canvasLeft, ty = canvasTop - ty)) : (tx = x + globalTransform.x, ty = y + globalTransform.y, tx *= canvasMatrix.a, ty *= canvasMatrix.d, tx += canvasLeft, ty += canvasTop), ty += stage._safariOffsetY, perpendicular ? (domScaleX = canvasMatrix.d * globalTransform.height, domScaleY = canvasMatrix.a * globalTransform.width) : (domScaleX = canvasMatrix.a * globalTransform.width, domScaleY = canvasMatrix.d * globalTransform.height), {
                    x: tx,
                    y: ty,
                    scaleX: domScaleX,
                    scaleY: domScaleY
                }
            }

            static fitDOMElementInArea(dom, coordinateSpace, x, y, width, height) {
                dom._fitLayaAirInitialized || (dom._fitLayaAirInitialized = !0, dom.style.transformOrigin = dom.style.webKittransformOrigin = "left top", dom.style.position = "absolute");
                var transform = Utils.getTransformRelativeToWindow(coordinateSpace, x, y);
                dom.style.transform = dom.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + Utils.gStage.canvasDegree + "deg)", dom.style.width = width + "px", dom.style.height = height + "px", dom.style.left = transform.x + "px", dom.style.top = transform.y + "px"
            }

            static isOkTextureList(textureList) {
                if (!textureList) return !1;
                var i, tTexture, len = textureList.length;
                for (i = 0; i < len; i++) if (!(tTexture = textureList[i]) || !tTexture._getSource()) return !1;
                return !0
            }

            static isOKCmdList(cmds) {
                if (!cmds) return !1;
                var i, len = cmds.length;
                for (i = 0; i < len; i++) cmds[i];
                return !0
            }

            static getQueryString(name) {
                if (ILaya.Browser.onMiniGame) return null;
                if (!window.location || !window.location.search) return null;
                var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)"), r = window.location.search.substr(1).match(reg);
                return null != r ? unescape(r[2]) : null
            }
        }

        Utils.gStage = null, Utils._gid = 1, Utils._pi = 180 / Math.PI, Utils._pi2 = Math.PI / 180, Utils._extReg = /\.(\w+)\??/g, Utils.parseXMLFromString = function (value) {
            var rst;
            if (value = value.replace(/>\s+</g, "><"), (rst = (new DOMParser).parseFromString(value, "text/xml")).firstChild.textContent.indexOf("This page contains the following errors") > -1) throw new Error(rst.firstChild.firstChild.textContent);
            return rst
        };

        class ColorUtils {
            constructor(value) {
                if (this.arrColor = [], null == value) return this.strColor = "#00000000", this.numColor = 0, void (this.arrColor = [0, 0, 0, 0]);
                var i, len, color;
                if ("string" == typeof value) if (value.indexOf("rgba(") >= 0 || value.indexOf("rgb(") >= 0) {
                    var beginI, endI, tStr = value;
                    for (beginI = tStr.indexOf("("), endI = tStr.indexOf(")"), tStr = tStr.substring(beginI + 1, endI), this.arrColor = tStr.split(","), len = this.arrColor.length, i = 0; i < len; i++) this.arrColor[i] = parseFloat(this.arrColor[i]), i < 3 && (this.arrColor[i] = Math.round(this.arrColor[i]));
                    color = 4 == this.arrColor.length ? 256 * (256 * (256 * this.arrColor[0] + this.arrColor[1]) + this.arrColor[2]) + Math.round(255 * this.arrColor[3]) : 256 * (256 * this.arrColor[0] + this.arrColor[1]) + this.arrColor[2], this.strColor = value
                } else {
                    if (this.strColor = value, "#" === value.charAt(0) && (value = value.substr(1)), 3 === (len = value.length) || 4 === len) {
                        var temp = "";
                        for (i = 0; i < len; i++) temp += value[i] + value[i];
                        value = temp
                    }
                    color = parseInt(value, 16)
                } else color = value, this.strColor = Utils.toHexColor(color);
                this.strColor.indexOf("rgba") >= 0 || 9 === this.strColor.length ? (this.arrColor = [((4278190080 & color) >>> 24) / 255, ((16711680 & color) >> 16) / 255, ((65280 & color) >> 8) / 255, (255 & color) / 255], this.numColor = (4278190080 & color) >>> 24 | (16711680 & color) >> 8 | (65280 & color) << 8 | (255 & color) << 24) : (this.arrColor = [((16711680 & color) >> 16) / 255, ((65280 & color) >> 8) / 255, (255 & color) / 255, 1], this.numColor = 4278190080 | (16711680 & color) >> 16 | 65280 & color | (255 & color) << 16), this.arrColor.__id = ++ColorUtils._COLODID
            }

            static _initDefault() {
                for (var i in ColorUtils._DEFAULT = {}, ColorUtils._COLOR_MAP) ColorUtils._SAVE[i] = ColorUtils._DEFAULT[i] = new ColorUtils(ColorUtils._COLOR_MAP[i]);
                return ColorUtils._DEFAULT
            }

            static _initSaveMap() {
                for (var i in ColorUtils._SAVE_SIZE = 0, ColorUtils._SAVE = {}, ColorUtils._DEFAULT) ColorUtils._SAVE[i] = ColorUtils._DEFAULT[i]
            }

            static create(value) {
                var key = value + "", color = ColorUtils._SAVE[key];
                return null != color ? color : (ColorUtils._SAVE_SIZE < 1e3 && ColorUtils._initSaveMap(), ColorUtils._SAVE[key] = new ColorUtils(value))
            }
        }

        ColorUtils._SAVE = {}, ColorUtils._SAVE_SIZE = 0, ColorUtils._COLOR_MAP = {
            purple: "#800080",
            orange: "#ffa500",
            white: "#FFFFFF",
            red: "#FF0000",
            green: "#00FF00",
            blue: "#0000FF",
            black: "#000000",
            yellow: "#FFFF00",
            gray: "#808080"
        }, ColorUtils._DEFAULT = ColorUtils._initDefault(), ColorUtils._COLODID = 1;

        class ColorFilter extends Filter {
            constructor(mat = null) {
                super(), mat || (mat = this._copyMatrix(ColorFilter.IDENTITY_MATRIX)), this._mat = new Float32Array(16), this._alpha = new Float32Array(4), this.setByMatrix(mat)
            }

            gray() {
                return this.setByMatrix(ColorFilter.GRAY_MATRIX)
            }

            color(red = 0, green = 0, blue = 0, alpha = 1) {
                return this.setByMatrix([1, 0, 0, 0, red, 0, 1, 0, 0, green, 0, 0, 1, 0, blue, 0, 0, 0, 1, alpha])
            }

            setColor(color) {
                var arr = ColorUtils.create(color).arrColor,
                    mt = [0, 0, 0, 0, 256 * arr[0], 0, 0, 0, 0, 256 * arr[1], 0, 0, 0, 0, 256 * arr[2], 0, 0, 0, 1, 0];
                return this.setByMatrix(mt)
            }

            setByMatrix(matrix) {
                this._matrix != matrix && this._copyMatrix(matrix);
                for (var j = 0, z = 0, i = 0; i < 20; i++) i % 5 != 4 ? this._mat[j++] = matrix[i] : this._alpha[z++] = matrix[i];
                return this
            }

            get type() {
                return Filter.COLOR
            }

            adjustColor(brightness, contrast, saturation, hue) {
                return this.adjustHue(hue), this.adjustContrast(contrast), this.adjustBrightness(brightness), this.adjustSaturation(saturation), this
            }

            adjustBrightness(brightness) {
                return 0 == (brightness = this._clampValue(brightness, 100)) || isNaN(brightness) ? this : this._multiplyMatrix([1, 0, 0, 0, brightness, 0, 1, 0, 0, brightness, 0, 0, 1, 0, brightness, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1])
            }

            adjustContrast(contrast) {
                if (0 == (contrast = this._clampValue(contrast, 100)) || isNaN(contrast)) return this;
                var x,
                    x1 = (x = contrast < 0 ? 127 + contrast / 100 * 127 : 127 * (x = 0 == (x = contrast % 1) ? ColorFilter.DELTA_INDEX[contrast] : ColorFilter.DELTA_INDEX[contrast << 0] * (1 - x) + ColorFilter.DELTA_INDEX[1 + (contrast << 0)] * x) + 127) / 127,
                    x2 = .5 * (127 - x);
                return this._multiplyMatrix([x1, 0, 0, 0, x2, 0, x1, 0, 0, x2, 0, 0, x1, 0, x2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1])
            }

            adjustSaturation(saturation) {
                if (0 == (saturation = this._clampValue(saturation, 100)) || isNaN(saturation)) return this;
                var x = 1 + (saturation > 0 ? 3 * saturation / 100 : saturation / 100), dx = 1 - x, r = .3086 * dx,
                    g = .6094 * dx, b = .082 * dx;
                return this._multiplyMatrix([r + x, g, b, 0, 0, r, g + x, b, 0, 0, r, g, b + x, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1])
            }

            adjustHue(hue) {
                if (0 == (hue = this._clampValue(hue, 180) / 180 * Math.PI) || isNaN(hue)) return this;
                var cos = Math.cos(hue), sin = Math.sin(hue), r = .213, g = .715, b = .072;
                return this._multiplyMatrix([r + cos * (1 - r) + sin * -r, g + cos * -g + sin * -g, b + cos * -b + sin * (1 - b), 0, 0, r + cos * -r + .143 * sin, g + cos * (1 - g) + .14 * sin, b + cos * -b + -.283 * sin, 0, 0, r + cos * -r + -.787 * sin, g + cos * -g + sin * g, b + cos * (1 - b) + sin * b, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1])
            }

            reset() {
                return this.setByMatrix(this._copyMatrix(ColorFilter.IDENTITY_MATRIX))
            }

            _multiplyMatrix(matrix) {
                var col = [];
                this._matrix = this._fixMatrix(this._matrix);
                for (var i = 0; i < 5; i++) {
                    for (var j = 0; j < 5; j++) col[j] = this._matrix[j + 5 * i];
                    for (j = 0; j < 5; j++) {
                        for (var val = 0, k = 0; k < 5; k++) val += matrix[j + 5 * k] * col[k];
                        this._matrix[j + 5 * i] = val
                    }
                }
                return this.setByMatrix(this._matrix)
            }

            _clampValue(val, limit) {
                return Math.min(limit, Math.max(-limit, val))
            }

            _fixMatrix(matrix = null) {
                return null == matrix ? ColorFilter.IDENTITY_MATRIX : (matrix.length < ColorFilter.LENGTH ? matrix = matrix.slice(0, matrix.length).concat(ColorFilter.IDENTITY_MATRIX.slice(matrix.length, ColorFilter.LENGTH)) : matrix.length > ColorFilter.LENGTH && (matrix = matrix.slice(0, ColorFilter.LENGTH)), matrix)
            }

            _copyMatrix(matrix) {
                var len = ColorFilter.LENGTH;
                this._matrix || (this._matrix = []);
                for (var i = 0; i < len; i++) this._matrix[i] = matrix[i];
                return this._matrix
            }
        }

        ColorFilter.DELTA_INDEX = [0, .01, .02, .04, .05, .06, .07, .08, .1, .11, .12, .14, .15, .16, .17, .18, .2, .21, .22, .24, .25, .27, .28, .3, .32, .34, .36, .38, .4, .42, .44, .46, .48, .5, .53, .56, .59, .62, .65, .68, .71, .74, .77, .8, .83, .86, .89, .92, .95, .98, 1, 1.06, 1.12, 1.18, 1.24, 1.3, 1.36, 1.42, 1.48, 1.54, 1.6, 1.66, 1.72, 1.78, 1.84, 1.9, 1.96, 2, 2.12, 2.25, 2.37, 2.5, 2.62, 2.75, 2.87, 3, 3.2, 3.4, 3.6, 3.8, 4, 4.3, 4.7, 4.9, 5, 5.5, 6, 6.5, 6.8, 7, 7.3, 7.5, 7.8, 8, 8.4, 8.7, 9, 9.4, 9.6, 9.8, 10], ColorFilter.GRAY_MATRIX = [.3086, .6094, .082, 0, 0, .3086, .6094, .082, 0, 0, .3086, .6094, .082, 0, 0, 0, 0, 0, 1, 0], ColorFilter.IDENTITY_MATRIX = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], ColorFilter.LENGTH = 25;

        class DrawTextureCmd {
            constructor() {
                this.colorFlt = null, this.uv = null
            }

            static create(texture, x, y, width, height, matrix, alpha, color, blendMode, uv) {
                var cmd = Pool.getItemByClass("DrawTextureCmd", DrawTextureCmd);
                return cmd.texture = texture, texture._addReference(), cmd.x = x, cmd.y = y, cmd.width = width, cmd.height = height, cmd.matrix = matrix, cmd.alpha = alpha, cmd.color = color, cmd.blendMode = blendMode, cmd.uv = uv, color && (cmd.colorFlt = new ColorFilter, cmd.colorFlt.setColor(color)), cmd
            }

            recover() {
                this.texture._removeReference(), this.texture = null, this.matrix = null, Pool.recover("DrawTextureCmd", this)
            }

            run(context, gx, gy) {
                context.drawTextureWithTransform(this.texture, this.x, this.y, this.width, this.height, this.matrix, gx, gy, this.alpha, this.blendMode, this.colorFlt, this.uv)
            }

            get cmdID() {
                return DrawTextureCmd.ID
            }
        }

        DrawTextureCmd.ID = "DrawTexture";

        class FillTextureCmd {
            static create(texture, x, y, width, height, type, offset, other) {
                var cmd = Pool.getItemByClass("FillTextureCmd", FillTextureCmd);
                return cmd.texture = texture, cmd.x = x, cmd.y = y, cmd.width = width, cmd.height = height, cmd.type = type, cmd.offset = offset, cmd.other = other, cmd
            }

            recover() {
                this.texture = null, this.offset = null, this.other = null, Pool.recover("FillTextureCmd", this)
            }

            run(context, gx, gy) {
                context.fillTexture(this.texture, this.x + gx, this.y + gy, this.width, this.height, this.type, this.offset, this.other)
            }

            get cmdID() {
                return FillTextureCmd.ID
            }
        }

        FillTextureCmd.ID = "FillTexture";

        class RestoreCmd {
            static create() {
                return Pool.getItemByClass("RestoreCmd", RestoreCmd)
            }

            recover() {
                Pool.recover("RestoreCmd", this)
            }

            run(context, gx, gy) {
                context.restore()
            }

            get cmdID() {
                return RestoreCmd.ID
            }
        }

        RestoreCmd.ID = "Restore";

        class RotateCmd {
            static create(angle, pivotX, pivotY) {
                var cmd = Pool.getItemByClass("RotateCmd", RotateCmd);
                return cmd.angle = angle, cmd.pivotX = pivotX, cmd.pivotY = pivotY, cmd
            }

            recover() {
                Pool.recover("RotateCmd", this)
            }

            run(context, gx, gy) {
                context._rotate(this.angle, this.pivotX + gx, this.pivotY + gy)
            }

            get cmdID() {
                return RotateCmd.ID
            }
        }

        RotateCmd.ID = "Rotate";

        class ScaleCmd {
            static create(scaleX, scaleY, pivotX, pivotY) {
                var cmd = Pool.getItemByClass("ScaleCmd", ScaleCmd);
                return cmd.scaleX = scaleX, cmd.scaleY = scaleY, cmd.pivotX = pivotX, cmd.pivotY = pivotY, cmd
            }

            recover() {
                Pool.recover("ScaleCmd", this)
            }

            run(context, gx, gy) {
                context._scale(this.scaleX, this.scaleY, this.pivotX + gx, this.pivotY + gy)
            }

            get cmdID() {
                return ScaleCmd.ID
            }
        }

        ScaleCmd.ID = "Scale";

        class TransformCmd {
            static create(matrix, pivotX, pivotY) {
                var cmd = Pool.getItemByClass("TransformCmd", TransformCmd);
                return cmd.matrix = matrix, cmd.pivotX = pivotX, cmd.pivotY = pivotY, cmd
            }

            recover() {
                this.matrix = null, Pool.recover("TransformCmd", this)
            }

            run(context, gx, gy) {
                context._transform(this.matrix, this.pivotX + gx, this.pivotY + gy)
            }

            get cmdID() {
                return TransformCmd.ID
            }
        }

        TransformCmd.ID = "Transform";

        class TranslateCmd {
            static create(tx, ty) {
                var cmd = Pool.getItemByClass("TranslateCmd", TranslateCmd);
                return cmd.tx = tx, cmd.ty = ty, cmd
            }

            recover() {
                Pool.recover("TranslateCmd", this)
            }

            run(context, gx, gy) {
                context.translate(this.tx, this.ty)
            }

            get cmdID() {
                return TranslateCmd.ID
            }
        }

        TranslateCmd.ID = "Translate";

        class Bezier {
            constructor() {
                this._controlPoints = [new Point, new Point, new Point], this._calFun = this.getPoint2
            }

            _switchPoint(x, y) {
                var tPoint = this._controlPoints.shift();
                tPoint.setTo(x, y), this._controlPoints.push(tPoint)
            }

            getPoint2(t, rst) {
                var p1 = this._controlPoints[0], p2 = this._controlPoints[1], p3 = this._controlPoints[2],
                    lineX = Math.pow(1 - t, 2) * p1.x + 2 * t * (1 - t) * p2.x + Math.pow(t, 2) * p3.x,
                    lineY = Math.pow(1 - t, 2) * p1.y + 2 * t * (1 - t) * p2.y + Math.pow(t, 2) * p3.y;
                rst.push(lineX, lineY)
            }

            getPoint3(t, rst) {
                var p1 = this._controlPoints[0], p2 = this._controlPoints[1], p3 = this._controlPoints[2],
                    p4 = this._controlPoints[3],
                    lineX = Math.pow(1 - t, 3) * p1.x + 3 * p2.x * t * (1 - t) * (1 - t) + 3 * p3.x * t * t * (1 - t) + p4.x * Math.pow(t, 3),
                    lineY = Math.pow(1 - t, 3) * p1.y + 3 * p2.y * t * (1 - t) * (1 - t) + 3 * p3.y * t * t * (1 - t) + p4.y * Math.pow(t, 3);
                rst.push(lineX, lineY)
            }

            insertPoints(count, rst) {
                var i, dLen;
                for (dLen = 1 / (count = count > 0 ? count : 5), i = 0; i <= 1; i += dLen) this._calFun(i, rst)
            }

            getBezierPoints(pList, inSertCount = 5, count = 2) {
                var i, len;
                if ((len = pList.length) < 2 * (count + 1)) return [];
                var rst = [];
                switch (count) {
                    case 2:
                        this._calFun = this.getPoint2;
                        break;
                    case 3:
                        this._calFun = this.getPoint3;
                        break;
                    default:
                        return []
                }
                for (; this._controlPoints.length <= count;) this._controlPoints.push(Point.create());
                for (i = 0; i < 2 * count; i += 2) this._switchPoint(pList[i], pList[i + 1]);
                for (i = 2 * count; i < len; i += 2) this._switchPoint(pList[i], pList[i + 1]), i / 2 % count == 0 && this.insertPoints(inSertCount, rst);
                return rst
            }
        }

        Bezier.I = new Bezier;

        class GrahamScan {
            static multiply(p1, p2, p0) {
                return (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y)
            }

            static dis(p1, p2) {
                return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y)
            }

            static _getPoints(count, tempUse = !1, rst = null) {
                for (GrahamScan._mPointList || (GrahamScan._mPointList = []); GrahamScan._mPointList.length < count;) GrahamScan._mPointList.push(new Point);
                return rst || (rst = []), rst.length = 0, tempUse ? GrahamScan.getFrom(rst, GrahamScan._mPointList, count) : GrahamScan.getFromR(rst, GrahamScan._mPointList, count), rst
            }

            static getFrom(rst, src, count) {
                var i;
                for (i = 0; i < count; i++) rst.push(src[i]);
                return rst
            }

            static getFromR(rst, src, count) {
                var i;
                for (i = 0; i < count; i++) rst.push(src.pop());
                return rst
            }

            static pListToPointList(pList, tempUse = !1) {
                var i, len = pList.length / 2, rst = GrahamScan._getPoints(len, tempUse, GrahamScan._tempPointList);
                for (i = 0; i < len; i++) rst[i].setTo(pList[i + i], pList[i + i + 1]);
                return rst
            }

            static pointListToPlist(pointList) {
                var i, tPoint, len = pointList.length, rst = GrahamScan._temPList;
                for (rst.length = 0, i = 0; i < len; i++) tPoint = pointList[i], rst.push(tPoint.x, tPoint.y);
                return rst
            }

            static scanPList(pList) {
                return Utils.copyArray(pList, GrahamScan.pointListToPlist(GrahamScan.scan(GrahamScan.pListToPointList(pList, !0))))
            }

            static scan(PointSet) {
                var i, j, tmp, ch, key, k = 0, n = PointSet.length, _tmpDic = {};
                for ((ch = GrahamScan._temArr).length = 0, i = (n = PointSet.length) - 1; i >= 0; i--) (key = (tmp = PointSet[i]).x + "_" + tmp.y) in _tmpDic || (_tmpDic[key] = !0, ch.push(tmp));
                for (n = ch.length, Utils.copyArray(PointSet, ch), i = 1; i < n; i++) (PointSet[i].y < PointSet[k].y || PointSet[i].y == PointSet[k].y && PointSet[i].x < PointSet[k].x) && (k = i);
                for (tmp = PointSet[0], PointSet[0] = PointSet[k], PointSet[k] = tmp, i = 1; i < n - 1; i++) {
                    for (k = i, j = i + 1; j < n; j++) (GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) > 0 || 0 == GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) && GrahamScan.dis(PointSet[0], PointSet[j]) < GrahamScan.dis(PointSet[0], PointSet[k])) && (k = j);
                    tmp = PointSet[i], PointSet[i] = PointSet[k], PointSet[k] = tmp
                }
                if ((ch = GrahamScan._temArr).length = 0, PointSet.length < 3) return Utils.copyArray(ch, PointSet);
                for (ch.push(PointSet[0], PointSet[1], PointSet[2]), i = 3; i < n; i++) {
                    for (; ch.length >= 2 && GrahamScan.multiply(PointSet[i], ch[ch.length - 1], ch[ch.length - 2]) >= 0;) ch.pop();
                    PointSet[i] && ch.push(PointSet[i])
                }
                return ch
            }
        }

        GrahamScan._tempPointList = [], GrahamScan._temPList = [], GrahamScan._temArr = [];

        class DrawStyle {
            constructor(value) {
                this.setValue(value)
            }

            static create(value) {
                if (value) {
                    var color = value instanceof ColorUtils ? value : ColorUtils.create(value);
                    return color._drawStyle || (color._drawStyle = new DrawStyle(value))
                }
                return DrawStyle.DEFAULT
            }

            setValue(value) {
                this._color = value ? value instanceof ColorUtils ? value : ColorUtils.create(value) : ColorUtils.create("#000000")
            }

            reset() {
                this._color = ColorUtils.create("#000000")
            }

            toInt() {
                return this._color.numColor
            }

            equal(value) {
                return "string" == typeof value ? this._color.strColor === value : value instanceof ColorUtils && this._color.numColor === value.numColor
            }

            toColorStr() {
                return this._color.strColor
            }
        }

        DrawStyle.DEFAULT = new DrawStyle("#000000");

        class Path {
            constructor() {
                this._lastOriX = 0, this._lastOriY = 0, this.paths = [], this._curPath = null
            }

            beginPath(convex) {
                this.paths.length = 1, this._curPath = this.paths[0] = new renderPath, this._curPath.convex = convex
            }

            closePath() {
                this._curPath.loop = !0
            }

            newPath() {
                this._curPath = new renderPath, this.paths.push(this._curPath)
            }

            addPoint(pointX, pointY) {
                this._curPath.path.push(pointX, pointY)
            }

            push(points, convex) {
                this._curPath ? this._curPath.path.length > 0 && (this._curPath = new renderPath, this.paths.push(this._curPath)) : (this._curPath = new renderPath, this.paths.push(this._curPath));
                var rp = this._curPath;
                rp.path = points.slice(), rp.convex = convex
            }

            reset() {
                this.paths.length = 0
            }
        }

        class renderPath {
            constructor() {
                this.path = [], this.loop = !1, this.convex = !1
            }
        }

        class SubmitBase {
            constructor(renderType = SubmitBase.TYPE_2D) {
                this.clipInfoID = -1, this._mesh = null, this._blendFn = null, this._id = 0, this._renderType = 0, this._parent = null, this._key = new SubmitKey, this._startIdx = 0, this._numEle = 0, this._ref = 1, this.shaderValue = null, this._renderType = renderType, this._id = ++SubmitBase.ID
            }

            static __init__() {
                var s = SubmitBase.RENDERBASE = new SubmitBase(-1);
                s.shaderValue = new Value2D(0, 0), s.shaderValue.ALPHA = 1, s._ref = 4294967295
            }

            getID() {
                return this._id
            }

            getRenderType() {
                return this._renderType
            }

            toString() {
                return "ibindex:" + this._startIdx + " num:" + this._numEle + " key=" + this._key
            }

            renderSubmit() {
                return 1
            }

            releaseRender() {
            }
        }

        SubmitBase.TYPE_2D = 1e4, SubmitBase.TYPE_CANVAS = 10003, SubmitBase.TYPE_CMDSETRT = 10004, SubmitBase.TYPE_CUSTOM = 10005, SubmitBase.TYPE_BLURRT = 10006, SubmitBase.TYPE_CMDDESTORYPRERT = 10007, SubmitBase.TYPE_DISABLESTENCIL = 10008, SubmitBase.TYPE_OTHERIBVB = 10009, SubmitBase.TYPE_PRIMITIVE = 10010, SubmitBase.TYPE_RT = 10011, SubmitBase.TYPE_BLUR_RT = 10012, SubmitBase.TYPE_TARGET = 10013, SubmitBase.TYPE_CHANGE_VALUE = 10014, SubmitBase.TYPE_SHAPE = 10015, SubmitBase.TYPE_TEXTURE = 10016, SubmitBase.TYPE_FILLTEXTURE = 10017, SubmitBase.KEY_ONCE = -1, SubmitBase.KEY_FILLRECT = 1, SubmitBase.KEY_DRAWTEXTURE = 2, SubmitBase.KEY_VG = 3, SubmitBase.KEY_TRIANGLES = 4, SubmitBase.ID = 1, SubmitBase.preRender = null;

        class SaveBase {
            constructor() {
            }

            static _createArray() {
                var value = [];
                return value._length = 0, value
            }

            static _init() {
                var namemap = SaveBase._namemap = {};
                return namemap[SaveBase.TYPE_ALPHA] = "ALPHA", namemap[SaveBase.TYPE_FILESTYLE] = "fillStyle", namemap[SaveBase.TYPE_FONT] = "font", namemap[SaveBase.TYPE_LINEWIDTH] = "lineWidth", namemap[SaveBase.TYPE_STROKESTYLE] = "strokeStyle", namemap[SaveBase.TYPE_ENABLEMERGE] = "_mergeID", namemap[SaveBase.TYPE_MARK] = namemap[SaveBase.TYPE_TRANSFORM] = namemap[SaveBase.TYPE_TRANSLATE] = [], namemap[SaveBase.TYPE_TEXTBASELINE] = "textBaseline", namemap[SaveBase.TYPE_TEXTALIGN] = "textAlign", namemap[SaveBase.TYPE_GLOBALCOMPOSITEOPERATION] = "_nBlendType", namemap[SaveBase.TYPE_SHADER] = "shader", namemap[SaveBase.TYPE_FILTERS] = "filters", namemap[SaveBase.TYPE_COLORFILTER] = "_colorFiler", namemap
            }

            isSaveMark() {
                return !1
            }

            restore(context) {
                this._dataObj[this._valueName] = this._value, SaveBase.POOL[SaveBase.POOL._length++] = this, this._newSubmit && (context._curSubmit = SubmitBase.RENDERBASE)
            }

            static save(context, type, dataObj, newSubmit) {
                if ((context._saveMark._saveuse & type) !== type) {
                    context._saveMark._saveuse |= type;
                    var cache = SaveBase.POOL, o = cache._length > 0 ? cache[--cache._length] : new SaveBase;
                    o._value = dataObj[o._valueName = SaveBase._namemap[type]], o._dataObj = dataObj, o._newSubmit = newSubmit;
                    var _save = context._save;
                    _save[_save._length++] = o
                }
            }
        }

        SaveBase.TYPE_ALPHA = 1, SaveBase.TYPE_FILESTYLE = 2, SaveBase.TYPE_FONT = 8, SaveBase.TYPE_LINEWIDTH = 256, SaveBase.TYPE_STROKESTYLE = 512, SaveBase.TYPE_MARK = 1024, SaveBase.TYPE_TRANSFORM = 2048, SaveBase.TYPE_TRANSLATE = 4096, SaveBase.TYPE_ENABLEMERGE = 8192, SaveBase.TYPE_TEXTBASELINE = 16384, SaveBase.TYPE_TEXTALIGN = 32768, SaveBase.TYPE_GLOBALCOMPOSITEOPERATION = 65536, SaveBase.TYPE_CLIPRECT = 131072, SaveBase.TYPE_CLIPRECT_STENCIL = 262144, SaveBase.TYPE_IBVB = 524288, SaveBase.TYPE_SHADER = 1048576, SaveBase.TYPE_FILTERS = 2097152, SaveBase.TYPE_FILTERS_TYPE = 4194304, SaveBase.TYPE_COLORFILTER = 8388608, SaveBase.POOL = SaveBase._createArray(), SaveBase._namemap = SaveBase._init();

        class SaveClipRect {
            constructor() {
                this._globalClipMatrix = new Matrix, this._clipInfoID = -1, this._clipRect = new Rectangle, this.incache = !1
            }

            isSaveMark() {
                return !1
            }

            restore(context) {
                this._globalClipMatrix.copyTo(context._globalClipMatrix), this._clipRect.clone(context._clipRect), context._clipInfoID = this._clipInfoID, SaveClipRect.POOL[SaveClipRect.POOL._length++] = this, context._clipInCache = this.incache
            }

            static save(context) {
                if ((context._saveMark._saveuse & SaveBase.TYPE_CLIPRECT) != SaveBase.TYPE_CLIPRECT) {
                    context._saveMark._saveuse |= SaveBase.TYPE_CLIPRECT;
                    var cache = SaveClipRect.POOL, o = cache._length > 0 ? cache[--cache._length] : new SaveClipRect;
                    context._globalClipMatrix.copyTo(o._globalClipMatrix), context._clipRect.clone(o._clipRect), o._clipInfoID = context._clipInfoID, o.incache = context._clipInCache;
                    var _save = context._save;
                    _save[_save._length++] = o
                }
            }
        }

        SaveClipRect.POOL = SaveBase._createArray();

        class SaveMark {
            constructor() {
                this._saveuse = 0
            }

            isSaveMark() {
                return !0
            }

            restore(context) {
                context._saveMark = this._preSaveMark, SaveMark.POOL[SaveMark.POOL._length++] = this
            }

            static Create(context) {
                var no = SaveMark.POOL, o = no._length > 0 ? no[--no._length] : new SaveMark;
                return o._saveuse = 0, o._preSaveMark = context._saveMark, context._saveMark = o, o
            }
        }

        SaveMark.POOL = SaveBase._createArray();

        class SaveTransform {
            constructor() {
                this._matrix = new Matrix
            }

            isSaveMark() {
                return !1
            }

            restore(context) {
                context._curMat = this._savematrix, SaveTransform.POOL[SaveTransform.POOL._length++] = this
            }

            static save(context) {
                var _saveMark = context._saveMark;
                if ((_saveMark._saveuse & SaveBase.TYPE_TRANSFORM) !== SaveBase.TYPE_TRANSFORM) {
                    _saveMark._saveuse |= SaveBase.TYPE_TRANSFORM;
                    var no = SaveTransform.POOL, o = no._length > 0 ? no[--no._length] : new SaveTransform;
                    o._savematrix = context._curMat, context._curMat = context._curMat.copyTo(o._matrix);
                    var _save = context._save;
                    _save[_save._length++] = o
                }
            }
        }

        SaveTransform.POOL = SaveBase._createArray();

        class SaveTranslate {
            constructor() {
                this._mat = new Matrix
            }

            isSaveMark() {
                return !1
            }

            restore(context) {
                this._mat.copyTo(context._curMat), SaveTranslate.POOL[SaveTranslate.POOL._length++] = this
            }

            static save(context) {
                var no = SaveTranslate.POOL, o = no._length > 0 ? no[--no._length] : new SaveTranslate;
                context._curMat.copyTo(o._mat);
                var _save = context._save;
                _save[_save._length++] = o
            }
        }

        SaveTranslate.POOL = SaveBase._createArray();

        class RenderInfo {
        }

        RenderInfo.loopStTm = 0, RenderInfo.loopCount = 0;

        class Buffer {
            constructor() {
                this._byteLength = 0, this._glBuffer = LayaGL.instance.createBuffer()
            }

            get bufferUsage() {
                return this._bufferUsage
            }

            _bindForVAO() {
            }

            bind() {
                return !1
            }

            destroy() {
                this._glBuffer && (LayaGL.instance.deleteBuffer(this._glBuffer), this._glBuffer = null)
            }
        }

        class Buffer2D extends Buffer {
            constructor() {
                super(), this._maxsize = 0, this._upload = !0, this._uploadSize = 0, this._bufferSize = 0, this._u8Array = null
            }

            static __int__(gl) {
            }

            get bufferLength() {
                return this._buffer.byteLength
            }

            set byteLength(value) {
                this.setByteLength(value)
            }

            setByteLength(value) {
                this._byteLength !== value && (value <= this._bufferSize || this._resizeBuffer(2 * value + 256, !0), this._byteLength = value)
            }

            needSize(sz) {
                var old = this._byteLength;
                if (sz) {
                    var needsz = this._byteLength + sz;
                    needsz <= this._bufferSize || this._resizeBuffer(needsz << 1, !0), this._byteLength = needsz
                }
                return old
            }

            _bufferData() {
                this._maxsize = Math.max(this._maxsize, this._byteLength), RenderInfo.loopCount % 30 == 0 && (this._buffer.byteLength > this._maxsize + 64 && (this._buffer = this._buffer.slice(0, this._maxsize + 64), this._bufferSize = this._buffer.byteLength, this._checkArrayUse()), this._maxsize = this._byteLength), this._uploadSize < this._buffer.byteLength && (this._uploadSize = this._buffer.byteLength, LayaGL.instance.bufferData(this._bufferType, this._uploadSize, this._bufferUsage)), LayaGL.instance.bufferSubData(this._bufferType, 0, new Uint8Array(this._buffer, 0, this._byteLength))
            }

            _bufferSubData(offset = 0, dataStart = 0, dataLength = 0) {
                if (this._maxsize = Math.max(this._maxsize, this._byteLength), RenderInfo.loopCount % 30 == 0 && (this._buffer.byteLength > this._maxsize + 64 && (this._buffer = this._buffer.slice(0, this._maxsize + 64), this._bufferSize = this._buffer.byteLength, this._checkArrayUse()), this._maxsize = this._byteLength), this._uploadSize < this._buffer.byteLength && (this._uploadSize = this._buffer.byteLength, LayaGL.instance.bufferData(this._bufferType, this._uploadSize, this._bufferUsage)), dataStart || dataLength) {
                    var subBuffer = this._buffer.slice(dataStart, dataLength);
                    LayaGL.instance.bufferSubData(this._bufferType, offset, subBuffer)
                } else LayaGL.instance.bufferSubData(this._bufferType, offset, this._buffer)
            }

            _checkArrayUse() {
            }

            _bind_uploadForVAO() {
                return !!this._upload && (this._upload = !1, this._bindForVAO(), this._bufferData(), !0)
            }

            _bind_upload() {
                return !!this._upload && (this._upload = !1, this.bind(), this._bufferData(), !0)
            }

            _bind_subUpload(offset = 0, dataStart = 0, dataLength = 0) {
                return !!this._upload && (this._upload = !1, this.bind(), this._bufferSubData(offset, dataStart, dataLength), !0)
            }

            _resizeBuffer(nsz, copy) {
                var buff = this._buffer;
                if (nsz <= buff.byteLength) return this;
                var u8buf = this._u8Array;
                if (copy && buff && buff.byteLength > 0) {
                    var newbuffer = new ArrayBuffer(nsz),
                        oldU8Arr = u8buf && u8buf.buffer == buff ? u8buf : new Uint8Array(buff);
                    (u8buf = this._u8Array = new Uint8Array(newbuffer)).set(oldU8Arr, 0), buff = this._buffer = newbuffer
                } else buff = this._buffer = new ArrayBuffer(nsz), this._u8Array = null;
                return this._checkArrayUse(), this._upload = !0, this._bufferSize = buff.byteLength, this
            }

            append(data) {
                var byteLen, n;
                this._upload = !0, byteLen = data.byteLength, data instanceof Uint8Array ? (this._resizeBuffer(this._byteLength + byteLen, !0), n = new Uint8Array(this._buffer, this._byteLength)) : data instanceof Uint16Array ? (this._resizeBuffer(this._byteLength + byteLen, !0), n = new Uint16Array(this._buffer, this._byteLength)) : data instanceof Float32Array && (this._resizeBuffer(this._byteLength + byteLen, !0), n = new Float32Array(this._buffer, this._byteLength)), n.set(data, 0), this._byteLength += byteLen, this._checkArrayUse()
            }

            appendU16Array(data, len) {
                this._resizeBuffer(this._byteLength + 2 * len, !0);
                var u = new Uint16Array(this._buffer, this._byteLength, len);
                if (6 == len) u[0] = data[0], u[1] = data[1], u[2] = data[2], u[3] = data[3], u[4] = data[4], u[5] = data[5]; else if (len >= 100) u.set(new Uint16Array(data.buffer, 0, len)); else for (var i = 0; i < len; i++) u[i] = data[i];
                this._byteLength += 2 * len, this._checkArrayUse()
            }

            appendEx(data, type) {
                var byteLen;
                this._upload = !0, byteLen = data.byteLength, this._resizeBuffer(this._byteLength + byteLen, !0), new type(this._buffer, this._byteLength).set(data, 0), this._byteLength += byteLen, this._checkArrayUse()
            }

            appendEx2(data, type, dataLen, perDataLen = 1) {
                var byteLen, n, i;
                for (this._upload = !0, byteLen = dataLen * perDataLen, this._resizeBuffer(this._byteLength + byteLen, !0), n = new type(this._buffer, this._byteLength), i = 0; i < dataLen; i++) n[i] = data[i];
                this._byteLength += byteLen, this._checkArrayUse()
            }

            getBuffer() {
                return this._buffer
            }

            setNeedUpload() {
                this._upload = !0
            }

            getNeedUpload() {
                return this._upload
            }

            upload() {
                var gl = LayaGL.instance, scuess = this._bind_upload();
                return gl.bindBuffer(this._bufferType, null), this._bufferType == gl.ARRAY_BUFFER && (Buffer._bindedVertexBuffer = null), this._bufferType == gl.ELEMENT_ARRAY_BUFFER && (Buffer._bindedIndexBuffer = null), BaseShader.activeShader = null, scuess
            }

            subUpload(offset = 0, dataStart = 0, dataLength = 0) {
                var gl = LayaGL.instance, scuess = this._bind_subUpload();
                return gl.bindBuffer(this._bufferType, null), this._bufferType == gl.ARRAY_BUFFER && (Buffer._bindedVertexBuffer = null), this._bufferType == gl.ELEMENT_ARRAY_BUFFER && (Buffer._bindedIndexBuffer = null), BaseShader.activeShader = null, scuess
            }

            _disposeResource() {
                this._upload = !0, this._uploadSize = 0
            }

            clear() {
                this._byteLength = 0, this._upload = !0
            }
        }

        Buffer2D.FLOAT32 = 4, Buffer2D.SHORT = 2;

        class VertexBuffer2D extends Buffer2D {
            constructor(vertexStride, bufferUsage) {
                super(), this._vertexStride = vertexStride, this._bufferUsage = bufferUsage, this._bufferType = LayaGL.instance.ARRAY_BUFFER, this._buffer = new ArrayBuffer(8), this._floatArray32 = new Float32Array(this._buffer), this._uint32Array = new Uint32Array(this._buffer)
            }

            get vertexStride() {
                return this._vertexStride
            }

            getFloat32Array() {
                return this._floatArray32
            }

            appendArray(data) {
                var oldoff = this._byteLength >> 2;
                this.setByteLength(this._byteLength + 4 * data.length), this.getFloat32Array().set(data, oldoff), this._upload = !0
            }

            _checkArrayUse() {
                this._floatArray32 && (this._floatArray32 = new Float32Array(this._buffer)), this._uint32Array && (this._uint32Array = new Uint32Array(this._buffer))
            }

            deleteBuffer() {
                super._disposeResource()
            }

            _bindForVAO() {
                var gl = LayaGL.instance;
                gl.bindBuffer(gl.ARRAY_BUFFER, this._glBuffer)
            }

            bind() {
                if (Buffer._bindedVertexBuffer !== this._glBuffer) {
                    var gl = LayaGL.instance;
                    return gl.bindBuffer(gl.ARRAY_BUFFER, this._glBuffer), Buffer._bindedVertexBuffer = this._glBuffer, !0
                }
                return !1
            }

            destroy() {
                super.destroy(), this._byteLength = 0, this._upload = !0, this._buffer = null, this._floatArray32 = null
            }
        }

        VertexBuffer2D.create = function (vertexStride, bufferUsage = 35048) {
            return new VertexBuffer2D(vertexStride, bufferUsage)
        };

        class IndexBuffer2D extends Buffer2D {
            constructor(bufferUsage = 35044) {
                super(), this._bufferUsage = bufferUsage, this._bufferType = LayaGL.instance.ELEMENT_ARRAY_BUFFER, this._buffer = new ArrayBuffer(8)
            }

            _checkArrayUse() {
                this._uint16Array && (this._uint16Array = new Uint16Array(this._buffer))
            }

            getUint16Array() {
                return this._uint16Array || (this._uint16Array = new Uint16Array(this._buffer))
            }

            _bindForVAO() {
                var gl = LayaGL.instance;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._glBuffer)
            }

            bind() {
                if (Buffer._bindedIndexBuffer !== this._glBuffer) {
                    var gl = LayaGL.instance;
                    return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._glBuffer), Buffer._bindedIndexBuffer = this._glBuffer, !0
                }
                return !1
            }

            destory() {
                this._uint16Array = null, this._buffer = null
            }

            disposeResource() {
                this._disposeResource()
            }
        }

        IndexBuffer2D.create = function (bufferUsage = 35044) {
            return new IndexBuffer2D(bufferUsage)
        };

        class BufferStateBase {
            constructor() {
                this._nativeVertexArrayObject = LayaGL.layaGPUInstance.createVertexArray()
            }

            bind() {
                BufferStateBase._curBindedBufferState !== this && (LayaGL.layaGPUInstance.bindVertexArray(this._nativeVertexArrayObject), BufferStateBase._curBindedBufferState = this)
            }

            unBind() {
                if (BufferStateBase._curBindedBufferState !== this) throw"BufferState: must call bind() function first.";
                LayaGL.layaGPUInstance.bindVertexArray(null), BufferStateBase._curBindedBufferState = null
            }

            destroy() {
                LayaGL.layaGPUInstance.deleteVertexArray(this._nativeVertexArrayObject)
            }

            bindForNative() {
                LayaGL.instance.bindVertexArray(this._nativeVertexArrayObject), BufferStateBase._curBindedBufferState = this
            }

            unBindForNative() {
                LayaGL.instance.bindVertexArray(null), BufferStateBase._curBindedBufferState = null
            }
        }

        class BufferState2D extends BufferStateBase {
            constructor() {
                super()
            }
        }

        class Mesh2D {
            constructor(stride, vballoc, iballoc) {
                this._stride = 0, this.vertNum = 0, this.indexNum = 0, this._applied = !1, this._quadNum = 0, this.canReuse = !1, this._stride = stride, this._vb = new VertexBuffer2D(stride, LayaGL.instance.DYNAMIC_DRAW), vballoc ? this._vb._resizeBuffer(vballoc, !1) : Config.webGL2D_MeshAllocMaxMem && this._vb._resizeBuffer(65536 * stride, !1), this._ib = new IndexBuffer2D, iballoc && this._ib._resizeBuffer(iballoc, !1)
            }

            cloneWithNewVB() {
                var mesh = new Mesh2D(this._stride, 0, 0);
                return mesh._ib = this._ib, mesh._quadNum = this._quadNum, mesh._attribInfo = this._attribInfo, mesh
            }

            cloneWithNewVBIB() {
                var mesh = new Mesh2D(this._stride, 0, 0);
                return mesh._attribInfo = this._attribInfo, mesh
            }

            getVBW() {
                return this._vb.setNeedUpload(), this._vb
            }

            getVBR() {
                return this._vb
            }

            getIBR() {
                return this._ib
            }

            getIBW() {
                return this._ib.setNeedUpload(), this._ib
            }

            createQuadIB(QuadNum) {
                this._quadNum = QuadNum, this._ib._resizeBuffer(6 * QuadNum * 2, !1), this._ib.byteLength = this._ib.bufferLength;
                for (var bd = this._ib.getUint16Array(), idx = 0, curvert = 0, i = 0; i < QuadNum; i++) bd[idx++] = curvert, bd[idx++] = curvert + 2, bd[idx++] = curvert + 1, bd[idx++] = curvert, bd[idx++] = curvert + 3, bd[idx++] = curvert + 2, curvert += 4;
                this._ib.setNeedUpload()
            }

            setAttributes(attribs) {
                if (this._attribInfo = attribs, this._attribInfo.length % 3 != 0) throw"Mesh2D setAttributes error!"
            }

            configVAO(gl) {
                if (!this._applied) {
                    this._applied = !0, this._vao || (this._vao = new BufferState2D), this._vao.bind(), this._vb._bindForVAO(), this._ib.setNeedUpload(), this._ib._bind_uploadForVAO();
                    for (var attribNum = this._attribInfo.length / 3, idx = 0, i = 0; i < attribNum; i++) {
                        var _size = this._attribInfo[idx + 1], _type = this._attribInfo[idx],
                            _off = this._attribInfo[idx + 2];
                        gl.enableVertexAttribArray(i), gl.vertexAttribPointer(i, _size, _type, !1, this._stride, _off), idx += 3
                    }
                    this._vao.unBind()
                }
            }

            useMesh(gl) {
                this._applied || this.configVAO(gl), this._vao.bind(), this._vb.bind(), this._ib._bind_upload() || this._ib.bind(), this._vb._bind_upload() || this._vb.bind()
            }

            getEleNum() {
                return this._ib.getBuffer().byteLength / 2
            }

            releaseMesh() {
            }

            destroy() {
            }

            clearVB() {
                this._vb.clear()
            }
        }

        Mesh2D._gvaoid = 0;

        class MeshQuadTexture extends Mesh2D {
            constructor() {
                super(MeshQuadTexture.const_stride, 4, 4), this.canReuse = !0, this.setAttributes(MeshQuadTexture._fixattriInfo), MeshQuadTexture._fixib ? (this._ib = MeshQuadTexture._fixib, this._quadNum = MeshQuadTexture._maxIB) : (this.createQuadIB(MeshQuadTexture._maxIB), MeshQuadTexture._fixib = this._ib)
            }

            static __int__() {
                MeshQuadTexture._fixattriInfo = [5126, 4, 0, 5121, 4, 16, 5121, 4, 20]
            }

            static getAMesh(mainctx) {
                var ret = null;
                return ret = MeshQuadTexture._POOL.length ? MeshQuadTexture._POOL.pop() : new MeshQuadTexture, mainctx && ret._vb._resizeBuffer(65536 * MeshQuadTexture.const_stride, !1), ret
            }

            releaseMesh() {
                this._vb.setByteLength(0), this.vertNum = 0, this.indexNum = 0, MeshQuadTexture._POOL.push(this)
            }

            destroy() {
                this._vb.destroy(), this._vb.deleteBuffer()
            }

            addQuad(pos, uv, color, useTex) {
                var vb = this._vb, vpos = vb._byteLength >> 2;
                vb.setByteLength(vpos + MeshQuadTexture.const_stride << 2);
                var vbdata = vb._floatArray32 || vb.getFloat32Array(), vbu32Arr = vb._uint32Array, cpos = vpos,
                    useTexVal = useTex ? 255 : 0;
                vbdata[cpos++] = pos[0], vbdata[cpos++] = pos[1], vbdata[cpos++] = uv[0], vbdata[cpos++] = uv[1], vbu32Arr[cpos++] = color, vbu32Arr[cpos++] = useTexVal, vbdata[cpos++] = pos[2], vbdata[cpos++] = pos[3], vbdata[cpos++] = uv[2], vbdata[cpos++] = uv[3], vbu32Arr[cpos++] = color, vbu32Arr[cpos++] = useTexVal, vbdata[cpos++] = pos[4], vbdata[cpos++] = pos[5], vbdata[cpos++] = uv[4], vbdata[cpos++] = uv[5], vbu32Arr[cpos++] = color, vbu32Arr[cpos++] = useTexVal, vbdata[cpos++] = pos[6], vbdata[cpos++] = pos[7], vbdata[cpos++] = uv[6], vbdata[cpos++] = uv[7], vbu32Arr[cpos++] = color, vbu32Arr[cpos++] = useTexVal, vb._upload = !0
            }
        }

        MeshQuadTexture.const_stride = 24, MeshQuadTexture._maxIB = 16384, MeshQuadTexture._POOL = [];

        class MeshTexture extends Mesh2D {
            constructor() {
                super(MeshTexture.const_stride, 4, 4), this.canReuse = !0, this.setAttributes(MeshTexture._fixattriInfo)
            }

            static __init__() {
                MeshTexture._fixattriInfo = [5126, 4, 0, 5121, 4, 16, 5121, 4, 20]
            }

            static getAMesh(mainctx) {
                var ret;
                return ret = MeshTexture._POOL.length ? MeshTexture._POOL.pop() : new MeshTexture, mainctx && ret._vb._resizeBuffer(65536 * MeshTexture.const_stride, !1), ret
            }

            addData(vertices, uvs, idx, matrix, rgba) {
                var vb = this._vb, ib = this._ib, vertsz = vertices.length >> 1,
                    f32pos = vb.needSize(vertsz * MeshTexture.const_stride) >> 2,
                    vbdata = vb._floatArray32 || vb.getFloat32Array(), vbu32Arr = vb._uint32Array, ci = 0,
                    m00 = matrix.a, m01 = matrix.b, m10 = matrix.c, m11 = matrix.d, tx = matrix.tx, ty = matrix.ty,
                    i = 0;
                for (i = 0; i < vertsz; i++) {
                    var x = vertices[ci], y = vertices[ci + 1];
                    vbdata[f32pos] = x * m00 + y * m10 + tx, vbdata[f32pos + 1] = x * m01 + y * m11 + ty, vbdata[f32pos + 2] = uvs[ci], vbdata[f32pos + 3] = uvs[ci + 1], vbu32Arr[f32pos + 4] = rgba, vbu32Arr[f32pos + 5] = 255, f32pos += 6, ci += 2
                }
                vb.setNeedUpload();
                var vertN = this.vertNum, sz = idx.length, stib = ib.needSize(idx.byteLength),
                    cidx = ib.getUint16Array(), stibid = stib >> 1;
                if (vertN > 0) {
                    var end = stibid + sz, si = 0;
                    for (i = stibid; i < end; i++, si++) cidx[i] = idx[si] + vertN
                } else cidx.set(idx, stibid);
                ib.setNeedUpload(), this.vertNum += vertsz, this.indexNum += idx.length
            }

            releaseMesh() {
                this._vb.setByteLength(0), this._ib.setByteLength(0), this.vertNum = 0, this.indexNum = 0, MeshTexture._POOL.push(this)
            }

            destroy() {
                this._ib.destroy(), this._vb.destroy(), this._ib.disposeResource(), this._vb.deleteBuffer()
            }
        }

        MeshTexture.const_stride = 24, MeshTexture._POOL = [];

        class MeshVG extends Mesh2D {
            constructor() {
                super(MeshVG.const_stride, 4, 4), this.canReuse = !0, this.setAttributes(MeshVG._fixattriInfo)
            }

            static __init__() {
                MeshVG._fixattriInfo = [5126, 2, 0, 5121, 4, 8]
            }

            static getAMesh(mainctx) {
                var ret;
                return ret = MeshVG._POOL.length ? MeshVG._POOL.pop() : new MeshVG, mainctx && ret._vb._resizeBuffer(65536 * MeshVG.const_stride, !1), ret
            }

            addVertAndIBToMesh(ctx, points, rgba, ib) {
                for (var f32pos = this._vb.needSize(points.length / 2 * MeshVG.const_stride) >> 2, vbdata = this._vb._floatArray32 || this._vb.getFloat32Array(), vbu32Arr = this._vb._uint32Array, ci = 0, sz = points.length / 2, i = 0; i < sz; i++) vbdata[f32pos++] = points[ci], vbdata[f32pos++] = points[ci + 1], ci += 2, vbu32Arr[f32pos++] = rgba;
                this._vb.setNeedUpload(), this._ib.append(new Uint16Array(ib)), this._ib.setNeedUpload(), this.vertNum += sz, this.indexNum += ib.length
            }

            releaseMesh() {
                this._vb.setByteLength(0), this._ib.setByteLength(0), this.vertNum = 0, this.indexNum = 0, MeshVG._POOL.push(this)
            }

            destroy() {
                this._ib.destroy(), this._vb.destroy(), this._ib.disposeResource(), this._vb.deleteBuffer()
            }
        }

        MeshVG.const_stride = 12, MeshVG._POOL = [];

        class WebGLCacheAsNormalCanvas {
            constructor(ctx, sp) {
                this.submitStartPos = 0, this.submitEndPos = 0, this.context = null, this.touches = [], this.submits = [], this.sprite = null, this.meshlist = [], this.cachedClipInfo = new Matrix, this.oldTx = 0, this.oldTy = 0, this.invMat = new Matrix, this.context = ctx, this.sprite = sp, ctx._globalClipMatrix.copyTo(this.cachedClipInfo)
            }

            startRec() {
                this.context._charSubmitCache._enbale && (this.context._charSubmitCache.enable(!1, this.context), this.context._charSubmitCache.enable(!0, this.context)), this.context._incache = !0, this.touches.length = 0, this.context.touches = this.touches, this.context._globalClipMatrix.copyTo(this.cachedClipInfo), this.submits.length = 0, this.submitStartPos = this.context._submits._length;
                for (var i = 0, sz = this.meshlist.length; i < sz; i++) {
                    var curm = this.meshlist[i];
                    curm.canReuse ? curm.releaseMesh() : curm.destroy()
                }
                this.meshlist.length = 0, this._mesh = MeshQuadTexture.getAMesh(!1), this._pathMesh = MeshVG.getAMesh(!1), this._triangleMesh = MeshTexture.getAMesh(!1), this.meshlist.push(this._mesh), this.meshlist.push(this._pathMesh), this.meshlist.push(this._triangleMesh), this.context._curSubmit = SubmitBase.RENDERBASE, this._oldMesh = this.context._mesh, this._oldPathMesh = this.context._pathMesh, this._oldTriMesh = this.context._triangleMesh, this._oldMeshList = this.context.meshlist, this.context._mesh = this._mesh, this.context._pathMesh = this._pathMesh, this.context._triangleMesh = this._triangleMesh, this.context.meshlist = this.meshlist, this.oldTx = this.context._curMat.tx, this.oldTy = this.context._curMat.ty, this.context._curMat.tx = 0, this.context._curMat.ty = 0, this.context._curMat.copyTo(this.invMat), this.invMat.invert()
            }

            endRec() {
                this.context._charSubmitCache._enbale && (this.context._charSubmitCache.enable(!1, this.context), this.context._charSubmitCache.enable(!0, this.context));
                var parsubmits = this.context._submits;
                this.submitEndPos = parsubmits._length;
                for (var num = this.submitEndPos - this.submitStartPos, i = 0; i < num; i++) this.submits.push(parsubmits[this.submitStartPos + i]);
                parsubmits._length -= num, this.context._mesh = this._oldMesh, this.context._pathMesh = this._oldPathMesh, this.context._triangleMesh = this._oldTriMesh, this.context.meshlist = this._oldMeshList, this.context._curSubmit = SubmitBase.RENDERBASE, this.context._curMat.tx = this.oldTx, this.context._curMat.ty = this.oldTy, this.context.touches = null, this.context._incache = !1
            }

            isCacheValid() {
                var curclip = this.context._globalClipMatrix;
                return curclip.a == this.cachedClipInfo.a && curclip.b == this.cachedClipInfo.b && curclip.c == this.cachedClipInfo.c && curclip.d == this.cachedClipInfo.d && curclip.tx == this.cachedClipInfo.tx && curclip.ty == this.cachedClipInfo.ty
            }

            flushsubmit() {
                var curSubmit = SubmitBase.RENDERBASE;
                this.submits.forEach(function (subm) {
                    subm != SubmitBase.RENDERBASE && (SubmitBase.preRender = curSubmit, curSubmit = subm, subm.renderSubmit())
                })
            }

            releaseMem() {
            }
        }

        WebGLCacheAsNormalCanvas.matI = new Matrix;
        var texture_vs = "/*\r\n\ttexture和fillrect使用的。\r\n*/\r\nattribute vec4 posuv;\r\nattribute vec4 attribColor;\r\nattribute vec4 attribFlags;\r\n//attribute vec4 clipDir;\r\n//attribute vec2 clipRect;\r\nuniform vec4 clipMatDir;\r\nuniform vec2 clipMatPos;\t\t// 这个是全局的，不用再应用矩阵了。\r\nvarying vec2 cliped;\r\nuniform vec2 size;\r\nuniform vec2 clipOff;\t\t\t// 使用要把clip偏移。cacheas normal用. 只用了[0]\r\n#ifdef WORLDMAT\r\n\tuniform mat4 mmat;\r\n#endif\r\n#ifdef MVP3D\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\nvarying vec4 v_texcoordAlpha;\r\nvarying vec4 v_color;\r\nvarying float v_useTex;\r\n\r\nvoid main() {\r\n\r\n\tvec4 pos = vec4(posuv.xy,0.,1.);\r\n#ifdef WORLDMAT\r\n\tpos=mmat*pos;\r\n#endif\r\n\tvec4 pos1  =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,0.,1.0);\r\n#ifdef MVP3D\r\n\tgl_Position=u_MvpMatrix*pos1;\r\n#else\r\n\tgl_Position=pos1;\r\n#endif\r\n\tv_texcoordAlpha.xy = posuv.zw;\r\n\t//v_texcoordAlpha.z = attribColor.a/255.0;\r\n\tv_color = attribColor/255.0;\r\n\tv_color.xyz*=v_color.w;//反正后面也要预乘\r\n\t\r\n\tv_useTex = attribFlags.r/255.0;\r\n\tfloat clipw = length(clipMatDir.xy);\r\n\tfloat cliph = length(clipMatDir.zw);\r\n\t\r\n\tvec2 clpos = clipMatPos.xy;\r\n\t#ifdef WORLDMAT\r\n\t\t// 如果有mmat，需要修改clipMatPos,因为 这是cacheas normal （如果不是就错了）， clipMatPos被去掉了偏移\r\n\t\tif(clipOff[0]>0.0){\r\n\t\t\tclpos.x+=mmat[3].x;\t//tx\t最简单处理\r\n\t\t\tclpos.y+=mmat[3].y;\t//ty\r\n\t\t}\r\n\t#endif\r\n\tvec2 clippos = pos.xy - clpos;\t//pos已经应用矩阵了，为了减的有意义，clip的位置也要缩放\r\n\tif(clipw>20000. && cliph>20000.)\r\n\t\tcliped = vec2(0.5,0.5);\r\n\telse {\r\n\t\t//转成0到1之间。/clipw/clipw 表示clippos与normalize之后的clip朝向点积之后，再除以clipw\r\n\t\tcliped=vec2( dot(clippos,clipMatDir.xy)/clipw/clipw, dot(clippos,clipMatDir.zw)/cliph/cliph);\r\n\t}\r\n\r\n}",
            texture_ps = "/*\r\n\ttexture和fillrect使用的。\r\n*/\r\n#ifdef FSHIGHPRECISION\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_texcoordAlpha;\r\nvarying vec4 v_color;\r\nvarying float v_useTex;\r\nuniform sampler2D texture;\r\nvarying vec2 cliped;\r\n\r\n#ifdef BLUR_FILTER\r\nuniform vec4 strength_sig2_2sig2_gauss1;\r\nuniform vec2 blurInfo;\r\n\r\n#define PI 3.141593\r\n\r\nfloat getGaussian(float x, float y){\r\n    return strength_sig2_2sig2_gauss1.w*exp(-(x*x+y*y)/strength_sig2_2sig2_gauss1.z);\r\n}\r\n\r\nvec4 blur(){\r\n    const float blurw = 9.0;\r\n    vec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\r\n    vec2 halfsz=vec2(blurw,blurw)/2.0/blurInfo;    \r\n    vec2 startpos=v_texcoordAlpha.xy-halfsz;\r\n    vec2 ctexcoord = startpos;\r\n    vec2 step = 1.0/blurInfo;  //每个像素      \r\n    \r\n    for(float y = 0.0;y<=blurw; ++y){\r\n        ctexcoord.x=startpos.x;\r\n        for(float x = 0.0;x<=blurw; ++x){\r\n            //TODO 纹理坐标的固定偏移应该在vs中处理\r\n            vec4Color += texture2D(texture, ctexcoord)*getGaussian(x-blurw/2.0,y-blurw/2.0);\r\n            ctexcoord.x+=step.x;\r\n        }\r\n        ctexcoord.y+=step.y;\r\n    }\r\n    return vec4Color;\r\n}\r\n#endif\r\n\r\n#ifdef COLOR_FILTER\r\nuniform vec4 colorAlpha;\r\nuniform mat4 colorMat;\r\n#endif\r\n\r\n#ifdef GLOW_FILTER\r\nuniform vec4 u_color;\r\nuniform vec4 u_blurInfo1;\r\nuniform vec4 u_blurInfo2;\r\n#endif\r\n\r\n#ifdef COLOR_ADD\r\nuniform vec4 colorAdd;\r\n#endif\r\n\r\n#ifdef FILLTEXTURE\t\r\nuniform vec4 u_TexRange;//startu,startv,urange, vrange\r\n#endif\r\nvoid main() {\r\n\tif(cliped.x<0.) discard;\r\n\tif(cliped.x>1.) discard;\r\n\tif(cliped.y<0.) discard;\r\n\tif(cliped.y>1.) discard;\r\n\t\r\n#ifdef FILLTEXTURE\t\r\n   vec4 color= texture2D(texture, fract(v_texcoordAlpha.xy)*u_TexRange.zw + u_TexRange.xy);\r\n#else\r\n   vec4 color= texture2D(texture, v_texcoordAlpha.xy);\r\n#endif\r\n\r\n   if(v_useTex<=0.)color = vec4(1.,1.,1.,1.);\r\n   color.a*=v_color.w;\r\n   //color.rgb*=v_color.w;\r\n   color.rgb*=v_color.rgb;\r\n   gl_FragColor=color;\r\n   \r\n   #ifdef COLOR_ADD\r\n\tgl_FragColor = vec4(colorAdd.rgb,colorAdd.a*gl_FragColor.a);\r\n\tgl_FragColor.xyz *= colorAdd.a;\r\n   #endif\r\n   \r\n   #ifdef BLUR_FILTER\r\n\tgl_FragColor =   blur();\r\n\tgl_FragColor.w*=v_color.w;   \r\n   #endif\r\n   \r\n   #ifdef COLOR_FILTER\r\n\tmat4 alphaMat =colorMat;\r\n\r\n\talphaMat[0][3] *= gl_FragColor.a;\r\n\talphaMat[1][3] *= gl_FragColor.a;\r\n\talphaMat[2][3] *= gl_FragColor.a;\r\n\r\n\tgl_FragColor = gl_FragColor * alphaMat;\r\n\tgl_FragColor += colorAlpha/255.0*gl_FragColor.a;\r\n   #endif\r\n   \r\n   #ifdef GLOW_FILTER\r\n\tconst float c_IterationTime = 10.0;\r\n\tfloat floatIterationTotalTime = c_IterationTime * c_IterationTime;\r\n\tvec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\r\n\tvec2 vec2FilterDir = vec2(-(u_blurInfo1.z)/u_blurInfo2.x,-(u_blurInfo1.w)/u_blurInfo2.y);\r\n\tvec2 vec2FilterOff = vec2(u_blurInfo1.x/u_blurInfo2.x/c_IterationTime * 2.0,u_blurInfo1.y/u_blurInfo2.y/c_IterationTime * 2.0);\r\n\tfloat maxNum = u_blurInfo1.x * u_blurInfo1.y;\r\n\tvec2 vec2Off = vec2(0.0,0.0);\r\n\tfloat floatOff = c_IterationTime/2.0;\r\n\tfor(float i = 0.0;i<=c_IterationTime; ++i){\r\n\t\tfor(float j = 0.0;j<=c_IterationTime; ++j){\r\n\t\t\tvec2Off = vec2(vec2FilterOff.x * (i - floatOff),vec2FilterOff.y * (j - floatOff));\r\n\t\t\tvec4Color += texture2D(texture, v_texcoordAlpha.xy + vec2FilterDir + vec2Off)/floatIterationTotalTime;\r\n\t\t}\r\n\t}\r\n\tgl_FragColor = vec4(u_color.rgb,vec4Color.a * u_blurInfo2.z);\r\n\tgl_FragColor.rgb *= gl_FragColor.a;   \r\n   #endif\r\n   \r\n}",
            prime_vs = "attribute vec4 position;\r\nattribute vec4 attribColor;\r\n//attribute vec4 clipDir;\r\n//attribute vec2 clipRect;\r\nuniform vec4 clipMatDir;\r\nuniform vec2 clipMatPos;\r\n#ifdef WORLDMAT\r\n\tuniform mat4 mmat;\r\n#endif\r\nuniform mat4 u_mmat2;\r\n//uniform vec2 u_pos;\r\nuniform vec2 size;\r\nvarying vec4 color;\r\n//vec4 dirxy=vec4(0.9,0.1, -0.1,0.9);\r\n//vec4 clip=vec4(100.,30.,300.,600.);\r\nvarying vec2 cliped;\r\nvoid main(){\r\n\t\r\n#ifdef WORLDMAT\r\n\tvec4 pos=mmat*vec4(position.xy,0.,1.);\r\n\tgl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\r\n#else\r\n\tgl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\r\n#endif\t\r\n\tfloat clipw = length(clipMatDir.xy);\r\n\tfloat cliph = length(clipMatDir.zw);\r\n\tvec2 clippos = position.xy - clipMatPos.xy;\t//pos已经应用矩阵了，为了减的有意义，clip的位置也要缩放\r\n\tif(clipw>20000. && cliph>20000.)\r\n\t\tcliped = vec2(0.5,0.5);\r\n\telse {\r\n\t\t//clipdir是带缩放的方向，由于上面clippos是在缩放后的空间计算的，所以需要把方向先normalize一下\r\n\t\tcliped=vec2( dot(clippos,clipMatDir.xy)/clipw/clipw, dot(clippos,clipMatDir.zw)/cliph/cliph);\r\n\t}\r\n  //pos2d.x = dot(clippos,dirx);\r\n  color=attribColor/255.;\r\n}",
            prime_ps = "precision mediump float;\r\n//precision mediump float;\r\nvarying vec4 color;\r\n//uniform float alpha;\r\nvarying vec2 cliped;\r\nvoid main(){\r\n\t//vec4 a=vec4(color.r, color.g, color.b, 1);\r\n\t//a.a*=alpha;\r\n    gl_FragColor= color;// vec4(color.r, color.g, color.b, alpha);\r\n\tgl_FragColor.rgb*=color.a;\r\n\tif(cliped.x<0.) discard;\r\n\tif(cliped.x>1.) discard;\r\n\tif(cliped.y<0.) discard;\r\n\tif(cliped.y>1.) discard;\r\n}",
            skin_vs = "attribute vec2 position;\r\nattribute vec2 texcoord;\r\nattribute vec4 color;\r\nuniform vec2 size;\r\nuniform float offsetX;\r\nuniform float offsetY;\r\nuniform mat4 mmat;\r\nuniform mat4 u_mmat2;\r\nvarying vec2 v_texcoord;\r\nvarying vec4 v_color;\r\nvoid main() {\r\n  vec4 pos=mmat*u_mmat2*vec4(offsetX+position.x,offsetY+position.y,0,1 );\r\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\r\n  v_color = color;\r\n  v_color.rgb *= v_color.a;\r\n  v_texcoord = texcoord;  \r\n}",
            skin_ps = "precision mediump float;\r\nvarying vec2 v_texcoord;\r\nvarying vec4 v_color;\r\nuniform sampler2D texture;\r\nuniform float alpha;\r\nvoid main() {\r\n\tvec4 t_color = texture2D(texture, v_texcoord);\r\n\tgl_FragColor = t_color.rgba * v_color;\r\n\tgl_FragColor *= alpha;\r\n}";

        class Shader2D {
            constructor() {
                this.ALPHA = 1, this.defines = new ShaderDefines2D, this.shaderType = 0, this.fillStyle = DrawStyle.DEFAULT, this.strokeStyle = DrawStyle.DEFAULT
            }

            destroy() {
                this.defines = null, this.filters = null
            }

            static __init__() {
                Shader.preCompile2D(0, ShaderDefines2D.TEXTURE2D, texture_vs, texture_ps, null), Shader.preCompile2D(0, ShaderDefines2D.PRIMITIVE, prime_vs, prime_ps, null), Shader.preCompile2D(0, ShaderDefines2D.SKINMESH, skin_vs, skin_ps, null)
            }
        }

        class SkinMeshBuffer {
            constructor() {
                var gl = LayaGL.instance;
                this.ib = IndexBuffer2D.create(gl.DYNAMIC_DRAW), this.vb = VertexBuffer2D.create(8)
            }

            static getInstance() {
                return SkinMeshBuffer.instance = SkinMeshBuffer.instance || new SkinMeshBuffer
            }

            addSkinMesh(skinMesh) {
                skinMesh.getData2(this.vb, this.ib, this.vb._byteLength / 32)
            }

            reset() {
                this.vb.clear(), this.ib.clear()
            }
        }

        class BasePoly {
            static createLine2(p, indices, lineWidth, indexBase, outVertex, loop) {
                if (p.length < 4) return null;
                var points = BasePoly.tempData.length > p.length + 2 ? BasePoly.tempData : new Array(p.length + 2);
                points[0] = p[0], points[1] = p[1];
                var newlen = 2, i = 0, length = p.length;
                for (i = 2; i < length; i += 2) Math.abs(p[i] - p[i - 2]) + Math.abs(p[i + 1] - p[i - 1]) > .01 && (points[newlen++] = p[i], points[newlen++] = p[i + 1]);
                loop && Math.abs(p[0] - points[newlen - 2]) + Math.abs(p[1] - points[newlen - 1]) > .01 && (points[newlen++] = p[0], points[newlen++] = p[1]);
                var result = outVertex;
                length = newlen / 2;
                var px, py, p1x, p1y, p2x, p2y, p3x, p3y, perpx, perpy, perp2x, perp2y, a1, b1, c1, a2, b2, c2, denom,
                    dist, w = lineWidth / 2;
                for (p1x = points[0], p1y = points[1], perpy = p1x - (p2x = points[2]), perpx = (perpx = -(p1y - (p2y = points[3]))) / (dist = Math.sqrt(perpx * perpx + perpy * perpy)) * w, perpy = perpy / dist * w, result.push(p1x - perpx, p1y - perpy, p1x + perpx, p1y + perpy), i = 1; i < length - 1; i++) p1x = points[2 * (i - 1)], p1y = points[2 * (i - 1) + 1], p2x = points[2 * i], p2y = points[2 * i + 1], p3x = points[2 * (i + 1)], p3y = points[2 * (i + 1) + 1], perpy = p1x - p2x, perp2y = p2x - p3x, c1 = (-(perpx = (perpx = -(p1y - p2y)) / (dist = Math.sqrt(perpx * perpx + perpy * perpy)) * w) + p1x) * (-(perpy = perpy / dist * w) + p2y) - (-perpx + p2x) * (-perpy + p1y), c2 = (-(perp2x = (perp2x = -(p2y - p3y)) / (dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y)) * w) + p3x) * (-(perp2y = perp2y / dist * w) + p2y) - (-perp2x + p2x) * (-perp2y + p3y), denom = (a1 = -perpy + p1y - (-perpy + p2y)) * (b2 = -perp2x + p2x - (-perp2x + p3x)) - (a2 = -perp2y + p3y - (-perp2y + p2y)) * (b1 = -perpx + p2x - (-perpx + p1x)), Math.abs(denom) < .1 ? (denom += 10.1, result.push(p2x - perpx, p2y - perpy, p2x + perpx, p2y + perpy)) : (px = (b1 * c2 - b2 * c1) / denom, py = (a2 * c1 - a1 * c2) / denom, result.push(px, py, p2x - (px - p2x), p2y - (py - p2y)));
                for (p1x = points[newlen - 4], p1y = points[newlen - 3], perpy = p1x - (p2x = points[newlen - 2]), perpx = (perpx = -(p1y - (p2y = points[newlen - 1]))) / (dist = Math.sqrt(perpx * perpx + perpy * perpy)) * w, perpy = perpy / dist * w, result.push(p2x - perpx, p2y - perpy, p2x + perpx, p2y + perpy), i = 1; i < length; i++) indices.push(indexBase + 2 * (i - 1), indexBase + 2 * (i - 1) + 1, indexBase + 2 * i + 1, indexBase + 2 * i + 1, indexBase + 2 * i, indexBase + 2 * (i - 1));
                return result
            }

            static createLineTriangle(path, color, width, loop, outvb, vbstride, outib) {
                var points = path.slice(), ptlen = points.length, p1x = points[0], p1y = points[1], p2x = points[2],
                    len = (points[2], 0), rp = 0, dx = 0, dy = 0, pointnum = ptlen / 2;
                if (!(pointnum <= 1) && 2 != pointnum) {
                    for (var tmpData = new Array(4 * pointnum), realPtNum = 0, ci = 0, i = 0; i < pointnum - 1; i++) p1x = points[ci++], p1y = points[ci++], p2x = points[ci++], dy = points[ci++] - p1y, 0 != (dx = p2x - p1x) && 0 != dy && (len = Math.sqrt(dx * dx + dy * dy)) > .001 && (tmpData[rp = 4 * realPtNum] = p1x, tmpData[rp + 1] = p1y, tmpData[rp + 2] = dx / len, tmpData[rp + 3] = dy / len, realPtNum++);
                    for (loop ? (p1x = points[ptlen - 2], p1y = points[ptlen - 1], p2x = points[0], dy = points[1] - p1y, 0 != (dx = p2x - p1x) && 0 != dy && (len = Math.sqrt(dx * dx + dy * dy)) > .001 && (tmpData[rp = 4 * realPtNum] = p1x, tmpData[rp + 1] = p1y, tmpData[rp + 2] = dx / len, tmpData[rp + 3] = dy / len, realPtNum++)) : (tmpData[rp = 4 * realPtNum] = p1x, tmpData[rp + 1] = p1y, tmpData[rp + 2] = dx / len, tmpData[rp + 3] = dy / len, realPtNum++), ci = 0, i = 0; i < pointnum; i++) {
                        p1x = points[ci], p1y = points[ci + 1], p2x = points[ci + 2], points[ci + 3];
                        points[ci + 4], points[ci + 5]
                    }
                }
            }
        }

        BasePoly.tempData = new Array(256);

        class EarcutNode {
            constructor(i, x, y) {
                this.i = i, this.x = x, this.y = y, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
        }

        class Earcut {
            static earcut(data, holeIndices, dim) {
                dim = dim || 2;
                var minX, minY, maxX, maxY, x, y, invSize, hasHoles = holeIndices && holeIndices.length,
                    outerLen = hasHoles ? holeIndices[0] * dim : data.length,
                    outerNode = Earcut.linkedList(data, 0, outerLen, dim, !0), triangles = [];
                if (!outerNode) return triangles;
                if (hasHoles && (outerNode = Earcut.eliminateHoles(data, holeIndices, outerNode, dim)), data.length > 80 * dim) {
                    minX = maxX = data[0], minY = maxY = data[1];
                    for (var i = dim; i < outerLen; i += dim) (x = data[i]) < minX && (minX = x), (y = data[i + 1]) < minY && (minY = y), x > maxX && (maxX = x), y > maxY && (maxY = y);
                    invSize = 0 !== (invSize = Math.max(maxX - minX, maxY - minY)) ? 1 / invSize : 0
                }
                return Earcut.earcutLinked(outerNode, triangles, dim, minX, minY, invSize), triangles
            }

            static linkedList(data, start, end, dim, clockwise) {
                var i, last;
                if (clockwise === Earcut.signedArea(data, start, end, dim) > 0) for (i = start; i < end; i += dim) last = Earcut.insertNode(i, data[i], data[i + 1], last); else for (i = end - dim; i >= start; i -= dim) last = Earcut.insertNode(i, data[i], data[i + 1], last);
                return last && Earcut.equals(last, last.next) && (Earcut.removeNode(last), last = last.next), last
            }

            static filterPoints(start, end) {
                if (!start) return start;
                end || (end = start);
                var again, p = start;
                do {
                    if (again = !1, p.steiner || !Earcut.equals(p, p.next) && 0 !== Earcut.area(p.prev, p, p.next)) p = p.next; else {
                        if (Earcut.removeNode(p), (p = end = p.prev) === p.next) break;
                        again = !0
                    }
                } while (again || p !== end);
                return end
            }

            static earcutLinked(ear, triangles, dim, minX, minY, invSize, pass = null) {
                if (ear) {
                    !pass && invSize && Earcut.indexCurve(ear, minX, minY, invSize);
                    for (var prev, next, stop = ear; ear.prev !== ear.next;) if (prev = ear.prev, next = ear.next, invSize ? Earcut.isEarHashed(ear, minX, minY, invSize) : Earcut.isEar(ear)) triangles.push(prev.i / dim), triangles.push(ear.i / dim), triangles.push(next.i / dim), Earcut.removeNode(ear), ear = next.next, stop = next.next; else if ((ear = next) === stop) {
                        pass ? 1 === pass ? (ear = Earcut.cureLocalIntersections(ear, triangles, dim), Earcut.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2)) : 2 === pass && Earcut.splitEarcut(ear, triangles, dim, minX, minY, invSize) : Earcut.earcutLinked(Earcut.filterPoints(ear, null), triangles, dim, minX, minY, invSize, 1);
                        break
                    }
                }
            }

            static isEar(ear) {
                var a = ear.prev, b = ear, c = ear.next;
                if (Earcut.area(a, b, c) >= 0) return !1;
                for (var p = ear.next.next; p !== ear.prev;) {
                    if (Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && Earcut.area(p.prev, p, p.next) >= 0) return !1;
                    p = p.next
                }
                return !0
            }

            static isEarHashed(ear, minX, minY, invSize) {
                var a = ear.prev, b = ear, c = ear.next;
                if (Earcut.area(a, b, c) >= 0) return !1;
                for (var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y, minZ = Earcut.zOrder(minTX, minTY, minX, minY, invSize), maxZ = Earcut.zOrder(maxTX, maxTY, minX, minY, invSize), p = ear.nextZ; p && p.z <= maxZ;) {
                    if (p !== ear.prev && p !== ear.next && Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && Earcut.area(p.prev, p, p.next) >= 0) return !1;
                    p = p.nextZ
                }
                for (p = ear.prevZ; p && p.z >= minZ;) {
                    if (p !== ear.prev && p !== ear.next && Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && Earcut.area(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                return !0
            }

            static cureLocalIntersections(start, triangles, dim) {
                var p = start;
                do {
                    var a = p.prev, b = p.next.next;
                    !Earcut.equals(a, b) && Earcut.intersects(a, p, p.next, b) && Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a) && (triangles.push(a.i / dim), triangles.push(p.i / dim), triangles.push(b.i / dim), Earcut.removeNode(p), Earcut.removeNode(p.next), p = start = b), p = p.next
                } while (p !== start);
                return p
            }

            static splitEarcut(start, triangles, dim, minX, minY, invSize) {
                var a = start;
                do {
                    for (var b = a.next.next; b !== a.prev;) {
                        if (a.i !== b.i && Earcut.isValidDiagonal(a, b)) {
                            var c = Earcut.splitPolygon(a, b);
                            return a = Earcut.filterPoints(a, a.next), c = Earcut.filterPoints(c, c.next), Earcut.earcutLinked(a, triangles, dim, minX, minY, invSize), void Earcut.earcutLinked(c, triangles, dim, minX, minY, invSize)
                        }
                        b = b.next
                    }
                    a = a.next
                } while (a !== start)
            }

            static eliminateHoles(data, holeIndices, outerNode, dim) {
                var i, len, start, end, list, queue = [];
                for (i = 0, len = holeIndices.length; i < len; i++) start = holeIndices[i] * dim, end = i < len - 1 ? holeIndices[i + 1] * dim : data.length, (list = Earcut.linkedList(data, start, end, dim, !1)) === list.next && (list.steiner = !0), queue.push(Earcut.getLeftmost(list));
                for (queue.sort(Earcut.compareX), i = 0; i < queue.length; i++) Earcut.eliminateHole(queue[i], outerNode), outerNode = Earcut.filterPoints(outerNode, outerNode.next);
                return outerNode
            }

            static compareX(a, b) {
                return a.x - b.x
            }

            static eliminateHole(hole, outerNode) {
                if (outerNode = Earcut.findHoleBridge(hole, outerNode)) {
                    var b = Earcut.splitPolygon(outerNode, hole);
                    Earcut.filterPoints(b, b.next)
                }
            }

            static findHoleBridge(hole, outerNode) {
                var m, p = outerNode, hx = hole.x, hy = hole.y, qx = -1 / 0;
                do {
                    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                        if (x <= hx && x > qx) {
                            if (qx = x, x === hx) {
                                if (hy === p.y) return p;
                                if (hy === p.next.y) return p.next
                            }
                            m = p.x < p.next.x ? p : p.next
                        }
                    }
                    p = p.next
                } while (p !== outerNode);
                if (!m) return null;
                if (hx === qx) return m.prev;
                var tan, stop = m, mx = m.x, my = m.y, tanMin = 1 / 0;
                for (p = m.next; p !== stop;) hx >= p.x && p.x >= mx && hx !== p.x && Earcut.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y) && ((tan = Math.abs(hy - p.y) / (hx - p.x)) < tanMin || tan === tanMin && p.x > m.x) && Earcut.locallyInside(p, hole) && (m = p, tanMin = tan), p = p.next;
                return m
            }

            static indexCurve(start, minX, minY, invSize) {
                var p = start;
                do {
                    null === p.z && (p.z = Earcut.zOrder(p.x, p.y, minX, minY, invSize)), p.prevZ = p.prev, p.nextZ = p.next, p = p.next
                } while (p !== start);
                p.prevZ.nextZ = null, p.prevZ = null, Earcut.sortLinked(p)
            }

            static sortLinked(list) {
                var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
                do {
                    for (p = list, list = null, tail = null, numMerges = 0; p;) {
                        for (numMerges++, q = p, pSize = 0, i = 0; i < inSize && (pSize++, q = q.nextZ); i++) ;
                        for (qSize = inSize; pSize > 0 || qSize > 0 && q;) 0 !== pSize && (0 === qSize || !q || p.z <= q.z) ? (e = p, p = p.nextZ, pSize--) : (e = q, q = q.nextZ, qSize--), tail ? tail.nextZ = e : list = e, e.prevZ = tail, tail = e;
                        p = q
                    }
                    tail.nextZ = null, inSize *= 2
                } while (numMerges > 1);
                return list
            }

            static zOrder(x, y, minX, minY, invSize) {
                return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x = 32767 * (x - minX) * invSize) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y = 32767 * (y - minY) * invSize) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1
            }

            static getLeftmost(start) {
                var p = start, leftmost = start;
                do {
                    p.x < leftmost.x && (leftmost = p), p = p.next
                } while (p !== start);
                return leftmost
            }

            static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
                return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0
            }

            static isValidDiagonal(a, b) {
                return a.next.i !== b.i && a.prev.i !== b.i && !Earcut.intersectsPolygon(a, b) && Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a) && Earcut.middleInside(a, b)
            }

            static area(p, q, r) {
                return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)
            }

            static equals(p1, p2) {
                return p1.x === p2.x && p1.y === p2.y
            }

            static intersects(p1, q1, p2, q2) {
                return !!(Earcut.equals(p1, q1) && Earcut.equals(p2, q2) || Earcut.equals(p1, q2) && Earcut.equals(p2, q1)) || Earcut.area(p1, q1, p2) > 0 != Earcut.area(p1, q1, q2) > 0 && Earcut.area(p2, q2, p1) > 0 != Earcut.area(p2, q2, q1) > 0
            }

            static intersectsPolygon(a, b) {
                var p = a;
                do {
                    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && Earcut.intersects(p, p.next, a, b)) return !0;
                    p = p.next
                } while (p !== a);
                return !1
            }

            static locallyInside(a, b) {
                return Earcut.area(a.prev, a, a.next) < 0 ? Earcut.area(a, b, a.next) >= 0 && Earcut.area(a, a.prev, b) >= 0 : Earcut.area(a, b, a.prev) < 0 || Earcut.area(a, a.next, b) < 0
            }

            static middleInside(a, b) {
                var p = a, inside = !1, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
                do {
                    p.y > py != p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x && (inside = !inside), p = p.next
                } while (p !== a);
                return inside
            }

            static splitPolygon(a, b) {
                var a2 = new EarcutNode(a.i, a.x, a.y), b2 = new EarcutNode(b.i, b.x, b.y), an = a.next, bp = b.prev;
                return a.next = b, b.prev = a, a2.next = an, an.prev = a2, b2.next = a2, a2.prev = b2, bp.next = b2, b2.prev = bp, b2
            }

            static insertNode(i, x, y, last) {
                var p = new EarcutNode(i, x, y);
                return last ? (p.next = last.next, p.prev = last, last.next.prev = p, last.next = p) : (p.prev = p, p.next = p), p
            }

            static removeNode(p) {
                p.next.prev = p.prev, p.prev.next = p.next, p.prevZ && (p.prevZ.nextZ = p.nextZ), p.nextZ && (p.nextZ.prevZ = p.prevZ)
            }

            static signedArea(data, start, end, dim) {
                for (var sum = 0, i = start, j = end - dim; i < end; i += dim) sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]), j = i;
                return sum
            }
        }

        class CONST3D2D {
        }

        CONST3D2D.BYTES_PE = 4, CONST3D2D.BYTES_PIDX = 2, CONST3D2D.defaultMatrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], CONST3D2D.defaultMinusYMatrix4 = [1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], CONST3D2D.uniformMatrix3 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], CONST3D2D._TMPARRAY = [], CONST3D2D._OFFSETX = 0, CONST3D2D._OFFSETY = 0;

        class Submit extends SubmitBase {
            constructor(renderType = SubmitBase.TYPE_2D) {
                super(renderType)
            }

            renderSubmit() {
                if (0 === this._numEle || !this._mesh || 0 == this._numEle) return 1;
                var _tex = this.shaderValue.textureHost;
                if (_tex) {
                    var source = _tex._getSource();
                    if (!source) return 1;
                    this.shaderValue.texture = source
                }
                var gl = WebGLContext.mainContext;
                return this._mesh.useMesh(gl), this.shaderValue.upload(), BlendMode.activeBlendFunction !== this._blendFn && (WebGLContext.setBlend(gl, !0), this._blendFn(gl), BlendMode.activeBlendFunction = this._blendFn), gl.drawElements(gl.TRIANGLES, this._numEle, gl.UNSIGNED_SHORT, this._startIdx), Stat.renderBatches++, Stat.trianglesFaces += this._numEle / 3, 1
            }

            releaseRender() {
                SubmitBase.RENDERBASE != this && --this._ref < 1 && (Submit.POOL[Submit._poolSize++] = this, this.shaderValue.release(), this.shaderValue = null, this._mesh = null, this._parent && (this._parent.releaseRender(), this._parent = null))
            }

            static create(context, mesh, sv) {
                var o = Submit._poolSize ? Submit.POOL[--Submit._poolSize] : new Submit;
                o._ref = 1, o._mesh = mesh, o._key.clear(), o._startIdx = mesh.indexNum * CONST3D2D.BYTES_PIDX, o._numEle = 0;
                var blendType = context._nBlendType;
                o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType], o.shaderValue = sv, o.shaderValue.setValue(context._shader2D);
                var filters = context._shader2D.filters;
                return filters && o.shaderValue.setFilters(filters), o
            }

            static createShape(ctx, mesh, numEle, sv) {
                var o = Submit._poolSize ? Submit.POOL[--Submit._poolSize] : new Submit;
                o._mesh = mesh, o._numEle = numEle, o._startIdx = 2 * mesh.indexNum, o._ref = 1, o.shaderValue = sv, o.shaderValue.setValue(ctx._shader2D);
                var blendType = ctx._nBlendType;
                return o._key.blendShader = blendType, o._blendFn = ctx._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType], o
            }
        }

        Submit._poolSize = 0, Submit.POOL = [];

        class SubmitCanvas extends SubmitBase {
            constructor() {
                super(SubmitBase.TYPE_2D), this._matrix = new Matrix, this._matrix4 = CONST3D2D.defaultMatrix4.concat(), this.shaderValue = new Value2D(0, 0)
            }

            static create(canvas, alpha, filters) {
                var o = SubmitCanvas.POOL._length ? SubmitCanvas.POOL[--SubmitCanvas.POOL._length] : new SubmitCanvas;
                o.canv = canvas, o._ref = 1, o._numEle = 0;
                var v = o.shaderValue;
                return v.alpha = alpha, v.defines.setValue(0), filters && filters.length && v.setFilters(filters), o
            }

            renderSubmit() {
                var preAlpha = RenderState2D.worldAlpha, preMatrix4 = RenderState2D.worldMatrix4,
                    preMatrix = RenderState2D.worldMatrix, preFilters = RenderState2D.worldFilters,
                    preWorldShaderDefines = RenderState2D.worldShaderDefines, v = this.shaderValue, m = this._matrix,
                    m4 = this._matrix4, mout = Matrix.TEMP;
                return Matrix.mul(m, preMatrix, mout), m4[0] = mout.a, m4[1] = mout.b, m4[4] = mout.c, m4[5] = mout.d, m4[12] = mout.tx, m4[13] = mout.ty, RenderState2D.worldMatrix = mout.clone(), RenderState2D.worldMatrix4 = m4, RenderState2D.worldAlpha = RenderState2D.worldAlpha * v.alpha, v.filters && v.filters.length && (RenderState2D.worldFilters = v.filters, RenderState2D.worldShaderDefines = v.defines), this.canv.flushsubmit(), RenderState2D.worldAlpha = preAlpha, RenderState2D.worldMatrix4 = preMatrix4, RenderState2D.worldMatrix.destroy(), RenderState2D.worldMatrix = preMatrix, RenderState2D.worldFilters = preFilters, RenderState2D.worldShaderDefines = preWorldShaderDefines, 1
            }

            releaseRender() {
                if (--this._ref < 1) {
                    var cache = SubmitCanvas.POOL;
                    this._mesh = null, cache[cache._length++] = this
                }
            }

            getRenderType() {
                return SubmitBase.TYPE_CANVAS
            }
        }

        SubmitCanvas.POOL = [], SubmitCanvas.POOL._length = 0;

        class SubmitTarget {
            constructor() {
                this.blendType = 0, this._ref = 1, this._key = new SubmitKey
            }

            renderSubmit() {
                var gl = WebGLContext.mainContext;
                this._mesh.useMesh(gl);
                var target = this.srcRT;
                return target && (this.shaderValue.texture = target._getSource(), this.shaderValue.upload(), this.blend(), Stat.renderBatches++, Stat.trianglesFaces += this._numEle / 3, gl.drawElements(gl.TRIANGLES, this._numEle, gl.UNSIGNED_SHORT, this._startIdx)), 1
            }

            blend() {
                if (BlendMode.activeBlendFunction !== BlendMode.fns[this.blendType]) {
                    var gl = WebGLContext.mainContext;
                    gl.enable(gl.BLEND), BlendMode.fns[this.blendType](gl), BlendMode.activeBlendFunction = BlendMode.fns[this.blendType]
                }
            }

            getRenderType() {
                return 0
            }

            releaseRender() {
                if (--this._ref < 1) {
                    var pool = SubmitTarget.POOL;
                    pool[pool._length++] = this
                }
            }

            static create(context, mesh, sv, rt) {
                var o = SubmitTarget.POOL._length ? SubmitTarget.POOL[--SubmitTarget.POOL._length] : new SubmitTarget;
                if (o._mesh = mesh, o.srcRT = rt, o._startIdx = mesh.indexNum * CONST3D2D.BYTES_PIDX, o._ref = 1, o._key.clear(), o._numEle = 0, o.blendType = context._nBlendType, o._key.blendShader = o.blendType, o.shaderValue = sv, o.shaderValue.setValue(context._shader2D), context._colorFiler) {
                    var ft = context._colorFiler;
                    sv.defines.add(ft.type), sv.colorMat = ft._mat, sv.colorAlpha = ft._alpha
                }
                return o
            }
        }

        SubmitTarget.POOL = [], SubmitTarget.POOL._length = 0;

        class SubmitTexture extends SubmitBase {
            constructor(renderType = SubmitBase.TYPE_2D) {
                super(renderType)
            }

            releaseRender() {
                --this._ref < 1 && (SubmitTexture.POOL[SubmitTexture._poolSize++] = this, this.shaderValue.release(), this._mesh = null, this._parent && (this._parent.releaseRender(), this._parent = null))
            }

            renderSubmit() {
                if (0 === this._numEle) return 1;
                var tex = this.shaderValue.textureHost;
                if (tex) {
                    var source = tex ? tex._getSource() : null;
                    if (!source) return 1
                }
                var gl = WebGLContext.mainContext;
                this._mesh.useMesh(gl);
                var lastSubmit = SubmitBase.preRender, prekey = SubmitBase.preRender._key;
                return 0 === this._key.blendShader && this._key.submitType === prekey.submitType && this._key.blendShader === prekey.blendShader && BaseShader.activeShader && SubmitBase.preRender.clipInfoID == this.clipInfoID && lastSubmit.shaderValue.defines._value === this.shaderValue.defines._value && 0 == (this.shaderValue.defines._value & ShaderDefines2D.NOOPTMASK) ? BaseShader.activeShader.uploadTexture2D(source) : (BlendMode.activeBlendFunction !== this._blendFn && (WebGLContext.setBlend(gl, !0), this._blendFn(gl), BlendMode.activeBlendFunction = this._blendFn), this.shaderValue.texture = source, this.shaderValue.upload()), gl.drawElements(gl.TRIANGLES, this._numEle, gl.UNSIGNED_SHORT, this._startIdx), Stat.renderBatches++, Stat.trianglesFaces += this._numEle / 3, 1
            }

            static create(context, mesh, sv) {
                var o = SubmitTexture._poolSize ? SubmitTexture.POOL[--SubmitTexture._poolSize] : new SubmitTexture(SubmitBase.TYPE_TEXTURE);
                o._mesh = mesh, o._key.clear(), o._key.submitType = SubmitBase.KEY_DRAWTEXTURE, o._ref = 1, o._startIdx = mesh.indexNum * CONST3D2D.BYTES_PIDX, o._numEle = 0;
                var blendType = context._nBlendType;
                if (o._key.blendShader = blendType, o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType], o.shaderValue = sv, context._colorFiler) {
                    var ft = context._colorFiler;
                    sv.defines.add(ft.type), sv.colorMat = ft._mat, sv.colorAlpha = ft._alpha
                }
                return o
            }
        }

        SubmitTexture._poolSize = 0, SubmitTexture.POOL = [];

        class CharSubmitCache {
            constructor() {
                this._data = [], this._ndata = 0, this._clipid = -1, this._clipMatrix = new Matrix, this._enbale = !1
            }

            clear() {
                this._tex = null, this._imgId = -1, this._ndata = 0, this._enbale = !1, this._colorFiler = null
            }

            destroy() {
                this.clear(), this._data.length = 0, this._data = null
            }

            add(ctx, tex, imgid, pos, uv, color) {
                this._ndata > 0 && (this._tex != tex || this._imgId != imgid || this._clipid >= 0 && this._clipid != ctx._clipInfoID) && this.submit(ctx), this._clipid = ctx._clipInfoID, ctx._globalClipMatrix.copyTo(this._clipMatrix), this._tex = tex, this._imgId = imgid, this._colorFiler = ctx._colorFiler, this._data[this._ndata] = pos, this._data[this._ndata + 1] = uv, this._data[this._ndata + 2] = color, this._ndata += 3
            }

            getPos() {
                return 0 == CharSubmitCache.__nPosPool ? new Array(8) : CharSubmitCache.__posPool[--CharSubmitCache.__nPosPool]
            }

            enable(value, ctx) {
                value !== this._enbale && (this._enbale = value, this._enbale || this.submit(ctx))
            }

            submit(ctx) {
                var n = this._ndata;
                if (n) {
                    var _mesh = ctx._mesh, colorFiler = ctx._colorFiler;
                    ctx._colorFiler = this._colorFiler;
                    var submit = SubmitTexture.create(ctx, _mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
                    ctx._submits[ctx._submits._length++] = ctx._curSubmit = submit, submit.shaderValue.textureHost = this._tex, submit._key.other = this._imgId, ctx._colorFiler = colorFiler, ctx._copyClipInfo(submit, this._clipMatrix), submit.clipInfoID = this._clipid;
                    for (var i = 0; i < n; i += 3) _mesh.addQuad(this._data[i], this._data[i + 1], this._data[i + 2], !0), CharSubmitCache.__posPool[CharSubmitCache.__nPosPool++] = this._data[i];
                    n /= 3, submit._numEle += 6 * n, _mesh.indexNum += 6 * n, _mesh.vertNum += 4 * n, ctx._drawCount += n, this._ndata = 0, RenderInfo.loopCount % 100 == 0 && (this._data.length = 0)
                }
            }
        }

        CharSubmitCache.__posPool = [], CharSubmitCache.__nPosPool = 0;

        class AtlasGrid {
            constructor(width = 0, height = 0, id = 0) {
                this.atlasID = 0, this._width = 0, this._height = 0, this._texCount = 0, this._rowInfo = null, this._cells = null, this._used = 0, this._cells = null, this._rowInfo = null, this.atlasID = id, this._init(width, height)
            }

            addRect(type, width, height, pt) {
                return !!this._get(width, height, pt) && (this._fill(pt.x, pt.y, width, height, type), this._texCount++, !0)
            }

            _release() {
                this._cells = null, this._rowInfo = null
            }

            _init(width, height) {
                return this._width = width, this._height = height, this._release(), 0 != this._width && (this._cells = new Uint8Array(this._width * this._height * 3), this._rowInfo = new Uint8Array(this._height), this._used = 0, this._clear(), !0)
            }

            _get(width, height, pt) {
                if (width > this._width || height > this._height) return !1;
                for (var rx = -1, ry = -1, nWidth = this._width, nHeight = this._height, pCellBox = this._cells, y = 0; y < nHeight; y++) if (!(this._rowInfo[y] < width)) for (var x = 0; x < nWidth;) {
                    var tm = 3 * (y * nWidth + x);
                    if (0 != pCellBox[tm] || pCellBox[tm + 1] < width || pCellBox[tm + 2] < height) x += pCellBox[tm + 1]; else {
                        rx = x, ry = y;
                        for (var xx = 0; xx < width; xx++) if (pCellBox[3 * xx + tm + 2] < height) {
                            rx = -1;
                            break
                        }
                        if (!(rx < 0)) return pt.x = rx, pt.y = ry, !0;
                        x += pCellBox[tm + 1]
                    }
                }
                return !1
            }

            _fill(x, y, w, h, type) {
                var nWidth = this._width, nHeghit = this._height;
                this._check(x + w <= nWidth && y + h <= nHeghit);
                for (var yy = y; yy < h + y; ++yy) {
                    this._check(this._rowInfo[yy] >= w), this._rowInfo[yy] -= w;
                    for (var xx = 0; xx < w; xx++) {
                        var tm = 3 * (x + yy * nWidth + xx);
                        this._check(0 == this._cells[tm]), this._cells[tm] = type, this._cells[tm + 1] = w, this._cells[tm + 2] = h
                    }
                }
                if (x > 0) for (yy = 0; yy < h; ++yy) {
                    var s = 0;
                    for (xx = x - 1; xx >= 0 && 0 == this._cells[3 * ((y + yy) * nWidth + xx)]; --xx, ++s) ;
                    for (xx = s; xx > 0; --xx) this._cells[3 * ((y + yy) * nWidth + x - xx) + 1] = xx, this._check(xx > 0)
                }
                if (y > 0) for (xx = x; xx < x + w; ++xx) {
                    for (s = 0, yy = y - 1; yy >= 0 && 0 == this._cells[3 * (xx + yy * nWidth)]; --yy, s++) ;
                    for (yy = s; yy > 0; --yy) this._cells[3 * (xx + (y - yy) * nWidth) + 2] = yy, this._check(yy > 0)
                }
                this._used += w * h / (this._width * this._height)
            }

            _check(ret) {
                0 == ret && console.log("xtexMerger 错误啦")
            }

            _clear() {
                this._texCount = 0;
                for (var y = 0; y < this._height; y++) this._rowInfo[y] = this._width;
                for (var i = 0; i < this._height; i++) for (var j = 0; j < this._width; j++) {
                    var tm = 3 * (i * this._width + j);
                    this._cells[tm] = 0, this._cells[tm + 1] = this._width - j, this._cells[tm + 2] = this._width - i
                }
            }
        }

        class TextTexture extends Resource {
            constructor(textureW, textureH) {
                super(), this._texW = 0, this._texH = 0, this.__destroyed = !1, this._discardTm = 0, this.genID = 0, this.bitmap = {
                    id: 0,
                    _glTexture: null
                }, this.curUsedCovRate = 0, this.curUsedCovRateAtlas = 0, this.lastTouchTm = 0, this.ri = null, this._texW = textureW || TextTexture.gTextRender.atlasWidth, this._texH = textureH || TextTexture.gTextRender.atlasWidth, this.bitmap.id = this.id, this.lock = !0
            }

            recreateResource() {
                if (!this._source) {
                    var gl = LayaGL.instance, glTex = this._source = gl.createTexture();
                    this.bitmap._glTexture = glTex, WebGLContext.bindTexture(gl, gl.TEXTURE_2D, glTex), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._texW, this._texH, 0, gl.RGBA, gl.UNSIGNED_BYTE, null), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), TextTexture.gTextRender.debugUV && this.fillWhite()
                }
            }

            addChar(data, x, y, uv = null) {
                if (TextTexture.gTextRender.isWan1Wan) return this.addCharCanvas(data, x, y, uv);
                !this._source && this.recreateResource();
                var gl = LayaGL.instance;
                WebGLContext.bindTexture(gl, gl.TEXTURE_2D, this._source), !ILaya.Render.isConchApp && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0);
                var u0, v0, u1, v1, dt = data.data;
                return data.data instanceof Uint8ClampedArray && (dt = new Uint8Array(dt.buffer)), gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, data.width, data.height, gl.RGBA, gl.UNSIGNED_BYTE, dt), !ILaya.Render.isConchApp && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), ILaya.Render.isConchApp ? (u0 = x / this._texW, v0 = y / this._texH, u1 = (x + data.width) / this._texW, v1 = (y + data.height) / this._texH) : (u0 = (x + 1) / this._texW, v0 = y / this._texH, u1 = (x + data.width - 1) / this._texW, v1 = (y + data.height - 1) / this._texH), (uv = uv || new Array(8))[0] = u0, uv[1] = v0, uv[2] = u1, uv[3] = v0, uv[4] = u1, uv[5] = v1, uv[6] = u0, uv[7] = v1, uv
            }

            addCharCanvas(canv, x, y, uv = null) {
                !this._source && this.recreateResource();
                var u0, v0, u1, v1, gl = LayaGL.instance;
                return WebGLContext.bindTexture(gl, gl.TEXTURE_2D, this._source), !ILaya.Render.isConchApp && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, gl.RGBA, gl.UNSIGNED_BYTE, canv), !ILaya.Render.isConchApp && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), ILaya.Render.isConchApp ? (u0 = x / this._texW, v0 = y / this._texH, u1 = (x + canv.width) / this._texW, v1 = (y + canv.height) / this._texH) : (u0 = (x + 1) / this._texW, v0 = (y + 1) / this._texH, u1 = (x + canv.width - 1) / this._texW, v1 = (y + canv.height - 1) / this._texH), (uv = uv || new Array(8))[0] = u0, uv[1] = v0, uv[2] = u1, uv[3] = v0, uv[4] = u1, uv[5] = v1, uv[6] = u0, uv[7] = v1, uv
            }

            fillWhite() {
                !this._source && this.recreateResource();
                var gl = LayaGL.instance, dt = new Uint8Array(this._texW * this._texH * 4);
                dt.fill(255), gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this._texW, this._texH, gl.RGBA, gl.UNSIGNED_BYTE, dt)
            }

            discard() {
                this._texW == TextTexture.gTextRender.atlasWidth && this._texH == TextTexture.gTextRender.atlasWidth ? (this.genID++, TextTexture.poolLen >= TextTexture.pool.length && (TextTexture.pool = TextTexture.pool.concat(new Array(10))), this._discardTm = RenderInfo.loopStTm, TextTexture.pool[TextTexture.poolLen++] = this) : this.destroy()
            }

            static getTextTexture(w, h) {
                if (w != TextTexture.gTextRender.atlasWidth || w != TextTexture.gTextRender.atlasWidth) return new TextTexture(w, h);
                if (TextTexture.poolLen > 0) {
                    var ret = TextTexture.pool[--TextTexture.poolLen];
                    return TextTexture.poolLen > 0 && TextTexture.clean(), ret
                }
                return new TextTexture(w, h)
            }

            destroy() {
                this.__destroyed = !0;
                var gl = LayaGL.instance;
                this._source && gl.deleteTexture(this._source), this._source = null
            }

            static clean() {
                var curtm = RenderInfo.loopStTm;
                if (0 === TextTexture.cleanTm && (TextTexture.cleanTm = curtm), curtm - TextTexture.cleanTm >= TextTexture.gTextRender.checkCleanTextureDt) {
                    for (var i = 0; i < TextTexture.poolLen; i++) {
                        var p = TextTexture.pool[i];
                        curtm - p._discardTm >= TextTexture.gTextRender.destroyUnusedTextureDt && (p.destroy(), TextTexture.pool[i] = TextTexture.pool[TextTexture.poolLen - 1], TextTexture.poolLen--, i--)
                    }
                    TextTexture.cleanTm = curtm
                }
            }

            touchRect(ri, curloop) {
                this.lastTouchTm != curloop && (this.curUsedCovRate = 0, this.curUsedCovRateAtlas = 0, this.lastTouchTm = curloop);
                var texw2 = TextTexture.gTextRender.atlasWidth * TextTexture.gTextRender.atlasWidth,
                    gridw2 = ILaya.TextAtlas.atlasGridW * ILaya.TextAtlas.atlasGridW;
                this.curUsedCovRate += ri.bmpWidth * ri.bmpHeight / texw2, this.curUsedCovRateAtlas += Math.ceil(ri.bmpWidth / ILaya.TextAtlas.atlasGridW) * Math.ceil(ri.bmpHeight / ILaya.TextAtlas.atlasGridW) / (texw2 / gridw2)
            }

            get texture() {
                return this
            }

            _getSource() {
                return this._source
            }

            drawOnScreen(x, y) {
            }
        }

        TextTexture.gTextRender = null, TextTexture.pool = new Array(10), TextTexture.poolLen = 0, TextTexture.cleanTm = 0;

        class TextAtlas {
            constructor() {
                this.texWidth = 1024, this.texHeight = 1024, this.protectDist = 1, this.texture = null, this.charMaps = {}, this.texHeight = this.texWidth = ILaya.TextRender.atlasWidth, this.texture = TextTexture.getTextTexture(this.texWidth, this.texHeight), this.texWidth / TextAtlas.atlasGridW > 256 && (TextAtlas.atlasGridW = Math.ceil(this.texWidth / 256)), this.atlasgrid = new AtlasGrid(this.texWidth / TextAtlas.atlasGridW, this.texHeight / TextAtlas.atlasGridW, this.texture.id)
            }

            setProtecteDist(d) {
                this.protectDist = d
            }

            getAEmpty(w, h, pt) {
                var find = this.atlasgrid.addRect(1, Math.ceil(w / TextAtlas.atlasGridW), Math.ceil(h / TextAtlas.atlasGridW), pt);
                return find && (pt.x *= TextAtlas.atlasGridW, pt.y *= TextAtlas.atlasGridW), find
            }

            get usedRate() {
                return this.atlasgrid._used
            }

            destroy() {
                for (var k in this.charMaps) {
                    this.charMaps[k].deleted = !0
                }
                this.texture.discard()
            }

            printDebugInfo() {
            }
        }

        TextAtlas.atlasGridW = 16;

        class Event {
            setTo(type, currentTarget, target) {
                return this.type = type, this.currentTarget = currentTarget, this.target = target, this
            }

            stopPropagation() {
                this._stoped = !0
            }

            get touches() {
                if (!this.nativeEvent) return null;
                var arr = this.nativeEvent.touches;
                if (arr) for (var stage = ILaya.stage, i = 0, n = arr.length; i < n; i++) {
                    var e = arr[i], point = Point.TEMP;
                    point.setTo(e.clientX, e.clientY), stage._canvasTransform.invertTransformPoint(point), stage.transform.invertTransformPoint(point), e.stageX = point.x, e.stageY = point.y
                }
                return arr
            }

            get altKey() {
                return this.nativeEvent.altKey
            }

            get ctrlKey() {
                return this.nativeEvent.ctrlKey
            }

            get shiftKey() {
                return this.nativeEvent.shiftKey
            }

            get charCode() {
                return this.nativeEvent.charCode
            }

            get keyLocation() {
                return this.nativeEvent.location || this.nativeEvent.keyLocation
            }

            get stageX() {
                return ILaya.stage.mouseX
            }

            get stageY() {
                return ILaya.stage.mouseY
            }
        }

        Event.EMPTY = new Event, Event.MOUSE_DOWN = "mousedown", Event.MOUSE_UP = "mouseup", Event.CLICK = "click", Event.RIGHT_MOUSE_DOWN = "rightmousedown", Event.RIGHT_MOUSE_UP = "rightmouseup", Event.RIGHT_CLICK = "rightclick", Event.MOUSE_MOVE = "mousemove", Event.MOUSE_OVER = "mouseover", Event.MOUSE_OUT = "mouseout", Event.MOUSE_WHEEL = "mousewheel", Event.ROLL_OVER = "mouseover", Event.ROLL_OUT = "mouseout", Event.DOUBLE_CLICK = "doubleclick", Event.CHANGE = "change", Event.CHANGED = "changed", Event.RESIZE = "resize", Event.ADDED = "added", Event.REMOVED = "removed", Event.DISPLAY = "display", Event.UNDISPLAY = "undisplay", Event.ERROR = "error", Event.COMPLETE = "complete", Event.LOADED = "loaded", Event.READY = "ready", Event.PROGRESS = "progress", Event.INPUT = "input", Event.RENDER = "render", Event.OPEN = "open", Event.MESSAGE = "message", Event.CLOSE = "close", Event.KEY_DOWN = "keydown", Event.KEY_PRESS = "keypress", Event.KEY_UP = "keyup", Event.FRAME = "enterframe", Event.DRAG_START = "dragstart", Event.DRAG_MOVE = "dragmove", Event.DRAG_END = "dragend", Event.ENTER = "enter", Event.SELECT = "select", Event.BLUR = "blur", Event.FOCUS = "focus", Event.VISIBILITY_CHANGE = "visibilitychange", Event.FOCUS_CHANGE = "focuschange", Event.PLAYED = "played", Event.PAUSED = "paused", Event.STOPPED = "stopped", Event.START = "start", Event.END = "end", Event.COMPONENT_ADDED = "componentadded", Event.COMPONENT_REMOVED = "componentremoved", Event.RELEASED = "released", Event.LINK = "link", Event.LABEL = "label", Event.FULL_SCREEN_CHANGE = "fullscreenchange", Event.DEVICE_LOST = "devicelost", Event.TRANSFORM_CHANGED = "transformchanged", Event.ANIMATION_CHANGED = "animationchanged", Event.TRAIL_FILTER_CHANGE = "trailfilterchange", Event.TRIGGER_ENTER = "triggerenter", Event.TRIGGER_STAY = "triggerstay", Event.TRIGGER_EXIT = "triggerexit";

        class Texture extends EventDispatcher {
            constructor(bitmap = null, uv = null, sourceWidth = 0, sourceHeight = 0) {
                super(), this.uvrect = [0, 0, 1, 1], this._destroyed = !1, this._referenceCount = 0, this.$_GID = 0, this.offsetX = 0, this.offsetY = 0, this._w = 0, this._h = 0, this.sourceWidth = 0, this.sourceHeight = 0, this.url = null, this.scaleRate = 1, this.setTo(bitmap, uv, sourceWidth, sourceHeight)
            }

            static moveUV(offsetX, offsetY, uv) {
                for (var i = 0; i < 8; i += 2) uv[i] += offsetX, uv[i + 1] += offsetY;
                return uv
            }

            static create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0) {
                return Texture._create(source, x, y, width, height, offsetX, offsetY, sourceWidth, sourceHeight)
            }

            static _create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0, outTexture = null) {
                var tex, btex = source instanceof Texture, uv = btex ? source.uv : Texture.DEF_UV,
                    bitmap = btex ? source.bitmap : source;
                bitmap.width && x + width > bitmap.width && (width = bitmap.width - x), bitmap.height && y + height > bitmap.height && (height = bitmap.height - y), outTexture ? (tex = outTexture).setTo(bitmap, null, sourceWidth || width, sourceHeight || height) : tex = new Texture(bitmap, null, sourceWidth || width, sourceHeight || height), tex.width = width, tex.height = height, tex.offsetX = offsetX, tex.offsetY = offsetY;
                var dwidth = 1 / bitmap.width, dheight = 1 / bitmap.height;
                x *= dwidth, y *= dheight, width *= dwidth, height *= dheight;
                var u1 = tex.uv[0], v1 = tex.uv[1], u2 = tex.uv[4], v2 = tex.uv[5], inAltasUVWidth = u2 - u1,
                    inAltasUVHeight = v2 - v1,
                    oriUV = Texture.moveUV(uv[0], uv[1], [x, y, x + width, y, x + width, y + height, x, y + height]);
                tex.uv = new Float32Array([u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight, u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight, u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight, u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight]);
                var bitmapScale = bitmap.scaleRate;
                return bitmapScale && 1 != bitmapScale ? (tex.sourceWidth /= bitmapScale, tex.sourceHeight /= bitmapScale, tex.width /= bitmapScale, tex.height /= bitmapScale, tex.scaleRate = bitmapScale) : tex.scaleRate = 1, tex
            }

            static createFromTexture(texture, x, y, width, height) {
                var texScaleRate = texture.scaleRate;
                1 != texScaleRate && (x *= texScaleRate, y *= texScaleRate, width *= texScaleRate, height *= texScaleRate);
                var rect = Rectangle.TEMP.setTo(x - texture.offsetX, y - texture.offsetY, width, height),
                    result = rect.intersection(Texture._rect1.setTo(0, 0, texture.width, texture.height), Texture._rect2);
                return result ? Texture.create(texture, result.x, result.y, result.width, result.height, result.x - rect.x, result.y - rect.y, width, height) : null
            }

            get uv() {
                return this._uv
            }

            set uv(value) {
                this.uvrect[0] = Math.min(value[0], value[2], value[4], value[6]), this.uvrect[1] = Math.min(value[1], value[3], value[5], value[7]), this.uvrect[2] = Math.max(value[0], value[2], value[4], value[6]) - this.uvrect[0], this.uvrect[3] = Math.max(value[1], value[3], value[5], value[7]) - this.uvrect[1], this._uv = value
            }

            get width() {
                return this._w ? this._w : this.bitmap ? this.uv && this.uv !== Texture.DEF_UV ? (this.uv[2] - this.uv[0]) * this.bitmap.width : this.bitmap.width : 0
            }

            set width(value) {
                this._w = value, this.sourceWidth || (this.sourceWidth = value)
            }

            get height() {
                return this._h ? this._h : this.bitmap ? this.uv && this.uv !== Texture.DEF_UV ? (this.uv[5] - this.uv[1]) * this.bitmap.height : this.bitmap.height : 0
            }

            set height(value) {
                this._h = value, this.sourceHeight || (this.sourceHeight = value)
            }

            get bitmap() {
                return this._bitmap
            }

            set bitmap(value) {
                this._bitmap && this._bitmap._removeReference(this._referenceCount), this._bitmap = value, value && value._addReference(this._referenceCount)
            }

            get destroyed() {
                return this._destroyed
            }

            _addReference() {
                this._bitmap && this._bitmap._addReference(), this._referenceCount++
            }

            _removeReference() {
                this._bitmap && this._bitmap._removeReference(), this._referenceCount--
            }

            _getSource(cb = null) {
                return this._destroyed || !this._bitmap ? null : (this.recoverBitmap(cb), this._bitmap.destroyed ? null : this.bitmap._getSource())
            }

            _onLoaded(complete, context) {
                if (context) if (context == this) ; else if (context instanceof Texture) {
                    var tex = context;
                    Texture._create(context, 0, 0, tex.width, tex.height, 0, 0, tex.sourceWidth, tex.sourceHeight, this)
                } else this.bitmap = context, this.sourceWidth = this._w = context.width, this.sourceHeight = this._h = context.height; else ;
                complete && complete.run(), this.event(Event.READY, this)
            }

            getIsReady() {
                return !this._destroyed && !!this._bitmap
            }

            setTo(bitmap = null, uv = null, sourceWidth = 0, sourceHeight = 0) {
                this.bitmap = bitmap, this.sourceWidth = sourceWidth, this.sourceHeight = sourceHeight, bitmap && (this._w = bitmap.width, this._h = bitmap.height, this.sourceWidth = this.sourceWidth || bitmap.width, this.sourceHeight = this.sourceHeight || bitmap.height), this.uv = uv || Texture.DEF_UV
            }

            load(url, complete = null) {
                this._destroyed || ILaya.loader.load(url, Handler.create(this, this._onLoaded, [complete]), null, "htmlimage", 1, !1, null, !0)
            }

            getTexturePixels(x, y, width, height) {
                var st, dst, i, tex2d = this.bitmap, texw = tex2d.width, texh = tex2d.height;
                if (x + width > texw && (width -= x + width - texw), y + height > texh && (height -= y + height - texh), width <= 0 || height <= 0) return null;
                var wstride = 4 * width, pix = null;
                try {
                    pix = tex2d.getPixels()
                } catch (e) {
                }
                if (pix) {
                    if (0 == x && 0 == y && width == texw && height == texh) return pix;
                    var ret = new Uint8Array(width * height * 4);
                    for (st = 4 * x, dst = (y + height - 1) * (wstride = 4 * texw) + 4 * x, i = height - 1; i >= 0; i--) ret.set(dt.slice(dst, dst + 4 * width), st), st += wstride, dst -= wstride;
                    return ret
                }
                var ctx = new ILaya.Context;
                ctx.size(width, height), ctx.asBitmap = !0;
                var uv = null;
                if (0 != x || 0 != y || width != texw || height != texh) {
                    var stu = (uv = this._uv.slice())[0], stv = uv[1], uk = (uv[2] - stu) / texw,
                        vk = (uv[7] - stv) / texh;
                    uv = [stu + x * uk, stv + y * vk, stu + (x + width) * uk, stv + y * vk, stu + (x + width) * uk, stv + (y + height) * vk, stu + x * uk, stv + (y + height) * vk]
                }
                ctx._drawTextureM(this, 0, 0, width, height, null, 1, uv), ctx._targets.start(), ctx.flush(), ctx._targets.end(), ctx._targets.restore();
                var dt = ctx._targets.getData(0, 0, width, height);
                for (ctx.destroy(), ret = new Uint8Array(width * height * 4), st = 0, dst = (height - 1) * wstride, i = height - 1; i >= 0; i--) ret.set(dt.slice(dst, dst + wstride), st), st += wstride, dst -= wstride;
                return ret
            }

            getPixels(x, y, width, height) {
                return window.conch ? this._nativeObj.getImageData(x, y, width, height) : this.getTexturePixels(x, y, width, height)
            }

            recoverBitmap(onok = null) {
                var url = this._bitmap.url;
                this._destroyed || this._bitmap && !this._bitmap.destroyed || !url || ILaya.loader.load(url, Handler.create(this, function (bit) {
                    this.bitmap = bit, onok && onok()
                }), null, "htmlimage", 1, !1, null, !0)
            }

            disposeBitmap() {
                !this._destroyed && this._bitmap && this._bitmap.destroy()
            }

            destroy(force = !1) {
                if (!this._destroyed) {
                    this._destroyed = !0;
                    var bit = this._bitmap;
                    bit && (bit._removeReference(this._referenceCount), (0 === bit.referenceCount || force) && bit.destroy(), bit = null), this.url && this === ILaya.loader.getRes(this.url) && ILaya.loader.clearRes(this.url)
                }
            }
        }

        Texture.DEF_UV = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), Texture.NO_UV = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0]), Texture.INV_UV = new Float32Array([0, 1, 1, 1, 1, 0, 0, 0]), Texture._rect1 = new Rectangle, Texture._rect2 = new Rectangle;

        class FontInfo {
            constructor(font) {
                this._font = "14px Arial", this._family = "Arial", this._size = 14, this._italic = !1, this._bold = !1, this._id = FontInfo._gfontID++, this.setFont(font || this._font)
            }

            static Parse(font) {
                if (font === FontInfo._lastFont) return FontInfo._lastFontInfo;
                var r = FontInfo._cache[font];
                return r || (r = FontInfo._cache[font] = new FontInfo(font)), FontInfo._lastFont = font, FontInfo._lastFontInfo = r, r
            }

            setFont(value) {
                this._font = value;
                var _words = value.split(" "), l = _words.length;
                if (l < 2) 1 == l && _words[0].indexOf("px") > 0 && (this._size = parseInt(_words[0])); else {
                    for (var szpos = -1, i = 0; i < l; i++) if (_words[i].indexOf("px") > 0 || _words[i].indexOf("pt") > 0) {
                        szpos = i, this._size = parseInt(_words[i]), this._size <= 0 && (console.error("font parse error:" + value), this._size = 14);
                        break
                    }
                    var fpos = szpos + 1, familys = _words[fpos];
                    for (fpos++; fpos < l; fpos++) familys += " " + _words[fpos];
                    this._family = familys.split(",")[0], this._italic = _words.indexOf("italic") >= 0, this._bold = _words.indexOf("bold") >= 0
                }
            }
        }

        FontInfo.EMPTY = new FontInfo(null), FontInfo._cache = {}, FontInfo._gfontID = 0, FontInfo._lastFont = "";

        class WordText {
            constructor() {
                this.save = [], this.toUpperCase = null, this.width = -1, this.pageChars = [], this.startID = 0, this.startIDStroke = 0, this.lastGCCnt = 0, this.splitRender = !1
            }

            setText(txt) {
                this.changed = !0, this._text = txt, this.width = -1, this.cleanCache()
            }

            toString() {
                return this._text
            }

            get length() {
                return this._text ? this._text.length : 0
            }

            charCodeAt(i) {
                return this._text ? this._text.charCodeAt(i) : NaN
            }

            charAt(i) {
                return this._text ? this._text.charAt(i) : null
            }

            cleanCache() {
                this.pageChars.forEach(function (p) {
                    var tex = p.tex;
                    p.words;
                    1 == p.words.length && tex && tex.ri && tex.destroy()
                }), this.pageChars = [], this.startID = 0
            }
        }

        class CharRenderInfo {
            constructor() {
                this.char = "", this.deleted = !1, this.uv = new Array(8), this.pos = 0, this.orix = 0, this.oriy = 0, this.touchTick = 0, this.isSpace = !1
            }

            touch() {
                var curLoop = RenderInfo.loopCount;
                this.touchTick != curLoop && this.tex.touchRect(this, curLoop), this.touchTick = curLoop
            }
        }

        class ICharRender {
            constructor() {
                this.fontsz = 16
            }

            getWidth(font, str) {
                return 0
            }

            scale(sx, sy) {
            }

            get canvasWidth() {
                return 0
            }

            set canvasWidth(w) {
            }

            getCharBmp(char, font, lineWidth, colStr, strokeColStr, size, margin_left, margin_top, margin_right, margin_bottom, rect = null) {
                return null
            }
        }

        class Browser {
            static __init__() {
                var Laya = window.Laya || ILaya.Laya;
                if (Browser._window) return Browser._window;
                var win = Browser._window = window, doc = Browser._document = win.document,
                    u = Browser.userAgent = win.navigator.userAgent;
                u.indexOf("AlipayMiniGame") > -1 && "my" in Browser.window && (window.aliMiniGame(Laya, Laya), window.aliPayMiniGame(Laya, Laya), Laya.ALIMiniAdapter ? Laya.ALIMiniAdapter.enable() : console.error("请先添加阿里小游戏适配库")), -1 == u.indexOf("OPPO") && u.indexOf("MiniGame") > -1 && "wx" in Browser.window && ("qq" in Browser.window ? (window.qqMiniGame(Laya, Laya), Laya.QQMiniAdapter ? Laya.QQMiniAdapter.enable() : console.error("请引入手机QQ小游戏的适配库：https://ldc2.layabox.com/doc/?nav=zh-ts-5-0-0")) : (window.wxMiniGame(Laya, Laya), Laya.MiniAdpter ? Laya.MiniAdpter.enable() : console.error("请先添加小游戏适配库,详细教程：https://ldc2.layabox.com/doc/?nav=zh-ts-5-0-0"))), u.indexOf("SwanGame") > -1 && (window.bdMiniGame(Laya, Laya), Laya.BMiniAdapter ? Laya.BMiniAdapter.enable() : console.error("请先添加百度小游戏适配库,详细教程：https://ldc2.layabox.com/doc/?nav=zh-ts-5-0-0")), u.indexOf("QuickGame") > -1 && (window.miMiniGame(Laya, Laya), Laya.KGMiniAdapter ? Laya.KGMiniAdapter.enable() : console.error("请先添加小米小游戏适配库,详细教程：https://ldc2.layabox.com/doc/?nav=zh-ts-5-0-0")), u.indexOf("OPPO") > -1 && u.indexOf("MiniGame") > -1 && (window.qgMiniGame(Laya, Laya), Laya.QGMiniAdapter ? Laya.QGMiniAdapter.enable() : console.error("请先添加OPPO小游戏适配库")), u.indexOf("VVGame") > -1 && (window.vvMiniGame(Laya, Laya), Laya.VVMiniAdapter ? Laya.VVMiniAdapter.enable() : console.error("请先添加VIVO小游戏适配库")), win.trace = console.log, win.requestAnimationFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function (fun) {
                    return win.setTimeout(fun, 1e3 / 60)
                };
                var bodyStyle = doc.body.style;
                bodyStyle.margin = 0, bodyStyle.overflow = "hidden", bodyStyle["-webkit-user-select"] = "none", bodyStyle["-webkit-tap-highlight-color"] = "rgba(200,200,200,0)";
                for (var metas = doc.getElementsByTagName("meta"), i = 0, flag = !1, content = "width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"; i < metas.length;) {
                    var meta = metas[i];
                    if ("viewport" == meta.name) {
                        meta.content = content, flag = !0;
                        break
                    }
                    i++
                }
                return flag || ((meta = doc.createElement("meta")).name = "viewport", meta.content = content, doc.getElementsByTagName("head")[0].appendChild(meta)), Browser.onMobile = !!window.isConchApp || u.indexOf("Mobile") > -1, Browser.onIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), Browser.onIPhone = u.indexOf("iPhone") > -1, Browser.onMac = u.indexOf("Mac OS X") > -1, Browser.onIPad = u.indexOf("iPad") > -1, Browser.onAndroid = u.indexOf("Android") > -1 || u.indexOf("Adr") > -1, Browser.onWP = u.indexOf("Windows Phone") > -1, Browser.onQQBrowser = u.indexOf("QQBrowser") > -1, Browser.onMQQBrowser = u.indexOf("MQQBrowser") > -1 || u.indexOf("Mobile") > -1 && u.indexOf("QQ") > -1, Browser.onIE = !!win.ActiveXObject || "ActiveXObject" in win, Browser.onWeiXin = u.indexOf("MicroMessenger") > -1, Browser.onSafari = u.indexOf("Safari") > -1, Browser.onPC = !Browser.onMobile, Browser.onMiniGame = u.indexOf("MiniGame") > -1, Browser.onBDMiniGame = u.indexOf("SwanGame") > -1, Browser.onLayaRuntime = !!Browser.window.conch, u.indexOf("OPPO") > -1 && u.indexOf("MiniGame") > -1 ? (Browser.onQGMiniGame = !0, Browser.onMiniGame = !1) : "qq" in Browser.window && u.indexOf("MiniGame") > -1 && (Browser.onQQMiniGame = !0, Browser.onMiniGame = !1), Browser.onVVMiniGame = u.indexOf("VVGame") > -1, Browser.onKGMiniGame = u.indexOf("QuickGame") > -1, u.indexOf("AlipayMiniGame") > -1 && (Browser.onAlipayMiniGame = !0, Browser.onMiniGame = !1), win
            }

            static createElement(type) {
                return Browser.__init__(), Browser._document.createElement(type)
            }

            static getElementById(type) {
                return Browser.__init__(), Browser._document.getElementById(type)
            }

            static removeElement(ele) {
                ele && ele.parentNode && ele.parentNode.removeChild(ele)
            }

            static now() {
                return Date.now()
            }

            static get clientWidth() {
                return Browser.__init__(), Browser._window.innerWidth || Browser._document.body.clientWidth
            }

            static get clientHeight() {
                return Browser.__init__(), Browser._window.innerHeight || Browser._document.body.clientHeight || Browser._document.documentElement.clientHeight
            }

            static get width() {
                return Browser.__init__(), (ILaya.stage && ILaya.stage.canvasRotation ? Browser.clientHeight : Browser.clientWidth) * Browser.pixelRatio
            }

            static get height() {
                return Browser.__init__(), (ILaya.stage && ILaya.stage.canvasRotation ? Browser.clientWidth : Browser.clientHeight) * Browser.pixelRatio
            }

            static get pixelRatio() {
                return Browser._pixelRatio < 0 && (Browser.__init__(), Browser.userAgent.indexOf("Mozilla/6.0(Linux; Android 6.0; HUAWEI NXT-AL10 Build/HUAWEINXT-AL10)") > -1 ? Browser._pixelRatio = 2 : (Browser._pixelRatio = Browser._window.devicePixelRatio || 1, Browser._pixelRatio < 1 && (Browser._pixelRatio = 1))), Browser._pixelRatio
            }

            static get container() {
                return Browser._container || (Browser.__init__(), Browser._container = Browser.createElement("div"), Browser._container.id = "layaContainer", Browser._document.body.appendChild(Browser._container)), Browser._container
            }

            static set container(value) {
                Browser._container = value
            }

            static get window() {
                return Browser._window || Browser.__init__()
            }

            static get document() {
                return Browser.__init__(), Browser._document
            }
        }

        Browser._pixelRatio = -1, Browser.mainCanvas = null, Browser.hanzi = new RegExp("^[一-龥]$"), Browser.fontMap = [], Browser.measureText = function (txt, font) {
            var isChinese = Browser.hanzi.test(txt);
            if (isChinese && Browser.fontMap[font]) return Browser.fontMap[font];
            var ctx = Browser.context;
            ctx.font = font;
            var r = ctx.measureText(txt);
            return isChinese && (Browser.fontMap[font] = r), r
        };

        class CharRender_Canvas extends ICharRender {
            constructor(maxw, maxh, scalefont = !0, useImageData = !0, showdbg = !1) {
                super(), this.ctx = null, this.lastScaleX = 1, this.lastScaleY = 1, this.needResetScale = !1, this.maxTexW = 0, this.maxTexH = 0, this.scaleFontSize = !0, this.showDbgInfo = !1, this.supportImageData = !0, this.maxTexW = maxw, this.maxTexH = maxh, this.scaleFontSize = scalefont, this.supportImageData = useImageData, this.showDbgInfo = showdbg, CharRender_Canvas.canvas || (CharRender_Canvas.canvas = Browser.createElement("canvas"), CharRender_Canvas.canvas.width = 1024, CharRender_Canvas.canvas.height = 512, CharRender_Canvas.canvas.style.left = "-10000px", CharRender_Canvas.canvas.style.position = "absolute", document.body.appendChild(CharRender_Canvas.canvas), this.ctx = CharRender_Canvas.canvas.getContext("2d"))
            }

            get canvasWidth() {
                return CharRender_Canvas.canvas.width
            }

            set canvasWidth(w) {
                CharRender_Canvas.canvas.width != w && (CharRender_Canvas.canvas.width = w, w > 2048 && console.warn("画文字设置的宽度太大，超过2048了"), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.scale(this.lastScaleX, this.lastScaleY))
            }

            getWidth(font, str) {
                return this.ctx ? (this.ctx._lastFont != font && (this.ctx.font = font, this.ctx._lastFont = font), this.ctx.measureText(str).width) : 0
            }

            scale(sx, sy) {
                if (!this.supportImageData) return this.lastScaleX = sx, void (this.lastScaleY = sy);
                this.lastScaleX == sx && this.lastScaleY == sy || (this.ctx.setTransform(sx, 0, 0, sy, 0, 0), this.lastScaleX = sx, this.lastScaleY = sy)
            }

            getCharBmp(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom, rect = null) {
                if (!this.supportImageData) return this.getCharCanvas(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom);
                var ctx = this.ctx, sz = this.fontsz;
                ctx.font != font && (ctx.font = font, ctx._lastFont = font), cri.width = ctx.measureText(char).width;
                var w = cri.width * this.lastScaleX, h = cri.height * this.lastScaleY;
                w += (margin_left + margin_right) * this.lastScaleX, h += (margin_top + margin_bottom) * this.lastScaleY, w = Math.ceil(w), h = Math.ceil(h);
                var clearW = (w = Math.min(w, CharRender_Canvas.canvas.width)) + 2 * lineWidth + 1,
                    clearH = (h = Math.min(h, CharRender_Canvas.canvas.height)) + 2 * lineWidth + 1;
                rect && (clearW = Math.max(clearW, rect[0] + rect[2] + 1), clearH = Math.max(clearH, rect[1] + rect[3] + 1)), ctx.clearRect(0, 0, clearW, clearH), ctx.save(), ctx.textBaseline = "middle", lineWidth > 0 && (ctx.strokeStyle = strokeColStr, ctx.lineWidth = lineWidth, ctx.strokeText(char, margin_left, margin_top + sz / 2)), colStr && (ctx.fillStyle = colStr, ctx.fillText(char, margin_left, margin_top + sz / 2)), this.showDbgInfo && (ctx.strokeStyle = "#ff0000", ctx.strokeRect(1, 1, w - 2, h - 2), ctx.strokeStyle = "#00ff00", ctx.strokeRect(margin_left, margin_top, cri.width, cri.height)), rect && -1 == rect[2] && (rect[2] = Math.ceil((cri.width + 2 * lineWidth) * this.lastScaleX));
                var imgdt = rect ? ctx.getImageData(rect[0], rect[1], rect[2], rect[3]) : ctx.getImageData(0, 0, w, h);
                return ctx.restore(), cri.bmpWidth = imgdt.width, cri.bmpHeight = imgdt.height, imgdt
            }

            getCharCanvas(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom) {
                var ctx = this.ctx;
                ctx.font != font && (ctx.font = font, ctx._lastFont = font), cri.width = ctx.measureText(char).width;
                var w = cri.width * this.lastScaleX, h = cri.height * this.lastScaleY;
                w += (margin_left + margin_right) * this.lastScaleX, h += (margin_top + margin_bottom) * this.lastScaleY + 1, w = Math.min(w, this.maxTexW), h = Math.min(h, this.maxTexH), CharRender_Canvas.canvas.width = Math.min(w + 1, this.maxTexW), CharRender_Canvas.canvas.height = Math.min(h + 1, this.maxTexH), ctx.font = font, ctx.clearRect(0, 0, w + 1 + lineWidth, h + 1 + lineWidth), ctx.setTransform(1, 0, 0, 1, 0, 0), ctx.save(), this.scaleFontSize && ctx.scale(this.lastScaleX, this.lastScaleY), ctx.translate(margin_left, margin_top), ctx.textAlign = "left";
                var sz = this.fontsz;
                return ctx.textBaseline = "middle", lineWidth > 0 ? (ctx.strokeStyle = strokeColStr, ctx.fillStyle = colStr, ctx.lineWidth = lineWidth, ctx.fillAndStrokeText ? ctx.fillAndStrokeText(char, 0, sz / 2) : (ctx.strokeText(char, 0, sz / 2), ctx.fillText(char, 0, sz / 2))) : colStr && (ctx.fillStyle = colStr, ctx.fillText(char, 0, sz / 2)), this.showDbgInfo && (ctx.strokeStyle = "#ff0000", ctx.strokeRect(0, 0, w, h), ctx.strokeStyle = "#00ff00", ctx.strokeRect(0, 0, cri.width, cri.height)), ctx.restore(), cri.bmpWidth = CharRender_Canvas.canvas.width, cri.bmpHeight = CharRender_Canvas.canvas.height, CharRender_Canvas.canvas
            }
        }

        CharRender_Canvas.canvas = null;

        class CharRender_Native extends ICharRender {
            constructor() {
                super(), this.lastFont = ""
            }

            getWidth(font, str) {
                return window.conchTextCanvas ? (window.conchTextCanvas.font = font, this.lastFont = font, window.conchTextCanvas.measureText(str).width) : 0
            }

            scale(sx, sy) {
            }

            getCharBmp(char, font, lineWidth, colStr, strokeColStr, size, margin_left, margin_top, margin_right, margin_bottom, rect = null) {
                if (!window.conchTextCanvas) return null;
                window.conchTextCanvas.font = font, this.lastFont = font;
                size.width = window.conchTextCanvas.measureText(char).width, size.height;
                var nStrokeColor = ColorUtils.create(strokeColStr).numColor,
                    nTextColor = ColorUtils.create(colStr).numColor,
                    textInfo = window.conchTextCanvas.getTextBitmapData(char, nTextColor, lineWidth > 2 ? 2 : lineWidth, nStrokeColor);
                return size.bmpWidth = textInfo.width, size.bmpHeight = textInfo.height, textInfo
            }
        }

        class TextRender {
            constructor() {
                this.fontSizeInfo = {}, this.charRender = null, this.mapFont = {}, this.fontID = 0, this.mapColor = [], this.colorID = 0, this.fontScaleX = 1, this.fontScaleY = 1, this._curStrPos = 0, this.textAtlases = [], this.isoTextures = [], this.lastFont = null, this.fontSizeW = 0, this.fontSizeH = 0, this.fontSizeOffX = 0, this.fontSizeOffY = 0, this.renderPerChar = !0, this.tmpAtlasPos = new Point, this.textureMem = 0, ILaya.TextAtlas = TextAtlas;
                var bugIOS = !1, miniadp = ILaya.Laya.MiniAdpter;
                miniadp && miniadp.systemInfo && miniadp.systemInfo.system && (bugIOS = "ios 10.1.1" === miniadp.systemInfo.system.toLowerCase()), ILaya.Browser.onMiniGame && !bugIOS && (TextRender.isWan1Wan = !0), this.charRender = ILaya.Render.isConchApp ? new CharRender_Native : new CharRender_Canvas(TextRender.atlasWidth, TextRender.atlasWidth, TextRender.scaleFontWithCtx, !TextRender.isWan1Wan, !1), TextRender.textRenderInst = this, ILaya.Laya.textRender = this, TextRender.atlasWidth2 = TextRender.atlasWidth * TextRender.atlasWidth
            }

            setFont(font) {
                if (this.lastFont != font) {
                    this.lastFont = font;
                    var fontsz = this.getFontSizeInfo(font._family), offx = fontsz >> 24, offy = fontsz >> 16 & 255,
                        fw = fontsz >> 8 & 255, fh = 255 & fontsz, k = font._size / TextRender.standardFontSize;
                    this.fontSizeOffX = Math.ceil(offx * k), this.fontSizeOffY = Math.ceil(offy * k), this.fontSizeW = Math.ceil(fw * k), this.fontSizeH = Math.ceil(fh * k), font._font.indexOf("italic") >= 0 ? this.fontStr = font._font.replace("italic", "") : this.fontStr = font._font
                }
            }

            getNextChar(str) {
                var len = str.length, start = this._curStrPos;
                if (start >= len) return null;
                for (var i = start, state = 0; i < len; i++) {
                    var c = str.charCodeAt(i);
                    if (c >>> 11 == 27) {
                        if (1 == state) break;
                        state = 1, i++
                    } else if (65038 === c || 65039 === c) ; else if (8205 == c) state = 2; else if (0 == state) state = 1; else if (1 == state) break
                }
                return this._curStrPos = i, str.substring(start, i)
            }

            filltext(ctx, data, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine = 0) {
                if (!(data.length <= 0)) {
                    var font = FontInfo.Parse(fontStr), nTextAlign = 0;
                    switch (textAlign) {
                        case"center":
                            nTextAlign = ILaya.Context.ENUM_TEXTALIGN_CENTER;
                            break;
                        case"right":
                            nTextAlign = ILaya.Context.ENUM_TEXTALIGN_RIGHT
                    }
                    this._fast_filltext(ctx, data, null, x, y, font, color, strokeColor, lineWidth, nTextAlign, underLine)
                }
            }

            fillWords(ctx, data, x, y, fontStr, color, strokeColor, lineWidth) {
                if (data && !(data.length <= 0)) {
                    var font = FontInfo.Parse(fontStr);
                    this._fast_filltext(ctx, null, data, x, y, font, color, strokeColor, lineWidth, 0, 0)
                }
            }

            _fast_filltext(ctx, data, htmlchars, x, y, font, color, strokeColor, lineWidth, textAlign, underLine = 0) {
                if (!(data && data.length < 1 || htmlchars && htmlchars.length < 1)) {
                    if (lineWidth < 0 && (lineWidth = 0), this.setFont(font), this.fontScaleX = this.fontScaleY = 1, !ILaya.Render.isConchApp && TextRender.scaleFontWithCtx) {
                        var sx = 1, sy = 1;
                        if (ILaya.Render.isConchApp ? (sx = ctx._curMat.getScaleX(), sy = ctx._curMat.getScaleY()) : (sx = ctx.getMatScaleX(), sy = ctx.getMatScaleY()), sx < 1e-4 || sy < .1) return;
                        sx > 1 && (this.fontScaleX = sx), sy > 1 && (this.fontScaleY = sy)
                    }
                    font._italic && (ctx._italicDeg = 13);
                    var wt = data, isWT = !htmlchars && data instanceof WordText, str = data, isHtmlChar = !!htmlchars,
                        sameTexData = isWT ? wt.pageChars : [], strWidth = 0;
                    switch (isWT ? (str = wt._text, (strWidth = wt.width) < 0 && (strWidth = wt.width = this.charRender.getWidth(this.fontStr, str))) : strWidth = str ? this.charRender.getWidth(this.fontStr, str) : 0, textAlign) {
                        case ILaya.Context.ENUM_TEXTALIGN_CENTER:
                            x -= strWidth / 2;
                            break;
                        case ILaya.Context.ENUM_TEXTALIGN_RIGHT:
                            x -= strWidth
                    }
                    wt && sameTexData && this.hasFreedText(sameTexData) && (sameTexData = wt.pageChars = []);
                    var ri = null,
                        splitTex = this.renderPerChar = !isWT || TextRender.forceSplitRender || isHtmlChar || isWT && wt.splitRender;
                    if (!sameTexData || sameTexData.length < 1) if (splitTex) {
                        var curstr, stx = 0, sty = 0;
                        for (this._curStrPos = 0; ;) {
                            if (isHtmlChar) {
                                var chc = htmlchars[this._curStrPos++];
                                chc ? (curstr = chc.char, stx = chc.x, sty = chc.y) : curstr = null
                            } else curstr = this.getNextChar(str);
                            if (!curstr) break;
                            if (!(ri = this.getCharRenderInfo(curstr, font, color, strokeColor, lineWidth, !1))) break;
                            if (ri.isSpace) ; else {
                                var add = sameTexData[ri.tex.id];
                                if (add) add = add.words; else {
                                    var o1 = {texgen: ri.tex.genID, tex: ri.tex, words: []};
                                    sameTexData[ri.tex.id] = o1, add = o1.words
                                }
                                ILaya.Render.isConchApp ? add.push({
                                    ri: ri,
                                    x: stx,
                                    y: sty,
                                    w: ri.bmpWidth / this.fontScaleX,
                                    h: ri.bmpHeight / this.fontScaleY
                                }) : add.push({
                                    ri: ri,
                                    x: stx + 1 / this.fontScaleX,
                                    y: sty,
                                    w: (ri.bmpWidth - 2) / this.fontScaleX,
                                    h: (ri.bmpHeight - 1) / this.fontScaleY
                                }), stx += ri.width
                            }
                        }
                    } else {
                        var isotex = TextRender.noAtlas || strWidth * this.fontScaleX > TextRender.atlasWidth;
                        ri = this.getCharRenderInfo(str, font, color, strokeColor, lineWidth, isotex), ILaya.Render.isConchApp ? sameTexData[0] = {
                            texgen: ri.tex.genID,
                            tex: ri.tex,
                            words: [{
                                ri: ri,
                                x: 0,
                                y: 0,
                                w: ri.bmpWidth / this.fontScaleX,
                                h: ri.bmpHeight / this.fontScaleY
                            }]
                        } : sameTexData[0] = {
                            texgen: ri.tex.genID,
                            tex: ri.tex,
                            words: [{
                                ri: ri,
                                x: 1 / this.fontScaleX,
                                y: 0 / this.fontScaleY,
                                w: (ri.bmpWidth - 2) / this.fontScaleX,
                                h: (ri.bmpHeight - 1) / this.fontScaleY
                            }]
                        }
                    }
                    this._drawResortedWords(ctx, x, y, sameTexData), ctx._italicDeg = 0
                }
            }

            _drawResortedWords(ctx, startx, starty, samePagesData) {
                for (var isLastRender = ctx._charSubmitCache && ctx._charSubmitCache._enbale, mat = ctx._curMat, slen = samePagesData.length, id = 0; id < slen; id++) {
                    var dt = samePagesData[id];
                    if (dt) {
                        var pri = dt.words, pisz = pri.length;
                        if (!(pisz <= 0)) for (var tex = samePagesData[id].tex, j = 0; j < pisz; j++) {
                            var riSaved = pri[j], ri = riSaved.ri;
                            if (!ri.isSpace) {
                                if (ri.touch(), ctx.drawTexAlign = !0, ILaya.Render.isConchApp) ctx._drawTextureM(tex.texture, startx + riSaved.x - ri.orix, starty + riSaved.y - ri.oriy, riSaved.w, riSaved.h, null, 1, ri.uv); else {
                                    let t = tex;
                                    ctx._inner_drawTexture(t.texture, t.id, startx + riSaved.x - ri.orix, starty + riSaved.y - ri.oriy, riSaved.w, riSaved.h, mat, ri.uv, 1, isLastRender)
                                }
                                ctx.touches && ctx.touches.push(ri)
                            }
                        }
                    }
                }
            }

            hasFreedText(txts) {
                for (var sz = txts.length, i = 0; i < sz; i++) {
                    var pri = txts[i];
                    if (pri) {
                        var tex = pri.tex;
                        if (tex.__destroyed || tex.genID != pri.texgen) return !0
                    }
                }
                return !1
            }

            getCharRenderInfo(str, font, color, strokeColor, lineWidth, isoTexture = !1) {
                var fid = this.mapFont[font._family];
                null == fid && (this.mapFont[font._family] = fid = this.fontID++);
                var key = str + "_" + fid + "_" + font._size + "_" + color;
                lineWidth > 0 && (key += "_" + strokeColor + lineWidth), font._bold && (key += "P"), 1 == this.fontScaleX && 1 == this.fontScaleY || (key += (20 * this.fontScaleX | 0) + "_" + (20 * this.fontScaleY | 0));
                var i = 0, sz = this.textAtlases.length, ri = null, atlas = null;
                if (!isoTexture) for (i = 0; i < sz; i++) if (ri = (atlas = this.textAtlases[i]).charMaps[key]) return ri.touch(), ri;
                ri = new CharRenderInfo, this.charRender.scale(this.fontScaleX, this.fontScaleY), ri.char = str, ri.height = font._size;
                var margin = ILaya.Render.isConchApp ? 0 : font._size / 3 | 0, imgdt = null,
                    w1 = Math.ceil(this.charRender.getWidth(this.fontStr, str) * this.fontScaleX);
                if (w1 > this.charRender.canvasWidth && (this.charRender.canvasWidth = Math.min(2048, w1 + 2 * margin)), isoTexture) {
                    this.charRender.fontsz = font._size, imgdt = this.charRender.getCharBmp(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin, null);
                    var tex = TextTexture.getTextTexture(imgdt.width, imgdt.height);
                    tex.addChar(imgdt, 0, 0, ri.uv), ri.tex = tex, ri.orix = margin, ri.oriy = margin, tex.ri = ri, this.isoTextures.push(tex)
                } else {
                    var len = str.length, lineExt = 1 * lineWidth,
                        fw = Math.ceil((this.fontSizeW + 2 * lineExt) * this.fontScaleX),
                        fh = Math.ceil((this.fontSizeH + 2 * lineExt) * this.fontScaleY);
                    TextRender.imgdtRect[0] = (margin - this.fontSizeOffX - lineExt) * this.fontScaleX | 0, TextRender.imgdtRect[1] = (margin - this.fontSizeOffY - lineExt) * this.fontScaleY | 0, this.renderPerChar || 1 == len ? (TextRender.imgdtRect[2] = Math.max(w1, fw), TextRender.imgdtRect[3] = Math.max(w1, fh)) : (TextRender.imgdtRect[2] = -1, TextRender.imgdtRect[3] = fh), this.charRender.fontsz = font._size, imgdt = this.charRender.getCharBmp(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin, TextRender.imgdtRect), atlas = this.addBmpData(imgdt, ri), TextRender.isWan1Wan ? (ri.orix = margin, ri.oriy = margin) : (ri.orix = this.fontSizeOffX + lineExt, ri.oriy = this.fontSizeOffY + lineExt), atlas.charMaps[key] = ri
                }
                return ri
            }

            addBmpData(data, ri) {
                for (var w = data.width, h = data.height, sz = this.textAtlases.length, atlas = null, find = !1, i = 0; i < sz && !(find = (atlas = this.textAtlases[i]).getAEmpty(w, h, this.tmpAtlasPos)); i++) ;
                if (!find) {
                    if (atlas = new TextAtlas, this.textAtlases.push(atlas), !(find = atlas.getAEmpty(w, h, this.tmpAtlasPos))) throw"err1";
                    this.cleanAtlases()
                }
                return find && (atlas.texture.addChar(data, this.tmpAtlasPos.x, this.tmpAtlasPos.y, ri.uv), ri.tex = atlas.texture), atlas
            }

            GC() {
                for (var i = 0, sz = this.textAtlases.length, destroyDt = TextRender.destroyAtlasDt, totalUsedRateAtlas = 0, curloop = RenderInfo.loopCount, maxWasteRateID = -1, maxWasteRate = 0, tex = null, curatlas = null; i < sz; i++) {
                    if (tex = (curatlas = this.textAtlases[i]).texture) {
                        tex.curUsedCovRate, totalUsedRateAtlas += tex.curUsedCovRateAtlas;
                        var waste = curatlas.usedRate - tex.curUsedCovRateAtlas;
                        maxWasteRate < waste && (maxWasteRate = waste, maxWasteRateID = i)
                    }
                    curloop - curatlas.texture.lastTouchTm > destroyDt && (TextRender.showLog && console.log(curatlas.texture.id), curatlas.destroy(), this.textAtlases[i] = this.textAtlases[sz - 1], sz--, i--, maxWasteRateID = -1)
                }
                for (this.textAtlases.length = sz, sz = this.isoTextures.length, i = 0; i < sz; i++) curloop - (tex = this.isoTextures[i]).lastTouchTm > TextRender.destroyUnusedTextureDt && (tex.ri.deleted = !0, tex.ri.tex = null, tex.destroy(), this.isoTextures[i] = this.isoTextures[sz - 1], sz--, i--);
                this.isoTextures.length = sz;
                var needGC = this.textAtlases.length > 1 && this.textAtlases.length - totalUsedRateAtlas >= 2;
                (TextRender.atlasWidth * TextRender.atlasWidth * 4 * this.textAtlases.length > TextRender.cleanMem || needGC || TextRender.simClean) && (TextRender.simClean = !1, TextRender.showLog && console.log("清理使用率低的贴图。总使用率:", totalUsedRateAtlas, ":", this.textAtlases.length, "最差贴图:" + maxWasteRateID), maxWasteRateID >= 0 && ((curatlas = this.textAtlases[maxWasteRateID]).destroy(), this.textAtlases[maxWasteRateID] = this.textAtlases[this.textAtlases.length - 1], this.textAtlases.length = this.textAtlases.length - 1)), TextTexture.clean()
            }

            cleanAtlases() {
            }

            getCharBmp(c) {
            }

            checkBmpLine(data, l, sx, ex) {
                this.bmpData32.buffer != data.data.buffer && (this.bmpData32 = new Uint32Array(data.data.buffer));
                for (var stpos = data.width * l + sx, x = sx; x < ex; x++) if (0 != this.bmpData32[stpos++]) return !0;
                return !1
            }

            updateBbx(data, curbbx, onlyH = !1) {
                var w = data.width, h = data.height, x = 0, sy = curbbx[1], ey = 0, y = sy;
                if (this.checkBmpLine(data, sy, 0, w)) for (; ;) {
                    if ((y = (sy + ey) / 2 | 0) + 1 >= sy) {
                        curbbx[1] = y;
                        break
                    }
                    this.checkBmpLine(data, y, 0, w) ? sy = y : ey = y
                }
                if (curbbx[3] > h) curbbx[3] = h; else if (y = sy = curbbx[3], ey = h, this.checkBmpLine(data, sy, 0, w)) for (; ;) {
                    if ((y = (sy + ey) / 2 | 0) - 1 <= sy) {
                        curbbx[3] = y;
                        break
                    }
                    this.checkBmpLine(data, y, 0, w) ? sy = y : ey = y
                }
                if (!onlyH) {
                    var minx = curbbx[0], stpos = w * curbbx[1];
                    for (y = curbbx[1]; y < curbbx[3]; y++) {
                        for (x = 0; x < minx; x++) if (0 != this.bmpData32[stpos + x]) {
                            minx = x;
                            break
                        }
                        stpos += w
                    }
                    curbbx[0] = minx;
                    var maxx = curbbx[2];
                    for (stpos = w * curbbx[1], y = curbbx[1]; y < curbbx[3]; y++) {
                        for (x = maxx; x < w; x++) if (0 != this.bmpData32[stpos + x]) {
                            maxx = x;
                            break
                        }
                        stpos += w
                    }
                    curbbx[2] = maxx
                }
            }

            getFontSizeInfo(font) {
                var finfo = this.fontSizeInfo[font];
                if (null != finfo) return finfo;
                var fontstr = "bold " + TextRender.standardFontSize + "px " + font;
                if (TextRender.isWan1Wan) {
                    this.fontSizeW = 1.5 * this.charRender.getWidth(fontstr, "有"), this.fontSizeH = 1.5 * TextRender.standardFontSize;
                    var szinfo = this.fontSizeW << 8 | this.fontSizeH;
                    return this.fontSizeInfo[font] = szinfo, szinfo
                }
                TextRender.pixelBBX[0] = TextRender.standardFontSize / 2, TextRender.pixelBBX[1] = TextRender.standardFontSize / 2, TextRender.pixelBBX[2] = TextRender.standardFontSize, TextRender.pixelBBX[3] = TextRender.standardFontSize;
                var orix = 16, oriy = 16;
                this.charRender.scale(1, 1), TextRender.tmpRI.height = TextRender.standardFontSize, this.charRender.fontsz = TextRender.standardFontSize;
                var bmpdt = this.charRender.getCharBmp("g", fontstr, 0, "red", null, TextRender.tmpRI, orix, oriy, 16, 16);
                ILaya.Render.isConchApp && (bmpdt.data = new Uint8ClampedArray(bmpdt.data)), this.bmpData32 = new Uint32Array(bmpdt.data.buffer), this.updateBbx(bmpdt, TextRender.pixelBBX, !1), bmpdt = this.charRender.getCharBmp("有", fontstr, 0, "red", null, TextRender.tmpRI, oriy, oriy, 16, 16), ILaya.Render.isConchApp && (bmpdt.data = new Uint8ClampedArray(bmpdt.data)), this.bmpData32 = new Uint32Array(bmpdt.data.buffer), TextRender.pixelBBX[2] < orix + TextRender.tmpRI.width && (TextRender.pixelBBX[2] = orix + TextRender.tmpRI.width), this.updateBbx(bmpdt, TextRender.pixelBBX, !1), ILaya.Render.isConchApp && (orix = 0, oriy = 0);
                var sizeinfo = Math.max(orix - TextRender.pixelBBX[0], 0) << 24 | Math.max(oriy - TextRender.pixelBBX[1], 0) << 16 | TextRender.pixelBBX[2] - TextRender.pixelBBX[0] << 8 | TextRender.pixelBBX[3] - TextRender.pixelBBX[1];
                return this.fontSizeInfo[font] = sizeinfo, sizeinfo
            }

            printDbgInfo() {
                for (var f in console.log("图集个数:" + this.textAtlases.length + ",每个图集大小:" + TextRender.atlasWidth + "x" + TextRender.atlasWidth, " 用canvas:", TextRender.isWan1Wan), console.log("图集占用空间:" + TextRender.atlasWidth * TextRender.atlasWidth * 4 / 1024 / 1024 * this.textAtlases.length + "M"), console.log("缓存用到的字体:"), this.mapFont) {
                    var fontsz = this.getFontSizeInfo(f), offx = fontsz >> 24, offy = fontsz >> 16 & 255,
                        fw = fontsz >> 8 & 255, fh = 255 & fontsz;
                    console.log("    " + f, " off:", offx, offy, " size:", fw, fh)
                }
                var num = 0;
                console.log("缓存数据:");
                var totalUsedRate = 0, totalUsedRateAtlas = 0;
                this.textAtlases.forEach(function (a) {
                    var id = a.texture.id, dt = RenderInfo.loopCount - a.texture.lastTouchTm,
                        dtstr = dt > 0 ? dt + "帧以前" : "当前帧";
                    for (var k in totalUsedRate += a.texture.curUsedCovRate, totalUsedRateAtlas += a.texture.curUsedCovRateAtlas, console.log("--图集(id:" + id + ",当前使用率:" + (1e3 * a.texture.curUsedCovRate | 0) + "‰", "当前图集使用率:", (100 * a.texture.curUsedCovRateAtlas | 0) + "%", "图集使用率:", 100 * a.usedRate | 0, "%, 使用于:" + dtstr + ")--:"), a.charMaps) {
                        var ri = a.charMaps[k];
                        console.log("     off:", ri.orix, ri.oriy, " bmp宽高:", ri.bmpWidth, ri.bmpHeight, "无效:", ri.deleted, "touchdt:", RenderInfo.loopCount - ri.touchTick, "位置:", ri.uv[0] * TextRender.atlasWidth | 0, ri.uv[1] * TextRender.atlasWidth | 0, "字符:", ri.char, "key:", k), num++
                    }
                }), console.log("独立贴图文字(" + this.isoTextures.length + "个):"), this.isoTextures.forEach(function (tex) {
                    console.log("    size:", tex._texW, tex._texH, "touch间隔:", RenderInfo.loopCount - tex.lastTouchTm, "char:", tex.ri.char)
                }), console.log("总缓存:", num, "总使用率:", totalUsedRate, "总当前图集使用率:", totalUsedRateAtlas)
            }

            showAtlas(n, bgcolor, x, y, w, h) {
                if (!this.textAtlases[n]) return console.log("没有这个图集"), null;
                var sp = new ILaya.Sprite, texttex = this.textAtlases[n].texture, texture = {
                    width: TextRender.atlasWidth,
                    height: TextRender.atlasWidth,
                    sourceWidth: TextRender.atlasWidth,
                    sourceHeight: TextRender.atlasWidth,
                    offsetX: 0,
                    offsetY: 0,
                    getIsReady: function () {
                        return !0
                    },
                    _addReference: function () {
                    },
                    _removeReference: function () {
                    },
                    _getSource: function () {
                        return texttex._getSource()
                    },
                    bitmap: {id: texttex.id},
                    _uv: Texture.DEF_UV
                };
                return sp.size = function (w, h) {
                    return this.width = w, this.height = h, sp.graphics.clear(), sp.graphics.drawRect(0, 0, sp.width, sp.height, bgcolor), sp.graphics.drawTexture(texture, 0, 0, sp.width, sp.height), this
                }, sp.graphics.drawRect(0, 0, w, h, bgcolor), sp.graphics.drawTexture(texture, 0, 0, w, h), sp.pos(x, y), ILaya.stage.addChild(sp), sp
            }

            filltext_native(ctx, data, htmlchars, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine = 0) {
                if (!(data && data.length <= 0 || htmlchars && htmlchars.length < 1)) {
                    var font = FontInfo.Parse(fontStr), nTextAlign = 0;
                    switch (textAlign) {
                        case"center":
                            nTextAlign = ILaya.Context.ENUM_TEXTALIGN_CENTER;
                            break;
                        case"right":
                            nTextAlign = ILaya.Context.ENUM_TEXTALIGN_RIGHT
                    }
                    return this._fast_filltext(ctx, data, htmlchars, x, y, font, color, strokeColor, lineWidth, nTextAlign, underLine)
                }
            }
        }

        TextRender.useOldCharBook = !1, TextRender.atlasWidth = 2048, TextRender.noAtlas = !1, TextRender.forceSplitRender = !1, TextRender.forceWholeRender = !1, TextRender.scaleFontWithCtx = !0, TextRender.standardFontSize = 32, TextRender.destroyAtlasDt = 10, TextRender.checkCleanTextureDt = 2e3, TextRender.destroyUnusedTextureDt = 3e3, TextRender.cleanMem = 104857600, TextRender.isWan1Wan = !1, TextRender.showLog = !1, TextRender.debugUV = !1, TextRender.atlasWidth2 = 4194304, TextRender.tmpRI = new CharRenderInfo, TextRender.pixelBBX = [0, 0, 0, 0], TextRender.textRenderInst = null, TextRender.imgdtRect = [0, 0, 0, 0], TextRender.simClean = !1, TextTexture.gTextRender = TextRender;

        class Context {
            constructor() {
                if (this._tmpMatrix = new Matrix, this._drawTexToDrawTri_Vert = new Float32Array(8), this._drawTexToDrawTri_Index = new Uint16Array([0, 1, 2, 0, 2, 3]), this._tempUV = new Float32Array(8), this._drawTriUseAbsMatrix = !1, this._id = ++Context._COUNT, this._other = null, this._renderNextSubmitIndex = 0, this._path = null, this._drawCount = 1, this._width = Context._MAXSIZE, this._height = Context._MAXSIZE, this._renderCount = 0, this._isConvexCmd = !0, this._submits = null, this._curSubmit = null, this._submitKey = new SubmitKey, this._mesh = null, this._pathMesh = null, this._triangleMesh = null, this.meshlist = [], this._transedPoints = new Array(8), this._temp4Points = new Array(8), this._clipRect = Context.MAXCLIPRECT, this._globalClipMatrix = new Matrix(Context._MAXSIZE, 0, 0, Context._MAXSIZE, 0, 0), this._clipInCache = !1, this._clipInfoID = 0, this._clipID_Gen = 0, this._curMat = null, this._lastMatScaleX = 1, this._lastMatScaleY = 1, this._lastMat_a = 1, this._lastMat_b = 0, this._lastMat_c = 0, this._lastMat_d = 1, this._nBlendType = 0, this._save = null, this._targets = null, this._charSubmitCache = null, this._saveMark = null, this._shader2D = new Shader2D, this.sprite = null, this._italicDeg = 0, this._lastTex = null, this._fillColor = 0, this._flushCnt = 0, this.defTexture = null, this._colorFiler = null, this.drawTexAlign = !1, this._incache = !1, this.isMain = !1, Context._contextcount++, Context._textRender = Context._textRender || new TextRender, !this.defTexture) {
                    var defTex2d = new Texture2D(2, 2);
                    defTex2d.setPixels(new Uint8Array(16)), defTex2d.lock = !0, this.defTexture = new Texture(defTex2d)
                }
                this._lastTex = this.defTexture, this.clear()
            }

            static __init__() {
                Context.MAXCLIPRECT = new Rectangle(0, 0, Context._MAXSIZE, Context._MAXSIZE), ContextParams.DEFAULT = new ContextParams
            }

            drawImage(...args) {
            }

            getImageData(...args) {
            }

            measureText(text) {
                return null
            }

            setTransform(...args) {
            }

            $transform(a, b, c, d, tx, ty) {
            }

            get lineJoin() {
                return null
            }

            set lineJoin(value) {
            }

            get lineCap() {
                return null
            }

            set lineCap(value) {
            }

            get miterLimit() {
                return null
            }

            set miterLimit(value) {
            }

            clearRect(x, y, width, height) {
            }

            _drawRect(x, y, width, height, style) {
                Stat.renderBatches++, style && (this.fillStyle = style), this.fillRect(x, y, width, height, null)
            }

            drawTexture2(x, y, pivotX, pivotY, m, args2) {
            }

            transformByMatrix(matrix, tx, ty) {
                this.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx + tx, matrix.ty + ty)
            }

            saveTransform(matrix) {
                this.save()
            }

            restoreTransform(matrix) {
                this.restore()
            }

            drawRect(x, y, width, height, fillColor, lineColor, lineWidth) {
                null != fillColor && (this.fillStyle = fillColor, this.fillRect(x, y, width, height)), null != lineColor && (this.strokeStyle = lineColor, this.lineWidth = lineWidth, this.strokeRect(x, y, width, height))
            }

            alpha(value) {
                this.globalAlpha *= value
            }

            _transform(mat, pivotX, pivotY) {
                this.translate(pivotX, pivotY), this.transform(mat.a, mat.b, mat.c, mat.d, mat.tx, mat.ty), this.translate(-pivotX, -pivotY)
            }

            _rotate(angle, pivotX, pivotY) {
                this.translate(pivotX, pivotY), this.rotate(angle), this.translate(-pivotX, -pivotY)
            }

            _scale(scaleX, scaleY, pivotX, pivotY) {
                this.translate(pivotX, pivotY), this.scale(scaleX, scaleY), this.translate(-pivotX, -pivotY)
            }

            _drawLine(x, y, fromX, fromY, toX, toY, lineColor, lineWidth, vid) {
                this.beginPath(), this.strokeStyle = lineColor, this.lineWidth = lineWidth, this.moveTo(x + fromX, y + fromY), this.lineTo(x + toX, y + toY), this.stroke()
            }

            _drawLines(x, y, points, lineColor, lineWidth, vid) {
                this.beginPath(), this.strokeStyle = lineColor, this.lineWidth = lineWidth;
                points.length;
                this.addPath(points.slice(), !1, !1, x, y), this.stroke()
            }

            drawCurves(x, y, points, lineColor, lineWidth) {
                this.beginPath(), this.strokeStyle = lineColor, this.lineWidth = lineWidth, this.moveTo(x + points[0], y + points[1]);
                for (var i = 2, n = points.length; i < n;) this.quadraticCurveTo(x + points[i++], y + points[i++], x + points[i++], y + points[i++]);
                this.stroke()
            }

            _fillAndStroke(fillColor, strokeColor, lineWidth, isConvexPolygon = !1) {
                null != fillColor && (this.fillStyle = fillColor, this.fill()), null != strokeColor && lineWidth > 0 && (this.strokeStyle = strokeColor, this.lineWidth = lineWidth, this.stroke())
            }

            _drawCircle(x, y, radius, fillColor, lineColor, lineWidth, vid) {
                Stat.renderBatches++, this.beginPath(!0), this.arc(x, y, radius, 0, Context.PI2), this.closePath(), this._fillAndStroke(fillColor, lineColor, lineWidth)
            }

            _drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth, vid) {
                this.beginPath(), this.moveTo(x, y), this.arc(x, y, radius, startAngle, endAngle), this.closePath(), this._fillAndStroke(fillColor, lineColor, lineWidth)
            }

            _drawPoly(x, y, points, fillColor, lineColor, lineWidth, isConvexPolygon, vid) {
                points.length;
                this.beginPath(), this.addPath(points.slice(), !0, isConvexPolygon, x, y), this.closePath(), this._fillAndStroke(fillColor, lineColor, lineWidth, isConvexPolygon)
            }

            _drawPath(x, y, paths, brush, pen) {
                this.beginPath();
                for (var i = 0, n = paths.length; i < n; i++) {
                    var path = paths[i];
                    switch (path[0]) {
                        case"moveTo":
                            this.moveTo(x + path[1], y + path[2]);
                            break;
                        case"lineTo":
                            this.lineTo(x + path[1], y + path[2]);
                            break;
                        case"arcTo":
                            this.arcTo(x + path[1], y + path[2], x + path[3], y + path[4], path[5]);
                            break;
                        case"closePath":
                            this.closePath()
                    }
                }
                null != brush && (this.fillStyle = brush.fillStyle, this.fill()), null != pen && (this.strokeStyle = pen.strokeStyle, this.lineWidth = pen.lineWidth || 1, this.lineJoin = pen.lineJoin, this.lineCap = pen.lineCap, this.miterLimit = pen.miterLimit, this.stroke())
            }

            static set2DRenderConfig() {
                var gl = LayaGL.instance;
                WebGLContext.setBlend(gl, !0), WebGLContext.setBlendFunc(gl, gl.ONE, gl.ONE_MINUS_SRC_ALPHA), WebGLContext.setDepthTest(gl, !1), WebGLContext.setCullFace(gl, !1), WebGLContext.setDepthMask(gl, !0), WebGLContext.setFrontFace(gl, gl.CCW), gl.viewport(0, 0, RenderState2D.width, RenderState2D.height)
            }

            clearBG(r, g, b, a) {
                var gl = WebGLContext.mainContext;
                gl.clearColor(r, g, b, a), gl.clear(gl.COLOR_BUFFER_BIT)
            }

            _getSubmits() {
                return this._submits
            }

            _releaseMem(keepRT = !1) {
                if (this._submits) {
                    this._curMat.destroy(), this._curMat = null, this._shader2D.destroy(), this._shader2D = null, this._charSubmitCache.clear();
                    for (var i = 0, n = this._submits._length; i < n; i++) this._submits[i].releaseRender();
                    var sz;
                    for (this._submits.length = 0, this._submits._length = 0, this._submits = null, this._curSubmit = null, this._path = null, this._save = null, i = 0, sz = this.meshlist.length; i < sz; i++) {
                        this.meshlist[i].destroy()
                    }
                    this.meshlist.length = 0, this.sprite = null, keepRT || (this._targets && this._targets.destroy(), this._targets = null)
                }
            }

            destroy(keepRT = !1) {
                --Context._contextcount, this.sprite = null, this._releaseMem(keepRT), this._charSubmitCache.destroy(), this._mesh.destroy(), keepRT || (this._targets && this._targets.destroy(), this._targets = null)
            }

            clear() {
                this._submits || (this._other = ContextParams.DEFAULT, this._curMat = Matrix.create(), this._charSubmitCache = new CharSubmitCache, this._mesh = MeshQuadTexture.getAMesh(this.isMain), this.meshlist.push(this._mesh), this._pathMesh = MeshVG.getAMesh(this.isMain), this.meshlist.push(this._pathMesh), this._triangleMesh = MeshTexture.getAMesh(this.isMain), this.meshlist.push(this._triangleMesh), this._submits = [], this._save = [SaveMark.Create(this)], this._save.length = 10, this._shader2D = new Shader2D), this._submitKey.clear(), this._mesh.clearVB(), this._renderCount++, this._drawCount = 1, this._other = ContextParams.DEFAULT, this._other.lineWidth = this._shader2D.ALPHA = 1, this._nBlendType = 0, this._clipRect = Context.MAXCLIPRECT, this._curSubmit = SubmitBase.RENDERBASE, SubmitBase.RENDERBASE._ref = 16777215, SubmitBase.RENDERBASE._numEle = 0, this._shader2D.fillStyle = this._shader2D.strokeStyle = DrawStyle.DEFAULT;
                for (var i = 0, n = this._submits._length; i < n; i++) this._submits[i].releaseRender();
                this._submits._length = 0, this._curMat.identity(), this._other.clear(), this._saveMark = this._save[0], this._save._length = 1
            }

            size(w, h) {
                this._width == w && this._height == h || (this._width = w, this._height = h, this._targets && (this._targets.destroy(), this._targets = new RenderTexture2D(w, h, BaseTexture.FORMAT_R8G8B8A8, -1)), this.isMain && (WebGLContext.mainContext.viewport(0, 0, w, h), RenderState2D.width = w, RenderState2D.height = h)), 0 === w && 0 === h && this._releaseMem()
            }

            set asBitmap(value) {
                if (value) {
                    if (this._targets || (this._targets = new RenderTexture2D(this._width, this._height, BaseTexture.FORMAT_R8G8B8A8, -1)), !this._width || !this._height) throw Error("asBitmap no size!")
                } else this._targets && this._targets.destroy(), this._targets = null
            }

            getMatScaleX() {
                return this._lastMat_a == this._curMat.a && this._lastMat_b == this._curMat.b ? this._lastMatScaleX : (this._lastMatScaleX = this._curMat.getScaleX(), this._lastMat_a = this._curMat.a, this._lastMat_b = this._curMat.b, this._lastMatScaleX)
            }

            getMatScaleY() {
                return this._lastMat_c == this._curMat.c && this._lastMat_d == this._curMat.d ? this._lastMatScaleY : (this._lastMatScaleY = this._curMat.getScaleY(), this._lastMat_c = this._curMat.c, this._lastMat_d = this._curMat.d, this._lastMatScaleY)
            }

            setFillColor(color) {
                this._fillColor = color
            }

            getFillColor() {
                return this._fillColor
            }

            set fillStyle(value) {
                this._shader2D.fillStyle.equal(value) || (SaveBase.save(this, SaveBase.TYPE_FILESTYLE, this._shader2D, !1), this._shader2D.fillStyle = DrawStyle.create(value), this._submitKey.other = -this._shader2D.fillStyle.toInt())
            }

            get fillStyle() {
                return this._shader2D.fillStyle
            }

            set globalAlpha(value) {
                (value = Math.floor(1e3 * value) / 1e3) != this._shader2D.ALPHA && (SaveBase.save(this, SaveBase.TYPE_ALPHA, this._shader2D, !1), this._shader2D.ALPHA = value)
            }

            get globalAlpha() {
                return this._shader2D.ALPHA
            }

            set textAlign(value) {
                this._other.textAlign === value || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTALIGN, this._other, !1), this._other.textAlign = value)
            }

            get textAlign() {
                return this._other.textAlign
            }

            set textBaseline(value) {
                this._other.textBaseline === value || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTBASELINE, this._other, !1), this._other.textBaseline = value)
            }

            get textBaseline() {
                return this._other.textBaseline
            }

            set globalCompositeOperation(value) {
                var n = BlendMode.TOINT[value];
                null == n || this._nBlendType === n || (SaveBase.save(this, SaveBase.TYPE_GLOBALCOMPOSITEOPERATION, this, !0), this._curSubmit = SubmitBase.RENDERBASE, this._nBlendType = n)
            }

            get globalCompositeOperation() {
                return BlendMode.NAMES[this._nBlendType]
            }

            set strokeStyle(value) {
                this._shader2D.strokeStyle.equal(value) || (SaveBase.save(this, SaveBase.TYPE_STROKESTYLE, this._shader2D, !1), this._shader2D.strokeStyle = DrawStyle.create(value), this._submitKey.other = -this._shader2D.strokeStyle.toInt())
            }

            get strokeStyle() {
                return this._shader2D.strokeStyle
            }

            translate(x, y) {
                0 === x && 0 === y || (SaveTranslate.save(this), this._curMat._bTransform ? (SaveTransform.save(this), this._curMat.tx += x * this._curMat.a + y * this._curMat.c, this._curMat.ty += x * this._curMat.b + y * this._curMat.d) : (this._curMat.tx = x, this._curMat.ty = y))
            }

            set lineWidth(value) {
                this._other.lineWidth === value || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_LINEWIDTH, this._other, !1), this._other.lineWidth = value)
            }

            get lineWidth() {
                return this._other.lineWidth
            }

            save() {
                this._save[this._save._length++] = SaveMark.Create(this)
            }

            restore() {
                var sz = this._save._length, lastBlend = this._nBlendType;
                if (!(sz < 1)) {
                    for (var i = sz - 1; i >= 0; i--) {
                        var o = this._save[i];
                        if (o.restore(this), o.isSaveMark()) return void (this._save._length = i)
                    }
                    lastBlend != this._nBlendType && (this._curSubmit = SubmitBase.RENDERBASE)
                }
            }

            set font(str) {
                this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_FONT, this._other, !1)
            }

            fillText(txt, x, y, fontStr, color, align) {
                this._fillText(txt, null, x, y, fontStr, color, null, 0, null)
            }

            _fillText(txt, words, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine = 0) {
                txt ? Context._textRender.filltext(this, txt, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine) : words && Context._textRender.fillWords(this, words, x, y, fontStr, color, strokeColor, lineWidth)
            }

            _fast_filltext(data, x, y, fontObj, color, strokeColor, lineWidth, textAlign, underLine = 0) {
                Context._textRender._fast_filltext(this, data, null, x, y, fontObj, color, strokeColor, lineWidth, textAlign, underLine)
            }

            fillWords(words, x, y, fontStr, color) {
                this._fillText(null, words, x, y, fontStr, color, null, -1, null, 0)
            }

            fillBorderWords(words, x, y, font, color, borderColor, lineWidth) {
                this._fillBorderText(null, words, x, y, font, color, borderColor, lineWidth, null)
            }

            drawText(text, x, y, font, color, textAlign) {
                this._fillText(text, null, x, y, font, ColorUtils.create(color).strColor, null, -1, textAlign)
            }

            strokeWord(text, x, y, font, color, lineWidth, textAlign) {
                this._fillText(text, null, x, y, font, null, ColorUtils.create(color).strColor, lineWidth || 1, textAlign)
            }

            fillBorderText(txt, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign) {
                this._fillBorderText(txt, null, x, y, fontStr, ColorUtils.create(fillColor).strColor, ColorUtils.create(borderColor).strColor, lineWidth, textAlign)
            }

            _fillBorderText(txt, words, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign) {
                this._fillText(txt, words, x, y, fontStr, fillColor, borderColor, lineWidth || 1, textAlign)
            }

            _fillRect(x, y, width, height, rgba) {
                var submit = this._curSubmit,
                    sameKey = submit && submit._key.submitType === SubmitBase.KEY_DRAWTEXTURE && submit._key.blendShader === this._nBlendType;
                this._mesh.vertNum + 4 > Context._MAXVERTNUM && (this._mesh = MeshQuadTexture.getAMesh(this.isMain), this.meshlist.push(this._mesh), sameKey = !1), sameKey && (sameKey = sameKey && this.isSameClipInfo(submit)), this.transformQuad(x, y, width, height, 0, this._curMat, this._transedPoints), this.clipedOff(this._transedPoints) || (this._mesh.addQuad(this._transedPoints, Texture.NO_UV, rgba, !1), sameKey || (submit = this._curSubmit = SubmitTexture.create(this, this._mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0)), this._submits[this._submits._length++] = submit, this._copyClipInfo(submit, this._globalClipMatrix), submit.shaderValue.textureHost = this._lastTex, submit._key.other = this._lastTex && this._lastTex.bitmap ? this._lastTex.bitmap.id : -1, submit._renderType = SubmitBase.TYPE_TEXTURE), this._curSubmit._numEle += 6, this._mesh.indexNum += 6, this._mesh.vertNum += 4)
            }

            fillRect(x, y, width, height, fillStyle) {
                var drawstyle = fillStyle ? DrawStyle.create(fillStyle) : this._shader2D.fillStyle,
                    rgba = this.mixRGBandAlpha(drawstyle.toInt());
                this._fillRect(x, y, width, height, rgba)
            }

            fillTexture(texture, x, y, width, height, type, offset, other) {
                texture._getSource() ? this._fillTexture(texture, texture.width, texture.height, texture.uvrect, x, y, width, height, type, offset.x, offset.y) : this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite)
            }

            _fillTexture(texture, texw, texh, texuvRect, x, y, width, height, type, offsetx, offsety) {
                var submit = this._curSubmit;
                this._mesh.vertNum + 4 > Context._MAXVERTNUM && (this._mesh = MeshQuadTexture.getAMesh(this.isMain), this.meshlist.push(this._mesh));
                var repeatx = !0, repeaty = !0;
                switch (type) {
                    case"repeat":
                        break;
                    case"repeat-x":
                        repeaty = !1;
                        break;
                    case"repeat-y":
                        repeatx = !1;
                        break;
                    case"no-repeat":
                        repeatx = repeaty = !1
                }
                var uv = this._temp4Points, stu = 0, stv = 0, stx = 0, sty = 0, edx = 0, edy = 0;
                if (offsetx < 0 ? (stx = x, stu = -offsetx % texw / texw) : stx = x + offsetx, offsety < 0 ? (sty = y, stv = -offsety % texh / texh) : sty = y + offsety, edx = x + width, edy = y + height, !repeatx && (edx = Math.min(edx, x + offsetx + texw)), !repeaty && (edy = Math.min(edy, y + offsety + texh)), !(edx < x || edy < y || stx > edx || sty > edy)) {
                    var edu = (edx - x - offsetx) / texw, edv = (edy - y - offsety) / texh;
                    if (this.transformQuad(stx, sty, edx - stx, edy - sty, 0, this._curMat, this._transedPoints), uv[0] = stu, uv[1] = stv, uv[2] = edu, uv[3] = stv, uv[4] = edu, uv[5] = edv, uv[6] = stu, uv[7] = edv, !this.clipedOff(this._transedPoints)) {
                        var rgba = this._mixRGBandAlpha(4294967295, this._shader2D.ALPHA);
                        this._mesh.addQuad(this._transedPoints, uv, rgba, !0);
                        var sv = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);
                        sv.defines.add(ShaderDefines2D.FILLTEXTURE), sv.u_TexRange = texuvRect, submit = this._curSubmit = SubmitTexture.create(this, this._mesh, sv), this._submits[this._submits._length++] = submit, this._copyClipInfo(submit, this._globalClipMatrix), submit.shaderValue.textureHost = texture, submit._renderType = SubmitBase.TYPE_TEXTURE, this._curSubmit._numEle += 6, this._mesh.indexNum += 6, this._mesh.vertNum += 4
                    }
                    this.breakNextMerge()
                }
            }

            setColorFilter(filter) {
                SaveBase.save(this, SaveBase.TYPE_COLORFILTER, this, !0), this._colorFiler = filter, this._curSubmit = SubmitBase.RENDERBASE
            }

            drawTexture(tex, x, y, width, height) {
                this._drawTextureM(tex, x, y, width, height, null, 1, null)
            }

            drawTextures(tex, pos, tx, ty) {
                if (tex._getSource()) for (var n = pos.length / 2, ipos = 0, bmpid = tex.bitmap.id, i = 0; i < n; i++) this._inner_drawTexture(tex, bmpid, pos[ipos++] + tx, pos[ipos++] + ty, 0, 0, null, null, 1, !1); else this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite)
            }

            _drawTextureAddSubmit(imgid, tex) {
                var submit = null;
                submit = SubmitTexture.create(this, this._mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0)), this._submits[this._submits._length++] = submit, submit.shaderValue.textureHost = tex, submit._key.other = imgid, submit._renderType = SubmitBase.TYPE_TEXTURE, this._curSubmit = submit
            }

            _drawTextureM(tex, x, y, width, height, m, alpha, uv) {
                var cs = this.sprite;
                return !!tex._getSource(function () {
                    cs && cs.repaint()
                }) && this._inner_drawTexture(tex, tex.bitmap.id, x, y, width, height, m, uv, alpha, !1)
            }

            _drawRenderTexture(tex, x, y, width, height, m, alpha, uv) {
                return this._inner_drawTexture(tex, -1, x, y, width, height, m, uv, 1, !1)
            }

            submitDebugger() {
                this._submits[this._submits._length++] = SubmitCMD.create([], function () {
                }, this)
            }

            _copyClipInfo(submit, clipInfo) {
                var cm = submit.shaderValue.clipMatDir;
                cm[0] = clipInfo.a, cm[1] = clipInfo.b, cm[2] = clipInfo.c, cm[3] = clipInfo.d;
                var cmp = submit.shaderValue.clipMatPos;
                cmp[0] = clipInfo.tx, cmp[1] = clipInfo.ty, submit.clipInfoID = this._clipInfoID, this._clipInCache && (submit.shaderValue.clipOff[0] = 1)
            }

            isSameClipInfo(submit) {
                return submit.clipInfoID === this._clipInfoID
            }

            _useNewTex2DSubmit(tex, minVertNum) {
                this._mesh.vertNum + minVertNum > Context._MAXVERTNUM && (this._mesh = MeshQuadTexture.getAMesh(this.isMain), this.meshlist.push(this._mesh));
                var submit = SubmitTexture.create(this, this._mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
                this._submits[this._submits._length++] = this._curSubmit = submit, submit.shaderValue.textureHost = tex, this._copyClipInfo(submit, this._globalClipMatrix)
            }

            _drawTexRect(x, y, w, h, uv) {
                this.transformQuad(x, y, w, h, this._italicDeg, this._curMat, this._transedPoints);
                var ops = this._transedPoints;
                ops[0] = ops[0] + .5 | 0, ops[1] = ops[1] + .5 | 0, ops[2] = ops[2] + .5 | 0, ops[3] = ops[3] + .5 | 0, ops[4] = ops[4] + .5 | 0, ops[5] = ops[5] + .5 | 0, ops[6] = ops[6] + .5 | 0, ops[7] = ops[7] + .5 | 0, this.clipedOff(this._transedPoints) || (this._mesh.addQuad(this._transedPoints, uv, this._fillColor, !0), this._curSubmit._numEle += 6, this._mesh.indexNum += 6, this._mesh.vertNum += 4)
            }

            drawCallOptimize(enbale) {
                return this._charSubmitCache.enable(enbale, this), enbale
            }

            _inner_drawTexture(tex, imgid, x, y, width, height, m, uv, alpha, lastRender) {
                var preKey = this._curSubmit._key;
                if (uv = uv || tex._uv, preKey.submitType === SubmitBase.KEY_TRIANGLES && preKey.other === imgid) {
                    var tv = this._drawTexToDrawTri_Vert;
                    tv[0] = x, tv[1] = y, tv[2] = x + width, tv[3] = y, tv[4] = x + width, tv[5] = y + height, tv[6] = x, tv[7] = y + height, this._drawTriUseAbsMatrix = !0;
                    var tuv = this._tempUV;
                    return tuv[0] = uv[0], tuv[1] = uv[1], tuv[2] = uv[2], tuv[3] = uv[3], tuv[4] = uv[4], tuv[5] = uv[5], tuv[6] = uv[6], tuv[7] = uv[7], this.drawTriangles(tex, 0, 0, tv, tuv, this._drawTexToDrawTri_Index, m, alpha, null, null), this._drawTriUseAbsMatrix = !1, !0
                }
                var mesh = this._mesh, submit = this._curSubmit,
                    ops = lastRender ? this._charSubmitCache.getPos() : this._transedPoints;
                if (this.transformQuad(x, y, width || tex.width, height || tex.height, this._italicDeg, m || this._curMat, ops), this.drawTexAlign) {
                    var round = Math.round;
                    ops[0] = round(ops[0]), ops[1] = round(ops[1]), ops[2] = round(ops[2]), ops[3] = round(ops[3]), ops[4] = round(ops[4]), ops[5] = round(ops[5]), ops[6] = round(ops[6]), ops[7] = round(ops[7]), this.drawTexAlign = !1
                }
                var rgba = this._mixRGBandAlpha(4294967295, this._shader2D.ALPHA * alpha);
                if (lastRender) return this._charSubmitCache.add(this, tex, imgid, ops, uv, rgba), !0;
                this._drawCount++;
                var sameKey = imgid >= 0 && preKey.submitType === SubmitBase.KEY_DRAWTEXTURE && preKey.other === imgid;
                return sameKey && (sameKey = sameKey && this.isSameClipInfo(submit)), this._lastTex = tex, mesh.vertNum + 4 > Context._MAXVERTNUM && (mesh = this._mesh = MeshQuadTexture.getAMesh(this.isMain), this.meshlist.push(mesh), sameKey = !1), mesh.addQuad(ops, uv, rgba, !0), sameKey || (this._submits[this._submits._length++] = this._curSubmit = submit = SubmitTexture.create(this, mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0)), submit.shaderValue.textureHost = tex, submit._key.other = imgid, this._copyClipInfo(submit, this._globalClipMatrix)), submit._numEle += 6, mesh.indexNum += 6, mesh.vertNum += 4, !0
            }

            transform4Points(a, m, out) {
                var tx = m.tx, ty = m.ty, ma = m.a, mb = m.b, mc = m.c, md = m.d, a0 = a[0], a1 = a[1], a2 = a[2],
                    a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
                m._bTransform ? (out[0] = a0 * ma + a1 * mc + tx, out[1] = a0 * mb + a1 * md + ty, out[2] = a2 * ma + a3 * mc + tx, out[3] = a2 * mb + a3 * md + ty, out[4] = a4 * ma + a5 * mc + tx, out[5] = a4 * mb + a5 * md + ty, out[6] = a6 * ma + a7 * mc + tx, out[7] = a6 * mb + a7 * md + ty) : (out[0] = a0 + tx, out[1] = a1 + ty, out[2] = a2 + tx, out[3] = a3 + ty, out[4] = a4 + tx, out[5] = a5 + ty, out[6] = a6 + tx, out[7] = a7 + ty)
            }

            clipedOff(pt) {
                return this._clipRect.width <= 0 || this._clipRect.height <= 0
            }

            transformQuad(x, y, w, h, italicDeg, m, out) {
                var xoff = 0;
                0 != italicDeg && (xoff = Math.tan(italicDeg * Math.PI / 180) * h);
                var maxx = x + w, maxy = y + h, tx = m.tx, ty = m.ty, ma = m.a, mb = m.b, mc = m.c, md = m.d,
                    a0 = x + xoff, a1 = y, a2 = maxx + xoff, a3 = y, a4 = maxx, a5 = maxy, a6 = x, a7 = maxy;
                m._bTransform ? (out[0] = a0 * ma + a1 * mc + tx, out[1] = a0 * mb + a1 * md + ty, out[2] = a2 * ma + a3 * mc + tx, out[3] = a2 * mb + a3 * md + ty, out[4] = a4 * ma + a5 * mc + tx, out[5] = a4 * mb + a5 * md + ty, out[6] = a6 * ma + a7 * mc + tx, out[7] = a6 * mb + a7 * md + ty) : (out[0] = a0 + tx, out[1] = a1 + ty, out[2] = a2 + tx, out[3] = a3 + ty, out[4] = a4 + tx, out[5] = a5 + ty, out[6] = a6 + tx, out[7] = a7 + ty)
            }

            pushRT() {
                this.addRenderObject(SubmitCMD.create(null, RenderTexture2D.pushRT, this))
            }

            popRT() {
                this.addRenderObject(SubmitCMD.create(null, RenderTexture2D.popRT, this)), this.breakNextMerge()
            }

            useRT(rt) {
                this.addRenderObject(SubmitCMD.create([rt], function (rt) {
                    if (!rt) throw"error useRT";
                    rt.start(), rt.clear(0, 0, 0, 0)
                }, this)), this.breakNextMerge()
            }

            RTRestore(rt) {
                this.addRenderObject(SubmitCMD.create([rt], function (rt) {
                    rt.restore()
                }, this)), this.breakNextMerge()
            }

            breakNextMerge() {
                this._curSubmit = SubmitBase.RENDERBASE
            }

            _repaintSprite() {
                this.sprite && this.sprite.repaint()
            }

            drawTextureWithTransform(tex, x, y, width, height, transform, tx, ty, alpha, blendMode, colorfilter = null, uv) {
                var oldcomp = null, curMat = this._curMat;
                blendMode && (oldcomp = this.globalCompositeOperation, this.globalCompositeOperation = blendMode);
                var oldColorFilter = this._colorFiler;
                if (colorfilter && this.setColorFilter(colorfilter), !transform) return this._drawTextureM(tex, x + tx, y + ty, width, height, curMat, alpha, uv), blendMode && (this.globalCompositeOperation = oldcomp), void (colorfilter && this.setColorFilter(oldColorFilter));
                var tmpMat = this._tmpMatrix;
                tmpMat.a = transform.a, tmpMat.b = transform.b, tmpMat.c = transform.c, tmpMat.d = transform.d, tmpMat.tx = transform.tx + tx, tmpMat.ty = transform.ty + ty, tmpMat._bTransform = transform._bTransform, transform && curMat._bTransform ? (Matrix.mul(tmpMat, curMat, tmpMat), (transform = tmpMat)._bTransform = !0) : (tmpMat.tx += curMat.tx, tmpMat.ty += curMat.ty, transform = tmpMat), this._drawTextureM(tex, x, y, width, height, transform, alpha, uv), blendMode && (this.globalCompositeOperation = oldcomp), colorfilter && this.setColorFilter(oldColorFilter)
            }

            _flushToTarget(context, target) {
                RenderState2D.worldScissorTest = !1;
                var gl = LayaGL.instance;
                gl.disable(gl.SCISSOR_TEST);
                var preAlpha = RenderState2D.worldAlpha, preMatrix4 = RenderState2D.worldMatrix4,
                    preMatrix = RenderState2D.worldMatrix;
                RenderState2D.worldMatrix = Matrix.EMPTY, RenderState2D.restoreTempArray(), RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY, RenderState2D.worldAlpha = 1, BaseShader.activeShader = null, target.start(), context._submits._length > 0 && target.clear(0, 0, 0, 0), context._curSubmit = SubmitBase.RENDERBASE, context.flush(), context.clear(), target.restore(), context._curSubmit = SubmitBase.RENDERBASE, BaseShader.activeShader = null, RenderState2D.worldAlpha = preAlpha, RenderState2D.worldMatrix4 = preMatrix4, RenderState2D.worldMatrix = preMatrix
            }

            drawCanvas(canvas, x, y, width, height) {
                if (canvas) {
                    var submit, src = canvas.context;
                    if (src._targets) src._submits._length > 0 && (submit = SubmitCMD.create([src, src._targets], this._flushToTarget, this), this._submits[this._submits._length++] = submit), this._drawRenderTexture(src._targets, x, y, width, height, null, 1, RenderTexture2D.flipyuv), this._curSubmit = SubmitBase.RENDERBASE; else {
                        var canv = canvas;
                        canv.touches && canv.touches.forEach(function (v) {
                            v.touch()
                        }), submit = SubmitCanvas.create(canvas, this._shader2D.ALPHA, this._shader2D.filters), this._submits[this._submits._length++] = submit, submit._key.clear();
                        var mat = submit._matrix;
                        this._curMat.copyTo(mat);
                        var tx = mat.tx, ty = mat.ty;
                        mat.tx = mat.ty = 0, mat.transformPoint(Point.TEMP.setTo(x, y)), mat.translate(Point.TEMP.x + tx, Point.TEMP.y + ty), Matrix.mul(canv.invMat, mat, mat), this._curSubmit = SubmitBase.RENDERBASE
                    }
                }
            }

            drawTarget(rt, x, y, width, height, m, shaderValue, uv = null, blend = -1) {
                if (this._drawCount++, this._mesh.vertNum + 4 > Context._MAXVERTNUM && (this._mesh = MeshQuadTexture.getAMesh(this.isMain), this.meshlist.push(this._mesh)), this.transformQuad(x, y, width, height, 0, m || this._curMat, this._transedPoints), !this.clipedOff(this._transedPoints)) {
                    this._mesh.addQuad(this._transedPoints, uv || Texture.DEF_UV, 4294967295, !0);
                    var submit = this._curSubmit = SubmitTarget.create(this, this._mesh, shaderValue, rt);
                    return submit.blendType = -1 == blend ? this._nBlendType : blend, this._copyClipInfo(submit, this._globalClipMatrix), submit._numEle = 6, this._mesh.indexNum += 6, this._mesh.vertNum += 4, this._submits[this._submits._length++] = submit, this._curSubmit = SubmitBase.RENDERBASE, !0
                }
                return this._curSubmit = SubmitBase.RENDERBASE, !1
            }

            drawTriangles(tex, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
                if (tex._getSource()) {
                    this._drawCount++;
                    var tmpMat = this._tmpMatrix, triMesh = this._triangleMesh, oldColorFilter = null,
                        needRestorFilter = !1;
                    color && (oldColorFilter = this._colorFiler, this._colorFiler = color, this._curSubmit = SubmitBase.RENDERBASE, needRestorFilter = oldColorFilter != color);
                    var webGLImg = tex.bitmap, preKey = this._curSubmit._key,
                        sameKey = preKey.submitType === SubmitBase.KEY_TRIANGLES && preKey.other === webGLImg.id && preKey.blendShader == this._nBlendType;
                    if (triMesh.vertNum + vertices.length / 2 > Context._MAXVERTNUM && (triMesh = this._triangleMesh = MeshTexture.getAMesh(this.isMain), this.meshlist.push(triMesh), sameKey = !1), !sameKey) {
                        var submit = this._curSubmit = SubmitTexture.create(this, triMesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
                        submit.shaderValue.textureHost = tex, submit._renderType = SubmitBase.TYPE_TEXTURE, submit._key.submitType = SubmitBase.KEY_TRIANGLES, submit._key.other = webGLImg.id, this._copyClipInfo(submit, this._globalClipMatrix), this._submits[this._submits._length++] = submit
                    }
                    var rgba = this._mixRGBandAlpha(4294967295, this._shader2D.ALPHA * alpha);
                    this._drawTriUseAbsMatrix ? triMesh.addData(vertices, uvs, indices, matrix, rgba) : (matrix ? (tmpMat.a = matrix.a, tmpMat.b = matrix.b, tmpMat.c = matrix.c, tmpMat.d = matrix.d, tmpMat.tx = matrix.tx + x, tmpMat.ty = matrix.ty + y) : (tmpMat.a = 1, tmpMat.b = 0, tmpMat.c = 0, tmpMat.d = 1, tmpMat.tx = x, tmpMat.ty = y), Matrix.mul(tmpMat, this._curMat, tmpMat), triMesh.addData(vertices, uvs, indices, tmpMat, rgba)), this._curSubmit._numEle += indices.length, needRestorFilter && (this._colorFiler = oldColorFilter, this._curSubmit = SubmitBase.RENDERBASE)
                } else this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite)
            }

            transform(a, b, c, d, tx, ty) {
                SaveTransform.save(this), Matrix.mul(Matrix.TEMP.setTo(a, b, c, d, tx, ty), this._curMat, this._curMat), this._curMat._checkTransform()
            }

            _transformByMatrix(matrix, tx, ty) {
                matrix.setTranslate(tx, ty), Matrix.mul(matrix, this._curMat, this._curMat), matrix.setTranslate(0, 0), this._curMat._bTransform = !0
            }

            setTransformByMatrix(value) {
                value.copyTo(this._curMat)
            }

            rotate(angle) {
                SaveTransform.save(this), this._curMat.rotateEx(angle)
            }

            scale(scaleX, scaleY) {
                SaveTransform.save(this), this._curMat.scaleEx(scaleX, scaleY)
            }

            clipRect(x, y, width, height) {
                SaveClipRect.save(this), this._clipRect == Context.MAXCLIPRECT ? this._clipRect = new Rectangle(x, y, width, height) : (this._clipRect.width = width, this._clipRect.height = height, this._clipRect.x = x, this._clipRect.y = y), this._clipID_Gen++, this._clipID_Gen %= 1e4, this._clipInfoID = this._clipID_Gen;
                var cm = this._globalClipMatrix, minx = cm.tx, miny = cm.ty, maxx = minx + cm.a, maxy = miny + cm.d;
                if (this._clipRect.width >= Context._MAXSIZE ? (cm.a = cm.d = Context._MAXSIZE, cm.b = cm.c = cm.tx = cm.ty = 0) : (this._curMat._bTransform ? (cm.tx = this._clipRect.x * this._curMat.a + this._clipRect.y * this._curMat.c + this._curMat.tx, cm.ty = this._clipRect.x * this._curMat.b + this._clipRect.y * this._curMat.d + this._curMat.ty, cm.a = this._clipRect.width * this._curMat.a, cm.b = this._clipRect.width * this._curMat.b, cm.c = this._clipRect.height * this._curMat.c, cm.d = this._clipRect.height * this._curMat.d) : (cm.tx = this._clipRect.x + this._curMat.tx, cm.ty = this._clipRect.y + this._curMat.ty, cm.a = this._clipRect.width, cm.b = cm.c = 0, cm.d = this._clipRect.height), this._incache && (this._clipInCache = !0)), cm.a > 0 && cm.d > 0) {
                    var cmaxx = cm.tx + cm.a, cmaxy = cm.ty + cm.d;
                    cmaxx <= minx || cmaxy <= miny || cm.tx >= maxx || cm.ty >= maxy ? (cm.a = -.1, cm.d = -.1) : (cm.tx < minx && (cm.a -= minx - cm.tx, cm.tx = minx), cmaxx > maxx && (cm.a -= cmaxx - maxx), cm.ty < miny && (cm.d -= miny - cm.ty, cm.ty = miny), cmaxy > maxy && (cm.d -= cmaxy - maxy), cm.a <= 0 && (cm.a = -.1), cm.d <= 0 && (cm.d = -.1))
                }
            }

            drawMesh(x, y, ib, vb, numElement, mat, shader, shaderValues, startIndex = 0) {
            }

            addRenderObject(o) {
                this._submits[this._submits._length++] = o
            }

            submitElement(start, end) {
                this.isMain;
                var renderList = this._submits, ret = renderList._length;
                end < 0 && (end = renderList._length);
                for (var submit = SubmitBase.RENDERBASE; start < end;) this._renderNextSubmitIndex = start + 1, renderList[start] !== SubmitBase.RENDERBASE ? (SubmitBase.preRender = submit, start += (submit = renderList[start]).renderSubmit()) : start++;
                return ret
            }

            flush() {
                this._clipID_Gen = 0;
                var ret = this.submitElement(0, this._submits._length);
                this._path && this._path.reset(), SkinMeshBuffer.instance && SkinMeshBuffer.getInstance().reset(), this._curSubmit = SubmitBase.RENDERBASE;
                for (var i = 0, sz = this.meshlist.length; i < sz; i++) {
                    var curm = this.meshlist[i];
                    curm.canReuse ? curm.releaseMesh() : curm.destroy()
                }
                return this.meshlist.length = 0, this._mesh = MeshQuadTexture.getAMesh(this.isMain), this._pathMesh = MeshVG.getAMesh(this.isMain), this._triangleMesh = MeshTexture.getAMesh(this.isMain), this.meshlist.push(this._mesh, this._pathMesh, this._triangleMesh), this._flushCnt++, this._flushCnt % 60 == 0 && this.isMain && TextRender.textRenderInst && TextRender.textRenderInst.GC(), ret
            }

            beginPath(convex = !1) {
                this._getPath().beginPath(convex)
            }

            closePath() {
                this._path.closePath()
            }

            addPath(points, close, convex, dx, dy) {
                for (var ci = 0, i = 0, sz = points.length / 2; i < sz; i++) {
                    var x1 = points[ci] + dx, y1 = points[ci + 1] + dy;
                    points[ci] = x1, points[ci + 1] = y1, ci += 2
                }
                this._getPath().push(points, convex)
            }

            fill() {
                var m = this._curMat, tPath = this._getPath(), submit = this._curSubmit,
                    sameKey = submit._key.submitType === SubmitBase.KEY_VG && submit._key.blendShader === this._nBlendType;
                sameKey && (sameKey = sameKey && this.isSameClipInfo(submit)), sameKey || (this._curSubmit = this.addVGSubmit(this._pathMesh));
                for (var idx, rgba = this.mixRGBandAlpha(this.fillStyle.toInt()), curEleNum = 0, i = 0, sz = tPath.paths.length; i < sz; i++) {
                    var p = tPath.paths[i], vertNum = p.path.length / 2;
                    if (!(vertNum < 3 || 3 == vertNum && !p.convex)) {
                        var xp, yp, _x, _y, cpath = p.path.concat(), pi = 0;
                        if (m._bTransform) for (pi = 0; pi < vertNum; pi++) yp = (xp = pi << 1) + 1, _x = cpath[xp], _y = cpath[yp], cpath[xp] = m.a * _x + m.c * _y + m.tx, cpath[yp] = m.b * _x + m.d * _y + m.ty; else for (pi = 0; pi < vertNum; pi++) yp = (xp = pi << 1) + 1, _x = cpath[xp], _y = cpath[yp], cpath[xp] = _x + m.tx, cpath[yp] = _y + m.ty;
                        this._pathMesh.vertNum + vertNum > Context._MAXVERTNUM && (this._curSubmit._numEle += curEleNum, curEleNum = 0, this._pathMesh = MeshVG.getAMesh(this.isMain), this._curSubmit = this.addVGSubmit(this._pathMesh));
                        var curvert = this._pathMesh.vertNum;
                        if (p.convex) {
                            var faceNum = vertNum - 2;
                            idx = new Array(3 * faceNum);
                            for (var idxpos = 0, fi = 0; fi < faceNum; fi++) idx[idxpos++] = curvert, idx[idxpos++] = fi + 1 + curvert, idx[idxpos++] = fi + 2 + curvert
                        } else if (idx = Earcut.earcut(cpath, null, 2), curvert > 0) for (var ii = 0; ii < idx.length; ii++) idx[ii] += curvert;
                        this._pathMesh.addVertAndIBToMesh(this, cpath, rgba, idx), curEleNum += idx.length
                    }
                }
                this._curSubmit._numEle += curEleNum
            }

            addVGSubmit(mesh) {
                var submit = Submit.createShape(this, mesh, 0, Value2D.create(ShaderDefines2D.PRIMITIVE, 0));
                return submit._key.submitType = SubmitBase.KEY_VG, this._submits[this._submits._length++] = submit, this._copyClipInfo(submit, this._globalClipMatrix), submit
            }

            stroke() {
                if (this.lineWidth > 0) {
                    var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor), tPath = this._getPath(),
                        submit = this._curSubmit,
                        sameKey = submit._key.submitType === SubmitBase.KEY_VG && submit._key.blendShader === this._nBlendType;
                    sameKey && (sameKey = sameKey && this.isSameClipInfo(submit)), sameKey || (this._curSubmit = this.addVGSubmit(this._pathMesh));
                    for (var curEleNum = 0, i = 0, sz = tPath.paths.length; i < sz; i++) {
                        var p = tPath.paths[i];
                        if (!(p.path.length <= 0)) {
                            var idx = [], vertex = [], maxVertexNum = 2 * p.path.length;
                            if (!(maxVertexNum < 2)) {
                                this._pathMesh.vertNum + maxVertexNum > Context._MAXVERTNUM && (this._curSubmit._numEle += curEleNum, curEleNum = 0, this._pathMesh = MeshVG.getAMesh(this.isMain), this.meshlist.push(this._pathMesh), this._curSubmit = this.addVGSubmit(this._pathMesh)), BasePoly.createLine2(p.path, idx, this.lineWidth, this._pathMesh.vertNum, vertex, p.loop);
                                var xp, yp, _x, _y, ptnum = vertex.length / 2, m = this._curMat, pi = 0;
                                if (m._bTransform) for (pi = 0; pi < ptnum; pi++) yp = (xp = pi << 1) + 1, _x = vertex[xp], _y = vertex[yp], vertex[xp] = m.a * _x + m.c * _y + m.tx, vertex[yp] = m.b * _x + m.d * _y + m.ty; else for (pi = 0; pi < ptnum; pi++) yp = (xp = pi << 1) + 1, _x = vertex[xp], _y = vertex[yp], vertex[xp] = _x + m.tx, vertex[yp] = _y + m.ty;
                                this._pathMesh.addVertAndIBToMesh(this, vertex, rgba, idx), curEleNum += idx.length
                            }
                        }
                    }
                    this._curSubmit._numEle += curEleNum
                }
            }

            moveTo(x, y) {
                var tPath = this._getPath();
                tPath.newPath(), tPath._lastOriX = x, tPath._lastOriY = y, tPath.addPoint(x, y)
            }

            lineTo(x, y) {
                var tPath = this._getPath();
                Math.abs(x - tPath._lastOriX) < .001 && Math.abs(y - tPath._lastOriY) < .001 || (tPath._lastOriX = x, tPath._lastOriY = y, tPath.addPoint(x, y))
            }

            arcTo(x1, y1, x2, y2, r) {
                var i = 0, x = 0, y = 0, dx = this._path._lastOriX - x1, dy = this._path._lastOriY - y1,
                    len1 = Math.sqrt(dx * dx + dy * dy);
                if (!(len1 <= 1e-6)) {
                    var ndx = dx / len1, ndy = dy / len1, dx2 = x2 - x1, dy2 = y2 - y1, len22 = dx2 * dx2 + dy2 * dy2,
                        len2 = Math.sqrt(len22);
                    if (!(len2 <= 1e-6)) {
                        var ndx2 = dx2 / len2, ndy2 = dy2 / len2, odx = ndx + ndx2, ody = ndy + ndy2,
                            olen = Math.sqrt(odx * odx + ody * ody);
                        if (!(olen <= 1e-6)) {
                            var nOdx = odx / olen, nOdy = ody / olen, alpha = Math.acos(nOdx * ndx + nOdy * ndy),
                                halfAng = Math.PI / 2 - alpha, ptx1 = (len1 = r / Math.tan(halfAng)) * ndx + x1,
                                pty1 = len1 * ndy + y1, orilen = Math.sqrt(len1 * len1 + r * r),
                                orix = x1 + nOdx * orilen, oriy = y1 + nOdy * orilen, sinx = 0, cosx = 0;
                            if (ndx * ndy2 - ndy * ndx2 >= 0) {
                                var fda = 2 * halfAng / Context.SEGNUM;
                                sinx = Math.sin(fda), cosx = Math.cos(fda)
                            } else fda = 2 * -halfAng / Context.SEGNUM, sinx = Math.sin(fda), cosx = Math.cos(fda);
                            var lastx = this._path._lastOriX, lasty = this._path._lastOriY, _x1 = ptx1, _y1 = pty1;
                            (Math.abs(_x1 - this._path._lastOriX) > .1 || Math.abs(_y1 - this._path._lastOriY) > .1) && (x = _x1, y = _y1, lastx = _x1, lasty = _y1, this._path.addPoint(x, y));
                            var cvx = ptx1 - orix, cvy = pty1 - oriy;
                            for (i = 0; i < Context.SEGNUM; i++) {
                                var cx = cvx * cosx + cvy * sinx, cy = -cvx * sinx + cvy * cosx;
                                x = cx + orix, y = cy + oriy, (Math.abs(lastx - x) > .1 || Math.abs(lasty - y) > .1) && (this._path.addPoint(x, y), lastx = x, lasty = y), cvx = cx, cvy = cy
                            }
                        }
                    }
                }
            }

            arc(cx, cy, r, startAngle, endAngle, counterclockwise = !1, b = !0) {
                var i, ndivs, a = 0, da = 0, dx = 0, x = 0, y = 0;
                if (da = endAngle - startAngle, counterclockwise) if (Math.abs(da) >= 2 * Math.PI) da = 2 * -Math.PI; else for (; da > 0;) da -= 2 * Math.PI; else if (Math.abs(da) >= 2 * Math.PI) da = 2 * Math.PI; else for (; da < 0;) da += 2 * Math.PI;
                var sx = this.getMatScaleX(), sy = this.getMatScaleY(), sr = r * (sx > sy ? sx : sy),
                    cl = 2 * Math.PI * sr;
                ndivs = 0 | Math.max(cl / 10, 10);
                var tPath = this._getPath();
                for (i = 0; i <= ndivs; i++) a = startAngle + da * (i / ndivs), dx = Math.cos(a), y = cy + Math.sin(a) * r, (x = cx + dx * r) == this._path._lastOriX && y == this._path._lastOriY || tPath.addPoint(x, y);
                dx = Math.cos(endAngle), y = cy + Math.sin(endAngle) * r, (x = cx + dx * r) == this._path._lastOriX && y == this._path._lastOriY || tPath.addPoint(x, y)
            }

            quadraticCurveTo(cpx, cpy, x, y) {
                for (var tArray = Bezier.I.getBezierPoints([this._path._lastOriX, this._path._lastOriY, cpx, cpy, x, y], 30, 2), i = 0, n = tArray.length / 2; i < n; i++) this.lineTo(tArray[2 * i], tArray[2 * i + 1]);
                this.lineTo(x, y)
            }

            mixRGBandAlpha(color) {
                return this._mixRGBandAlpha(color, this._shader2D.ALPHA)
            }

            _mixRGBandAlpha(color, alpha) {
                if (alpha >= 1) return color;
                var a = (4278190080 & color) >>> 24;
                return 0 != a ? a *= alpha : a = 255 * alpha, 16777215 & color | a << 24
            }

            strokeRect(x, y, width, height, parameterLineWidth) {
                if (this.lineWidth > 0) {
                    var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor), hw = this.lineWidth / 2;
                    this._fillRect(x - hw, y - hw, width + this.lineWidth, this.lineWidth, rgba), this._fillRect(x - hw, y - hw + height, width + this.lineWidth, this.lineWidth, rgba), this._fillRect(x - hw, y + hw, this.lineWidth, height - this.lineWidth, rgba), this._fillRect(x - hw + width, y + hw, this.lineWidth, height - this.lineWidth, rgba)
                }
            }

            clip() {
            }

            drawParticle(x, y, pt) {
                pt.x = x, pt.y = y, this._submits[this._submits._length++] = pt
            }

            _getPath() {
                return this._path || (this._path = new Path)
            }

            get canvas() {
                return this._canvas
            }

            _fillTexture_h(tex, imgid, uv, oriw, orih, x, y, w) {
                for (var stx = x, num = Math.floor(w / oriw), left = w % oriw, i = 0; i < num; i++) this._inner_drawTexture(tex, imgid, stx, y, oriw, orih, this._curMat, uv, 1, !1), stx += oriw;
                if (left > 0) {
                    var du = uv[2] - uv[0], uvr = uv[0] + du * (left / oriw), tuv = Context.tmpuv1;
                    tuv[0] = uv[0], tuv[1] = uv[1], tuv[2] = uvr, tuv[3] = uv[3], tuv[4] = uvr, tuv[5] = uv[5], tuv[6] = uv[6], tuv[7] = uv[7], this._inner_drawTexture(tex, imgid, stx, y, left, orih, this._curMat, tuv, 1, !1)
                }
            }

            _fillTexture_v(tex, imgid, uv, oriw, orih, x, y, h) {
                for (var sty = y, num = Math.floor(h / orih), left = h % orih, i = 0; i < num; i++) this._inner_drawTexture(tex, imgid, x, sty, oriw, orih, this._curMat, uv, 1, !1), sty += orih;
                if (left > 0) {
                    var dv = uv[7] - uv[1], uvb = uv[1] + dv * (left / orih), tuv = Context.tmpuv1;
                    tuv[0] = uv[0], tuv[1] = uv[1], tuv[2] = uv[2], tuv[3] = uv[3], tuv[4] = uv[4], tuv[5] = uvb, tuv[6] = uv[6], tuv[7] = uvb, this._inner_drawTexture(tex, imgid, x, sty, oriw, left, this._curMat, tuv, 1, !1)
                }
            }

            drawTextureWithSizeGrid(tex, tx, ty, width, height, sizeGrid, gx, gy) {
                if (tex._getSource()) {
                    tx += gx, ty += gy;
                    var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height, top = sizeGrid[0], left = sizeGrid[3],
                        d_top = top / h, d_left = left / w, right = sizeGrid[1], bottom = sizeGrid[2],
                        d_right = right / w, d_bottom = bottom / h, repeat = sizeGrid[4], needClip = !1;
                    if (width == w && (left = right = 0), height == h && (top = bottom = 0), left + right > width) {
                        var clipWidth = width;
                        needClip = !0, width = left + right, this.save(), this.clipRect(0 + tx, 0 + ty, clipWidth, height)
                    }
                    var imgid = tex.bitmap.id, mat = this._curMat, tuv = this._tempUV, uvl = uv[0], uvt = uv[1],
                        uvr = uv[4], uvb = uv[5], uvl_ = uvl, uvt_ = uvt, uvr_ = uvr, uvb_ = uvb;
                    if (left && top && (uvr_ = uvl + d_left, uvb_ = uvt + d_top, tuv[0] = uvl, tuv[1] = uvt, tuv[2] = uvr_, tuv[3] = uvt, tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl, tuv[7] = uvb_, this._inner_drawTexture(tex, imgid, tx, ty, left, top, mat, tuv, 1, !1)), right && top && (uvl_ = uvr - d_right, uvt_ = uvt, uvr_ = uvr, uvb_ = uvt + d_top, tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_, tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_, this._inner_drawTexture(tex, imgid, width - right + tx, 0 + ty, right, top, mat, tuv, 1, !1)), left && bottom && (uvl_ = uvl, uvt_ = uvb - d_bottom, uvr_ = uvl + d_left, uvb_ = uvb, tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_, tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_, this._inner_drawTexture(tex, imgid, 0 + tx, height - bottom + ty, left, bottom, mat, tuv, 1, !1)), right && bottom && (uvl_ = uvr - d_right, uvt_ = uvb - d_bottom, uvr_ = uvr, uvb_ = uvb, tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_, tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_, this._inner_drawTexture(tex, imgid, width - right + tx, height - bottom + ty, right, bottom, mat, tuv, 1, !1)), top && (uvl_ = uvl + d_left, uvt_ = uvt, uvr_ = uvr - d_right, uvb_ = uvt + d_top, tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_, tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_, repeat ? this._fillTexture_h(tex, imgid, tuv, tex.width - left - right, top, left + tx, ty, width - left - right) : this._inner_drawTexture(tex, imgid, left + tx, ty, width - left - right, top, mat, tuv, 1, !1)), bottom && (uvl_ = uvl + d_left, uvt_ = uvb - d_bottom, uvr_ = uvr - d_right, uvb_ = uvb, tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_, tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_, repeat ? this._fillTexture_h(tex, imgid, tuv, tex.width - left - right, bottom, left + tx, height - bottom + ty, width - left - right) : this._inner_drawTexture(tex, imgid, left + tx, height - bottom + ty, width - left - right, bottom, mat, tuv, 1, !1)), left && (uvl_ = uvl, uvt_ = uvt + d_top, uvr_ = uvl + d_left, uvb_ = uvb - d_bottom, tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_, tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_, repeat ? this._fillTexture_v(tex, imgid, tuv, left, tex.height - top - bottom, tx, top + ty, height - top - bottom) : this._inner_drawTexture(tex, imgid, tx, top + ty, left, height - top - bottom, mat, tuv, 1, !1)), right && (uvl_ = uvr - d_right, uvt_ = uvt + d_top, uvr_ = uvr, uvb_ = uvb - d_bottom, tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_, tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_, repeat ? this._fillTexture_v(tex, imgid, tuv, right, tex.height - top - bottom, width - right + tx, top + ty, height - top - bottom) : this._inner_drawTexture(tex, imgid, width - right + tx, top + ty, right, height - top - bottom, mat, tuv, 1, !1)), uvl_ = uvl + d_left, uvt_ = uvt + d_top, uvr_ = uvr - d_right, uvb_ = uvb - d_bottom, tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_, tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_, repeat) {
                        var tuvr = Context.tmpUVRect;
                        tuvr[0] = uvl_, tuvr[1] = uvt_, tuvr[2] = uvr_ - uvl_, tuvr[3] = uvb_ - uvt_, this._fillTexture(tex, tex.width - left - right, tex.height - top - bottom, tuvr, left + tx, top + ty, width - left - right, height - top - bottom, "repeat", 0, 0)
                    } else this._inner_drawTexture(tex, imgid, left + tx, top + ty, width - left - right, height - top - bottom, mat, tuv, 1, !1);
                    needClip && this.restore()
                }
            }
        }

        Context.ENUM_TEXTALIGN_DEFAULT = 0, Context.ENUM_TEXTALIGN_CENTER = 1, Context.ENUM_TEXTALIGN_RIGHT = 2, Context._SUBMITVBSIZE = 32e3, Context._MAXSIZE = 99999999, Context._MAXVERTNUM = 65535, Context.MAXCLIPRECT = null, Context._COUNT = 0, Context.SEGNUM = 32, Context._contextcount = 0, Context.PI2 = 2 * Math.PI, Context._textRender = null, Context.tmpuv1 = [0, 0, 0, 0, 0, 0, 0, 0], Context.tmpUV = [0, 0, 0, 0, 0, 0, 0, 0], Context.tmpUVRect = [0, 0, 0, 0];

        class ContextParams {
            constructor() {
                this.lineWidth = 1
            }

            clear() {
                this.lineWidth = 1, this.textAlign = this.textBaseline = null
            }

            make() {
                return this === ContextParams.DEFAULT ? new ContextParams : this
            }
        }

        class WebGL {
            static _uint8ArraySlice() {
                for (var sz = this.length, dec = new Uint8Array(this.length), i = 0; i < sz; i++) dec[i] = this[i];
                return dec
            }

            static _float32ArraySlice() {
                for (var sz = this.length, dec = new Float32Array(this.length), i = 0; i < sz; i++) dec[i] = this[i];
                return dec
            }

            static _uint16ArraySlice(...arg) {
                var sz, dec, i;
                if (0 === arg.length) for (sz = this.length, dec = new Uint16Array(sz), i = 0; i < sz; i++) dec[i] = this[i]; else if (2 === arg.length) {
                    var start = arg[0], end = arg[1];
                    if (end > start) for (sz = end - start, dec = new Uint16Array(sz), i = start; i < end; i++) dec[i - start] = this[i]; else dec = new Uint16Array(0)
                }
                return dec
            }

            static _nativeRender_enable() {
            }

            static enable() {
                return !0
            }

            static inner_enable() {
                return Float32Array.prototype.slice || (Float32Array.prototype.slice = WebGL._float32ArraySlice), Uint16Array.prototype.slice || (Uint16Array.prototype.slice = WebGL._uint16ArraySlice), Uint8Array.prototype.slice || (Uint8Array.prototype.slice = WebGL._uint8ArraySlice), !0
            }

            static onStageResize(width, height) {
                null != WebGLContext.mainContext && (WebGLContext.mainContext.viewport(0, 0, width, height), RenderState2D.width = width, RenderState2D.height = height)
            }
        }

        WebGL._isWebGL2 = !1, WebGL.isNativeRender_enable = !1;
        !function () {
            var glErrorShadow = {};

            function synthesizeGLError(err, opt_msg) {
                var msg;
                glErrorShadow[err] = !0, void 0 !== opt_msg && (msg = opt_msg, window.console && window.console.error && window.console.error(msg))
            }

            var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
                var gl = ext.gl;
                this.ext = ext, this.isAlive = !0, this.hasBeenBound = !1, this.elementArrayBuffer = null, this.attribs = new Array(ext.maxVertexAttribs);
                for (var n = 0; n < this.attribs.length; n++) {
                    var attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
                    this.attribs[n] = attrib
                }
                this.maxAttrib = 0
            };
            (WebGLVertexArrayObjectOES.VertexAttrib = function (gl) {
                this.enabled = !1, this.buffer = null, this.size = 4, this.type = gl.FLOAT, this.normalized = !1, this.stride = 16, this.offset = 0, this.cached = "", this.recache()
            }).prototype.recache = function () {
                this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":")
            };
            var OESVertexArrayObject = function (gl) {
                var self = this;
                this.gl = gl, function (gl) {
                    var f = gl.getError;
                    gl.getError = function () {
                        var err;
                        do {
                            (err = f.apply(gl)) != gl.NO_ERROR && (glErrorShadow[err] = !0)
                        } while (err != gl.NO_ERROR);
                        for (var err1 in glErrorShadow) if (glErrorShadow[err1]) return delete glErrorShadow[err1], parseInt(err1);
                        return gl.NO_ERROR
                    }
                }(gl);
                var original = this.original = {
                    getParameter: gl.getParameter,
                    enableVertexAttribArray: gl.enableVertexAttribArray,
                    disableVertexAttribArray: gl.disableVertexAttribArray,
                    bindBuffer: gl.bindBuffer,
                    getVertexAttrib: gl.getVertexAttrib,
                    vertexAttribPointer: gl.vertexAttribPointer
                };
                gl.getParameter = function (pname) {
                    return pname == self.VERTEX_ARRAY_BINDING_OES ? self.currentVertexArrayObject == self.defaultVertexArrayObject ? null : self.currentVertexArrayObject : original.getParameter.apply(this, arguments)
                }, gl.enableVertexAttribArray = function (index) {
                    var vao = self.currentVertexArrayObject;
                    return vao.maxAttrib = Math.max(vao.maxAttrib, index), vao.attribs[index].enabled = !0, original.enableVertexAttribArray.apply(this, arguments)
                }, gl.disableVertexAttribArray = function (index) {
                    var vao = self.currentVertexArrayObject;
                    return vao.maxAttrib = Math.max(vao.maxAttrib, index), vao.attribs[index].enabled = !1, original.disableVertexAttribArray.apply(this, arguments)
                }, gl.bindBuffer = function (target, buffer) {
                    switch (target) {
                        case gl.ARRAY_BUFFER:
                            self.currentArrayBuffer = buffer;
                            break;
                        case gl.ELEMENT_ARRAY_BUFFER:
                            self.currentVertexArrayObject.elementArrayBuffer = buffer
                    }
                    return original.bindBuffer.apply(this, arguments)
                }, gl.getVertexAttrib = function (index, pname) {
                    var attrib = self.currentVertexArrayObject.attribs[index];
                    switch (pname) {
                        case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
                            return attrib.buffer;
                        case gl.VERTEX_ATTRIB_ARRAY_ENABLED:
                            return attrib.enabled;
                        case gl.VERTEX_ATTRIB_ARRAY_SIZE:
                            return attrib.size;
                        case gl.VERTEX_ATTRIB_ARRAY_STRIDE:
                            return attrib.stride;
                        case gl.VERTEX_ATTRIB_ARRAY_TYPE:
                            return attrib.type;
                        case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:
                            return attrib.normalized;
                        default:
                            return original.getVertexAttrib.apply(this, arguments)
                    }
                }, gl.vertexAttribPointer = function (indx, size, type, normalized, stride, offset) {
                    var vao = self.currentVertexArrayObject;
                    vao.maxAttrib = Math.max(vao.maxAttrib, indx);
                    var attrib = vao.attribs[indx];
                    return attrib.buffer = self.currentArrayBuffer, attrib.size = size, attrib.type = type, attrib.normalized = normalized, attrib.stride = stride, attrib.offset = offset, attrib.recache(), original.vertexAttribPointer.apply(this, arguments)
                }, gl.instrumentExtension && gl.instrumentExtension(this, "OES_vertex_array_object"), gl.canvas.addEventListener("webglcontextrestored", function () {
                    var msg;
                    msg = "OESVertexArrayObject emulation library context restored", window.console && window.console.log && window.console.log(msg), self.reset_()
                }, !0), this.reset_()
            };
            OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 34229, OESVertexArrayObject.prototype.reset_ = function () {
                if (void 0 !== this.vertexArrayObjects) for (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) this.vertexArrayObjects.isAlive = !1;
                var gl = this.gl;
                this.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this), this.currentVertexArrayObject = null, this.currentArrayBuffer = null, this.vertexArrayObjects = [this.defaultVertexArrayObject], this.bindVertexArrayOES(null)
            }, OESVertexArrayObject.prototype.createVertexArrayOES = function () {
                var arrayObject = new WebGLVertexArrayObjectOES(this);
                return this.vertexArrayObjects.push(arrayObject), arrayObject
            }, OESVertexArrayObject.prototype.deleteVertexArrayOES = function (arrayObject) {
                arrayObject.isAlive = !1, this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1), this.currentVertexArrayObject == arrayObject && this.bindVertexArrayOES(null)
            }, OESVertexArrayObject.prototype.isVertexArrayOES = function (arrayObject) {
                return !!(arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES && arrayObject.hasBeenBound && arrayObject.ext == this)
            }, OESVertexArrayObject.prototype.bindVertexArrayOES = function (arrayObject) {
                var gl = this.gl;
                if (!arrayObject || arrayObject.isAlive) {
                    var original = this.original, oldVAO = this.currentVertexArrayObject;
                    this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject, this.currentVertexArrayObject.hasBeenBound = !0;
                    var newVAO = this.currentVertexArrayObject;
                    if (oldVAO != newVAO) {
                        oldVAO && newVAO.elementArrayBuffer == oldVAO.elementArrayBuffer || original.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);
                        for (var currentBinding = this.currentArrayBuffer, maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib), n = 0; n <= maxAttrib; n++) {
                            var attrib = newVAO.attribs[n], oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
                            if (oldVAO && attrib.enabled == oldAttrib.enabled || (attrib.enabled ? original.enableVertexAttribArray.call(gl, n) : original.disableVertexAttribArray.call(gl, n)), attrib.enabled) {
                                var bufferChanged = !1;
                                oldVAO && attrib.buffer == oldAttrib.buffer || (currentBinding != attrib.buffer && (original.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer), currentBinding = attrib.buffer), bufferChanged = !0), (bufferChanged || attrib.cached != oldAttrib.cached) && original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset)
                            }
                        }
                        this.currentArrayBuffer != currentBinding && original.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer)
                    }
                } else synthesizeGLError(gl.INVALID_OPERATION, "bindVertexArrayOES: attempt to bind deleted arrayObject")
            }, window._setupVertexArrayObject = function (gl) {
                var original_getSupportedExtensions = gl.getSupportedExtensions;
                gl.getSupportedExtensions = function () {
                    var list = original_getSupportedExtensions.call(this) || [];
                    return list.indexOf("OES_vertex_array_object") < 0 && list.push("OES_vertex_array_object"), list
                };
                var original_getExtension = gl.getExtension;
                gl.getExtension = function (name) {
                    var ext = original_getExtension.call(this, name);
                    return ext || ("OES_vertex_array_object" !== name ? null : (this.__OESVertexArrayObject || (console.log("Setup OES_vertex_array_object polyfill"), this.__OESVertexArrayObject = new OESVertexArrayObject(this)), this.__OESVertexArrayObject))
                }
            }, window._forceSetupVertexArrayObject = function (gl) {
                var original_getSupportedExtensions = gl.getSupportedExtensions;
                gl.getSupportedExtensions = function () {
                    var list = original_getSupportedExtensions.call(this) || [];
                    return list.indexOf("OES_vertex_array_object") < 0 && list.push("OES_vertex_array_object"), list
                };
                var original_getExtension = gl.getExtension;
                gl.getExtension = function (name) {
                    if ("OES_vertex_array_object" === name) return this.__OESVertexArrayObject || (console.log("Setup OES_vertex_array_object polyfill"), this.__OESVertexArrayObject = new OESVertexArrayObject(this)), this.__OESVertexArrayObject;
                    var ext = original_getExtension.call(this, name);
                    return ext || null
                }
            }
        }();

        class LayaGPU {
            constructor(gl, isWebGL2) {
                this._gl = null, this._vaoExt = null, this._angleInstancedArrays = null, this._isWebGL2 = !1, this._oesTextureHalfFloat = null, this._extTextureFilterAnisotropic = null, this._compressedTextureS3tc = null, this._compressedTexturePvrtc = null, this._compressedTextureEtc1 = null, this._gl = gl, this._isWebGL2 = isWebGL2;
                try {
                    gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision ? WebGL.shaderHighPrecision = !0 : WebGL.shaderHighPrecision = !1
                } catch (e) {
                }
                if (isWebGL2) this._getExtension("EXT_color_buffer_float"); else {
                    var forceVAO = LayaGPU._forceSupportVAOPlatform();
                    ILaya.Render.isConchApp || window._setupVertexArrayObject && (forceVAO ? window._forceSetupVertexArrayObject(gl) : window._setupVertexArrayObject(gl)), this._vaoExt = this._getExtension("OES_vertex_array_object"), this._angleInstancedArrays = this._getExtension("ANGLE_instanced_arrays"), this._oesTextureHalfFloat = this._getExtension("OES_texture_half_float"), this._getExtension("OES_texture_half_float_linear")
                }
                this._extTextureFilterAnisotropic = this._getExtension("EXT_texture_filter_anisotropic"), this._compressedTextureS3tc = this._getExtension("WEBGL_compressed_texture_s3tc"), this._compressedTexturePvrtc = this._getExtension("WEBGL_compressed_texture_pvrtc"), this._compressedTextureEtc1 = this._getExtension("WEBGL_compressed_texture_etc1")
            }

            static _forceSupportVAOPlatform() {
                let Browser = ILaya.Browser;
                return Browser.onMiniGame && Browser.onIOS || Browser.onBDMiniGame || Browser.onQGMiniGame
            }

            _getExtension(name) {
                var prefixes = LayaGPU._extentionVendorPrefixes;
                for (var k in prefixes) {
                    var ext = this._gl.getExtension(prefixes[k] + name);
                    if (ext) return ext
                }
                return null
            }

            createVertexArray() {
                return this._isWebGL2 ? this._gl.createVertexArray() : this._vaoExt.createVertexArrayOES()
            }

            bindVertexArray(vertexArray) {
                this._isWebGL2 ? this._gl.bindVertexArray(vertexArray) : this._vaoExt.bindVertexArrayOES(vertexArray)
            }

            deleteVertexArray(vertexArray) {
                this._isWebGL2 ? this._gl.deleteVertexArray(vertexArray) : this._vaoExt.deleteVertexArrayOES(vertexArray)
            }

            isVertexArray(vertexArray) {
                this._isWebGL2 ? this._gl.isVertexArray(vertexArray) : this._vaoExt.isVertexArrayOES(vertexArray)
            }

            drawElementsInstanced(mode, count, type, offset, instanceCount) {
                this._isWebGL2 ? this._gl.drawElementsInstanced(mode, count, type, offset, instanceCount) : this._angleInstancedArrays.drawElementsInstancedANGLE(mode, count, type, offset, instanceCount)
            }

            drawArraysInstanced(mode, first, count, instanceCount) {
                this._isWebGL2 ? this._gl.drawArraysInstanced(mode, first, count, instanceCount) : this._angleInstancedArrays.drawArraysInstancedANGLE(mode, first, count, instanceCount)
            }

            vertexAttribDivisor(index, divisor) {
                this._isWebGL2 ? this._gl.vertexAttribDivisor(index, divisor) : this._angleInstancedArrays.vertexAttribDivisorANGLE(index, divisor)
            }

            supportInstance() {
                return !(!this._isWebGL2 && !this._angleInstancedArrays)
            }
        }

        LayaGPU._extentionVendorPrefixes = ["", "WEBKIT_", "MOZ_"];

        class Render {
            constructor(width, height, mainCanv) {
                this._timeId = 0, Render._mainCanvas = mainCanv, Render._mainCanvas.source.id = "layaCanvas", Render._mainCanvas.source.width = width, Render._mainCanvas.source.height = height, Render.isConchApp && document.body.appendChild(Render._mainCanvas.source), this.initRender(Render._mainCanvas, width, height), window.requestAnimationFrame(function loop(stamp) {
                    ILaya.stage._loop();
                    window.requestAnimationFrame(loop)
                }), ILaya.stage.on("visibilitychange", this, this._onVisibilitychange)
            }

            _onVisibilitychange() {
                ILaya.stage.isVisibility ? 0 != this._timeId && window.clearInterval(this._timeId) : this._timeId = window.setInterval(this._enterFrame, 1e3)
            }

            initRender(canvas, w, h) {
                var gl = LayaGL.instance = WebGLContext.mainContext = function (canvas) {
                    var gl, names = ["webgl2", "webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
                    Config.useWebGL2 && !Browser.onBDMiniGame || names.shift();
                    for (var i = 0; i < names.length; i++) {
                        try {
                            gl = canvas.getContext(names[i], {
                                stencil: Config.isStencil,
                                alpha: Config.isAlpha,
                                antialias: Config.isAntialias,
                                premultipliedAlpha: Config.premultipliedAlpha,
                                preserveDrawingBuffer: Config.preserveDrawingBuffer
                            })
                        } catch (e) {
                        }
                        if (gl) return "webgl2" === names[i] && (WebGL._isWebGL2 = !0), gl
                    }
                    return null
                }(Render._mainCanvas.source);
                if (!gl) return !1;
                LayaGL.instance = gl, LayaGL.layaGPUInstance = new LayaGPU(gl, WebGL._isWebGL2), canvas.size(w, h), Context.__init__(), SubmitBase.__init__();
                var ctx = new Context;
                return ctx.isMain = !0, Render._context = ctx, canvas._setContext(ctx), ShaderDefines2D.__init__(), Value2D.__init__(), Shader2D.__init__(), Buffer2D.__int__(gl), BlendMode._init_(gl), !0
            }

            _enterFrame(e = null) {
                ILaya.stage._loop()
            }

            static get context() {
                return Render._context
            }

            static get canvas() {
                return Render._mainCanvas.source
            }
        }

        Render.supportWebGLPlusCulling = !1, Render.supportWebGLPlusAnimation = !1, Render.supportWebGLPlusRendering = !1, Render.isConchApp = !1, Render.isConchApp = null != window.conch, Render.isConchApp && (Render.supportWebGLPlusCulling = !0, Render.supportWebGLPlusAnimation = !0, Render.supportWebGLPlusRendering = !0);

        class DrawTrianglesCmd {
            static create(texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
                var cmd = Pool.getItemByClass("DrawTrianglesCmd", DrawTrianglesCmd);
                if (cmd.texture = texture, cmd.x = x, cmd.y = y, cmd.vertices = vertices, cmd.uvs = uvs, cmd.indices = indices, cmd.matrix = matrix, cmd.alpha = alpha, color) {
                    cmd.color = new ColorFilter;
                    var c = ColorUtils.create(color).arrColor;
                    cmd.color.color(255 * c[0], 255 * c[1], 255 * c[2], 255 * c[3])
                }
                return cmd.blendMode = blendMode, cmd
            }

            recover() {
                this.texture = null, this.vertices = null, this.uvs = null, this.indices = null, this.matrix = null, Pool.recover("DrawTrianglesCmd", this)
            }

            run(context, gx, gy) {
                context.drawTriangles(this.texture, this.x + gx, this.y + gy, this.vertices, this.uvs, this.indices, this.matrix, this.alpha, this.color, this.blendMode)
            }

            get cmdID() {
                return DrawTrianglesCmd.ID
            }
        }

        DrawTrianglesCmd.ID = "DrawTriangles";

        class Draw9GridTexture {
            constructor() {
            }

            static create(texture, x, y, width, height, sizeGrid) {
                var cmd = Pool.getItemByClass("Draw9GridTexture", Draw9GridTexture);
                return cmd.texture = texture, texture._addReference(), cmd.x = x, cmd.y = y, cmd.width = width, cmd.height = height, cmd.sizeGrid = sizeGrid, cmd
            }

            recover() {
                this.texture._removeReference(), Pool.recover("Draw9GridTexture", this)
            }

            run(context, gx, gy) {
                context.drawTextureWithSizeGrid(this.texture, this.x, this.y, this.width, this.height, this.sizeGrid, gx, gy)
            }

            get cmdID() {
                return Draw9GridTexture.ID
            }
        }

        Draw9GridTexture.ID = "Draw9GridTexture";

        class GraphicsBounds {
            constructor() {
                this._cacheBoundsType = !1
            }

            destroy() {
                this._graphics = null, this._cacheBoundsType = !1, this._temp && (this._temp.length = 0), this._rstBoundPoints && (this._rstBoundPoints.length = 0), this._bounds && this._bounds.recover(), this._bounds = null, Pool.recover("GraphicsBounds", this)
            }

            static create() {
                return Pool.getItemByClass("GraphicsBounds", GraphicsBounds)
            }

            reset() {
                this._temp && (this._temp.length = 0)
            }

            getBounds(realSize = !1) {
                return (!this._bounds || !this._temp || this._temp.length < 1 || realSize != this._cacheBoundsType) && (this._bounds = Rectangle._getWrapRec(this.getBoundPoints(realSize), this._bounds)), this._cacheBoundsType = realSize, this._bounds
            }

            getBoundPoints(realSize = !1) {
                return (!this._temp || this._temp.length < 1 || realSize != this._cacheBoundsType) && (this._temp = this._getCmdPoints(realSize)), this._cacheBoundsType = realSize, this._rstBoundPoints = Utils.copyArray(this._rstBoundPoints, this._temp)
            }

            _getCmdPoints(realSize = !1) {
                var rst, cmds = this._graphics.cmds;
                if ((rst = this._temp || (this._temp = [])).length = 0, cmds || null == this._graphics._one || (GraphicsBounds._tempCmds.length = 0, GraphicsBounds._tempCmds.push(this._graphics._one), cmds = GraphicsBounds._tempCmds), !cmds) return rst;
                var matrixs = GraphicsBounds._tempMatrixArrays;
                matrixs.length = 0;
                var tMatrix = GraphicsBounds._initMatrix;
                tMatrix.identity();
                for (var cmd, tex, tempMatrix = GraphicsBounds._tempMatrix, i = 0, n = cmds.length; i < n; i++) switch ((cmd = cmds[i]).cmdID) {
                    case AlphaCmd.ID:
                        matrixs.push(tMatrix), tMatrix = tMatrix.clone();
                        break;
                    case RestoreCmd.ID:
                        tMatrix = matrixs.pop();
                        break;
                    case ScaleCmd.ID:
                        tempMatrix.identity(), tempMatrix.translate(-cmd.pivotX, -cmd.pivotY), tempMatrix.scale(cmd.scaleX, cmd.scaleY), tempMatrix.translate(cmd.pivotX, cmd.pivotY), this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case RotateCmd.ID:
                        tempMatrix.identity(), tempMatrix.translate(-cmd.pivotX, -cmd.pivotY), tempMatrix.rotate(cmd.angle), tempMatrix.translate(cmd.pivotX, cmd.pivotY), this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case TranslateCmd.ID:
                        tempMatrix.identity(), tempMatrix.translate(cmd.tx, cmd.ty), this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case TransformCmd.ID:
                        tempMatrix.identity(), tempMatrix.translate(-cmd.pivotX, -cmd.pivotY), tempMatrix.concat(cmd.matrix), tempMatrix.translate(cmd.pivotX, cmd.pivotY), this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case DrawImageCmd.ID:
                    case FillTextureCmd.ID:
                        GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tMatrix);
                        break;
                    case DrawTextureCmd.ID:
                        tMatrix.copyTo(tempMatrix), cmd.matrix && tempMatrix.concat(cmd.matrix), GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tempMatrix);
                        break;
                    case DrawImageCmd.ID:
                        if (tex = cmd.texture, realSize) cmd.width && cmd.height ? GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tMatrix) : GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, tex.width, tex.height), tMatrix); else {
                            var wRate = (cmd.width || tex.sourceWidth) / tex.width,
                                hRate = (cmd.height || tex.sourceHeight) / tex.height, oWidth = wRate * tex.sourceWidth,
                                oHeight = hRate * tex.sourceHeight, offX = tex.offsetX > 0 ? tex.offsetX : 0,
                                offY = tex.offsetY > 0 ? tex.offsetY : 0;
                            offX *= wRate, offY *= hRate, GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x - offX, cmd.y - offY, oWidth, oHeight), tMatrix)
                        }
                        break;
                    case FillTextureCmd.ID:
                        cmd.width && cmd.height ? GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tMatrix) : (tex = cmd.texture, GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, tex.width, tex.height), tMatrix));
                        break;
                    case DrawTextureCmd.ID:
                        var drawMatrix;
                        cmd.matrix ? (tMatrix.copyTo(tempMatrix), tempMatrix.concat(cmd.matrix), drawMatrix = tempMatrix) : drawMatrix = tMatrix, realSize ? cmd.width && cmd.height ? GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), drawMatrix) : (tex = cmd.texture, GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, tex.width, tex.height), drawMatrix)) : (tex = cmd.texture, wRate = (cmd.width || tex.sourceWidth) / tex.width, hRate = (cmd.height || tex.sourceHeight) / tex.height, oWidth = wRate * tex.sourceWidth, oHeight = hRate * tex.sourceHeight, offX = tex.offsetX > 0 ? tex.offsetX : 0, offY = tex.offsetY > 0 ? tex.offsetY : 0, offX *= wRate, offY *= hRate, GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x - offX, cmd.y - offY, oWidth, oHeight), drawMatrix));
                        break;
                    case DrawRectCmd.ID:
                        GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tMatrix);
                        break;
                    case DrawCircleCmd.ID:
                        GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x - cmd.radius, cmd.y - cmd.radius, cmd.radius + cmd.radius, cmd.radius + cmd.radius), tMatrix);
                        break;
                    case DrawLineCmd.ID:
                        var lineWidth;
                        GraphicsBounds._tempPoints.length = 0, lineWidth = .5 * cmd.lineWidth, cmd.fromX == cmd.toX ? GraphicsBounds._tempPoints.push(cmd.fromX + lineWidth, cmd.fromY, cmd.toX + lineWidth, cmd.toY, cmd.fromX - lineWidth, cmd.fromY, cmd.toX - lineWidth, cmd.toY) : cmd.fromY == cmd.toY ? GraphicsBounds._tempPoints.push(cmd.fromX, cmd.fromY + lineWidth, cmd.toX, cmd.toY + lineWidth, cmd.fromX, cmd.fromY - lineWidth, cmd.toX, cmd.toY - lineWidth) : GraphicsBounds._tempPoints.push(cmd.fromX, cmd.fromY, cmd.toX, cmd.toY), GraphicsBounds._addPointArrToRst(rst, GraphicsBounds._tempPoints, tMatrix);
                        break;
                    case DrawCurvesCmd.ID:
                        GraphicsBounds._addPointArrToRst(rst, Bezier.I.getBezierPoints(cmd.points), tMatrix, cmd.x, cmd.y);
                        break;
                    case DrawLinesCmd.ID:
                    case DrawPolyCmd.ID:
                        GraphicsBounds._addPointArrToRst(rst, cmd.points, tMatrix, cmd.x, cmd.y);
                        break;
                    case DrawPathCmd.ID:
                        GraphicsBounds._addPointArrToRst(rst, this._getPathPoints(cmd.paths), tMatrix, cmd.x, cmd.y);
                        break;
                    case DrawPieCmd.ID:
                        GraphicsBounds._addPointArrToRst(rst, this._getPiePoints(cmd.x, cmd.y, cmd.radius, cmd.startAngle, cmd.endAngle), tMatrix);
                        break;
                    case DrawTrianglesCmd.ID:
                        GraphicsBounds._addPointArrToRst(rst, this._getTriAngBBXPoints(cmd.vertices), tMatrix);
                        break;
                    case Draw9GridTexture.ID:
                        GraphicsBounds._addPointArrToRst(rst, this._getDraw9GridBBXPoints(cmd), tMatrix)
                }
                return rst.length > 200 ? rst = Utils.copyArray(rst, Rectangle._getWrapRec(rst)._getBoundPoints()) : rst.length > 8 && (rst = GrahamScan.scanPList(rst)), rst
            }

            _switchMatrix(tMatix, tempMatrix) {
                tempMatrix.concat(tMatix), tempMatrix.copyTo(tMatix)
            }

            static _addPointArrToRst(rst, points, matrix, dx = 0, dy = 0) {
                var i, len;
                for (len = points.length, i = 0; i < len; i += 2) GraphicsBounds._addPointToRst(rst, points[i] + dx, points[i + 1] + dy, matrix)
            }

            static _addPointToRst(rst, x, y, matrix) {
                var _tempPoint = Point.TEMP;
                _tempPoint.setTo(x || 0, y || 0), matrix.transformPoint(_tempPoint), rst.push(_tempPoint.x, _tempPoint.y)
            }

            _getPiePoints(x, y, radius, startAngle, endAngle) {
                var rst = GraphicsBounds._tempPoints;
                GraphicsBounds._tempPoints.length = 0;
                var k = Math.PI / 180, d1 = endAngle - startAngle;
                if (d1 >= 360 || d1 <= -360) return rst.push(x - radius, y - radius), rst.push(x + radius, y - radius), rst.push(x + radius, y + radius), rst.push(x - radius, y + radius), rst;
                rst.push(x, y);
                var delta = d1 % 360;
                delta < 0 && (delta += 360);
                var end1 = startAngle + delta, st = startAngle * k, ed = end1 * k;
                rst.push(x + radius * Math.cos(st), y + radius * Math.sin(st)), rst.push(x + radius * Math.cos(ed), y + radius * Math.sin(ed));
                for (var s1 = 90 * Math.ceil(startAngle / 90), s2 = 90 * Math.floor(end1 / 90), cs = s1; cs <= s2; cs += 90) {
                    var csr = cs * k;
                    rst.push(x + radius * Math.cos(csr), y + radius * Math.sin(csr))
                }
                return rst
            }

            _getTriAngBBXPoints(vert) {
                var vnum = vert.length;
                if (vnum < 2) return [];
                for (var minx = vert[0], miny = vert[1], maxx = minx, maxy = miny, i = 2; i < vnum;) {
                    var cx = vert[i++], cy = vert[i++];
                    minx > cx && (minx = cx), miny > cy && (miny = cy), maxx < cx && (maxx = cx), maxy < cy && (maxy = cy)
                }
                return [minx, miny, maxx, miny, maxx, maxy, minx, maxy]
            }

            _getDraw9GridBBXPoints(cmd) {
                var maxx = cmd.width, maxy = cmd.height;
                return [0, 0, maxx, 0, maxx, maxy, 0, maxy]
            }

            _getPathPoints(paths) {
                var i, len, tCMD, rst = GraphicsBounds._tempPoints;
                for (rst.length = 0, len = paths.length, i = 0; i < len; i++) (tCMD = paths[i]).length > 1 && (rst.push(tCMD[1], tCMD[2]), tCMD.length > 3 && rst.push(tCMD[3], tCMD[4]));
                return rst
            }
        }

        GraphicsBounds._tempMatrix = new Matrix, GraphicsBounds._initMatrix = new Matrix, GraphicsBounds._tempPoints = [], GraphicsBounds._tempMatrixArrays = [], GraphicsBounds._tempCmds = [];

        class SpriteConst {
        }

        SpriteConst.ALPHA = 1, SpriteConst.TRANSFORM = 2, SpriteConst.BLEND = 4, SpriteConst.CANVAS = 8, SpriteConst.FILTERS = 16, SpriteConst.MASK = 32, SpriteConst.CLIP = 64, SpriteConst.STYLE = 128, SpriteConst.TEXTURE = 256, SpriteConst.GRAPHICS = 512, SpriteConst.LAYAGL3D = 1024, SpriteConst.CUSTOM = 2048, SpriteConst.ONECHILD = 4096, SpriteConst.CHILDS = 8192, SpriteConst.REPAINT_NONE = 0, SpriteConst.REPAINT_NODE = 1, SpriteConst.REPAINT_CACHE = 2, SpriteConst.REPAINT_ALL = 3;

        class ClipRectCmd {
            static create(x, y, width, height) {
                var cmd = Pool.getItemByClass("ClipRectCmd", ClipRectCmd);
                return cmd.x = x, cmd.y = y, cmd.width = width, cmd.height = height, cmd
            }

            recover() {
                Pool.recover("ClipRectCmd", this)
            }

            run(context, gx, gy) {
                context.clipRect(this.x + gx, this.y + gy, this.width, this.height)
            }

            get cmdID() {
                return ClipRectCmd.ID
            }
        }

        ClipRectCmd.ID = "ClipRect";

        class DrawTexturesCmd {
            static create(texture, pos) {
                var cmd = Pool.getItemByClass("DrawTexturesCmd", DrawTexturesCmd);
                return cmd.texture = texture, texture._addReference(), cmd.pos = pos, cmd
            }

            recover() {
                this.texture._removeReference(), this.texture = null, this.pos = null, Pool.recover("DrawTexturesCmd", this)
            }

            run(context, gx, gy) {
                context.drawTextures(this.texture, this.pos, gx, gy)
            }

            get cmdID() {
                return DrawTexturesCmd.ID
            }
        }

        DrawTexturesCmd.ID = "DrawTextures";

        class FillBorderTextCmd {
            static create(text, x, y, font, fillColor, borderColor, lineWidth, textAlign) {
                var cmd = Pool.getItemByClass("FillBorderTextCmd", FillBorderTextCmd);
                return cmd.text = text, cmd.x = x, cmd.y = y, cmd.font = font, cmd.fillColor = fillColor, cmd.borderColor = borderColor, cmd.lineWidth = lineWidth, cmd.textAlign = textAlign, cmd
            }

            recover() {
                Pool.recover("FillBorderTextCmd", this)
            }

            run(context, gx, gy) {
                context.fillBorderText(this.text, this.x + gx, this.y + gy, this.font, this.fillColor, this.borderColor, this.lineWidth, this.textAlign)
            }

            get cmdID() {
                return FillBorderTextCmd.ID
            }
        }

        FillBorderTextCmd.ID = "FillBorderText";

        class FillBorderWordsCmd {
            static create(words, x, y, font, fillColor, borderColor, lineWidth) {
                var cmd = Pool.getItemByClass("FillBorderWordsCmd", FillBorderWordsCmd);
                return cmd.words = words, cmd.x = x, cmd.y = y, cmd.font = font, cmd.fillColor = fillColor, cmd.borderColor = borderColor, cmd.lineWidth = lineWidth, cmd
            }

            recover() {
                this.words = null, Pool.recover("FillBorderWordsCmd", this)
            }

            run(context, gx, gy) {
                context.fillBorderWords(this.words, this.x + gx, this.y + gy, this.font, this.fillColor, this.borderColor, this.lineWidth)
            }

            get cmdID() {
                return FillBorderWordsCmd.ID
            }
        }

        FillBorderWordsCmd.ID = "FillBorderWords";

        class FillTextCmd {
            constructor() {
                this._textIsWorldText = !1, this._fontColor = 4294967295, this._strokeColor = 0, this._fontObj = FillTextCmd._defFontObj, this._nTexAlign = 0
            }

            static create(text, x, y, font, color, textAlign) {
                var cmd = Pool.getItemByClass("FillTextCmd", FillTextCmd);
                return cmd.text = text, cmd._textIsWorldText = text instanceof WordText, cmd.x = x, cmd.y = y, cmd.font = font, cmd.color = color, cmd.textAlign = textAlign, cmd
            }

            recover() {
                Pool.recover("FillTextCmd", this)
            }

            run(context, gx, gy) {
                ILaya.stage.isGlobalRepaint() && this._textIsWorldText && this._text.cleanCache(), this._textIsWorldText ? context._fast_filltext(this._text, this.x + gx, this.y + gy, this._fontObj, this._color, null, 0, this._nTexAlign, 0) : context.drawText(this._text, this.x + gx, this.y + gy, this._font, this._color, this._textAlign)
            }

            get cmdID() {
                return FillTextCmd.ID
            }

            get text() {
                return this._text
            }

            set text(value) {
                this._text = value, this._textIsWorldText = value instanceof WordText, this._textIsWorldText && this._text.cleanCache()
            }

            get font() {
                return this._font
            }

            set font(value) {
                this._font = value, this._fontObj = FontInfo.Parse(value), this._textIsWorldText && this._text.cleanCache()
            }

            get color() {
                return this._color
            }

            set color(value) {
                this._color = value, this._fontColor = ColorUtils.create(value).numColor, this._textIsWorldText && this._text.cleanCache()
            }

            get textAlign() {
                return this._textAlign
            }

            set textAlign(value) {
                switch (this._textAlign = value, value) {
                    case"center":
                        this._nTexAlign = ILaya.Context.ENUM_TEXTALIGN_CENTER;
                        break;
                    case"right":
                        this._nTexAlign = ILaya.Context.ENUM_TEXTALIGN_RIGHT;
                        break;
                    default:
                        this._nTexAlign = ILaya.Context.ENUM_TEXTALIGN_DEFAULT
                }
                this._textIsWorldText && this._text.cleanCache()
            }
        }

        FillTextCmd.ID = "FillText", FillTextCmd._defFontObj = new FontInfo(null);

        class FillWordsCmd {
            static create(words, x, y, font, color) {
                var cmd = Pool.getItemByClass("FillWordsCmd", FillWordsCmd);
                return cmd.words = words, cmd.x = x, cmd.y = y, cmd.font = font, cmd.color = color, cmd
            }

            recover() {
                this.words = null, Pool.recover("FillWordsCmd", this)
            }

            run(context, gx, gy) {
                context.fillWords(this.words, this.x + gx, this.y + gy, this.font, this.color)
            }

            get cmdID() {
                return FillWordsCmd.ID
            }
        }

        FillWordsCmd.ID = "FillWords";

        class SaveCmd {
            static create() {
                return Pool.getItemByClass("SaveCmd", SaveCmd)
            }

            recover() {
                Pool.recover("SaveCmd", this)
            }

            run(context, gx, gy) {
                context.save()
            }

            get cmdID() {
                return SaveCmd.ID
            }
        }

        SaveCmd.ID = "Save";

        class StrokeTextCmd {
            static create(text, x, y, font, color, lineWidth, textAlign) {
                var cmd = Pool.getItemByClass("StrokeTextCmd", StrokeTextCmd);
                return cmd.text = text, cmd.x = x, cmd.y = y, cmd.font = font, cmd.color = color, cmd.lineWidth = lineWidth, cmd.textAlign = textAlign, cmd
            }

            recover() {
                Pool.recover("StrokeTextCmd", this)
            }

            run(context, gx, gy) {
                context.strokeWord(this.text, this.x + gx, this.y + gy, this.font, this.color, this.lineWidth, this.textAlign)
            }

            get cmdID() {
                return StrokeTextCmd.ID
            }
        }

        StrokeTextCmd.ID = "StrokeText";

        class CacheManger {
            constructor() {
            }

            static regCacheByFunction(disposeFunction, getCacheListFunction) {
                var cache;
                CacheManger.unRegCacheByFunction(disposeFunction, getCacheListFunction), cache = {
                    tryDispose: disposeFunction,
                    getCacheList: getCacheListFunction
                }, CacheManger._cacheList.push(cache)
            }

            static unRegCacheByFunction(disposeFunction, getCacheListFunction) {
                var i, len;
                for (len = CacheManger._cacheList.length, i = 0; i < len; i++) if (CacheManger._cacheList[i].tryDispose == disposeFunction && CacheManger._cacheList[i].getCacheList == getCacheListFunction) return void CacheManger._cacheList.splice(i, 1)
            }

            static forceDispose() {
                var i, len = CacheManger._cacheList.length;
                for (i = 0; i < len; i++) CacheManger._cacheList[i].tryDispose(!0)
            }

            static beginCheck(waitTime = 15e3) {
                ILaya.systemTimer.loop(waitTime, null, CacheManger._checkLoop)
            }

            static stopCheck() {
                ILaya.systemTimer.clear(null, CacheManger._checkLoop)
            }

            static _checkLoop() {
                var cacheList = CacheManger._cacheList;
                if (!(cacheList.length < 1)) {
                    var count, len, tTime = ILaya.Browser.now();
                    for (len = count = cacheList.length; count > 0 && (CacheManger._index++, CacheManger._index = CacheManger._index % len, cacheList[CacheManger._index].tryDispose(!1), !(ILaya.Browser.now() - tTime > CacheManger.loopTimeLimit));) count--
                }
            }
        }

        CacheManger.loopTimeLimit = 2, CacheManger._cacheList = [], CacheManger._index = 0;

        class VectorGraphManager {
            constructor() {
                this.useDic = {}, this.shapeDic = {}, this.shapeLineDic = {}, this._id = 0, this._checkKey = !1, this._freeIdArray = [], CacheManger.regCacheByFunction(this.startDispose.bind(this), this.getCacheList.bind(this))
            }

            static getInstance() {
                return VectorGraphManager.instance = VectorGraphManager.instance || new VectorGraphManager
            }

            getId() {
                return this._id++
            }

            addShape(id, shape) {
                this.shapeDic[id] = shape, this.useDic[id] || (this.useDic[id] = !0)
            }

            addLine(id, Line) {
                this.shapeLineDic[id] = Line, this.shapeLineDic[id] || (this.shapeLineDic[id] = !0)
            }

            getShape(id) {
                this._checkKey && null != this.useDic[id] && (this.useDic[id] = !0)
            }

            deleteShape(id) {
                this.shapeDic[id] && (this.shapeDic[id] = null, delete this.shapeDic[id]), this.shapeLineDic[id] && (this.shapeLineDic[id] = null, delete this.shapeLineDic[id]), null != this.useDic[id] && delete this.useDic[id]
            }

            getCacheList() {
                var str, list = [];
                for (str in this.shapeDic) list.push(this.shapeDic[str]);
                for (str in this.shapeLineDic) list.push(this.shapeLineDic[str]);
                return list
            }

            startDispose(key) {
                var str;
                for (str in this.useDic) this.useDic[str] = !1;
                this._checkKey = !0
            }

            endDispose() {
                if (this._checkKey) {
                    var str;
                    for (str in this.useDic) this.useDic[str] || this.deleteShape(str);
                    this._checkKey = !1
                }
            }
        }

        class Graphics {
            constructor() {
                this._sp = null, this._one = null, this._render = this._renderEmpty, this._cmds = null, this._vectorgraphArray = null, this._graphicBounds = null, this.autoDestroy = !1, this._createData()
            }

            _createData() {
            }

            _clearData() {
            }

            _destroyData() {
            }

            destroy() {
                this.clear(!0), this._graphicBounds && this._graphicBounds.destroy(), this._graphicBounds = null, this._vectorgraphArray = null, this._sp && (this._sp._renderType = 0, this._sp._setRenderType(0), this._sp = null), this._destroyData()
            }

            clear(recoverCmds = !0) {
                if (recoverCmds) {
                    var tCmd = this._one;
                    if (this._cmds) {
                        var i, len = this._cmds.length;
                        for (i = 0; i < len; i++) (tCmd = this._cmds[i]).recover();
                        this._cmds.length = 0
                    } else tCmd && tCmd.recover()
                } else this._cmds = null;
                if (this._one = null, this._render = this._renderEmpty, this._clearData(), this._sp && (this._sp._renderType &= ~SpriteConst.GRAPHICS, this._sp._setRenderType(this._sp._renderType)), this._repaint(), this._vectorgraphArray) {
                    for (i = 0, len = this._vectorgraphArray.length; i < len; i++) VectorGraphManager.getInstance().deleteShape(this._vectorgraphArray[i]);
                    this._vectorgraphArray.length = 0
                }
            }

            _clearBoundsCache() {
                this._graphicBounds && this._graphicBounds.reset()
            }

            _initGraphicBounds() {
                this._graphicBounds || (this._graphicBounds = GraphicsBounds.create(), this._graphicBounds._graphics = this)
            }

            _repaint() {
                this._clearBoundsCache(), this._sp && this._sp.repaint()
            }

            _isOnlyOne() {
                return !this._cmds || 0 === this._cmds.length
            }

            get cmds() {
                return this._cmds
            }

            set cmds(value) {
                this._sp && (this._sp._renderType |= SpriteConst.GRAPHICS, this._sp._setRenderType(this._sp._renderType)), this._cmds = value, this._render = this._renderAll, this._repaint()
            }

            getBounds(realSize = !1) {
                return this._initGraphicBounds(), this._graphicBounds.getBounds(realSize)
            }

            getBoundPoints(realSize = !1) {
                return this._initGraphicBounds(), this._graphicBounds.getBoundPoints(realSize)
            }

            drawImage(texture, x = 0, y = 0, width = 0, height = 0) {
                if (!texture) return null;
                if (width || (width = texture.sourceWidth), height || (height = texture.sourceHeight), texture.getIsReady()) {
                    var wRate = width / texture.sourceWidth, hRate = height / texture.sourceHeight;
                    if (width = texture.width * wRate, height = texture.height * hRate, width <= 0 || height <= 0) return null;
                    x += texture.offsetX * wRate, y += texture.offsetY * hRate
                }
                this._sp && (this._sp._renderType |= SpriteConst.GRAPHICS, this._sp._setRenderType(this._sp._renderType));
                var args = DrawImageCmd.create.call(this, texture, x, y, width, height);
                return null == this._one ? (this._one = args, this._render = this._renderOneImg) : this._saveToCmd(null, args), this._repaint(), args
            }

            drawTexture(texture, x = 0, y = 0, width = 0, height = 0, matrix = null, alpha = 1, color = null, blendMode = null, uv) {
                if (!texture || alpha < .01) return null;
                if (!texture.getIsReady()) return null;
                if (width || (width = texture.sourceWidth), height || (height = texture.sourceHeight), texture.getIsReady()) {
                    var wRate = width / texture.sourceWidth, hRate = height / texture.sourceHeight;
                    if (width = texture.width * wRate, height = texture.height * hRate, width <= 0 || height <= 0) return null;
                    x += texture.offsetX * wRate, y += texture.offsetY * hRate
                }
                this._sp && (this._sp._renderType |= SpriteConst.GRAPHICS, this._sp._setRenderType(this._sp._renderType));
                var args = DrawTextureCmd.create.call(this, texture, x, y, width, height, matrix, alpha, color, blendMode, uv);
                return this._repaint(), this._saveToCmd(null, args)
            }

            drawTextures(texture, pos) {
                return texture ? this._saveToCmd(Render._context.drawTextures, DrawTexturesCmd.create.call(this, texture, pos)) : null
            }

            drawTriangles(texture, x, y, vertices, uvs, indices, matrix = null, alpha = 1, color = null, blendMode = null) {
                return this._saveToCmd(Render._context.drawTriangles, DrawTrianglesCmd.create.call(this, texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode))
            }

            fillTexture(texture, x, y, width = 0, height = 0, type = "repeat", offset = null) {
                return texture && texture.getIsReady() ? this._saveToCmd(Render._context._fillTexture, FillTextureCmd.create.call(this, texture, x, y, width, height, type, offset || Point.EMPTY, {})) : null
            }

            _saveToCmd(fun, args) {
                return this._sp && (this._sp._renderType |= SpriteConst.GRAPHICS, this._sp._setRenderType(this._sp._renderType)), null == this._one ? (this._one = args, this._render = this._renderOne) : (this._render = this._renderAll, 0 === (this._cmds || (this._cmds = [])).length && this._cmds.push(this._one), this._cmds.push(args)), this._repaint(), args
            }

            clipRect(x, y, width, height) {
                return this._saveToCmd(Render._context.clipRect, ClipRectCmd.create.call(this, x, y, width, height))
            }

            fillText(text, x, y, font, color, textAlign) {
                return this._saveToCmd(Render._context.fillText, FillTextCmd.create.call(this, text, x, y, font || ILaya.Text.defaultFontStr(), color, textAlign))
            }

            fillBorderText(text, x, y, font, fillColor, borderColor, lineWidth, textAlign) {
                return this._saveToCmd(Render._context.fillBorderText, FillBorderTextCmd.create.call(this, text, x, y, font || ILaya.Text.defaultFontStr(), fillColor, borderColor, lineWidth, textAlign))
            }

            fillWords(words, x, y, font, color) {
                return this._saveToCmd(Render._context.fillWords, FillWordsCmd.create.call(this, words, x, y, font || ILaya.Text.defaultFontStr(), color))
            }

            fillBorderWords(words, x, y, font, fillColor, borderColor, lineWidth) {
                return this._saveToCmd(Render._context.fillBorderWords, FillBorderWordsCmd.create.call(this, words, x, y, font || ILaya.Text.defaultFontStr(), fillColor, borderColor, lineWidth))
            }

            strokeText(text, x, y, font, color, lineWidth, textAlign) {
                return this._saveToCmd(Render._context.fillBorderText, StrokeTextCmd.create.call(this, text, x, y, font || ILaya.Text.defaultFontStr(), color, lineWidth, textAlign))
            }

            alpha(alpha) {
                return this._saveToCmd(Render._context.alpha, AlphaCmd.create.call(this, alpha))
            }

            transform(matrix, pivotX = 0, pivotY = 0) {
                return this._saveToCmd(Render._context._transform, TransformCmd.create.call(this, matrix, pivotX, pivotY))
            }

            rotate(angle, pivotX = 0, pivotY = 0) {
                return this._saveToCmd(Render._context._rotate, RotateCmd.create.call(this, angle, pivotX, pivotY))
            }

            scale(scaleX, scaleY, pivotX = 0, pivotY = 0) {
                return this._saveToCmd(Render._context._scale, ScaleCmd.create.call(this, scaleX, scaleY, pivotX, pivotY))
            }

            translate(tx, ty) {
                return this._saveToCmd(Render._context.translate, TranslateCmd.create.call(this, tx, ty))
            }

            save() {
                return this._saveToCmd(Render._context._save, SaveCmd.create.call(this))
            }

            restore() {
                return this._saveToCmd(Render._context.restore, RestoreCmd.create.call(this))
            }

            replaceText(text) {
                this._repaint();
                var cmds = this._cmds;
                if (cmds) {
                    for (var i = cmds.length - 1; i > -1; i--) if (this._isTextCmd(cmds[i])) return cmds[i].text = text, !0
                } else if (this._one && this._isTextCmd(this._one)) return this._one.text = text, !0;
                return !1
            }

            _isTextCmd(cmd) {
                var cmdID = cmd.cmdID;
                return cmdID == FillTextCmd.ID || cmdID == StrokeTextCmd.ID || cmdID == FillBorderTextCmd.ID
            }

            replaceTextColor(color) {
                this._repaint();
                var cmds = this._cmds;
                if (cmds) for (var i = cmds.length - 1; i > -1; i--) this._isTextCmd(cmds[i]) && this._setTextCmdColor(cmds[i], color); else this._one && this._isTextCmd(this._one) && this._setTextCmdColor(this._one, color)
            }

            _setTextCmdColor(cmdO, color) {
                switch (cmdO.cmdID) {
                    case FillTextCmd.ID:
                    case StrokeTextCmd.ID:
                        cmdO.color = color;
                        break;
                    case FillBorderTextCmd.ID:
                    case FillBorderWordsCmd.ID:
                    case FillBorderTextCmd.ID:
                        cmdO.fillColor = color
                }
            }

            loadImage(url, x = 0, y = 0, width = 0, height = 0, complete = null) {
                var tex = ILaya.Loader.getRes(url);
                tex ? tex.getIsReady() ? this.drawImage(tex, x, y, width, height) : tex.once(Event.READY, this, this.drawImage, [tex, x, y, width, height]) : ((tex = new Texture).load(url), ILaya.Loader.cacheRes(url, tex), tex.once(Event.READY, this, this.drawImage, [tex, x, y, width, height])), null != complete && (tex.getIsReady() ? complete.call(this._sp) : tex.on(Event.READY, this._sp, complete))
            }

            _renderEmpty(sprite, context, x, y) {
            }

            _renderAll(sprite, context, x, y) {
                for (var cmds = this._cmds, i = 0, n = cmds.length; i < n; i++) cmds[i].run(context, x, y)
            }

            _renderOne(sprite, context, x, y) {
                context.sprite = sprite, this._one.run(context, x, y)
            }

            _renderOneImg(sprite, context, x, y) {
                context.sprite = sprite, this._one.run(context, x, y)
            }

            drawLine(fromX, fromY, toX, toY, lineColor, lineWidth = 1) {
                var offset = lineWidth < 1 || lineWidth % 2 == 0 ? 0 : .5;
                return this._saveToCmd(Render._context._drawLine, DrawLineCmd.create.call(this, fromX + offset, fromY + offset, toX + offset, toY + offset, lineColor, lineWidth, 0))
            }

            drawLines(x, y, points, lineColor, lineWidth = 1) {
                if (!points || points.length < 4) return null;
                var offset = lineWidth < 1 || lineWidth % 2 == 0 ? 0 : .5;
                return this._saveToCmd(Render._context._drawLines, DrawLinesCmd.create.call(this, x + offset, y + offset, points, lineColor, lineWidth, 0))
            }

            drawCurves(x, y, points, lineColor, lineWidth = 1) {
                return this._saveToCmd(Render._context.drawCurves, DrawCurvesCmd.create.call(this, x, y, points, lineColor, lineWidth))
            }

            drawRect(x, y, width, height, fillColor, lineColor = null, lineWidth = 1) {
                var offset = lineWidth >= 1 && lineColor ? lineWidth / 2 : 0, lineOffset = lineColor ? lineWidth : 0;
                return this._saveToCmd(Render._context.drawRect, DrawRectCmd.create.call(this, x + offset, y + offset, width - lineOffset, height - lineOffset, fillColor, lineColor, lineWidth))
            }

            drawCircle(x, y, radius, fillColor, lineColor = null, lineWidth = 1) {
                var offset = lineWidth >= 1 && lineColor ? lineWidth / 2 : 0;
                return this._saveToCmd(Render._context._drawCircle, DrawCircleCmd.create.call(this, x, y, radius - offset, fillColor, lineColor, lineWidth, 0))
            }

            drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor = null, lineWidth = 1) {
                var offset = lineWidth >= 1 && lineColor ? lineWidth / 2 : 0, lineOffset = lineColor ? lineWidth : 0;
                return this._saveToCmd(Render._context._drawPie, DrawPieCmd.create.call(this, x + offset, y + offset, radius - lineOffset, Utils.toRadian(startAngle), Utils.toRadian(endAngle), fillColor, lineColor, lineWidth, 0))
            }

            drawPoly(x, y, points, fillColor, lineColor = null, lineWidth = 1) {
                var tIsConvexPolygon = !1;
                tIsConvexPolygon = !(points.length > 6);
                var offset = lineWidth >= 1 && lineColor ? lineWidth % 2 == 0 ? 0 : .5 : 0;
                return this._saveToCmd(Render._context._drawPoly, DrawPolyCmd.create.call(this, x + offset, y + offset, points, fillColor, lineColor, lineWidth, tIsConvexPolygon, 0))
            }

            drawPath(x, y, paths, brush = null, pen = null) {
                return this._saveToCmd(Render._context._drawPath, DrawPathCmd.create.call(this, x, y, paths, brush, pen))
            }

            draw9Grid(texture, x = 0, y = 0, width = 0, height = 0, sizeGrid = null) {
                this._saveToCmd(null, Draw9GridTexture.create(texture, x, y, width, height, sizeGrid))
            }
        }

        class Const {
        }

        Const.NOT_ACTIVE = 1, Const.ACTIVE_INHIERARCHY = 2, Const.AWAKED = 4, Const.NOT_READY = 8, Const.DISPLAY = 16, Const.HAS_ZORDER = 32, Const.HAS_MOUSE = 64, Const.DISPLAYED_INSTAGE = 128, Const.DRAWCALL_OPTIMIZE = 256;

        class HitArea {
            contains(x, y) {
                return !!HitArea._isHitGraphic(x, y, this.hit) && !HitArea._isHitGraphic(x, y, this.unHit)
            }

            static _isHitGraphic(x, y, graphic) {
                if (!graphic) return !1;
                var i, len, cmd, cmds = graphic.cmds;
                if (!cmds && graphic._one && ((cmds = HitArea._cmds).length = 1, cmds[0] = graphic._one), !cmds) return !1;
                for (len = cmds.length, i = 0; i < len; i++) if (cmd = cmds[i]) {
                    switch (cmd.cmdID) {
                        case"Translate":
                            x -= cmd.tx, y -= cmd.ty
                    }
                    if (HitArea._isHitCmd(x, y, cmd)) return !0
                }
                return !1
            }

            static _isHitCmd(x, y, cmd) {
                if (!cmd) return !1;
                var rst = !1;
                switch (cmd.cmdID) {
                    case"DrawRect":
                        HitArea._rect.setTo(cmd.x, cmd.y, cmd.width, cmd.height), rst = HitArea._rect.contains(x, y);
                        break;
                    case"DrawCircle":
                        rst = (x -= cmd.x) * x + (y -= cmd.y) * y < cmd.radius * cmd.radius;
                        break;
                    case"DrawPoly":
                        x -= cmd.x, y -= cmd.y, rst = HitArea._ptInPolygon(x, y, cmd.points)
                }
                return rst
            }

            static _ptInPolygon(x, y, areaPoints) {
                var p = HitArea._ptPoint;
                p.setTo(x, y);
                var p1x, p1y, p2x, p2y, len, nCross = 0;
                len = areaPoints.length;
                for (var i = 0; i < len; i += 2) {
                    if (p1x = areaPoints[i], p1y = areaPoints[i + 1], p2x = areaPoints[(i + 2) % len], p1y != (p2y = areaPoints[(i + 3) % len])) if (!(p.y < Math.min(p1y, p2y))) if (!(p.y >= Math.max(p1y, p2y))) (p.y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x > p.x && nCross++
                }
                return nCross % 2 == 1
            }

            get hit() {
                return this._hit || (this._hit = new ILaya.Graphics), this._hit
            }

            set hit(value) {
                this._hit = value
            }

            get unHit() {
                return this._unHit || (this._unHit = new ILaya.Graphics), this._unHit
            }

            set unHit(value) {
                this._unHit = value
            }
        }

        HitArea._cmds = [], HitArea._rect = new Rectangle, HitArea._ptPoint = new Point;

        class ClassUtils {
            static regClass(className, classDef) {
                ClassUtils._classMap[className] = classDef
            }

            static regShortClassName(classes) {
                for (var i = 0; i < classes.length; i++) {
                    var classDef = classes[i], className = classDef.name;
                    ClassUtils._classMap[className] = classDef
                }
            }

            static getRegClass(className) {
                return ClassUtils._classMap[className]
            }

            static getClass(className) {
                var classObject = ClassUtils._classMap[className] || ClassUtils._classMap["Laya." + className] || className,
                    glaya = ILaya.Laya;
                return "string" == typeof classObject ? ILaya.__classMap[classObject] || glaya[className] : classObject
            }

            static getInstance(className) {
                var compClass = ClassUtils.getClass(className);
                return compClass ? new compClass : (console.warn("[error] Undefined class:", className), null)
            }

            static createByJson(json, node = null, root = null, customHandler = null, instanceHandler = null) {
                "string" == typeof json && (json = JSON.parse(json));
                var props = json.props;
                if (!node && !(node = instanceHandler ? instanceHandler.runWith(json) : ClassUtils.getInstance(props.runtime || json.type))) return null;
                var child = json.child;
                if (child) for (var i = 0, n = child.length; i < n; i++) {
                    var data = child[i];
                    if ("render" !== data.props.name && "render" !== data.props.renderType || !node._$set_itemRender) if ("Graphic" == data.type) ClassUtils._addGraphicsToSprite(data, node); else if (ClassUtils._isDrawType(data.type)) ClassUtils._addGraphicToSprite(data, node, !0); else {
                        var tChild = ClassUtils.createByJson(data, null, root, customHandler, instanceHandler);
                        "Script" === data.type ? "owner" in tChild ? tChild.owner = node : "target" in tChild && (tChild.target = node) : "mask" == data.props.renderType ? node.mask = tChild : node.addChild(tChild)
                    } else node.itemRender = data
                }
                if (props) for (var prop in props) {
                    var value = props[prop];
                    "var" === prop && root ? root[value] = node : value instanceof Array && node[prop] instanceof Function ? node[prop].apply(node, value) : node[prop] = value
                }
                return customHandler && json.customProps && customHandler.runWith([node, json]), node.created && node.created(), node
            }

            static _addGraphicsToSprite(graphicO, sprite) {
                var graphics = graphicO.child;
                if (graphics && !(graphics.length < 1)) {
                    var i, len, g = ClassUtils._getGraphicsFromSprite(graphicO, sprite), ox = 0, oy = 0;
                    for (graphicO.props && (ox = ClassUtils._getObjVar(graphicO.props, "x", 0), oy = ClassUtils._getObjVar(graphicO.props, "y", 0)), 0 != ox && 0 != oy && g.translate(ox, oy), len = graphics.length, i = 0; i < len; i++) ClassUtils._addGraphicToGraphics(graphics[i], g);
                    0 != ox && 0 != oy && g.translate(-ox, -oy)
                }
            }

            static _addGraphicToSprite(graphicO, sprite, isChild = !1) {
                var g = isChild ? ClassUtils._getGraphicsFromSprite(graphicO, sprite) : sprite.graphics;
                ClassUtils._addGraphicToGraphics(graphicO, g)
            }

            static _getGraphicsFromSprite(dataO, sprite) {
                if (!dataO || !dataO.props) return sprite.graphics;
                var propsName = dataO.props.renderType;
                if ("hit" === propsName || "unHit" === propsName) {
                    var hitArea = sprite._style.hitArea || (sprite.hitArea = new HitArea);
                    hitArea[propsName] || (hitArea[propsName] = new Graphics);
                    var g = hitArea[propsName]
                }
                return g || (g = sprite.graphics), g
            }

            static _getTransformData(propsO) {
                var m;
                ("pivotX" in propsO || "pivotY" in propsO) && (m = m || new Matrix).translate(-ClassUtils._getObjVar(propsO, "pivotX", 0), -ClassUtils._getObjVar(propsO, "pivotY", 0));
                var sx = ClassUtils._getObjVar(propsO, "scaleX", 1), sy = ClassUtils._getObjVar(propsO, "scaleY", 1),
                    rotate = ClassUtils._getObjVar(propsO, "rotation", 0);
                ClassUtils._getObjVar(propsO, "skewX", 0), ClassUtils._getObjVar(propsO, "skewY", 0);
                return 1 == sx && 1 == sy && 0 == rotate || ((m = m || new Matrix).scale(sx, sy), m.rotate(.0174532922222222 * rotate)), m
            }

            static _addGraphicToGraphics(graphicO, graphic) {
                var propsO, drawConfig;
                if ((propsO = graphicO.props) && (drawConfig = ClassUtils.DrawTypeDic[graphicO.type])) {
                    var g = graphic,
                        params = ClassUtils._getParams(propsO, drawConfig[1], drawConfig[2], drawConfig[3]),
                        m = ClassUtils._tM;
                    (m || 1 != ClassUtils._alpha) && (g.save(), m && g.transform(m), 1 != ClassUtils._alpha && g.alpha(ClassUtils._alpha)), g[drawConfig[0]].apply(g, params), (m || 1 != ClassUtils._alpha) && g.restore()
                }
            }

            static _adptLineData(params) {
                return params[2] = parseFloat(params[0]) + parseFloat(params[2]), params[3] = parseFloat(params[1]) + parseFloat(params[3]), params
            }

            static _adptTextureData(params) {
                return params[0] = ILaya.Loader.getRes(params[0]), params
            }

            static _adptLinesData(params) {
                return params[2] = ClassUtils._getPointListByStr(params[2]), params
            }

            static _isDrawType(type) {
                return "Image" !== type && type in ClassUtils.DrawTypeDic
            }

            static _getParams(obj, params, xPos = 0, adptFun = null) {
                var i, len, m, rst = ClassUtils._temParam;
                for (rst.length = params.length, len = params.length, i = 0; i < len; i++) rst[i] = ClassUtils._getObjVar(obj, params[i][0], params[i][1]);
                return ClassUtils._alpha = ClassUtils._getObjVar(obj, "alpha", 1), (m = ClassUtils._getTransformData(obj)) ? (xPos || (xPos = 0), m.translate(rst[xPos], rst[xPos + 1]), rst[xPos] = rst[xPos + 1] = 0, ClassUtils._tM = m) : ClassUtils._tM = null, adptFun && ClassUtils[adptFun] && (rst = ClassUtils[adptFun](rst)), rst
            }

            static _getPointListByStr(str) {
                var i, len, pointArr = str.split(",");
                for (len = pointArr.length, i = 0; i < len; i++) pointArr[i] = parseFloat(pointArr[i]);
                return pointArr
            }

            static _getObjVar(obj, key, noValue) {
                return key in obj ? obj[key] : noValue
            }
        }

        ClassUtils.DrawTypeDic = {
            Rect: ["drawRect", [["x", 0], ["y", 0], ["width", 0], ["height", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]],
            Circle: ["drawCircle", [["x", 0], ["y", 0], ["radius", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]],
            Pie: ["drawPie", [["x", 0], ["y", 0], ["radius", 0], ["startAngle", 0], ["endAngle", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]],
            Image: ["drawTexture", [["x", 0], ["y", 0], ["width", 0], ["height", 0]]],
            Texture: ["drawTexture", [["skin", null], ["x", 0], ["y", 0], ["width", 0], ["height", 0]], 1, "_adptTextureData"],
            FillTexture: ["fillTexture", [["skin", null], ["x", 0], ["y", 0], ["width", 0], ["height", 0], ["repeat", null]], 1, "_adptTextureData"],
            FillText: ["fillText", [["text", ""], ["x", 0], ["y", 0], ["font", null], ["color", null], ["textAlign", null]], 1],
            Line: ["drawLine", [["x", 0], ["y", 0], ["toX", 0], ["toY", 0], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLineData"],
            Lines: ["drawLines", [["x", 0], ["y", 0], ["points", ""], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLinesData"],
            Curves: ["drawCurves", [["x", 0], ["y", 0], ["points", ""], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLinesData"],
            Poly: ["drawPoly", [["x", 0], ["y", 0], ["points", ""], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]], 0, "_adptLinesData"]
        }, ClassUtils._temParam = [], ClassUtils._classMap = {};

        class Node extends EventDispatcher {
            constructor() {
                super(), this._bits = 0, this._children = Node.ARRAY_EMPTY, this._extUIChild = Node.ARRAY_EMPTY, this._parent = null, this.name = "", this.destroyed = !1, this.createGLBuffer()
            }

            createGLBuffer() {
            }

            _setBit(type, value) {
                type === Const.DISPLAY && (this._getBit(type) != value && this._updateDisplayedInstage());
                value ? this._bits |= type : this._bits &= ~type
            }

            _getBit(type) {
                return 0 != (this._bits & type)
            }

            _setUpNoticeChain() {
                this._getBit(Const.DISPLAY) && this._setBitUp(Const.DISPLAY)
            }

            _setBitUp(type) {
                var ele = this;
                for (ele._setBit(type, !0), ele = ele._parent; ele;) {
                    if (ele._getBit(type)) return;
                    ele._setBit(type, !0), ele = ele._parent
                }
            }

            on(type, caller, listener, args = null) {
                return type !== Event.DISPLAY && type !== Event.UNDISPLAY || this._getBit(Const.DISPLAY) || this._setBitUp(Const.DISPLAY), this._createListener(type, caller, listener, args, !1)
            }

            once(type, caller, listener, args = null) {
                return type !== Event.DISPLAY && type !== Event.UNDISPLAY || this._getBit(Const.DISPLAY) || this._setBitUp(Const.DISPLAY), this._createListener(type, caller, listener, args, !0)
            }

            destroy(destroyChild = !0) {
                this.destroyed = !0, this._destroyAllComponent(), this._parent && this._parent.removeChild(this), this._children && (destroyChild ? this.destroyChildren() : this.removeChildren()), this.onDestroy(), this._children = null, this.offAll()
            }

            onDestroy() {
            }

            destroyChildren() {
                if (this._children) for (var i = 0, n = this._children.length; i < n; i++) this._children[0].destroy(!0)
            }

            addChild(node) {
                if (!node || this.destroyed || node === this) return node;
                if (node._zOrder && this._setBit(Const.HAS_ZORDER, !0), node._parent === this) {
                    var index = this.getChildIndex(node);
                    index !== this._children.length - 1 && (this._children.splice(index, 1), this._children.push(node), this._childChanged())
                } else node._parent && node._parent.removeChild(node), this._children === Node.ARRAY_EMPTY && (this._children = []), this._children.push(node), node._setParent(this), this._childChanged();
                return node
            }

            addInputChild(node) {
                if (this._extUIChild == Node.ARRAY_EMPTY) this._extUIChild = [node]; else {
                    if (this._extUIChild.indexOf(node) >= 0) return null;
                    this._extUIChild.push(node)
                }
                return null
            }

            removeInputChild(node) {
                var idx = this._extUIChild.indexOf(node);
                idx >= 0 && this._extUIChild.splice(idx, 1)
            }

            addChildren(...args) {
                for (var i = 0, n = args.length; i < n;) this.addChild(args[i++])
            }

            addChildAt(node, index) {
                if (!node || this.destroyed || node === this) return node;
                if (node._zOrder && this._setBit(Const.HAS_ZORDER, !0), index >= 0 && index <= this._children.length) {
                    if (node._parent === this) {
                        var oldIndex = this.getChildIndex(node);
                        this._children.splice(oldIndex, 1), this._children.splice(index, 0, node), this._childChanged()
                    } else node._parent && node._parent.removeChild(node), this._children === Node.ARRAY_EMPTY && (this._children = []), this._children.splice(index, 0, node), node._setParent(this);
                    return node
                }
                throw new Error("appendChildAt:The index is out of bounds")
            }

            getChildIndex(node) {
                return this._children.indexOf(node)
            }

            getChildByName(name) {
                var nodes = this._children;
                if (nodes) for (var i = 0, n = nodes.length; i < n; i++) {
                    var node = nodes[i];
                    if (node.name === name) return node
                }
                return null
            }

            getChildAt(index) {
                return this._children[index] || null
            }

            setChildIndex(node, index) {
                var childs = this._children;
                if (index < 0 || index >= childs.length) throw new Error("setChildIndex:The index is out of bounds.");
                var oldIndex = this.getChildIndex(node);
                if (oldIndex < 0) throw new Error("setChildIndex:node is must child of this object.");
                return childs.splice(oldIndex, 1), childs.splice(index, 0, node), this._childChanged(), node
            }

            _childChanged(child = null) {
            }

            removeChild(node) {
                if (!this._children) return node;
                var index = this._children.indexOf(node);
                return this.removeChildAt(index)
            }

            removeSelf() {
                return this._parent && this._parent.removeChild(this), this
            }

            removeChildByName(name) {
                var node = this.getChildByName(name);
                return node && this.removeChild(node), node
            }

            removeChildAt(index) {
                var node = this.getChildAt(index);
                return node && (this._children.splice(index, 1), node._setParent(null)), node
            }

            removeChildren(beginIndex = 0, endIndex = 2147483647) {
                if (this._children && this._children.length > 0) {
                    var childs = this._children;
                    if (0 === beginIndex && endIndex >= childs.length - 1) {
                        var arr = childs;
                        this._children = Node.ARRAY_EMPTY
                    } else arr = childs.splice(beginIndex, endIndex - beginIndex);
                    for (var i = 0, n = arr.length; i < n; i++) arr[i]._setParent(null)
                }
                return this
            }

            replaceChild(newNode, oldNode) {
                var index = this._children.indexOf(oldNode);
                return index > -1 ? (this._children.splice(index, 1, newNode), oldNode._setParent(null), newNode._setParent(this), newNode) : null
            }

            get numChildren() {
                return this._children.length
            }

            get parent() {
                return this._parent
            }

            _setParent(value) {
                this._parent !== value && (value ? (this._parent = value, this._onAdded(), this.event(Event.ADDED), this._getBit(Const.DISPLAY) && (this._setUpNoticeChain(), value.displayedInStage && this._displayChild(this, !0)), value._childChanged(this)) : (this._onRemoved(), this.event(Event.REMOVED), this._parent._childChanged(), this._getBit(Const.DISPLAY) && this._displayChild(this, !1), this._parent = value))
            }

            get displayedInStage() {
                return this._getBit(Const.DISPLAY) ? this._getBit(Const.DISPLAYED_INSTAGE) : (this._setBitUp(Const.DISPLAY), this._getBit(Const.DISPLAYED_INSTAGE))
            }

            _updateDisplayedInstage() {
                var ele;
                ele = this;
                for (var stage = ILaya.stage, displayedInStage = !1; ele;) {
                    if (ele._getBit(Const.DISPLAY)) {
                        displayedInStage = ele._getBit(Const.DISPLAYED_INSTAGE);
                        break
                    }
                    if (ele === stage || ele._getBit(Const.DISPLAYED_INSTAGE)) {
                        displayedInStage = !0;
                        break
                    }
                    ele = ele._parent
                }
                this._setBit(Const.DISPLAYED_INSTAGE, displayedInStage)
            }

            _setDisplay(value) {
                this._getBit(Const.DISPLAYED_INSTAGE) !== value && (this._setBit(Const.DISPLAYED_INSTAGE, value), value ? this.event(Event.DISPLAY) : this.event(Event.UNDISPLAY))
            }

            _displayChild(node, display) {
                var childs = node._children;
                if (childs) for (var i = 0, n = childs.length; i < n; i++) {
                    var child = childs[i];
                    child._getBit(Const.DISPLAY) && (child._children.length > 0 ? this._displayChild(child, display) : child._setDisplay(display))
                }
                node._setDisplay(display)
            }

            contains(node) {
                if (node === this) return !0;
                for (; node;) {
                    if (node._parent === this) return !0;
                    node = node._parent
                }
                return !1
            }

            timerLoop(delay, caller, method, args = null, coverBefore = !0, jumpFrame = !1) {
                (this.scene ? this.scene.timer : ILaya.timer).loop(delay, caller, method, args, coverBefore, jumpFrame)
            }

            timerOnce(delay, caller, method, args = null, coverBefore = !0) {
                (this.scene ? this.scene.timer : ILaya.timer)._create(!1, !1, delay, caller, method, args, coverBefore)
            }

            frameLoop(delay, caller, method, args = null, coverBefore = !0) {
                (this.scene ? this.scene.timer : ILaya.timer)._create(!0, !0, delay, caller, method, args, coverBefore)
            }

            frameOnce(delay, caller, method, args = null, coverBefore = !0) {
                (this.scene ? this.scene.timer : ILaya.timer)._create(!0, !1, delay, caller, method, args, coverBefore)
            }

            clearTimer(caller, method) {
                (this.scene ? this.scene.timer : ILaya.timer).clear(caller, method)
            }

            callLater(method, args = null) {
                (this.scene ? this.scene.timer : ILaya.timer).callLater(this, method, args)
            }

            runCallLater(method) {
                (this.scene ? this.scene.timer : ILaya.timer).runCallLater(this, method)
            }

            get scene() {
                return this._scene
            }

            get active() {
                return !this._getBit(Const.NOT_READY) && !this._getBit(Const.NOT_ACTIVE)
            }

            set active(value) {
                if (value = !!value, !this._getBit(Const.NOT_ACTIVE) !== value) {
                    if (this._activeChangeScripts && 0 !== this._activeChangeScripts.length) throw value ? "Node: can't set the main inActive node active in hierarchy,if the operate is in main inActive node or it's children script's onDisable Event." : "Node: can't set the main active node inActive in hierarchy,if the operate is in main active node or it's children script's onEnable Event.";
                    this._setBit(Const.NOT_ACTIVE, !value), this._parent && this._parent.activeInHierarchy && (value ? this._processActive() : this._processInActive())
                }
            }

            get activeInHierarchy() {
                return this._getBit(Const.ACTIVE_INHIERARCHY)
            }

            _onActive() {
                Stat.spriteCount++
            }

            _onInActive() {
                Stat.spriteCount--
            }

            _onActiveInScene() {
            }

            _onInActiveInScene() {
            }

            _parse(data, spriteMap) {
            }

            _setBelongScene(scene) {
                if (!this._scene) {
                    this._scene = scene, this._onActiveInScene();
                    for (var i = 0, n = this._children.length; i < n; i++) this._children[i]._setBelongScene(scene)
                }
            }

            _setUnBelongScene() {
                if (this._scene !== this) {
                    this._onInActiveInScene(), this._scene = null;
                    for (var i = 0, n = this._children.length; i < n; i++) this._children[i]._setUnBelongScene()
                }
            }

            onAwake() {
            }

            onEnable() {
            }

            _processActive() {
                this._activeChangeScripts || (this._activeChangeScripts = []), this._activeHierarchy(this._activeChangeScripts), this._activeScripts()
            }

            _activeHierarchy(activeChangeScripts) {
                if (this._setBit(Const.ACTIVE_INHIERARCHY, !0), this._components) for (var i = 0, n = this._components.length; i < n; i++) {
                    var comp = this._components[i];
                    comp._setActive(!0), comp._isScript() && comp._enabled && activeChangeScripts.push(comp)
                }
                for (this._onActive(), i = 0, n = this._children.length; i < n; i++) {
                    var child = this._children[i];
                    !child._getBit(Const.NOT_ACTIVE) && child._activeHierarchy(activeChangeScripts)
                }
                this._getBit(Const.AWAKED) || (this._setBit(Const.AWAKED, !0), this.onAwake()), this.onEnable()
            }

            _activeScripts() {
                for (var i = 0, n = this._activeChangeScripts.length; i < n; i++) this._activeChangeScripts[i].onEnable();
                this._activeChangeScripts.length = 0
            }

            _processInActive() {
                this._activeChangeScripts || (this._activeChangeScripts = []), this._inActiveHierarchy(this._activeChangeScripts), this._inActiveScripts()
            }

            _inActiveHierarchy(activeChangeScripts) {
                if (this._onInActive(), this._components) for (var i = 0, n = this._components.length; i < n; i++) {
                    var comp = this._components[i];
                    comp._setActive(!1), comp._isScript() && comp._enabled && activeChangeScripts.push(comp)
                }
                for (this._setBit(Const.ACTIVE_INHIERARCHY, !1), i = 0, n = this._children.length; i < n; i++) {
                    var child = this._children[i];
                    child && !child._getBit(Const.NOT_ACTIVE) && child._inActiveHierarchy(activeChangeScripts)
                }
                this.onDisable()
            }

            _inActiveScripts() {
                for (var i = 0, n = this._activeChangeScripts.length; i < n; i++) this._activeChangeScripts[i].onDisable();
                this._activeChangeScripts.length = 0
            }

            onDisable() {
            }

            _onAdded() {
                if (this._activeChangeScripts && 0 !== this._activeChangeScripts.length) throw"Node: can't set the main inActive node active in hierarchy,if the operate is in main inActive node or it's children script's onDisable Event.";
                var parentScene = this._parent.scene;
                parentScene && this._setBelongScene(parentScene), this._parent.activeInHierarchy && this.active && this._processActive()
            }

            _onRemoved() {
                if (this._activeChangeScripts && 0 !== this._activeChangeScripts.length) throw"Node: can't set the main active node inActive in hierarchy,if the operate is in main active node or it's children script's onEnable Event.";
                this._parent.activeInHierarchy && this.active && this._processInActive(), this._parent.scene && this._setUnBelongScene()
            }

            _addComponentInstance(comp) {
                this._components = this._components || [], this._components.push(comp), comp.owner = this, comp._onAdded(), this.activeInHierarchy && (comp._setActive(!0), comp._isScript() && comp._enabled && comp.onEnable())
            }

            _destroyComponent(comp) {
                if (this._components) for (var i = 0, n = this._components.length; i < n; i++) {
                    var item = this._components[i];
                    if (item === comp) {
                        item._destroy(), this._components.splice(i, 1);
                        break
                    }
                }
            }

            _destroyAllComponent() {
                if (this._components) {
                    for (var i = 0, n = this._components.length; i < n; i++) {
                        this._components[i]._destroy()
                    }
                    this._components.length = 0
                }
            }

            _cloneTo(destObject, srcRoot, dstRoot) {
                var destNode = destObject;
                if (this._components) for (var i = 0, n = this._components.length; i < n; i++) {
                    var destComponent = destNode.addComponent(this._components[i].constructor);
                    this._components[i]._cloneTo(destComponent)
                }
            }

            addComponentIntance(comp) {
                if (comp.owner) throw"Node:the component has belong to other node.";
                if (comp.isSingleton && this.getComponent(comp.constructor)) throw"Node:the component is singleton,can't add the second one.";
                return this._addComponentInstance(comp), comp
            }

            addComponent(type) {
                var comp = Pool.createByClass(type);
                if (comp._destroyed = !1, comp.isSingleton && this.getComponent(type)) throw"无法实例" + type + "组件，" + type + "组件已存在！";
                return this._addComponentInstance(comp), comp
            }

            getComponent(clas) {
                if (this._components) for (var i = 0, n = this._components.length; i < n; i++) {
                    var comp = this._components[i];
                    if (comp instanceof clas) return comp
                }
                return null
            }

            getComponents(clas) {
                var arr;
                if (this._components) for (var i = 0, n = this._components.length; i < n; i++) {
                    var comp = this._components[i];
                    comp instanceof clas && (arr = arr || []).push(comp)
                }
                return arr
            }

            get timer() {
                return this.scene ? this.scene.timer : ILaya.timer
            }
        }

        Node.ARRAY_EMPTY = [], ClassUtils.regClass("laya.display.Node", Node), ClassUtils.regClass("Laya.Node", Node);

        class BoundsStyle {
            reset() {
                return this.bounds && this.bounds.recover(), this.userBounds && this.userBounds.recover(), this.bounds = null, this.userBounds = null, this.temBM = null, this
            }

            recover() {
                Pool.recover("BoundsStyle", this.reset())
            }

            static create() {
                return Pool.getItemByClass("BoundsStyle", BoundsStyle)
            }
        }

        class HTMLCanvas extends Bitmap {
            get source() {
                return this._source
            }

            _getSource() {
                return this._source
            }

            constructor(createCanvas = !1) {
                super(), this._source = createCanvas ? Browser.createElement("canvas") : this, this.lock = !0
            }

            clear() {
                this._ctx && this._ctx.clear && this._ctx.clear(), this._texture && (this._texture.destroy(), this._texture = null)
            }

            destroy() {
                super.destroy(), this._setCPUMemory(0), this._ctx && this._ctx.destroy && this._ctx.destroy(), this._ctx = null
            }

            release() {
            }

            get context() {
                return this._ctx ? this._ctx : (this._source == this ? this._ctx = new ILaya.Context : this._ctx = this._source.getContext(ILaya.Render.isConchApp ? "layagl" : "2d"), this._ctx._canvas = this, this._ctx)
            }

            _setContext(context) {
                this._ctx = context
            }

            getContext(contextID, other = null) {
                return this.context
            }

            getMemSize() {
                return 0
            }

            size(w, h) {
                (this._width != w || this._height != h || this._source && (this._source.width != w || this._source.height != h)) && (this._width = w, this._height = h, this._setCPUMemory(w * h * 4), this._ctx && this._ctx.size && this._ctx.size(w, h), this._source && (this._source.height = h, this._source.width = w), this._texture && (this._texture.destroy(), this._texture = null))
            }

            getTexture() {
                if (!this._texture) {
                    var bitmap = new Texture2D;
                    bitmap.loadImageSource(this.source), this._texture = new Texture(bitmap)
                }
                return this._texture
            }

            toBase64(type, encoderOptions) {
                if (this._source) {
                    if (ILaya.Render.isConchApp) {
                        var win = window;
                        if (2 == win.conchConfig.threadMode) throw"native 2 thread mode use toBase64Async";
                        var width = this._ctx._targets.sourceWidth, height = this._ctx._targets.sourceHeight,
                            data = this._ctx._targets.getData(0, 0, width, height);
                        return win.conchToBase64FlipY ? win.conchToBase64FlipY(type, encoderOptions, data.buffer, width, height) : win.conchToBase64(type, encoderOptions, data.buffer, width, height)
                    }
                    return this._source.toDataURL(type, encoderOptions)
                }
                return null
            }

            toBase64Async(type, encoderOptions, callBack) {
                var width = this._ctx._targets.sourceWidth, height = this._ctx._targets.sourceHeight;
                this._ctx._targets.getDataAsync(0, 0, width, height, function (data) {
                    let win = window;
                    var base64 = win.conchToBase64FlipY ? win.conchToBase64FlipY(type, encoderOptions, data.buffer, width, height) : win.conchToBase64(type, encoderOptions, data.buffer, width, height);
                    callBack(base64)
                })
            }
        }

        class CacheStyle {
            constructor() {
                this.reset()
            }

            needBitmapCache() {
                return this.cacheForFilters || !!this.mask
            }

            needEnableCanvasRender() {
                return "none" != this.userSetCache || this.cacheForFilters || !!this.mask
            }

            releaseContext() {
                if (this.canvas && this.canvas.size) {
                    Pool.recover("CacheCanvas", this.canvas), this.canvas.size(0, 0);
                    try {
                        this.canvas.width = 0, this.canvas.height = 0
                    } catch (e) {
                    }
                }
                this.canvas = null
            }

            createContext() {
                if (!this.canvas) {
                    this.canvas = Pool.getItem("CacheCanvas") || new HTMLCanvas(!1);
                    var tx = this.canvas.context;
                    tx || (tx = this.canvas.getContext("2d"))
                }
            }

            releaseFilterCache() {
                var fc = this.filterCache;
                fc && (fc.destroy(), fc.recycle(), this.filterCache = null)
            }

            recover() {
                this !== CacheStyle.EMPTY && Pool.recover("SpriteCache", this.reset())
            }

            reset() {
                return this.releaseContext(), this.releaseFilterCache(), this.cacheAs = "none", this.enableCanvasRender = !1, this.userSetCache = "none", this.cacheForFilters = !1, this.staticCache = !1, this.reCache = !0, this.mask = null, this.maskParent = null, this.filterCache = null, this.filters = null, this.hasGlowFilter = !1, this.cacheRect && this.cacheRect.recover(), this.cacheRect = null, this
            }

            static create() {
                return Pool.getItemByClass("SpriteCache", CacheStyle)
            }

            _calculateCacheRect(sprite, tCacheType, x, y) {
                var tRec, _cacheStyle = sprite._cacheStyle;
                if (_cacheStyle.cacheRect || (_cacheStyle.cacheRect = Rectangle.create()), "bitmap" === tCacheType ? ((tRec = sprite.getSelfBounds()).width = tRec.width + 2 * CacheStyle.CANVAS_EXTEND_EDGE, tRec.height = tRec.height + 2 * CacheStyle.CANVAS_EXTEND_EDGE, tRec.x = tRec.x - sprite.pivotX, tRec.y = tRec.y - sprite.pivotY, tRec.x = tRec.x - CacheStyle.CANVAS_EXTEND_EDGE, tRec.y = tRec.y - CacheStyle.CANVAS_EXTEND_EDGE, tRec.x = Math.floor(tRec.x + x) - x, tRec.y = Math.floor(tRec.y + y) - y, tRec.width = Math.floor(tRec.width), tRec.height = Math.floor(tRec.height), _cacheStyle.cacheRect.copyFrom(tRec)) : _cacheStyle.cacheRect.setTo(-sprite._style.pivotX, -sprite._style.pivotY, 1, 1), tRec = _cacheStyle.cacheRect, sprite._style.scrollRect) {
                    var scrollRect = sprite._style.scrollRect;
                    tRec.x -= scrollRect.x, tRec.y -= scrollRect.y
                }
                return CacheStyle._scaleInfo.setTo(1, 1), CacheStyle._scaleInfo
            }
        }

        CacheStyle.EMPTY = new CacheStyle, CacheStyle._scaleInfo = new Point, CacheStyle.CANVAS_EXTEND_EDGE = 16;

        class SpriteStyle {
            constructor() {
                this.reset()
            }

            reset() {
                return this.scaleX = this.scaleY = 1, this.skewX = this.skewY = 0, this.pivotX = this.pivotY = this.rotation = 0, this.alpha = 1, this.scrollRect && this.scrollRect.recover(), this.scrollRect = null, this.viewport && this.viewport.recover(), this.viewport = null, this.hitArea = null, this.dragging = null, this.blendMode = null, this
            }

            recover() {
                this !== SpriteStyle.EMPTY && Pool.recover("SpriteStyle", this.reset())
            }

            static create() {
                return Pool.getItemByClass("SpriteStyle", SpriteStyle)
            }
        }

        SpriteStyle.EMPTY = new SpriteStyle;

        class LayaGLQuickRunner {
            static __init__() {
                LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TRANSFORM | SpriteConst.GRAPHICS] = LayaGLQuickRunner.alpha_transform_drawLayaGL, LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.GRAPHICS] = LayaGLQuickRunner.alpha_drawLayaGL, LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.GRAPHICS] = LayaGLQuickRunner.transform_drawLayaGL, LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.CHILDS] = LayaGLQuickRunner.transform_drawNodes, LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TRANSFORM | SpriteConst.TEXTURE] = LayaGLQuickRunner.alpha_transform_drawTexture, LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TEXTURE] = LayaGLQuickRunner.alpha_drawTexture, LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.TEXTURE] = LayaGLQuickRunner.transform_drawTexture, LayaGLQuickRunner.map[SpriteConst.GRAPHICS | SpriteConst.CHILDS] = LayaGLQuickRunner.drawLayaGL_drawNodes
            }

            static transform_drawTexture(sprite, context, x, y) {
                sprite._style;
                var tex = sprite.texture;
                context.saveTransform(LayaGLQuickRunner.curMat), context.transformByMatrix(sprite.transform, x, y), context.drawTexture(tex, -sprite.pivotX, -sprite.pivotY, sprite._width || tex.width, sprite._height || tex.height), context.restoreTransform(LayaGLQuickRunner.curMat)
            }

            static alpha_drawTexture(sprite, context, x, y) {
                var alpha, style = sprite._style, tex = sprite.texture;
                if ((alpha = style.alpha) > .01 || sprite._needRepaint()) {
                    var temp = context.globalAlpha;
                    context.globalAlpha *= alpha, context.drawTexture(tex, x - style.pivotX + tex.offsetX, y - style.pivotY + tex.offsetY, sprite._width || tex.width, sprite._height || tex.height), context.globalAlpha = temp
                }
            }

            static alpha_transform_drawTexture(sprite, context, x, y) {
                var alpha, style = sprite._style, tex = sprite.texture;
                if ((alpha = style.alpha) > .01 || sprite._needRepaint()) {
                    var temp = context.globalAlpha;
                    context.globalAlpha *= alpha, context.saveTransform(LayaGLQuickRunner.curMat), context.transformByMatrix(sprite.transform, x, y), context.drawTexture(tex, -style.pivotX + tex.offsetX, -style.pivotY + tex.offsetY, sprite._width || tex.width, sprite._height || tex.height), context.restoreTransform(LayaGLQuickRunner.curMat), context.globalAlpha = temp
                }
            }

            static alpha_transform_drawLayaGL(sprite, context, x, y) {
                var alpha, style = sprite._style;
                if ((alpha = style.alpha) > .01 || sprite._needRepaint()) {
                    var temp = context.globalAlpha;
                    context.globalAlpha *= alpha, context.saveTransform(LayaGLQuickRunner.curMat), context.transformByMatrix(sprite.transform, x, y), sprite._graphics && sprite._graphics._render(sprite, context, -style.pivotX, -style.pivotY), context.restoreTransform(LayaGLQuickRunner.curMat), context.globalAlpha = temp
                }
            }

            static alpha_drawLayaGL(sprite, context, x, y) {
                var alpha, style = sprite._style;
                if ((alpha = style.alpha) > .01 || sprite._needRepaint()) {
                    var temp = context.globalAlpha;
                    context.globalAlpha *= alpha, sprite._graphics && sprite._graphics._render(sprite, context, x - style.pivotX, y - style.pivotY), context.globalAlpha = temp
                }
            }

            static transform_drawLayaGL(sprite, context, x, y) {
                var style = sprite._style;
                context.saveTransform(LayaGLQuickRunner.curMat), context.transformByMatrix(sprite.transform, x, y), sprite._graphics && sprite._graphics._render(sprite, context, -style.pivotX, -style.pivotY), context.restoreTransform(LayaGLQuickRunner.curMat)
            }

            static transform_drawNodes(sprite, context, x, y) {
                var textLastRender = sprite._getBit(Const.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(!0),
                    style = sprite._style;
                context.saveTransform(LayaGLQuickRunner.curMat), context.transformByMatrix(sprite.transform, x, y), x = -style.pivotX, y = -style.pivotY;
                var ele, childs = sprite._children, n = childs.length;
                if (style.viewport) {
                    var _x, _y, rect = style.viewport, left = rect.x, top = rect.y, right = rect.right,
                        bottom = rect.bottom;
                    for (i = 0; i < n; ++i) (ele = childs[i])._visible && (_x = ele._x) < right && _x + ele.width > left && (_y = ele._y) < bottom && _y + ele.height > top && ele.render(context, x, y)
                } else for (var i = 0; i < n; ++i) (ele = childs[i])._visible && ele.render(context, x, y);
                context.restoreTransform(LayaGLQuickRunner.curMat), textLastRender && context.drawCallOptimize(!1)
            }

            static drawLayaGL_drawNodes(sprite, context, x, y) {
                var textLastRender = sprite._getBit(Const.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(!0),
                    style = sprite._style;
                x -= style.pivotX, y -= style.pivotY, sprite._graphics && sprite._graphics._render(sprite, context, x, y);
                var ele, childs = sprite._children, n = childs.length;
                if (style.viewport) {
                    var _x, _y, rect = style.viewport, left = rect.x, top = rect.y, right = rect.right,
                        bottom = rect.bottom;
                    for (i = 0; i < n; ++i) (ele = childs[i])._visible && (_x = ele._x) < right && _x + ele.width > left && (_y = ele._y) < bottom && _y + ele.height > top && ele.render(context, x, y)
                } else for (var i = 0; i < n; ++i) (ele = childs[i])._visible && ele.render(context, x, y);
                textLastRender && context.drawCallOptimize(!1)
            }
        }

        LayaGLQuickRunner.map = {}, LayaGLQuickRunner.curMat = new Matrix;

        class RenderSprite {
            constructor(type, next) {
                if (LayaGLQuickRunner.map[type]) return this._fun = LayaGLQuickRunner.map[type], void (this._next = RenderSprite.NORENDER);
                switch (this._next = next || RenderSprite.NORENDER, type) {
                    case 0:
                        return void (this._fun = this._no);
                    case SpriteConst.ALPHA:
                        return void (this._fun = this._alpha);
                    case SpriteConst.TRANSFORM:
                        return void (this._fun = this._transform);
                    case SpriteConst.BLEND:
                        return void (this._fun = this._blend);
                    case SpriteConst.CANVAS:
                        return void (this._fun = this._canvas);
                    case SpriteConst.MASK:
                        return void (this._fun = this._mask);
                    case SpriteConst.CLIP:
                        return void (this._fun = this._clip);
                    case SpriteConst.STYLE:
                        return void (this._fun = this._style);
                    case SpriteConst.GRAPHICS:
                        return void (this._fun = this._graphics);
                    case SpriteConst.CHILDS:
                        return void (this._fun = this._children);
                    case SpriteConst.CUSTOM:
                        return void (this._fun = this._custom);
                    case SpriteConst.TEXTURE:
                        return void (this._fun = this._texture);
                    case SpriteConst.FILTERS:
                        return void (this._fun = Filter._filter);
                    case RenderSprite.INIT:
                        return void (this._fun = RenderSprite._initRenderFun)
                }
                this.onCreate(type)
            }

            static __init__() {
                var i, len, initRender;
                for (LayaGLQuickRunner.__init__(), initRender = new RenderSprite(RenderSprite.INIT, null), len = RenderSprite.renders.length = 2 * SpriteConst.CHILDS, i = 0; i < len; i++) RenderSprite.renders[i] = initRender;
                RenderSprite.renders[0] = new RenderSprite(0, null)
            }

            static _initRenderFun(sprite, context, x, y) {
                var type = sprite._renderType;
                (RenderSprite.renders[type] = RenderSprite._getTypeRender(type))._fun(sprite, context, x, y)
            }

            static _getTypeRender(type) {
                if (LayaGLQuickRunner.map[type]) return new RenderSprite(type, null);
                for (var rst = null, tType = SpriteConst.CHILDS; tType > 0;) tType & type && (rst = new RenderSprite(tType, rst)), tType >>= 1;
                return rst
            }

            onCreate(type) {
            }

            _style(sprite, context, x, y) {
                var style = sprite._style;
                null != style.render && style.render(sprite, context, x, y);
                var next = this._next;
                next._fun.call(next, sprite, context, x, y)
            }

            _no(sprite, context, x, y) {
            }

            _custom(sprite, context, x, y) {
                sprite.customRender(context, x, y), this._next._fun.call(this._next, sprite, context, x - sprite.pivotX, y - sprite.pivotY)
            }

            _clip(sprite, context, x, y) {
                var next = this._next;
                if (next != RenderSprite.NORENDER) {
                    var r = sprite._style.scrollRect;
                    context.save(), context.clipRect(x, y, r.width, r.height), next._fun.call(next, sprite, context, x - r.x, y - r.y), context.restore()
                }
            }

            _texture(sprite, context, x, y) {
                var tex = sprite.texture;
                tex._getSource() && context.drawTexture(tex, x - sprite.pivotX + tex.offsetX, y - sprite.pivotY + tex.offsetY, sprite._width || tex.width, sprite._height || tex.height);
                var next = this._next;
                next != RenderSprite.NORENDER && next._fun.call(next, sprite, context, x, y)
            }

            _graphics(sprite, context, x, y) {
                var style = sprite._style, g = sprite._graphics;
                g && g._render(sprite, context, x - style.pivotX, y - style.pivotY);
                var next = this._next;
                next != RenderSprite.NORENDER && next._fun.call(next, sprite, context, x, y)
            }

            _image(sprite, context, x, y) {
                var style = sprite._style;
                context.drawTexture2(x, y, style.pivotX, style.pivotY, sprite.transform, sprite._graphics._one)
            }

            _image2(sprite, context, x, y) {
                var style = sprite._style;
                context.drawTexture2(x, y, style.pivotX, style.pivotY, sprite.transform, sprite._graphics._one)
            }

            _alpha(sprite, context, x, y) {
                var alpha;
                if ((alpha = sprite._style.alpha) > .01 || sprite._needRepaint()) {
                    var temp = context.globalAlpha;
                    context.globalAlpha *= alpha;
                    var next = this._next;
                    next._fun.call(next, sprite, context, x, y), context.globalAlpha = temp
                }
            }

            _transform(sprite, context, x, y) {
                var transform = sprite.transform, _next = this._next;
                sprite._style;
                transform && _next != RenderSprite.NORENDER ? (context.save(), context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx + x, transform.ty + y), _next._fun.call(_next, sprite, context, 0, 0), context.restore()) : _next != RenderSprite.NORENDER && _next._fun.call(_next, sprite, context, x, y)
            }

            _children(sprite, context, x, y) {
                var ele, style = sprite._style, childs = sprite._children, n = childs.length;
                x -= sprite.pivotX, y -= sprite.pivotY;
                var textLastRender = sprite._getBit(Const.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(!0);
                if (style.viewport) {
                    var _x, _y, rect = style.viewport, left = rect.x, top = rect.y, right = rect.right,
                        bottom = rect.bottom;
                    for (i = 0; i < n; ++i) (ele = childs[i])._visible && (_x = ele._x) < right && _x + ele.width > left && (_y = ele._y) < bottom && _y + ele.height > top && ele.render(context, x, y)
                } else for (var i = 0; i < n; ++i) (ele = childs[i])._visible && ele.render(context, x, y);
                textLastRender && context.drawCallOptimize(!1)
            }

            _canvas(sprite, context, x, y) {
                var _cacheStyle = sprite._cacheStyle, _next = this._next;
                if (_cacheStyle.enableCanvasRender) {
                    "bitmap" === _cacheStyle.cacheAs ? Stat.canvasBitmap++ : Stat.canvasNormal++;
                    var cacheNeedRebuild = !1, textNeedRestore = !1;
                    if (_cacheStyle.canvas) {
                        var canv = _cacheStyle.canvas, charRIs = (canv.context, canv.touches);
                        if (charRIs) for (var ci = 0; ci < charRIs.length; ci++) if (charRIs[ci].deleted) {
                            textNeedRestore = !0;
                            break
                        }
                        cacheNeedRebuild = canv.isCacheValid && !canv.isCacheValid()
                    }
                    if (sprite._needRepaint() || !_cacheStyle.canvas || textNeedRestore || cacheNeedRebuild || ILaya.stage.isGlobalRepaint()) if ("normal" === _cacheStyle.cacheAs) {
                        if (context._targets) return void _next._fun.call(_next, sprite, context, x, y);
                        this._canvas_webgl_normal_repaint(sprite, context)
                    } else this._canvas_repaint(sprite, context, x, y);
                    var tRec = _cacheStyle.cacheRect;
                    context.drawCanvas(_cacheStyle.canvas, x + tRec.x, y + tRec.y, tRec.width, tRec.height)
                } else _next._fun.call(_next, sprite, context, x, y)
            }

            _canvas_repaint(sprite, context, x, y) {
                var tx, left, top, tRec, w, h, scaleX, scaleY, scaleInfo, _cacheStyle = sprite._cacheStyle,
                    _next = this._next, canvas = _cacheStyle.canvas, tCacheType = _cacheStyle.cacheAs;
                if (scaleX = (scaleInfo = _cacheStyle._calculateCacheRect(sprite, tCacheType, x, y)).x, scaleY = scaleInfo.y, w = (tRec = _cacheStyle.cacheRect).width * scaleX, h = tRec.height * scaleY, left = tRec.x, top = tRec.y, "bitmap" === tCacheType && (w > 2048 || h > 2048)) return console.warn("cache bitmap size larger than 2048,cache ignored"), _cacheStyle.releaseContext(), void _next._fun.call(_next, sprite, context, x, y);
                if (canvas || (_cacheStyle.createContext(), canvas = _cacheStyle.canvas), (tx = canvas.context).sprite = sprite, (canvas.width != w || canvas.height != h) && canvas.size(w, h), "bitmap" === tCacheType ? tx.asBitmap = !0 : "normal" === tCacheType && (tx.asBitmap = !1), tx.clear(), 1 != scaleX || 1 != scaleY) {
                    var ctx = tx;
                    ctx.save(), ctx.scale(scaleX, scaleY), _next._fun.call(_next, sprite, tx, -left, -top), ctx.restore(), sprite._applyFilters()
                } else ctx = tx, _next._fun.call(_next, sprite, tx, -left, -top), sprite._applyFilters();
                _cacheStyle.staticCache && (_cacheStyle.reCache = !1), Stat.canvasReCache++
            }

            _canvas_webgl_normal_repaint(sprite, context) {
                var _cacheStyle = sprite._cacheStyle, _next = this._next, canvas = _cacheStyle.canvas,
                    tCacheType = _cacheStyle.cacheAs;
                _cacheStyle._calculateCacheRect(sprite, tCacheType, 0, 0);
                canvas || (canvas = _cacheStyle.canvas = new WebGLCacheAsNormalCanvas(context, sprite));
                var tx = canvas.context;
                canvas.startRec(), _next._fun.call(_next, sprite, tx, sprite.pivotX, sprite.pivotY), sprite._applyFilters(), Stat.canvasReCache++, canvas.endRec()
            }

            _blend(sprite, context, x, y) {
                var style = sprite._style, next = this._next;
                style.blendMode ? (context.save(), context.globalCompositeOperation = style.blendMode, next._fun.call(next, sprite, context, x, y), context.restore()) : next._fun.call(next, sprite, context, x, y)
            }

            _mask(sprite, context, x, y) {
                var next = this._next, mask = sprite.mask, ctx = context;
                if (mask) {
                    ctx.save();
                    var preBlendMode = ctx.globalCompositeOperation, tRect = new Rectangle;
                    if (tRect.copyFrom(mask.getBounds()), tRect.width = Math.round(tRect.width), tRect.height = Math.round(tRect.height), tRect.x = Math.round(tRect.x), tRect.y = Math.round(tRect.y), tRect.width > 0 && tRect.height > 0) {
                        var w = tRect.width, h = tRect.height, tmpRT = WebGLRTMgr.getRT(w, h);
                        ctx.breakNextMerge(), ctx.pushRT(), ctx.addRenderObject(SubmitCMD.create([ctx, tmpRT, w, h], RenderSprite.tmpTarget, this)), mask.render(ctx, -tRect.x, -tRect.y), ctx.breakNextMerge(), ctx.popRT(), ctx.save(), ctx.clipRect(x + tRect.x - sprite.getStyle().pivotX, y + tRect.y - sprite.getStyle().pivotY, w, h), next._fun.call(next, sprite, ctx, x, y), ctx.restore(), preBlendMode = ctx.globalCompositeOperation, ctx.addRenderObject(SubmitCMD.create(["mask"], RenderSprite.setBlendMode, this));
                        var shaderValue = Value2D.create(ShaderDefines2D.TEXTURE2D, 0), uv = Texture.INV_UV;
                        ctx.drawTarget(tmpRT, x + tRect.x - sprite.getStyle().pivotX, y + tRect.y - sprite.getStyle().pivotY, w, h, Matrix.TEMP.identity(), shaderValue, uv, 6), ctx.addRenderObject(SubmitCMD.create([tmpRT], RenderSprite.recycleTarget, this)), ctx.addRenderObject(SubmitCMD.create([preBlendMode], RenderSprite.setBlendMode, this))
                    }
                    ctx.restore()
                } else next._fun.call(next, sprite, context, x, y)
            }

            static tmpTarget(ctx, rt, w, h) {
                rt.start(), rt.clear(0, 0, 0, 0)
            }

            static recycleTarget(rt) {
                WebGLRTMgr.releaseRT(rt)
            }

            static setBlendMode(blendMode) {
                var gl = WebGLContext.mainContext;
                BlendMode.targetFns[BlendMode.TOINT[blendMode]](gl)
            }
        }

        RenderSprite.INIT = 69905, RenderSprite.renders = [], RenderSprite.NORENDER = new RenderSprite(0, null), RenderSprite.tempUV = new Array(8);

        class Sprite extends Node {
            constructor() {
                super(), this._x = 0, this._y = 0, this._width = 0, this._height = 0, this._visible = !0, this._mouseState = 0, this._zOrder = 0, this._renderType = 0, this._transform = null, this._tfChanged = !1, this._repaint = SpriteConst.REPAINT_NONE, this._texture = null, this._style = SpriteStyle.EMPTY, this._cacheStyle = CacheStyle.EMPTY, this._boundStyle = null, this._graphics = null, this.mouseThrough = !1, this.autoSize = !1, this.hitTestPrior = !1
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._style && this._style.recover(), this._cacheStyle && this._cacheStyle.recover(), this._boundStyle && this._boundStyle.recover(), this._style = null, this._cacheStyle = null, this._boundStyle = null, this._transform = null, this._graphics && this._graphics.autoDestroy && this._graphics.destroy(), this._graphics = null, this.texture = null
            }

            updateZOrder() {
                Utils.updateOrder(this._children) && this.repaint()
            }

            _getBoundsStyle() {
                return this._boundStyle || (this._boundStyle = BoundsStyle.create()), this._boundStyle
            }

            _setCustomRender() {
            }

            set customRenderEnable(b) {
                b && (this._renderType |= SpriteConst.CUSTOM, this._setRenderType(this._renderType), this._setCustomRender())
            }

            get cacheAs() {
                return this._cacheStyle.cacheAs
            }

            _setCacheAs(value) {
            }

            set cacheAs(value) {
                value !== this._cacheStyle.userSetCache && (this.mask && "normal" === value || (this._setCacheAs(value), this._getCacheStyle().userSetCache = value, this._checkCanvasEnable(), this.repaint()))
            }

            _checkCanvasEnable() {
                var tEnable = this._cacheStyle.needEnableCanvasRender();
                this._getCacheStyle().enableCanvasRender = tEnable, tEnable ? (this._cacheStyle.needBitmapCache() ? this._cacheStyle.cacheAs = "bitmap" : this._cacheStyle.cacheAs = this._cacheStyle.userSetCache, this._cacheStyle.reCache = !0, this._renderType |= SpriteConst.CANVAS) : (this._cacheStyle.cacheAs = "none", this._cacheStyle.releaseContext(), this._renderType &= ~SpriteConst.CANVAS), this._setCacheAs(this._cacheStyle.cacheAs), this._setRenderType(this._renderType)
            }

            get staticCache() {
                return this._cacheStyle.staticCache
            }

            set staticCache(value) {
                this._getCacheStyle().staticCache = value, value || this.reCache()
            }

            reCache() {
                this._cacheStyle.reCache = !0, this._repaint |= SpriteConst.REPAINT_CACHE
            }

            getRepaint() {
                return this._repaint
            }

            _setX(value) {
                this._x = value
            }

            _setY(value) {
                this._y = value
            }

            _setWidth(texture, value) {
            }

            _setHeight(texture, value) {
            }

            get x() {
                return this._x
            }

            set x(value) {
                if (!this.destroyed && this._x !== value) {
                    this._setX(value), this.parentRepaint(SpriteConst.REPAINT_CACHE);
                    var p = this._cacheStyle.maskParent;
                    p && p.repaint(SpriteConst.REPAINT_CACHE)
                }
            }

            get y() {
                return this._y
            }

            set y(value) {
                if (!this.destroyed && this._y !== value) {
                    this._setY(value), this.parentRepaint(SpriteConst.REPAINT_CACHE);
                    var p = this._cacheStyle.maskParent;
                    p && p.repaint(SpriteConst.REPAINT_CACHE)
                }
            }

            get width() {
                return this.get_width()
            }

            set width(value) {
                this.set_width(value)
            }

            set_width(value) {
                this._width !== value && (this._width = value, this._setWidth(this.texture, value), this._setTranformChange())
            }

            get_width() {
                return this.autoSize ? this.texture ? this.texture.width : this._graphics || 0 !== this._children.length ? this.getSelfBounds().width : 0 : this._width || (this.texture ? this.texture.width : 0)
            }

            get height() {
                return this.get_height()
            }

            set height(value) {
                this.set_height(value)
            }

            set_height(value) {
                this._height !== value && (this._height = value, this._setHeight(this.texture, value), this._setTranformChange())
            }

            get_height() {
                return this.autoSize ? this.texture ? this.texture.height : this._graphics || 0 !== this._children.length ? this.getSelfBounds().height : 0 : this._height || (this.texture ? this.texture.height : 0)
            }

            get displayWidth() {
                return this.width * this.scaleX
            }

            get displayHeight() {
                return this.height * this.scaleY
            }

            setSelfBounds(bound) {
                this._getBoundsStyle().userBounds = bound
            }

            getBounds() {
                return this._getBoundsStyle().bounds = Rectangle._getWrapRec(this._boundPointsToParent())
            }

            getSelfBounds() {
                return this._boundStyle && this._boundStyle.userBounds ? this._boundStyle.userBounds : this._graphics || 0 !== this._children.length || this._texture ? this._getBoundsStyle().bounds = Rectangle._getWrapRec(this._getBoundPointsM(!1)) : Rectangle.TEMP.setTo(0, 0, this.width, this.height)
            }

            _boundPointsToParent(ifRotate = !1) {
                var pX = 0, pY = 0;
                this._style && (pX = this.pivotX, pY = this.pivotY, ifRotate = ifRotate || 0 !== this._style.rotation, this._style.scrollRect && (pX += this._style.scrollRect.x, pY += this._style.scrollRect.y));
                var pList = this._getBoundPointsM(ifRotate);
                if (!pList || pList.length < 1) return pList;
                if (8 != pList.length && (pList = ifRotate ? GrahamScan.scanPList(pList) : Rectangle._getWrapRec(pList, Rectangle.TEMP)._getBoundPoints()), !this.transform) return Utils.transPointList(pList, this._x - pX, this._y - pY), pList;
                var i, tPoint = Point.TEMP, len = pList.length;
                for (i = 0; i < len; i += 2) tPoint.x = pList[i], tPoint.y = pList[i + 1], this.toParentPoint(tPoint), pList[i] = tPoint.x, pList[i + 1] = tPoint.y;
                return pList
            }

            getGraphicBounds(realSize = !1) {
                return this._graphics ? this._graphics.getBounds(realSize) : Rectangle.TEMP.setTo(0, 0, 0, 0)
            }

            _getBoundPointsM(ifRotate = !1) {
                if (this._boundStyle && this._boundStyle.userBounds) return this._boundStyle.userBounds._getBoundPoints();
                if (this._boundStyle || this._getBoundsStyle(), this._boundStyle.temBM || (this._boundStyle.temBM = []), this._style.scrollRect) {
                    var rst = Utils.clearArray(this._boundStyle.temBM), rec = Rectangle.TEMP;
                    return rec.copyFrom(this._style.scrollRect), Utils.concatArray(rst, rec._getBoundPoints()), rst
                }
                var pList, child, cList, __childs;
                this._graphics ? pList = this._graphics.getBoundPoints() : (pList = Utils.clearArray(this._boundStyle.temBM), this._texture && ((rec = Rectangle.TEMP).setTo(0, 0, this.width || this._texture.width, this.height || this._texture.height), Utils.concatArray(pList, rec._getBoundPoints())));
                for (var i = 0, n = (__childs = this._children).length; i < n; i++) (child = __childs[i]) instanceof Sprite && !0 === child._visible && (cList = child._boundPointsToParent(ifRotate)) && (pList = pList ? Utils.concatArray(pList, cList) : cList);
                return pList
            }

            _getCacheStyle() {
                return this._cacheStyle === CacheStyle.EMPTY && (this._cacheStyle = CacheStyle.create()), this._cacheStyle
            }

            getStyle() {
                return this._style === SpriteStyle.EMPTY && (this._style = SpriteStyle.create()), this._style
            }

            setStyle(value) {
                this._style = value
            }

            get scaleX() {
                return this._style.scaleX
            }

            set scaleX(value) {
                this.set_scaleX(value)
            }

            _setScaleX(value) {
                this._style.scaleX = value
            }

            get scaleY() {
                return this._style.scaleY
            }

            set scaleY(value) {
                this.set_scaleY(value)
            }

            _setScaleY(value) {
                this._style.scaleY = value
            }

            set_scaleX(value) {
                this.getStyle().scaleX !== value && (this._setScaleX(value), this._setTranformChange())
            }

            get_scaleX() {
                return this._style.scaleX
            }

            set_scaleY(value) {
                this.getStyle().scaleY !== value && (this._setScaleY(value), this._setTranformChange())
            }

            get_scaleY() {
                return this._style.scaleY
            }

            get rotation() {
                return this._style.rotation
            }

            set rotation(value) {
                this.getStyle().rotation !== value && (this._setRotation(value), this._setTranformChange())
            }

            _setRotation(value) {
                this._style.rotation = value
            }

            get skewX() {
                return this._style.skewX
            }

            set skewX(value) {
                this.getStyle().skewX !== value && (this._setSkewX(value), this._setTranformChange())
            }

            _setSkewX(value) {
                this._style.skewX = value
            }

            get skewY() {
                return this._style.skewY
            }

            set skewY(value) {
                this.getStyle().skewY !== value && (this._setSkewY(value), this._setTranformChange())
            }

            _setSkewY(value) {
                this._style.skewY = value
            }

            _createTransform() {
                return Matrix.create()
            }

            _adjustTransform() {
                this._tfChanged = !1;
                var style = this._style, sx = style.scaleX, sy = style.scaleY, sskx = style.skewX, ssky = style.skewY,
                    rot = style.rotation, m = this._transform || (this._transform = this._createTransform());
                if (rot || 1 !== sx || 1 !== sy || 0 !== sskx || 0 !== ssky) {
                    m._bTransform = !0;
                    var skx = .0174532922222222 * (rot - sskx), sky = .0174532922222222 * (rot + ssky),
                        cx = Math.cos(sky), ssx = Math.sin(sky), cy = Math.sin(skx), ssy = Math.cos(skx);
                    m.a = sx * cx, m.b = sx * ssx, m.c = -sy * cy, m.d = sy * ssy, m.tx = m.ty = 0
                } else m.identity(), this._renderType &= ~SpriteConst.TRANSFORM, this._setRenderType(this._renderType);
                return m
            }

            _setTransform(value) {
            }

            get transform() {
                return this._tfChanged ? this._adjustTransform() : this._transform
            }

            set transform(value) {
                this.set_transform(value)
            }

            get_transform() {
                return this._tfChanged ? this._adjustTransform() : this._transform
            }

            set_transform(value) {
                this._tfChanged = !1;
                var m = this._transform || (this._transform = this._createTransform());
                value.copyTo(m), this._setTransform(m), value && (this._x = m.tx, this._y = m.ty, m.tx = m.ty = 0), value ? this._renderType |= SpriteConst.TRANSFORM : this._renderType &= ~SpriteConst.TRANSFORM, this._setRenderType(this._renderType), this.parentRepaint()
            }

            _setPivotX(value) {
                this.getStyle().pivotX = value
            }

            _getPivotX() {
                return this._style.pivotX
            }

            _setPivotY(value) {
                this.getStyle().pivotY = value
            }

            _getPivotY() {
                return this._style.pivotY
            }

            get pivotX() {
                return this._getPivotX()
            }

            set pivotX(value) {
                this._setPivotX(value), this.repaint()
            }

            get pivotY() {
                return this._getPivotY()
            }

            set pivotY(value) {
                this._setPivotY(value), this.repaint()
            }

            _setAlpha(value) {
                this._style.alpha !== value && (this.getStyle().alpha = value, 1 !== value ? this._renderType |= SpriteConst.ALPHA : this._renderType &= ~SpriteConst.ALPHA, this._setRenderType(this._renderType), this.parentRepaint())
            }

            _getAlpha() {
                return this._style.alpha
            }

            get alpha() {
                return this._getAlpha()
            }

            set alpha(value) {
                value = value < 0 ? 0 : value > 1 ? 1 : value, this._setAlpha(value)
            }

            get visible() {
                return this.get_visible()
            }

            set visible(value) {
                this.set_visible(value)
            }

            get_visible() {
                return this._visible
            }

            set_visible(value) {
                this._visible !== value && (this._visible = value, this.parentRepaint(SpriteConst.REPAINT_ALL))
            }

            _setBlendMode(value) {
            }

            get blendMode() {
                return this._style.blendMode
            }

            set blendMode(value) {
                this._setBlendMode(value), this.getStyle().blendMode = value, value && "source-over" != value ? this._renderType |= SpriteConst.BLEND : this._renderType &= ~SpriteConst.BLEND, this._setRenderType(this._renderType), this.parentRepaint()
            }

            get graphics() {
                return this._graphics || (this.graphics = new Graphics, this._graphics.autoDestroy = !0), this._graphics
            }

            _setGraphics(value) {
            }

            _setGraphicsCallBack() {
            }

            set graphics(value) {
                this._graphics && (this._graphics._sp = null), this._graphics = value, value ? (this._setGraphics(value), this._renderType |= SpriteConst.GRAPHICS, value._sp = this) : this._renderType &= ~SpriteConst.GRAPHICS, this._setRenderType(this._renderType), this.repaint()
            }

            get scrollRect() {
                return this._style.scrollRect
            }

            _setScrollRect(value) {
            }

            set scrollRect(value) {
                this.getStyle().scrollRect = value, this._setScrollRect(value), this.repaint(), value ? this._renderType |= SpriteConst.CLIP : this._renderType &= ~SpriteConst.CLIP, this._setRenderType(this._renderType)
            }

            pos(x, y, speedMode = !1) {
                if (this._x !== x || this._y !== y) {
                    if (this.destroyed) return this;
                    if (speedMode) {
                        this._setX(x), this._setY(y), this.parentRepaint(SpriteConst.REPAINT_CACHE);
                        var p = this._cacheStyle.maskParent;
                        p && p.repaint(SpriteConst.REPAINT_CACHE)
                    } else this.x = x, this.y = y
                }
                return this
            }

            pivot(x, y) {
                return this.pivotX = x, this.pivotY = y, this
            }

            size(width, height) {
                return this.width = width, this.height = height, this
            }

            scale(scaleX, scaleY, speedMode = !1) {
                var style = this.getStyle();
                if (style.scaleX != scaleX || style.scaleY != scaleY) {
                    if (this.destroyed) return this;
                    speedMode ? (this._setScaleX(scaleX), this._setScaleY(scaleY), this._setTranformChange()) : (this.scaleX = scaleX, this.scaleY = scaleY)
                }
                return this
            }

            skew(skewX, skewY) {
                return this.skewX = skewX, this.skewY = skewY, this
            }

            render(ctx, x, y) {
                RenderSprite.renders[this._renderType]._fun(this, ctx, x + this._x, y + this._y), this._repaint = 0
            }

            drawToCanvas(canvasWidth, canvasHeight, offsetX, offsetY) {
                return Sprite.drawToCanvas(this, this._renderType, canvasWidth, canvasHeight, offsetX, offsetY)
            }

            drawToTexture(canvasWidth, canvasHeight, offsetX, offsetY) {
                return Sprite.drawToTexture(this, this._renderType, canvasWidth, canvasHeight, offsetX, offsetY)
            }

            drawToTexture3D(offx, offy, tex) {
                throw"not implement"
            }

            customRender(context, x, y) {
                this._repaint = SpriteConst.REPAINT_ALL
            }

            _applyFilters() {
            }

            get filters() {
                return this._cacheStyle.filters
            }

            _setColorFilter(value) {
            }

            set filters(value) {
                value && 0 === value.length && (value = null), this._cacheStyle.filters != value && (this._getCacheStyle().filters = value ? value.slice() : null, value && value.length ? (this._setColorFilter(value[0]), this._renderType |= SpriteConst.FILTERS) : (this._setColorFilter(null), this._renderType &= ~SpriteConst.FILTERS), this._setRenderType(this._renderType), value && value.length > 0 ? (this._getBit(Const.DISPLAY) || this._setBitUp(Const.DISPLAY), 1 == value.length && value[0] instanceof ColorFilter || (this._getCacheStyle().cacheForFilters = !0, this._checkCanvasEnable())) : this._cacheStyle.cacheForFilters && (this._cacheStyle.cacheForFilters = !1, this._checkCanvasEnable()), this._getCacheStyle().hasGlowFilter = this._isHaveGlowFilter(), this.repaint())
            }

            _isHaveGlowFilter() {
                var i, len;
                if (this.filters) for (i = 0; i < this.filters.length; i++) if (this.filters[i].type == Filter.GLOW) return !0;
                for (i = 0, len = this._children.length; i < len; i++) if (this._children[i]._isHaveGlowFilter()) return !0;
                return !1
            }

            localToGlobal(point, createNewPoint = !1, globalNode = null) {
                !0 === createNewPoint && (point = new Point(point.x, point.y));
                var ele = this;
                for (globalNode = globalNode || ILaya.stage; ele && !ele.destroyed && ele != globalNode;) point = ele.toParentPoint(point), ele = ele.parent;
                return point
            }

            globalToLocal(point, createNewPoint = !1, globalNode = null) {
                createNewPoint && (point = new Point(point.x, point.y));
                var ele = this, list = [];
                for (globalNode = globalNode || ILaya.stage; ele && !ele.destroyed && ele != globalNode;) list.push(ele), ele = ele.parent;
                for (var i = list.length - 1; i >= 0;) point = (ele = list[i]).fromParentPoint(point), i--;
                return point
            }

            toParentPoint(point) {
                if (!point) return point;
                point.x -= this.pivotX, point.y -= this.pivotY, this.transform && this._transform.transformPoint(point), point.x += this._x, point.y += this._y;
                var scroll = this._style.scrollRect;
                return scroll && (point.x -= scroll.x, point.y -= scroll.y), point
            }

            fromParentPoint(point) {
                if (!point) return point;
                point.x -= this._x, point.y -= this._y;
                var scroll = this._style.scrollRect;
                return scroll && (point.x += scroll.x, point.y += scroll.y), this.transform && this._transform.invertTransformPoint(point), point.x += this.pivotX, point.y += this.pivotY, point
            }

            fromStagePoint(point) {
                return point
            }

            on(type, caller, listener, args = null) {
                return 1 !== this._mouseState && this.isMouseEvent(type) ? (this.mouseEnabled = !0, this._setBit(Const.HAS_MOUSE, !0), this._parent && this._onDisplay(), this._createListener(type, caller, listener, args, !1)) : super.on(type, caller, listener, args)
            }

            once(type, caller, listener, args = null) {
                return 1 !== this._mouseState && this.isMouseEvent(type) ? (this.mouseEnabled = !0, this._setBit(Const.HAS_MOUSE, !0), this._parent && this._onDisplay(), this._createListener(type, caller, listener, args, !0)) : super.once(type, caller, listener, args)
            }

            _onDisplay(v) {
                if (1 !== this._mouseState) {
                    var ele = this;
                    for (ele = ele.parent; ele && 1 !== ele._mouseState && !ele._getBit(Const.HAS_MOUSE);) ele.mouseEnabled = !0, ele._setBit(Const.HAS_MOUSE, !0), ele = ele.parent
                }
            }

            _setParent(value) {
                super._setParent(value), value && this._getBit(Const.HAS_MOUSE) && this._onDisplay()
            }

            loadImage(url, complete = null) {
                if (url) {
                    var tex = ILaya.Loader.getRes(url);
                    tex || ((tex = new Texture).load(url), ILaya.Loader.cacheRes(url, tex)), this.texture = tex, tex.getIsReady() ? loaded.call(this) : tex.once(Event.READY, this, loaded)
                } else this.texture = null, loaded.call(this);

                function loaded() {
                    this.repaint(SpriteConst.REPAINT_ALL), complete && complete.run()
                }

                return this
            }

            static fromImage(url) {
                return (new Sprite).loadImage(url)
            }

            repaint(type = SpriteConst.REPAINT_CACHE) {
                this._repaint & type || (this._repaint |= type, this.parentRepaint(type)), this._cacheStyle && this._cacheStyle.maskParent && this._cacheStyle.maskParent.repaint(type)
            }

            _needRepaint() {
                return this._repaint & SpriteConst.REPAINT_CACHE && this._cacheStyle.enableCanvasRender && this._cacheStyle.reCache
            }

            _childChanged(child = null) {
                this._children.length ? this._renderType |= SpriteConst.CHILDS : this._renderType &= ~SpriteConst.CHILDS, this._setRenderType(this._renderType), child && this._getBit(Const.HAS_ZORDER) && ILaya.systemTimer.callLater(this, this.updateZOrder), this.repaint(SpriteConst.REPAINT_ALL)
            }

            parentRepaint(type = SpriteConst.REPAINT_CACHE) {
                var p = this._parent;
                !p || p._repaint & type || (p._repaint |= type, p.parentRepaint(type))
            }

            get stage() {
                return ILaya.stage
            }

            get hitArea() {
                return this._style.hitArea
            }

            set hitArea(value) {
                this.getStyle().hitArea = value
            }

            _setMask(value) {
            }

            get mask() {
                return this._cacheStyle.mask
            }

            set mask(value) {
                value && this.mask && this.mask._cacheStyle.maskParent || (this._getCacheStyle().mask = value, this._setMask(value), this._checkCanvasEnable(), value ? value._getCacheStyle().maskParent = this : this.mask && (this.mask._getCacheStyle().maskParent = null), this._renderType |= SpriteConst.MASK, this._setRenderType(this._renderType), this.parentRepaint(SpriteConst.REPAINT_ALL))
            }

            get mouseEnabled() {
                return this._mouseState > 1
            }

            set mouseEnabled(value) {
                this._mouseState = value ? 2 : 1
            }

            startDrag(area = null, hasInertia = !1, elasticDistance = 0, elasticBackTime = 300, data = null, disableMouseEvent = !1, ratio = .92) {
                this._style.dragging || (this.getStyle().dragging = new ILaya.Dragging), this._style.dragging.start(this, area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio)
            }

            stopDrag() {
                this._style.dragging && this._style.dragging.stop()
            }

            _setDisplay(value) {
                value || this._cacheStyle && (this._cacheStyle.releaseContext(), this._cacheStyle.releaseFilterCache(), this._cacheStyle.hasGlowFilter && (this._cacheStyle.hasGlowFilter = !1)), super._setDisplay(value)
            }

            hitTestPoint(x, y) {
                var point = this.globalToLocal(Point.TEMP.setTo(x, y));
                return x = point.x, y = point.y, (this._style.hitArea ? this._style.hitArea : this._width > 0 && this._height > 0 ? Rectangle.TEMP.setTo(0, 0, this._width, this._height) : this.getSelfBounds()).contains(x, y)
            }

            getMousePoint() {
                return this.globalToLocal(Point.TEMP.setTo(ILaya.stage.mouseX, ILaya.stage.mouseY))
            }

            get globalScaleX() {
                for (var scale = 1, ele = this; ele && ele !== ILaya.stage;) scale *= ele.scaleX, ele = ele.parent;
                return scale
            }

            get globalRotation() {
                for (var angle = 0, ele = this; ele && ele !== ILaya.stage;) angle += ele.rotation, ele = ele.parent;
                return angle
            }

            get globalScaleY() {
                for (var scale = 1, ele = this; ele && ele !== ILaya.stage;) scale *= ele.scaleY, ele = ele.parent;
                return scale
            }

            get mouseX() {
                return this.getMousePoint().x
            }

            get mouseY() {
                return this.getMousePoint().y
            }

            get zOrder() {
                return this._zOrder
            }

            set zOrder(value) {
                this._zOrder != value && (this._zOrder = value, this._parent && (value && this._parent._setBit(Const.HAS_ZORDER, !0), ILaya.systemTimer.callLater(this._parent, this.updateZOrder)))
            }

            get texture() {
                return this._texture
            }

            _setTexture(value) {
            }

            set texture(value) {
                "string" == typeof value ? this.loadImage(value) : this._texture != value && (this._texture && this._texture._removeReference(), this._texture = value, value && value._addReference(), this._setTexture(value), this._setWidth(this._texture, this.width), this._setHeight(this._texture, this.height), value ? this._renderType |= SpriteConst.TEXTURE : this._renderType &= ~SpriteConst.TEXTURE, this._setRenderType(this._renderType), this.repaint())
            }

            get viewport() {
                return this._style.viewport
            }

            set viewport(value) {
                var recArr;
                "string" == typeof value && ((recArr = value.split(",")).length > 3 && (value = new Rectangle(parseFloat(recArr[0]), parseFloat(recArr[1]), parseFloat(recArr[2]), parseFloat(recArr[3]))));
                this.getStyle().viewport = value
            }

            _setRenderType(type) {
            }

            _setTranformChange() {
                this._tfChanged = !0, this._renderType |= SpriteConst.TRANSFORM, this.parentRepaint(SpriteConst.REPAINT_CACHE)
            }

            _setBgStyleColor(x, y, width, height, fillColor) {
            }

            _setBorderStyleColor(x, y, width, height, fillColor, borderWidth) {
            }

            captureMouseEvent(exclusive) {
                ILaya.MouseManager.instance.setCapture(this, exclusive)
            }

            releaseMouseEvent() {
                ILaya.MouseManager.instance.releaseCapture()
            }

            set drawCallOptimize(value) {
                this._setBit(Const.DRAWCALL_OPTIMIZE, value)
            }

            get drawCallOptimize() {
                return this._getBit(Const.DRAWCALL_OPTIMIZE)
            }
        }

        Sprite.drawToCanvas = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
            offsetX -= sprite.x, offsetY -= sprite.y, offsetX |= 0, offsetY |= 0, canvasWidth |= 0, canvasHeight |= 0;
            var ctx = new Context;
            ctx.size(canvasWidth, canvasHeight), ctx.asBitmap = !0, ctx._targets.start(), RenderSprite.renders[_renderType]._fun(sprite, ctx, offsetX, offsetY), ctx.flush(), ctx._targets.end(), ctx._targets.restore();
            var dt = ctx._targets.getData(0, 0, canvasWidth, canvasHeight);
            ctx.destroy();
            for (var imgdata = new ImageData(canvasWidth, canvasHeight), lineLen = 4 * canvasWidth, dst = imgdata.data, y = canvasHeight - 1, off = y * lineLen, srcoff = 0; y >= 0; y--) dst.set(dt.subarray(srcoff, srcoff + lineLen), off), off -= lineLen, srcoff += lineLen;
            var canv = new HTMLCanvas(!0);
            return canv.size(canvasWidth, canvasHeight), canv.getContext("2d").putImageData(imgdata, 0, 0), canv
        }, Sprite.drawToTexture = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
            offsetX -= sprite.x, offsetY -= sprite.y, offsetX |= 0, offsetY |= 0, canvasWidth |= 0, canvasHeight |= 0;
            var ctx = new Context;
            ctx.size(canvasWidth, canvasHeight), ctx.asBitmap = !0, ctx._targets.start(), RenderSprite.renders[_renderType]._fun(sprite, ctx, offsetX, offsetY), ctx.flush(), ctx._targets.end(), ctx._targets.restore();
            var rtex = new Texture(ctx._targets, Texture.INV_UV);
            return ctx.destroy(!0), rtex
        }, ClassUtils.regClass("laya.display.Sprite", Sprite), ClassUtils.regClass("Laya.Sprite", Sprite);

        class TextStyle extends SpriteStyle {
            constructor() {
                super(...arguments), this.italic = !1
            }

            reset() {
                return super.reset(), this.italic = !1, this.align = "left", this.wordWrap = !1, this.leading = 0, this.padding = [0, 0, 0, 0], this.bgColor = null, this.borderColor = null, this.asPassword = !1, this.stroke = 0, this.strokeColor = "#000000", this.bold = !1, this.underline = !1, this.underlineColor = null, this.currBitmapFont = null, this
            }

            recover() {
                this !== TextStyle.EMPTY && Pool.recover("TextStyle", this.reset())
            }

            static create() {
                return Pool.getItemByClass("TextStyle", TextStyle)
            }

            render(sprite, context, x, y) {
                (this.bgColor || this.borderColor) && context.drawRect(x, y, sprite.width, sprite.height, this.bgColor, this.borderColor, 1)
            }
        }

        TextStyle.EMPTY = new TextStyle;

        class Text extends Sprite {
            constructor() {
                super(), this._textWidth = 0, this._textHeight = 0, this._lines = [], this._lineWidths = [], this._startX = 0, this._startY = 0, this._charSize = {}, this._valign = "top", this._fontSize = Text.defaultFontSize, this._font = Text.defaultFont, this._color = "#000000", this._singleCharRender = !1, this.overflow = Text.VISIBLE, this._style = TextStyle.EMPTY
            }

            static defaultFontStr() {
                return Text.defaultFontSize + "px " + Text.defaultFont
            }

            getStyle() {
                return this._style === TextStyle.EMPTY && (this._style = TextStyle.create()), this._style
            }

            _getTextStyle() {
                return this._style === TextStyle.EMPTY && (this._style = TextStyle.create()), this._style
            }

            static registerBitmapFont(name, bitmapFont) {
                Text._bitmapFonts || (Text._bitmapFonts = {}), Text._bitmapFonts[name] = bitmapFont
            }

            static unregisterBitmapFont(name, destroy = !0) {
                if (Text._bitmapFonts && Text._bitmapFonts[name]) {
                    var tBitmapFont = Text._bitmapFonts[name];
                    destroy && tBitmapFont.destroy(), delete Text._bitmapFonts[name]
                }
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._clipPoint = null, this._lines = null, this._lineWidths = null, this._words && this._words.forEach(function (w) {
                    w.cleanCache()
                }), this._words = null, this._charSize = null
            }

            _getBoundPointsM(ifRotate = !1) {
                var rec = Rectangle.TEMP;
                return rec.setTo(0, 0, this.width, this.height), rec._getBoundPoints()
            }

            getGraphicBounds(realSize = !1) {
                var rec = Rectangle.TEMP;
                return rec.setTo(0, 0, this.width, this.height), rec
            }

            get width() {
                return this._width ? this._width : this.textWidth + this.padding[1] + this.padding[3]
            }

            set width(value) {
                value != this._width && (super.set_width(value), this.isChanged = !0, this.borderColor && this._setBorderStyleColor(0, 0, this.width, this.height, this.borderColor, 1))
            }

            _getCSSStyle() {
                return this._style
            }

            get height() {
                return this._height ? this._height : this.textHeight
            }

            set height(value) {
                value != this._height && (super.set_height(value), this.isChanged = !0, this.borderColor && this._setBorderStyleColor(0, 0, this.width, this.height, this.borderColor, 1))
            }

            get textWidth() {
                return this._isChanged && ILaya.systemTimer.runCallLater(this, this.typeset), this._textWidth
            }

            get textHeight() {
                return this._isChanged && ILaya.systemTimer.runCallLater(this, this.typeset), this._textHeight
            }

            get text() {
                return this._text || ""
            }

            get_text() {
                return this._text || ""
            }

            set_text(value) {
                this._text !== value && (this.lang(value + ""), this.isChanged = !0, this.event(Event.CHANGE), this.borderColor && this._setBorderStyleColor(0, 0, this.width, this.height, this.borderColor, 1))
            }

            set text(value) {
                this.set_text(value)
            }

            lang(text, arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null, arg6 = null, arg7 = null, arg8 = null, arg9 = null, arg10 = null) {
                if (text = Text.langPacks && Text.langPacks[text] ? Text.langPacks[text] : text, arguments.length < 2) this._text = text; else {
                    for (var i = 0, n = arguments.length; i < n; i++) text = text.replace("{" + i + "}", arguments[i + 1]);
                    this._text = text
                }
            }

            get font() {
                return this._font
            }

            set font(value) {
                this._style.currBitmapFont && (this._getTextStyle().currBitmapFont = null, this.scale(1, 1)), Text._bitmapFonts && Text._bitmapFonts[value] && (this._getTextStyle().currBitmapFont = Text._bitmapFonts[value]), this._font = value, this.isChanged = !0
            }

            get fontSize() {
                return this._fontSize
            }

            set fontSize(value) {
                this._fontSize != value && (this._fontSize = value, this.isChanged = !0)
            }

            get bold() {
                return this._style.bold
            }

            set bold(value) {
                this._getTextStyle().bold = value, this.isChanged = !0
            }

            get color() {
                return this._color
            }

            set color(value) {
                this.set_color(value)
            }

            get_color() {
                return this._color
            }

            set_color(value) {
                this._color != value && (this._color = value, !this._isChanged && this._graphics ? this._graphics.replaceTextColor(this.color) : this.isChanged = !0)
            }

            get italic() {
                return this._style.italic
            }

            set italic(value) {
                this._getTextStyle().italic = value, this.isChanged = !0
            }

            get align() {
                return this._style.align
            }

            set align(value) {
                this._getTextStyle().align = value, this.isChanged = !0
            }

            get valign() {
                return this._valign
            }

            set valign(value) {
                this._valign = value, this.isChanged = !0
            }

            get wordWrap() {
                return this._style.wordWrap
            }

            set wordWrap(value) {
                this._getTextStyle().wordWrap = value, this.isChanged = !0
            }

            get leading() {
                return this._style.leading
            }

            set leading(value) {
                this._getTextStyle().leading = value, this.isChanged = !0
            }

            get padding() {
                return this._style.padding
            }

            set padding(value) {
                if ("string" == typeof value) {
                    var arr, i, len;
                    for (len = (arr = value.split(",")).length; arr.length < 4;) arr.push(0);
                    for (i = 0; i < len; i++) arr[i] = parseFloat(arr[i]) || 0;
                    value = arr
                }
                this._getTextStyle().padding = value, this.isChanged = !0
            }

            get bgColor() {
                return this._style.bgColor
            }

            set bgColor(value) {
                this.set_bgColor(value)
            }

            set_bgColor(value) {
                this._getTextStyle().bgColor = value, this._renderType |= SpriteConst.STYLE, this._setBgStyleColor(0, 0, this.width, this.height, value), this._setRenderType(this._renderType), this.isChanged = !0
            }

            get_bgColor() {
                return this._style.bgColor
            }

            get borderColor() {
                return this._style.borderColor
            }

            set borderColor(value) {
                this._getTextStyle().borderColor = value, this._renderType |= SpriteConst.STYLE, this._setBorderStyleColor(0, 0, this.width, this.height, value, 1), this._setRenderType(this._renderType), this.isChanged = !0
            }

            get stroke() {
                return this._style.stroke
            }

            set stroke(value) {
                this._getTextStyle().stroke = value, this.isChanged = !0
            }

            get strokeColor() {
                return this._style.strokeColor
            }

            set strokeColor(value) {
                this._getTextStyle().strokeColor = value, this.isChanged = !0
            }

            set isChanged(value) {
                this._isChanged !== value && (this._isChanged = value, value && ILaya.systemTimer.callLater(this, this.typeset))
            }

            _getContextFont() {
                return (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + (ILaya.Browser.onIPhone && Text.fontFamilyMap[this.font] || this.font)
            }

            _isPassWordMode() {
                var password = this._style.asPassword;
                return "prompt" in this && this.prompt == this._text && (password = !1), password
            }

            _getPassWordTxt(txt) {
                var word;
                word = "";
                for (var j = txt.length; j > 0; j--) word += "●";
                return word
            }

            _renderText() {
                var padding = this.padding, visibleLineCount = this._lines.length;
                this.overflow != Text.VISIBLE && (visibleLineCount = Math.min(visibleLineCount, Math.floor((this.height - padding[0] - padding[2]) / (this.leading + this._charSize.height)) + 1));
                var beginLine = this.scrollY / (this._charSize.height + this.leading) | 0, graphics = this.graphics;
                graphics.clear(!0);
                var ctxFont = this._getContextFont();
                ILaya.Browser.context.font = ctxFont;
                var startX = padding[3], textAlgin = "left", lines = this._lines,
                    lineHeight = this.leading + this._charSize.height, tCurrBitmapFont = this._style.currBitmapFont;
                tCurrBitmapFont && (lineHeight = this.leading + tCurrBitmapFont.getMaxHeight());
                var startY = padding[0];
                if (!tCurrBitmapFont && this._width > 0 && this._textWidth <= this._width && ("right" == this.align ? (textAlgin = "right", startX = this._width - padding[1]) : "center" == this.align && (textAlgin = "center", startX = .5 * this._width + padding[3] - padding[1])), this._height > 0) {
                    var tempVAlign = this._textHeight > this._height ? "top" : this.valign;
                    "middle" === tempVAlign ? startY = .5 * (this._height - visibleLineCount * lineHeight) + padding[0] - padding[2] : "bottom" === tempVAlign && (startY = this._height - visibleLineCount * lineHeight - padding[2])
                }
                var style = this._style;
                if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) var bitmapScale = tCurrBitmapFont.fontSize / this.fontSize;
                if (this._clipPoint) {
                    var tClipWidth, tClipHeight;
                    if (graphics.save(), tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) tClipWidth = this._width ? this._width - padding[3] - padding[1] : this._textWidth, tClipHeight = this._height ? this._height - padding[0] - padding[2] : this._textHeight, tClipWidth *= bitmapScale, tClipHeight *= bitmapScale, graphics.clipRect(padding[3], padding[0], tClipWidth, tClipHeight); else graphics.clipRect(padding[3], padding[0], this._width ? this._width - padding[3] - padding[1] : this._textWidth, this._height ? this._height - padding[0] - padding[2] : this._textHeight);
                    this.repaint()
                }
                var password = style.asPassword;
                "prompt" in this && this.prompt == this._text && (password = !1);
                for (var x = 0, y = 0, end = Math.min(this._lines.length, visibleLineCount + beginLine) || 1, i = beginLine; i < end; i++) {
                    var _word, word = lines[i];
                    if (password) {
                        var len = word.length;
                        word = "";
                        for (var j = len; j > 0; j--) word += "●"
                    }
                    if (null == word && (word = ""), x = startX - (this._clipPoint ? this._clipPoint.x : 0), y = startY + lineHeight * i - (this._clipPoint ? this._clipPoint.y : 0), this.underline && this._drawUnderline(textAlgin, x, y, i), tCurrBitmapFont) {
                        var tWidth = this.width;
                        tCurrBitmapFont.autoScaleSize && (tWidth = this.width * bitmapScale), tCurrBitmapFont._drawText(word, this, x, y, this.align, tWidth)
                    } else this._words || (this._words = []), this._words.length > i - beginLine ? _word = this._words[i - beginLine] : (_word = new WordText, this._words.push(_word)), _word.setText(word), _word.splitRender = this._singleCharRender, style.stroke ? graphics.fillBorderText(_word, x, y, ctxFont, this.color, style.strokeColor, style.stroke, textAlgin) : graphics.fillText(_word, x, y, ctxFont, this.color, textAlgin)
                }
                if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                    var tScale = 1 / bitmapScale;
                    this.scale(tScale, tScale)
                }
                this._clipPoint && graphics.restore(), this._startX = startX, this._startY = startY
            }

            _drawUnderline(align, x, y, lineIndex) {
                var lineWidth = this._lineWidths[lineIndex];
                switch (align) {
                    case"center":
                        x -= lineWidth / 2;
                        break;
                    case"right":
                        x -= lineWidth
                }
                y += this._charSize.height, this._graphics.drawLine(x, y, x + lineWidth, y, this.underlineColor || this.color, 1)
            }

            typeset() {
                if (this._isChanged = !1, !this._text) return this._clipPoint = null, this._textWidth = this._textHeight = 0, void this.graphics.clear(!0);
                ILaya.Render.isConchApp ? window.conchTextCanvas.font = this._getContextFont() : ILaya.Browser.context.font = this._getContextFont(), this._lines.length = 0, this._lineWidths.length = 0, this._isPassWordMode() ? this._parseLines(this._getPassWordTxt(this._text)) : this._parseLines(this._text), this._evalTextSize(), this._checkEnabledViewportOrNot() ? this._clipPoint || (this._clipPoint = new Point(0, 0)) : this._clipPoint = null, this._renderText()
            }

            _evalTextSize() {
                var nw, nh;
                nw = Math.max.apply(this, this._lineWidths), nh = this._style.currBitmapFont ? this._lines.length * (this._style.currBitmapFont.getMaxHeight() + this.leading) + this.padding[0] + this.padding[2] : this._lines.length * (this._charSize.height + this.leading) + this.padding[0] + this.padding[2], nw == this._textWidth && nh == this._textHeight || (this._textWidth = nw, this._textHeight = nh)
            }

            _checkEnabledViewportOrNot() {
                return this.overflow == Text.SCROLL && (this._width > 0 && this._textWidth > this._width || this._height > 0 && this._textHeight > this._height)
            }

            changeText(text) {
                this._text !== text && (this.lang(text + ""), this._graphics && this._graphics.replaceText(this._text) || this.typeset())
            }

            _parseLines(text) {
                var needWordWrapOrTruncate = this.wordWrap || this.overflow == Text.HIDDEN;
                if (needWordWrapOrTruncate) var wordWrapWidth = this._getWordWrapWidth();
                var bitmapFont = this._style.currBitmapFont;
                if (bitmapFont) this._charSize.width = bitmapFont.getMaxWidth(), this._charSize.height = bitmapFont.getMaxHeight(); else {
                    var measureResult = null;
                    (measureResult = ILaya.Render.isConchApp ? window.conchTextCanvas.measureText(Text._testWord) : ILaya.Browser.context.measureText(Text._testWord)) || (measureResult = {width: 100}), this._charSize.width = measureResult.width, this._charSize.height = measureResult.height || this.fontSize
                }
                for (var lines = text.replace(/\r\n/g, "\n").split("\n"), i = 0, n = lines.length; i < n; i++) {
                    var line = lines[i];
                    needWordWrapOrTruncate ? this._parseLine(line, wordWrapWidth) : (this._lineWidths.push(this._getTextWidth(line)), this._lines.push(line))
                }
            }

            _parseLine(line, wordWrapWidth) {
                var lines = this._lines, maybeIndex = 0, charsWidth = 0, wordWidth = 0, startIndex = 0;
                if ((charsWidth = this._getTextWidth(line)) <= wordWrapWidth) return lines.push(line), void this._lineWidths.push(charsWidth);
                charsWidth = this._charSize.width, 0 == (maybeIndex = Math.floor(wordWrapWidth / charsWidth)) && (maybeIndex = 1), wordWidth = charsWidth = this._getTextWidth(line.substring(0, maybeIndex));
                for (var j = maybeIndex, m = line.length; j < m; j++) if ((wordWidth += charsWidth = this._getTextWidth(line.charAt(j))) > wordWrapWidth) if (this.wordWrap) {
                    var newLine = line.substring(startIndex, j);
                    if (newLine.charCodeAt(newLine.length - 1) < 255) {
                        var execResult = /(?:\w|-)+$/.exec(newLine);
                        execResult && (j = execResult.index + startIndex, 0 == execResult.index ? j += newLine.length : newLine = line.substring(startIndex, j))
                    }
                    if (lines.push(newLine), this._lineWidths.push(wordWidth - charsWidth), startIndex = j, !(j + maybeIndex < m)) {
                        lines.push(line.substring(startIndex, m)), this._lineWidths.push(this._getTextWidth(lines[lines.length - 1])), startIndex = -1;
                        break
                    }
                    j += maybeIndex, wordWidth = charsWidth = this._getTextWidth(line.substring(startIndex, j)), j--
                } else if (this.overflow == Text.HIDDEN) return lines.push(line.substring(0, j)), void this._lineWidths.push(this._getTextWidth(lines[lines.length - 1]));
                this.wordWrap && -1 != startIndex && (lines.push(line.substring(startIndex, m)), this._lineWidths.push(this._getTextWidth(lines[lines.length - 1])))
            }

            _getTextWidth(text) {
                var bitmapFont = this._style.currBitmapFont;
                return bitmapFont ? bitmapFont.getTextWidth(text) : ILaya.Render.isConchApp ? window.conchTextCanvas.measureText(text).width : ILaya.Browser.context.measureText(text).width
            }

            _getWordWrapWidth() {
                var w, p = this.padding, bitmapFont = this._style.currBitmapFont;
                return (w = bitmapFont && bitmapFont.autoScaleSize ? this._width * (bitmapFont.fontSize / this.fontSize) : this._width) <= 0 && (w = this.wordWrap ? 100 : ILaya.Browser.width), w <= 0 && (w = 100), w - p[3] - p[1]
            }

            getCharPoint(charIndex, out = null) {
                this._isChanged && ILaya.systemTimer.runCallLater(this, this.typeset);
                for (var len = 0, lines = this._lines, startIndex = 0, i = 0, n = lines.length; i < n; i++) {
                    if (charIndex < (len += lines[i].length)) {
                        var line = i;
                        break
                    }
                    startIndex = len
                }
                var ctxFont = (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + this.font;
                ILaya.Browser.context.font = ctxFont;
                var width = this._getTextWidth(this._text.substring(startIndex, charIndex));
                return (out || new Point).setTo(this._startX + width - (this._clipPoint ? this._clipPoint.x : 0), this._startY + line * (this._charSize.height + this.leading) - (this._clipPoint ? this._clipPoint.y : 0))
            }

            set scrollX(value) {
                if (!(this.overflow != Text.SCROLL || this.textWidth < this._width) && this._clipPoint) {
                    value = value < this.padding[3] ? this.padding[3] : value;
                    var maxScrollX = this._textWidth - this._width;
                    value = value > maxScrollX ? maxScrollX : value, this._clipPoint.x = value, this._renderText()
                }
            }

            get scrollX() {
                return this._clipPoint ? this._clipPoint.x : 0
            }

            set scrollY(value) {
                if (!(this.overflow != Text.SCROLL || this.textHeight < this._height) && this._clipPoint) {
                    value = value < this.padding[0] ? this.padding[0] : value;
                    var maxScrollY = this._textHeight - this._height;
                    value = value > maxScrollY ? maxScrollY : value, this._clipPoint.y = value, this._renderText()
                }
            }

            get scrollY() {
                return this._clipPoint ? this._clipPoint.y : 0
            }

            get maxScrollX() {
                return this.textWidth < this._width ? 0 : this._textWidth - this._width
            }

            get maxScrollY() {
                return this.textHeight < this._height ? 0 : this._textHeight - this._height
            }

            get lines() {
                return this._isChanged && this.typeset(), this._lines
            }

            get underlineColor() {
                return this._style.underlineColor
            }

            set underlineColor(value) {
                this._getTextStyle().underlineColor = value, this._isChanged || this._renderText()
            }

            get underline() {
                return this._style.underline
            }

            set underline(value) {
                this._getTextStyle().underline = value
            }

            set singleCharRender(value) {
                this._singleCharRender = value
            }

            get singleCharRender() {
                return this._singleCharRender
            }
        }

        Text.VISIBLE = "visible", Text.SCROLL = "scroll", Text.HIDDEN = "hidden", Text.defaultFontSize = 12, Text.defaultFont = "Arial", Text.isComplexText = !1, Text.fontFamilyMap = {
            "报隶": "报隶-简",
            "黑体": "黑体-简",
            "楷体": "楷体-简",
            "兰亭黑": "兰亭黑-简",
            "隶变": "隶变-简",
            "凌慧体": "凌慧体-简",
            "翩翩体": "翩翩体-简",
            "苹方": "苹方-简",
            "手札体": "手札体-简",
            "宋体": "宋体-简",
            "娃娃体": "娃娃体-简",
            "魏碑": "魏碑-简",
            "行楷": "行楷-简",
            "雅痞": "雅痞-简",
            "圆体": "圆体-简"
        }, Text._testWord = "游", Text.CharacterCache = !0, Text.RightToLeft = !1, ILaya.regClass(Text), ClassUtils.regClass("laya.display.Text", Text), ClassUtils.regClass("Laya.Text", Text);

        class Input extends Text {
            constructor() {
                super(), this._multiline = !1, this._editable = !0, this._maxChars = 1e5, this._type = "text", this._prompt = "", this._promptColor = "#A9A9A9", this._originColor = "#000000", this._content = "", Input.IOS_IFRAME = ILaya.Browser.onIOS && ILaya.Browser.window.top != ILaya.Browser.window.self, this._width = 100, this._height = 20, this.multiline = !1, this.overflow = Text.SCROLL, this.on(Event.MOUSE_DOWN, this, this._onMouseDown), this.on(Event.UNDISPLAY, this, this._onUnDisplay)
            }

            static __init__() {
                if (Input._createInputElement(), ILaya.Browser.onMobile) {
                    var isTrue = !1;
                    (ILaya.Browser.onMiniGame || ILaya.Browser.onBDMiniGame || ILaya.Browser.onQGMiniGame || ILaya.Browser.onKGMiniGame || ILaya.Browser.onVVMiniGame || ILaya.Browser.onAlipayMiniGame || ILaya.Browser.onQQMiniGame) && (isTrue = !0), ILaya.Render.canvas.addEventListener(Input.IOS_IFRAME ? isTrue ? "touchend" : "click" : "touchend", Input._popupInputMethod)
                }
            }

            static _popupInputMethod(e) {
                Input.isInputting && Input.inputElement.focus()
            }

            static _createInputElement() {
                Input._initInput(Input.area = ILaya.Browser.createElement("textarea")), Input._initInput(Input.input = ILaya.Browser.createElement("input")), Input.inputContainer = ILaya.Browser.createElement("div"), Input.inputContainer.style.position = "absolute", Input.inputContainer.style.zIndex = 1e5, ILaya.Browser.container.appendChild(Input.inputContainer), Input.inputContainer.setPos = function (x, y) {
                    Input.inputContainer.style.left = x + "px", Input.inputContainer.style.top = y + "px"
                }
            }

            static _initInput(input) {
                var style = input.style;
                style.cssText = "position:absolute;overflow:hidden;resize:none;transform-origin:0 0;-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-o-transform-origin:0 0;", style.resize = "none", style.backgroundColor = "transparent", style.border = "none", style.outline = "none", style.zIndex = 1, input.addEventListener("input", Input._processInputting), input.addEventListener("mousemove", Input._stopEvent), input.addEventListener("mousedown", Input._stopEvent), input.addEventListener("touchmove", Input._stopEvent), input.setFontFace = function (fontFace) {
                    input.style.fontFamily = fontFace
                }, ILaya.Render.isConchApp || (input.setColor = function (color) {
                    input.style.color = color
                }, input.setFontSize = function (fontSize) {
                    input.style.fontSize = fontSize + "px"
                })
            }

            static _processInputting(e) {
                var input = Input.inputElement.target;
                if (input) {
                    var value = Input.inputElement.value;
                    input._restrictPattern && (value = value.replace(/\u2006|\x27/g, ""), input._restrictPattern.test(value) && (value = value.replace(input._restrictPattern, ""), Input.inputElement.value = value)), input._text = value, input.event(Event.INPUT)
                }
            }

            static _stopEvent(e) {
                "touchmove" == e.type && e.preventDefault(), e.stopPropagation && e.stopPropagation()
            }

            setSelection(startIndex, endIndex) {
                this.focus = !0, Input.inputElement.selectionStart = startIndex, Input.inputElement.selectionEnd = endIndex
            }

            get multiline() {
                return this._multiline
            }

            set multiline(value) {
                this._multiline = value, this.valign = value ? "top" : "middle"
            }

            get nativeInput() {
                return this._multiline ? Input.area : Input.input
            }

            _onUnDisplay(e = null) {
                this.focus = !1
            }

            _onMouseDown(e) {
                this.focus = !0
            }

            _syncInputTransform() {
                var inputElement = this.nativeInput,
                    transform = Utils.getTransformRelativeToWindow(this, this.padding[3], this.padding[0]),
                    inputWid = this._width - this.padding[1] - this.padding[3],
                    inputHei = this._height - this.padding[0] - this.padding[2];
                ILaya.Render.isConchApp ? (inputElement.setScale(transform.scaleX, transform.scaleY), inputElement.setSize(inputWid, inputHei), inputElement.setPos(transform.x, transform.y)) : (Input.inputContainer.style.transform = Input.inputContainer.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + ILaya.stage.canvasDegree + "deg)", inputElement.style.width = inputWid + "px", inputElement.style.height = inputHei + "px", Input.inputContainer.style.left = transform.x + "px", Input.inputContainer.style.top = transform.y + "px")
            }

            select() {
                this.nativeInput.select()
            }

            get focus() {
                return this._focus
            }

            set focus(value) {
                var input = this.nativeInput;
                this._focus !== value && (value ? (input.target ? input.target._focusOut() : this._setInputMethod(), input.target = this, this._focusIn()) : (input.target = null, this._focusOut(), ILaya.Browser.document.body.scrollTop = 0, input.blur(), ILaya.Render.isConchApp ? input.setPos(-1e4, -1e4) : Input.inputContainer.contains(input) && Input.inputContainer.removeChild(input)))
            }

            _setInputMethod() {
                Input.input.parentElement && Input.inputContainer.removeChild(Input.input), Input.area.parentElement && Input.inputContainer.removeChild(Input.area), Input.inputElement = this._multiline ? Input.area : Input.input, Input.inputContainer.appendChild(Input.inputElement), Text.RightToLeft && (Input.inputElement.style.direction = "rtl")
            }

            _focusIn() {
                Input.isInputting = !0;
                var input = this.nativeInput;
                this._focus = !0;
                var cssStyle = input.style;
                cssStyle.whiteSpace = this.wordWrap ? "pre-wrap" : "nowrap", this._setPromptColor(), input.readOnly = !this._editable, ILaya.Render.isConchApp && (input.setType(this._type), input.setForbidEdit(!this._editable)), input.maxLength = this._maxChars;
                this.padding;
                if (input.value = this._content, input.placeholder = this._prompt, ILaya.stage.off(Event.KEY_DOWN, this, this._onKeyDown), ILaya.stage.on(Event.KEY_DOWN, this, this._onKeyDown), ILaya.stage.focus = this, this.event(Event.FOCUS), ILaya.Browser.onPC && input.focus(), !(ILaya.Browser.onMiniGame || ILaya.Browser.onBDMiniGame || ILaya.Browser.onQGMiniGame || ILaya.Browser.onKGMiniGame || ILaya.Browser.onVVMiniGame || ILaya.Browser.onAlipayMiniGame || ILaya.Browser.onQQMiniGame)) {
                    this._text;
                    this._text = null
                }
                this.typeset(), input.setColor(this._originColor), input.setFontSize(this.fontSize), input.setFontFace(ILaya.Browser.onIPhone && Text.fontFamilyMap[this.font] || this.font), ILaya.Render.isConchApp && input.setMultiAble && input.setMultiAble(this._multiline), cssStyle.lineHeight = this.leading + this.fontSize + "px", cssStyle.fontStyle = this.italic ? "italic" : "normal", cssStyle.fontWeight = this.bold ? "bold" : "normal", cssStyle.textAlign = this.align, cssStyle.padding = "0 0", this._syncInputTransform(), !ILaya.Render.isConchApp && ILaya.Browser.onPC && ILaya.systemTimer.frameLoop(1, this, this._syncInputTransform)
            }

            _setPromptColor() {
                Input.promptStyleDOM = ILaya.Browser.getElementById("promptStyle"), Input.promptStyleDOM || (Input.promptStyleDOM = ILaya.Browser.createElement("style"), Input.promptStyleDOM.setAttribute("id", "promptStyle"), ILaya.Browser.document.head.appendChild(Input.promptStyleDOM)), Input.promptStyleDOM.innerText = "input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {color:" + this._promptColor + "}input:-moz-placeholder, textarea:-moz-placeholder {color:" + this._promptColor + "}input::-moz-placeholder, textarea::-moz-placeholder {color:" + this._promptColor + "}input:-ms-input-placeholder, textarea:-ms-input-placeholder {color:" + this._promptColor + "}"
            }

            _focusOut() {
                Input.isInputting = !1, this._focus = !1, this._text = null, this._content = this.nativeInput.value, this._content ? (super.set_text(this._content), super.set_color(this._originColor)) : (super.set_text(this._prompt), super.set_color(this._promptColor)), ILaya.stage.off(Event.KEY_DOWN, this, this._onKeyDown), ILaya.stage.focus = null, this.event(Event.BLUR), this.event(Event.CHANGE), ILaya.Render.isConchApp && this.nativeInput.blur(), ILaya.Browser.onPC && ILaya.systemTimer.clear(this, this._syncInputTransform)
            }

            _onKeyDown(e) {
                13 === e.keyCode && (ILaya.Browser.onMobile && !this._multiline && (this.focus = !1), this.event(Event.ENTER))
            }

            set text(value) {
                super.set_color(this._originColor), value += "", this._focus ? (this.nativeInput.value = value || "", this.event(Event.CHANGE)) : (this._multiline || (value = value.replace(/\r?\n/g, "")), this._content = value, value ? super.set_text(value) : (super.set_text(this._prompt), super.set_color(this.promptColor)))
            }

            get text() {
                return this._focus ? this.nativeInput.value : this._content || ""
            }

            changeText(text) {
                this._content = text, this._focus ? (this.nativeInput.value = text || "", this.event(Event.CHANGE)) : super.changeText(text)
            }

            set color(value) {
                this._focus && this.nativeInput.setColor(value), super.set_color(this._content ? value : this._promptColor), this._originColor = value
            }

            get color() {
                return super.color
            }

            set bgColor(value) {
                super.set_bgColor(value), ILaya.Render.isConchApp && this.nativeInput.setBgColor(value)
            }

            get bgColor() {
                return super.bgColor
            }

            get restrict() {
                return this._restrictPattern ? this._restrictPattern.source : ""
            }

            set restrict(pattern) {
                pattern ? ((pattern = "[^" + pattern + "]").indexOf("^^") > -1 && (pattern = pattern.replace("^^", "")), this._restrictPattern = new RegExp(pattern, "g")) : this._restrictPattern = null
            }

            set editable(value) {
                this._editable = value, ILaya.Render.isConchApp && Input.input.setForbidEdit(!value)
            }

            get editable() {
                return this._editable
            }

            get maxChars() {
                return this._maxChars
            }

            set maxChars(value) {
                value <= 0 && (value = 1e5), this._maxChars = value
            }

            get prompt() {
                return this._prompt
            }

            set prompt(value) {
                !this._text && value && super.set_color(this._promptColor), this.promptColor = this._promptColor, this._text ? super.set_text(this._text == this._prompt ? value : this._text) : super.set_text(value), this._prompt = Text.langPacks && Text.langPacks[value] ? Text.langPacks[value] : value
            }

            get promptColor() {
                return this._promptColor
            }

            set promptColor(value) {
                this._promptColor = value, this._content || super.set_color(value)
            }

            get type() {
                return this._type
            }

            set type(value) {
                this._getTextStyle().asPassword = "password" === value, this._type = value
            }
        }

        Input.TYPE_TEXT = "text", Input.TYPE_PASSWORD = "password", Input.TYPE_EMAIL = "email", Input.TYPE_URL = "url", Input.TYPE_NUMBER = "number", Input.TYPE_RANGE = "range", Input.TYPE_DATE = "date", Input.TYPE_MONTH = "month", Input.TYPE_WEEK = "week", Input.TYPE_TIME = "time", Input.TYPE_DATE_TIME = "datetime", Input.TYPE_DATE_TIME_LOCAL = "datetime-local", Input.TYPE_SEARCH = "search", Input.IOS_IFRAME = !1, Input.inputHeight = 45, Input.isInputting = !1, ClassUtils.regClass("laya.display.Input", Input), ClassUtils.regClass("Laya.Input", Input);

        class TouchManager {
            constructor() {
                this.preOvers = [], this.preDowns = [], this.preRightDowns = [], this.enable = !0, this._event = new Event, this._lastClickTime = 0
            }

            _clearTempArrs() {
                TouchManager._oldArr.length = 0, TouchManager._newArr.length = 0, TouchManager._tEleArr.length = 0
            }

            getTouchFromArr(touchID, arr) {
                var i, len, tTouchO;
                for (len = arr.length, i = 0; i < len; i++) if ((tTouchO = arr[i]).id == touchID) return tTouchO;
                return null
            }

            removeTouchFromArr(touchID, arr) {
                var i;
                for (i = arr.length - 1; i >= 0; i--) arr[i].id == touchID && arr.splice(i, 1)
            }

            createTouchO(ele, touchID) {
                var rst;
                return (rst = Pool.getItem("TouchData") || {}).id = touchID, rst.tar = ele, rst
            }

            onMouseDown(ele, touchID, isLeft = !1) {
                var preO, tO, arrs, preDowns;
                this.enable && (preO = this.getTouchFromArr(touchID, this.preOvers), arrs = this.getEles(ele, null, TouchManager._tEleArr), preO ? preO.tar = ele : (tO = this.createTouchO(ele, touchID), this.preOvers.push(tO)), Browser.onMobile && this.sendEvents(arrs, Event.MOUSE_OVER), preDowns = isLeft ? this.preDowns : this.preRightDowns, (preO = this.getTouchFromArr(touchID, preDowns)) ? preO.tar = ele : (tO = this.createTouchO(ele, touchID), preDowns.push(tO)), this.sendEvents(arrs, isLeft ? Event.MOUSE_DOWN : Event.RIGHT_MOUSE_DOWN), this._clearTempArrs())
            }

            sendEvents(eles, type) {
                var i, len, _target;
                for (len = eles.length, this._event._stoped = !1, _target = eles[0], i = 0; i < len; i++) {
                    var tE = eles[i];
                    if (tE.destroyed) return;
                    if (tE.event(type, this._event.setTo(type, tE, _target)), this._event._stoped) break
                }
            }

            getEles(start, end = null, rst = null) {
                for (rst ? rst.length = 0 : rst = []; start && start != end;) rst.push(start), start = start.parent;
                return rst
            }

            checkMouseOutAndOverOfMove(eleNew, elePre, touchID = 0) {
                var tar, arrs, i, len;
                if (elePre != eleNew) if (elePre.contains(eleNew)) arrs = this.getEles(eleNew, elePre, TouchManager._tEleArr), this.sendEvents(arrs, Event.MOUSE_OVER); else if (eleNew.contains(elePre)) arrs = this.getEles(elePre, eleNew, TouchManager._tEleArr), this.sendEvents(arrs, Event.MOUSE_OUT); else {
                    var oldArr, newArr, tIndex;
                    for ((arrs = TouchManager._tEleArr).length = 0, oldArr = this.getEles(elePre, null, TouchManager._oldArr), newArr = this.getEles(eleNew, null, TouchManager._newArr), len = oldArr.length, i = 0; i < len; i++) {
                        if (tar = oldArr[i], (tIndex = newArr.indexOf(tar)) >= 0) {
                            newArr.splice(tIndex, newArr.length - tIndex);
                            break
                        }
                        arrs.push(tar)
                    }
                    arrs.length > 0 && this.sendEvents(arrs, Event.MOUSE_OUT), newArr.length > 0 && this.sendEvents(newArr, Event.MOUSE_OVER)
                }
            }

            onMouseMove(ele, touchID) {
                var preO, arrs;
                this.enable && ((preO = this.getTouchFromArr(touchID, this.preOvers)) ? (this.checkMouseOutAndOverOfMove(ele, preO.tar), preO.tar = ele, arrs = this.getEles(ele, null, TouchManager._tEleArr)) : (arrs = this.getEles(ele, null, TouchManager._tEleArr), this.sendEvents(arrs, Event.MOUSE_OVER), this.preOvers.push(this.createTouchO(ele, touchID))), this.sendEvents(arrs, Event.MOUSE_MOVE), this._clearTempArrs())
            }

            getLastOvers() {
                return TouchManager._tEleArr.length = 0, this.preOvers.length > 0 && this.preOvers[0].tar ? this.getEles(this.preOvers[0].tar, null, TouchManager._tEleArr) : (TouchManager._tEleArr.push(ILaya.stage), TouchManager._tEleArr)
            }

            stageMouseOut() {
                var lastOvers;
                lastOvers = this.getLastOvers(), this.preOvers.length = 0, this.sendEvents(lastOvers, Event.MOUSE_OUT)
            }

            onMouseUp(ele, touchID, isLeft = !1) {
                if (this.enable) {
                    var preO, arrs, oldArr, i, len, tar, sendArr, preDowns, onMobile = Browser.onMobile;
                    if (arrs = this.getEles(ele, null, TouchManager._tEleArr), this.sendEvents(arrs, isLeft ? Event.MOUSE_UP : Event.RIGHT_MOUSE_UP), preDowns = isLeft ? this.preDowns : this.preRightDowns, preO = this.getTouchFromArr(touchID, preDowns)) {
                        var isDouble, now = Browser.now();
                        if (isDouble = now - this._lastClickTime < 300, this._lastClickTime = now, ele == preO.tar) sendArr = arrs; else for (oldArr = this.getEles(preO.tar, null, TouchManager._oldArr), (sendArr = TouchManager._newArr).length = 0, len = oldArr.length, i = 0; i < len; i++) tar = oldArr[i], arrs.indexOf(tar) >= 0 && sendArr.push(tar);
                        sendArr.length > 0 && this.sendEvents(sendArr, isLeft ? Event.CLICK : Event.RIGHT_CLICK), isLeft && isDouble && this.sendEvents(sendArr, Event.DOUBLE_CLICK), this.removeTouchFromArr(touchID, preDowns), preO.tar = null, Pool.recover("TouchData", preO)
                    } else ;
                    (preO = this.getTouchFromArr(touchID, this.preOvers)) && onMobile && ((sendArr = this.getEles(preO.tar, null, sendArr)) && sendArr.length > 0 && this.sendEvents(sendArr, Event.MOUSE_OUT), this.removeTouchFromArr(touchID, this.preOvers), preO.tar = null, Pool.recover("TouchData", preO)), this._clearTempArrs()
                }
            }
        }

        TouchManager.I = new TouchManager, TouchManager._oldArr = [], TouchManager._newArr = [], TouchManager._tEleArr = [];

        class MouseManager {
            constructor() {
                this.mouseX = 0, this.mouseY = 0, this.disableMouseEvent = !1, this.mouseDownTime = 0, this.mouseMoveAccuracy = 2, this._event = new Event, this._captureSp = null, this._captureChain = [], this._captureExlusiveMode = !1, this._hitCaputreSp = !1, this._point = new Point, this._rect = new Rectangle, this._lastMoveTimer = 0, this._prePoint = new Point, this._touchIDs = {}, this._curTouchID = NaN, this._id = 1
            }

            __init__(stage, canvas) {
                this._stage = stage;
                var _this = this;
                canvas.oncontextmenu = function (e) {
                    if (MouseManager.enabled) return !1
                }, canvas.addEventListener("mousedown", function (e) {
                    MouseManager.enabled && (Browser.onIE || e.preventDefault(), _this.mouseDownTime = Browser.now(), _this.runEvent(e))
                }), canvas.addEventListener("mouseup", function (e) {
                    MouseManager.enabled && (e.preventDefault(), _this.mouseDownTime = -Browser.now(), _this.runEvent(e))
                }, !0), canvas.addEventListener("mousemove", function (e) {
                    if (MouseManager.enabled) {
                        e.preventDefault();
                        var now = Browser.now();
                        if (now - _this._lastMoveTimer < 10) return;
                        _this._lastMoveTimer = now, _this.runEvent(e)
                    }
                }, !0), canvas.addEventListener("mouseout", function (e) {
                    MouseManager.enabled && _this.runEvent(e)
                }), canvas.addEventListener("mouseover", function (e) {
                    MouseManager.enabled && _this.runEvent(e)
                }), canvas.addEventListener("touchstart", function (e) {
                    MouseManager.enabled && (MouseManager._isFirstTouch || Input.isInputting || e.preventDefault(), _this.mouseDownTime = Browser.now(), _this.runEvent(e))
                }), canvas.addEventListener("touchend", function (e) {
                    MouseManager.enabled ? (MouseManager._isFirstTouch || Input.isInputting || e.preventDefault(), MouseManager._isFirstTouch = !1, _this.mouseDownTime = -Browser.now(), _this.runEvent(e)) : _this._curTouchID = NaN
                }, !0), canvas.addEventListener("touchmove", function (e) {
                    MouseManager.enabled && (e.preventDefault(), _this.runEvent(e))
                }, !0), canvas.addEventListener("touchcancel", function (e) {
                    MouseManager.enabled ? (e.preventDefault(), _this.runEvent(e)) : _this._curTouchID = NaN
                }, !0), canvas.addEventListener("mousewheel", function (e) {
                    MouseManager.enabled && _this.runEvent(e)
                }), canvas.addEventListener("DOMMouseScroll", function (e) {
                    MouseManager.enabled && _this.runEvent(e)
                })
            }

            initEvent(e, nativeEvent = null) {
                var evt;
                this._event._stoped = !1, this._event.nativeEvent = nativeEvent || e, this._target = null, this._point.setTo(e.pageX || e.clientX, e.pageY || e.clientY), this._stage._canvasTransform && (this._stage._canvasTransform.invertTransformPoint(this._point), this.mouseX = this._point.x, this.mouseY = this._point.y), this._event.touchId = e.identifier || 0, this._tTouchID = this._event.touchId, (evt = TouchManager.I._event)._stoped = !1, evt.nativeEvent = this._event.nativeEvent, evt.touchId = this._event.touchId
            }

            checkMouseWheel(e) {
                this._event.delta = e.wheelDelta ? .025 * e.wheelDelta : -e.detail;
                for (var _lastOvers = TouchManager.I.getLastOvers(), i = 0, n = _lastOvers.length; i < n; i++) {
                    var ele = _lastOvers[i];
                    ele.event(Event.MOUSE_WHEEL, this._event.setTo(Event.MOUSE_WHEEL, ele, this._target))
                }
            }

            onMouseMove(ele) {
                TouchManager.I.onMouseMove(ele, this._tTouchID)
            }

            onMouseDown(ele) {
                if (Input.isInputting && ILaya.stage.focus && ILaya.stage.focus.focus && !ILaya.stage.focus.contains(this._target)) {
                    var pre_input = ILaya.stage.focus._tf || ILaya.stage.focus, new_input = ele._tf || ele;
                    new_input instanceof Input && new_input.multiline == pre_input.multiline ? pre_input._focusOut() : pre_input.focus = !1
                }
                TouchManager.I.onMouseDown(ele, this._tTouchID, this._isLeftMouse)
            }

            onMouseUp(ele) {
                TouchManager.I.onMouseUp(ele, this._tTouchID, this._isLeftMouse)
            }

            check(sp, mouseX, mouseY, callBack) {
                this._point.setTo(mouseX, mouseY), sp.fromParentPoint(this._point), mouseX = this._point.x, mouseY = this._point.y;
                var scrollRect = sp._style.scrollRect;
                if (scrollRect && (this._rect.setTo(scrollRect.x, scrollRect.y, scrollRect.width, scrollRect.height), !this._rect.contains(mouseX, mouseY))) return !1;
                if (!this.disableMouseEvent) {
                    if (sp.hitTestPrior && !sp.mouseThrough && !this.hitTest(sp, mouseX, mouseY)) return !1;
                    for (var i = sp._children.length - 1; i > -1; i--) {
                        var child = sp._children[i];
                        if (!child.destroyed && child._mouseState > 1 && child._visible && this.check(child, mouseX, mouseY, callBack)) return !0
                    }
                    for (i = sp._extUIChild.length - 1; i >= 0; i--) {
                        var c = sp._extUIChild[i];
                        if (!c.destroyed && c._mouseState > 1 && c._visible && this.check(c, mouseX, mouseY, callBack)) return !0
                    }
                }
                var isHit = !(!sp.hitTestPrior || sp.mouseThrough || this.disableMouseEvent) || this.hitTest(sp, mouseX, mouseY);
                return isHit ? (this._target = sp, callBack.call(this, sp), this._target == this._hitCaputreSp && (this._hitCaputreSp = !0)) : callBack === this.onMouseUp && sp === this._stage && (this._target = this._stage, callBack.call(this, this._target)), isHit
            }

            hitTest(sp, mouseX, mouseY) {
                var isHit = !1;
                sp.scrollRect && (mouseX -= sp._style.scrollRect.x, mouseY -= sp._style.scrollRect.y);
                var hitArea = sp._style.hitArea;
                return hitArea && hitArea._hit ? hitArea.contains(mouseX, mouseY) : ((sp.width > 0 && sp.height > 0 || sp.mouseThrough || hitArea) && (isHit = sp.mouseThrough ? sp.getGraphicBounds().contains(mouseX, mouseY) : (hitArea || this._rect.setTo(0, 0, sp.width, sp.height)).contains(mouseX, mouseY)), isHit)
            }

            _checkAllBaseUI(mousex, mousey, callback) {
                var ret = this.handleExclusiveCapture(this.mouseX, this.mouseY, callback);
                return !!ret || (ret = this.check(this._stage, this.mouseX, this.mouseY, callback), this.handleCapture(this.mouseX, this.mouseY, callback) || ret)
            }

            check3DUI(mousex, mousey, callback) {
                for (var uis = this._stage._3dUI, i = 0, ret = !1; i < uis.length; i++) {
                    var curui = uis[i];
                    this._stage._curUIBase = curui, !curui.destroyed && curui._mouseState > 1 && curui._visible && (ret = ret || this.check(curui, this.mouseX, this.mouseY, callback))
                }
                return this._stage._curUIBase = this._stage, ret
            }

            handleExclusiveCapture(mousex, mousey, callback) {
                if (this._captureExlusiveMode && this._captureSp && this._captureChain.length > 0) {
                    var cursp;
                    this._point.setTo(mousex, mousey);
                    for (var i = 0; i < this._captureChain.length; i++) (cursp = this._captureChain[i]).fromParentPoint(this._point);
                    return this._target = cursp, callback.call(this, cursp), !0
                }
                return !1
            }

            handleCapture(mousex, mousey, callback) {
                if (!this._hitCaputreSp && this._captureSp && this._captureChain.length > 0) {
                    var cursp;
                    this._point.setTo(mousex, mousey);
                    for (var i = 0; i < this._captureChain.length; i++) (cursp = this._captureChain[i]).fromParentPoint(this._point);
                    return this._target = cursp, callback.call(this, cursp), !0
                }
                return !1
            }

            runEvent(evt) {
                var i, n, touch;
                switch ("mousemove" !== evt.type && (this._prePoint.x = this._prePoint.y = -1e6), evt.type) {
                    case"mousedown":
                        this._touchIDs[0] = this._id++, MouseManager._isTouchRespond ? MouseManager._isTouchRespond = !1 : (this._isLeftMouse = 0 === evt.button, this.initEvent(evt), this._checkAllBaseUI(this.mouseX, this.mouseY, this.onMouseDown));
                        break;
                    case"mouseup":
                        this._isLeftMouse = 0 === evt.button, this.initEvent(evt), this._checkAllBaseUI(this.mouseX, this.mouseY, this.onMouseUp);
                        break;
                    case"mousemove":
                        Math.abs(this._prePoint.x - evt.clientX) + Math.abs(this._prePoint.y - evt.clientY) >= this.mouseMoveAccuracy && (this._prePoint.x = evt.clientX, this._prePoint.y = evt.clientY, this.initEvent(evt), this._checkAllBaseUI(this.mouseX, this.mouseY, this.onMouseMove));
                        break;
                    case"touchstart":
                        MouseManager._isTouchRespond = !0, this._isLeftMouse = !0;
                        var touches = evt.changedTouches;
                        for (i = 0, n = touches.length; i < n; i++) touch = touches[i], (MouseManager.multiTouchEnabled || isNaN(this._curTouchID)) && (this._curTouchID = touch.identifier, this._id % 200 == 0 && (this._touchIDs = {}), this._touchIDs[touch.identifier] = this._id++, this.initEvent(touch, evt), this._checkAllBaseUI(this.mouseX, this.mouseY, this.onMouseDown));
                        break;
                    case"touchend":
                    case"touchcancel":
                        MouseManager._isTouchRespond = !0, this._isLeftMouse = !0;
                        var touchends = evt.changedTouches;
                        for (i = 0, n = touchends.length; i < n; i++) {
                            if (touch = touchends[i], MouseManager.multiTouchEnabled || touch.identifier == this._curTouchID) this._curTouchID = NaN, this.initEvent(touch, evt), this._checkAllBaseUI(this.mouseX, this.mouseY, this.onMouseUp) || this.onMouseUp(null)
                        }
                        break;
                    case"touchmove":
                        var touchemoves = evt.changedTouches;
                        for (i = 0, n = touchemoves.length; i < n; i++) touch = touchemoves[i], (MouseManager.multiTouchEnabled || touch.identifier == this._curTouchID) && (this.initEvent(touch, evt), this._checkAllBaseUI(this.mouseX, this.mouseY, this.onMouseMove));
                        break;
                    case"wheel":
                    case"mousewheel":
                    case"DOMMouseScroll":
                        this.checkMouseWheel(evt);
                        break;
                    case"mouseout":
                        TouchManager.I.stageMouseOut();
                        break;
                    case"mouseover":
                        this._stage.event(Event.MOUSE_OVER, this._event.setTo(Event.MOUSE_OVER, this._stage, this._stage))
                }
            }

            setCapture(sp, exclusive = !1) {
                this._captureSp = sp, this._captureExlusiveMode = exclusive, this._captureChain.length = 0, this._captureChain.push(sp);
                for (var cursp = sp; cursp != ILaya.stage && cursp != ILaya.stage._curUIBase && (cursp = cursp.parent);) this._captureChain.splice(0, 0, cursp)
            }

            releaseCapture() {
                console.log("release capture"), this._captureSp = null
            }
        }

        MouseManager.instance = new MouseManager, MouseManager.enabled = !0, MouseManager.multiTouchEnabled = !0, MouseManager._isFirstTouch = !0;

        class CallLater {
            constructor() {
                this._pool = [], this._map = [], this._laters = []
            }

            _update() {
                var laters = this._laters, len = laters.length;
                if (len > 0) {
                    for (var i = 0, n = len - 1; i <= n; i++) {
                        var handler = laters[i];
                        this._map[handler.key] = null, null !== handler.method && (handler.run(), handler.clear()), this._pool.push(handler), i === n && (n = laters.length - 1)
                    }
                    laters.length = 0
                }
            }

            _getHandler(caller, method) {
                var cid = caller ? caller.$_GID || (caller.$_GID = ILaya.Utils.getGID()) : 0,
                    mid = method.$_TID || (method.$_TID = 1e5 * ILaya.Timer._mid++);
                return this._map[cid + mid]
            }

            callLater(caller, method, args = null) {
                if (null == this._getHandler(caller, method)) {
                    if (this._pool.length) var handler = this._pool.pop(); else handler = new LaterHandler;
                    handler.caller = caller, handler.method = method, handler.args = args;
                    var cid = caller ? caller.$_GID : 0, mid = method.$_TID;
                    handler.key = cid + mid, this._map[handler.key] = handler, this._laters.push(handler)
                }
            }

            runCallLater(caller, method) {
                var handler = this._getHandler(caller, method);
                handler && null != handler.method && (this._map[handler.key] = null, handler.run(), handler.clear())
            }
        }

        CallLater.I = new CallLater;

        class LaterHandler {
            clear() {
                this.caller = null, this.method = null, this.args = null
            }

            run() {
                var caller = this.caller;
                if (caller && caller.destroyed) return this.clear();
                var method = this.method, args = this.args;
                null != method && (args ? method.apply(caller, args) : method.call(caller))
            }
        }

        class RunDriver {
        }

        RunDriver.createShaderCondition = function (conditionScript) {
            var fn = "(function() {return " + conditionScript + ";})";
            return window.Laya._runScript(fn)
        }, RunDriver.changeWebGLSize = function (w, h) {
            WebGL.onStageResize(w, h)
        };

        class Stage extends Sprite {
            constructor() {
                super(), this.offset = new Point, this._frameRate = "fast", this.designWidth = 0, this.designHeight = 0, this.canvasRotation = !1, this.canvasDegree = 0, this.renderingEnabled = !0, this.screenAdaptationEnabled = !0, this._canvasTransform = new Matrix, this._screenMode = "none", this._scaleMode = "noscale", this._alignV = "top", this._alignH = "left", this._bgColor = "black", this._mouseMoveTime = 0, this._renderCount = 0, this._safariOffsetY = 0, this._frameStartTime = 0, this._previousOrientation = Browser.window.orientation, this._wgColor = [0, 0, 0, 1], this._scene3Ds = [], this._globalRepaintSet = !1, this._globalRepaintGet = !1, this._3dUI = [], this._curUIBase = null, this.useRetinalCanvas = !1, super.set_transform(this._createTransform()), this.mouseEnabled = !0, this.hitTestPrior = !0, this.autoSize = !1, this._setBit(Const.DISPLAYED_INSTAGE, !0), this._setBit(Const.ACTIVE_INHIERARCHY, !0), this._isFocused = !0, this._isVisibility = !0, this.useRetinalCanvas = Config.useRetinalCanvas;
                var window = Browser.window, _me = this;
                window.addEventListener("focus", function () {
                    this._isFocused = !0, _me.event(Event.FOCUS), _me.event(Event.FOCUS_CHANGE)
                }), window.addEventListener("blur", function () {
                    this._isFocused = !1, _me.event(Event.BLUR), _me.event(Event.FOCUS_CHANGE), _me._isInputting() && (Input.inputElement.target.focus = !1)
                });
                var state = "visibilityState", visibilityChange = "visibilitychange", document = window.document;
                void 0 !== document.hidden ? (visibilityChange = "visibilitychange", state = "visibilityState") : void 0 !== document.mozHidden ? (visibilityChange = "mozvisibilitychange", state = "mozVisibilityState") : void 0 !== document.msHidden ? (visibilityChange = "msvisibilitychange", state = "msVisibilityState") : void 0 !== document.webkitHidden && (visibilityChange = "webkitvisibilitychange", state = "webkitVisibilityState"), window.document.addEventListener(visibilityChange, function () {
                    "hidden" == Browser.document[state] ? (this._isVisibility = !1, _me._isInputting() && (Input.inputElement.target.focus = !1)) : this._isVisibility = !0;
                    this.renderingEnabled = this._isVisibility, _me.event(Event.VISIBILITY_CHANGE)
                }), window.addEventListener("resize", function () {
                    var orientation = Browser.window.orientation;
                    null != orientation && orientation != this._previousOrientation && _me._isInputting() && (Input.inputElement.target.focus = !1), this._previousOrientation = orientation, _me._isInputting() || (Browser.onSafari && (_me._safariOffsetY = (Browser.window.__innerHeight || Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight) - Browser.window.innerHeight), _me._resetCanvas())
                }), window.addEventListener("orientationchange", function (e) {
                    _me._resetCanvas()
                }), this.on(Event.MOUSE_MOVE, this, this._onmouseMove), Browser.onMobile && this.on(Event.MOUSE_DOWN, this, this._onmouseMove)
            }

            _isInputting() {
                return Browser.onMobile && Input.isInputting
            }

            set width(value) {
                this.designWidth = value, super.set_width(value), ILaya.systemTimer.callLater(this, this._changeCanvasSize)
            }

            get width() {
                return super.get_width()
            }

            set height(value) {
                this.designHeight = value, super.set_height(value), ILaya.systemTimer.callLater(this, this._changeCanvasSize)
            }

            get height() {
                return super.get_height()
            }

            set transform(value) {
                super.set_transform(value)
            }

            get transform() {
                return this._tfChanged && this._adjustTransform(), this._transform = this._transform || this._createTransform()
            }

            get isFocused() {
                return this._isFocused
            }

            get isVisibility() {
                return this._isVisibility
            }

            _changeCanvasSize() {
                this.setScreenSize(Browser.clientWidth * Browser.pixelRatio, Browser.clientHeight * Browser.pixelRatio)
            }

            _resetCanvas() {
                this.screenAdaptationEnabled && this._changeCanvasSize()
            }

            setScreenSize(screenWidth, screenHeight) {
                var rotation = !1;
                if (this._screenMode !== Stage.SCREEN_NONE && (rotation = (screenWidth / screenHeight < 1 ? Stage.SCREEN_VERTICAL : Stage.SCREEN_HORIZONTAL) !== this._screenMode)) {
                    var temp = screenHeight;
                    screenHeight = screenWidth, screenWidth = temp
                }
                this.canvasRotation = rotation;
                var canvas = Render._mainCanvas, canvasStyle = canvas.source.style,
                    mat = this._canvasTransform.identity(), scaleMode = this._scaleMode,
                    scaleX = screenWidth / this.designWidth, scaleY = screenHeight / this.designHeight,
                    canvasWidth = this.useRetinalCanvas ? screenWidth : this.designWidth,
                    canvasHeight = this.useRetinalCanvas ? screenHeight : this.designHeight, realWidth = screenWidth,
                    realHeight = screenHeight, pixelRatio = Browser.pixelRatio;
                switch (this._width = this.designWidth, this._height = this.designHeight, scaleMode) {
                    case Stage.SCALE_NOSCALE:
                        scaleX = scaleY = 1, realWidth = this.designWidth, realHeight = this.designHeight;
                        break;
                    case Stage.SCALE_SHOWALL:
                        scaleX = scaleY = Math.min(scaleX, scaleY), canvasWidth = realWidth = Math.round(this.designWidth * scaleX), canvasHeight = realHeight = Math.round(this.designHeight * scaleY);
                        break;
                    case Stage.SCALE_NOBORDER:
                        scaleX = scaleY = Math.max(scaleX, scaleY), realWidth = Math.round(this.designWidth * scaleX), realHeight = Math.round(this.designHeight * scaleY);
                        break;
                    case Stage.SCALE_FULL:
                        scaleX = scaleY = 1, this._width = canvasWidth = screenWidth, this._height = canvasHeight = screenHeight;
                        break;
                    case Stage.SCALE_FIXED_WIDTH:
                        scaleY = scaleX, this._height = canvasHeight = Math.round(screenHeight / scaleX);
                        break;
                    case Stage.SCALE_FIXED_HEIGHT:
                        scaleX = scaleY, this._width = canvasWidth = Math.round(screenWidth / scaleY);
                        break;
                    case Stage.SCALE_FIXED_AUTO:
                        screenWidth / screenHeight < this.designWidth / this.designHeight ? (scaleY = scaleX, this._height = canvasHeight = Math.round(screenHeight / scaleX)) : (scaleX = scaleY, this._width = canvasWidth = Math.round(screenWidth / scaleY))
                }
                this.useRetinalCanvas && (canvasWidth = screenWidth, canvasHeight = screenHeight), scaleX *= this.scaleX, scaleY *= this.scaleY, 1 === scaleX && 1 === scaleY ? this.transform.identity() : (this.transform.a = this._formatData(scaleX / (realWidth / canvasWidth)), this.transform.d = this._formatData(scaleY / (realHeight / canvasHeight))), canvas.size(canvasWidth, canvasHeight), RunDriver.changeWebGLSize(canvasWidth, canvasHeight), mat.scale(realWidth / canvasWidth / pixelRatio, realHeight / canvasHeight / pixelRatio), this._alignH === Stage.ALIGN_LEFT ? this.offset.x = 0 : this._alignH === Stage.ALIGN_RIGHT ? this.offset.x = screenWidth - realWidth : this.offset.x = .5 * (screenWidth - realWidth) / pixelRatio, this._alignV === Stage.ALIGN_TOP ? this.offset.y = 0 : this._alignV === Stage.ALIGN_BOTTOM ? this.offset.y = screenHeight - realHeight : this.offset.y = .5 * (screenHeight - realHeight) / pixelRatio, this.offset.x = Math.round(this.offset.x), this.offset.y = Math.round(this.offset.y), mat.translate(this.offset.x, this.offset.y), this._safariOffsetY && mat.translate(0, this._safariOffsetY), this.canvasDegree = 0, rotation && (this._screenMode === Stage.SCREEN_HORIZONTAL ? (mat.rotate(Math.PI / 2), mat.translate(screenHeight / pixelRatio, 0), this.canvasDegree = 90) : (mat.rotate(-Math.PI / 2), mat.translate(0, screenWidth / pixelRatio), this.canvasDegree = -90)), mat.a = this._formatData(mat.a), mat.d = this._formatData(mat.d), mat.tx = this._formatData(mat.tx), mat.ty = this._formatData(mat.ty), super.set_transform(this.transform), canvasStyle.transformOrigin = canvasStyle.webkitTransformOrigin = canvasStyle.msTransformOrigin = canvasStyle.mozTransformOrigin = canvasStyle.oTransformOrigin = "0px 0px 0px", canvasStyle.transform = canvasStyle.webkitTransform = canvasStyle.msTransform = canvasStyle.mozTransform = canvasStyle.oTransform = "matrix(" + mat.toString() + ")", this._safariOffsetY && mat.translate(0, -this._safariOffsetY), mat.translate(parseInt(canvasStyle.left) || 0, parseInt(canvasStyle.top) || 0), this.visible = !0, this._repaint |= SpriteConst.REPAINT_CACHE, this.event(Event.RESIZE)
            }

            _formatData(value) {
                return Math.abs(value) < 1e-6 ? 0 : Math.abs(1 - value) < .001 ? value > 0 ? 1 : -1 : value
            }

            get scaleMode() {
                return this._scaleMode
            }

            set scaleMode(value) {
                this._scaleMode = value, ILaya.systemTimer.callLater(this, this._changeCanvasSize)
            }

            get alignH() {
                return this._alignH
            }

            set alignH(value) {
                this._alignH = value, ILaya.systemTimer.callLater(this, this._changeCanvasSize)
            }

            get alignV() {
                return this._alignV
            }

            set alignV(value) {
                this._alignV = value, ILaya.systemTimer.callLater(this, this._changeCanvasSize)
            }

            get bgColor() {
                return this._bgColor
            }

            set bgColor(value) {
                this._bgColor = value, this._wgColor = value ? ColorUtils.create(value).arrColor : null, Render.canvas.style.background = value || "none"
            }

            get mouseX() {
                return Math.round(MouseManager.instance.mouseX / this.clientScaleX)
            }

            get mouseY() {
                return Math.round(MouseManager.instance.mouseY / this.clientScaleY)
            }

            getMousePoint() {
                return Point.TEMP.setTo(this.mouseX, this.mouseY)
            }

            get clientScaleX() {
                return this._transform ? this._transform.getScaleX() : 1
            }

            get clientScaleY() {
                return this._transform ? this._transform.getScaleY() : 1
            }

            get screenMode() {
                return this._screenMode
            }

            set screenMode(value) {
                this._screenMode = value
            }

            repaint(type = SpriteConst.REPAINT_CACHE) {
                this._repaint |= type
            }

            parentRepaint(type = SpriteConst.REPAINT_CACHE) {
            }

            _loop() {
                return this._globalRepaintGet = this._globalRepaintSet, this._globalRepaintSet = !1, this.render(Render._context, 0, 0), !0
            }

            getFrameTm() {
                return this._frameStartTime
            }

            _onmouseMove(e) {
                this._mouseMoveTime = Browser.now()
            }

            getTimeFromFrameStart() {
                return Browser.now() - this._frameStartTime
            }

            set visible(value) {
                this.visible !== value && (super.set_visible(value), Render._mainCanvas.source.style.visibility = value ? "visible" : "hidden")
            }

            get visible() {
                return super.visible
            }

            render(context, x, y) {
                if (window.conch) this.renderToNative(context, x, y); else {
                    if (Stage._dbgSprite.graphics.clear(), this._frameRate === Stage.FRAME_SLEEP) {
                        var now = Browser.now();
                        if (!(now - this._frameStartTime >= 1e3)) return;
                        this._frameStartTime = now
                    } else {
                        if (!this._visible) return this._renderCount++, void (this._renderCount % 5 == 0 && (CallLater.I._update(), Stat.loopCount++, RenderInfo.loopCount = Stat.loopCount, this._updateTimers()));
                        this._frameStartTime = Browser.now(), RenderInfo.loopStTm = this._frameStartTime
                    }
                    this._renderCount++;
                    var isFastMode = (this._frameRate === Stage.FRAME_MOUSE ? this._frameStartTime - this._mouseMoveTime < 2e3 ? Stage.FRAME_FAST : Stage.FRAME_SLOW : this._frameRate) !== Stage.FRAME_SLOW,
                        isDoubleLoop = this._renderCount % 2 == 0;
                    if (Stat.renderSlow = !isFastMode, isFastMode || isDoubleLoop) {
                        if (CallLater.I._update(), Stat.loopCount++, RenderInfo.loopCount = Stat.loopCount, this.renderingEnabled) {
                            for (var i = 0, n = this._scene3Ds.length; i < n; i++) this._scene3Ds[i]._update();
                            context.clear(), super.render(context, x, y), Stat._StatRender.renderNotCanvas(context, x, y)
                        }
                        Stage._dbgSprite.render(context, 0, 0), this.renderingEnabled && (Stage.clear(this._bgColor), context.flush(), VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose()), this._updateTimers()
                    }
                }
            }

            renderToNative(context, x, y) {
                if (this._renderCount++, this._visible) {
                    if (CallLater.I._update(), Stat.loopCount++, RenderInfo.loopCount = Stat.loopCount, this.renderingEnabled) {
                        for (var i = 0, n = this._scene3Ds.length; i < n; i++) this._scene3Ds[i]._update();
                        context.clear(), super.render(context, x, y), Stat._StatRender.renderNotCanvas(context, x, y)
                    }
                    this.renderingEnabled && (Stage.clear(this._bgColor), context.flush(), VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose()), this._updateTimers()
                } else this._renderCount % 5 == 0 && (CallLater.I._update(), Stat.loopCount++, RenderInfo.loopCount = Stat.loopCount, this._updateTimers())
            }

            _updateTimers() {
                ILaya.systemTimer._update(), ILaya.startTimer._update(), ILaya.physicsTimer._update(), ILaya.updateTimer._update(), ILaya.lateTimer._update(), ILaya.timer._update()
            }

            set fullScreenEnabled(value) {
                var document = Browser.document, canvas = Render.canvas;
                value ? (canvas.addEventListener("mousedown", this._requestFullscreen), canvas.addEventListener("touchstart", this._requestFullscreen), document.addEventListener("fullscreenchange", this._fullScreenChanged), document.addEventListener("mozfullscreenchange", this._fullScreenChanged), document.addEventListener("webkitfullscreenchange", this._fullScreenChanged), document.addEventListener("msfullscreenchange", this._fullScreenChanged)) : (canvas.removeEventListener("mousedown", this._requestFullscreen), canvas.removeEventListener("touchstart", this._requestFullscreen), document.removeEventListener("fullscreenchange", this._fullScreenChanged), document.removeEventListener("mozfullscreenchange", this._fullScreenChanged), document.removeEventListener("webkitfullscreenchange", this._fullScreenChanged), document.removeEventListener("msfullscreenchange", this._fullScreenChanged))
            }

            get frameRate() {
                return ILaya.Render.isConchApp ? this._frameRateNative : this._frameRate
            }

            set frameRate(value) {
                if (ILaya.Render.isConchApp) {
                    var c = window.conch;
                    switch (value) {
                        case Stage.FRAME_FAST:
                            c.config.setLimitFPS(60);
                            break;
                        case Stage.FRAME_MOUSE:
                            c.config.setMouseFrame(2e3);
                            break;
                        case Stage.FRAME_SLOW:
                            c.config.setSlowFrame(!0);
                            break;
                        case Stage.FRAME_SLEEP:
                            c.config.setLimitFPS(1)
                    }
                    this._frameRateNative = value
                } else this._frameRate = value
            }

            _requestFullscreen() {
                var element = Browser.document.documentElement;
                element.requestFullscreen ? element.requestFullscreen() : element.mozRequestFullScreen ? element.mozRequestFullScreen() : element.webkitRequestFullscreen ? element.webkitRequestFullscreen() : element.msRequestFullscreen && element.msRequestFullscreen()
            }

            _fullScreenChanged() {
                ILaya.stage.event(Event.FULL_SCREEN_CHANGE)
            }

            exitFullscreen() {
                var document = Browser.document;
                document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen()
            }

            isGlobalRepaint() {
                return this._globalRepaintGet
            }

            setGlobalRepaint() {
                this._globalRepaintSet = !0
            }

            add3DUI(uibase) {
                var uiroot = uibase.rootView;
                this._3dUI.indexOf(uiroot) >= 0 || this._3dUI.push(uiroot)
            }

            remove3DUI(uibase) {
                var uiroot = uibase.rootView, p = this._3dUI.indexOf(uiroot);
                return p >= 0 && (this._3dUI.splice(p, 1), !0)
            }
        }

        Stage.SCALE_NOSCALE = "noscale", Stage.SCALE_EXACTFIT = "exactfit", Stage.SCALE_SHOWALL = "showall", Stage.SCALE_NOBORDER = "noborder", Stage.SCALE_FULL = "full", Stage.SCALE_FIXED_WIDTH = "fixedwidth", Stage.SCALE_FIXED_HEIGHT = "fixedheight", Stage.SCALE_FIXED_AUTO = "fixedauto", Stage.ALIGN_LEFT = "left", Stage.ALIGN_RIGHT = "right", Stage.ALIGN_CENTER = "center", Stage.ALIGN_TOP = "top", Stage.ALIGN_MIDDLE = "middle", Stage.ALIGN_BOTTOM = "bottom", Stage.SCREEN_NONE = "none", Stage.SCREEN_HORIZONTAL = "horizontal", Stage.SCREEN_VERTICAL = "vertical", Stage.FRAME_FAST = "fast", Stage.FRAME_SLOW = "slow", Stage.FRAME_MOUSE = "mouse", Stage.FRAME_SLEEP = "sleep", Stage._dbgSprite = new Sprite, Stage.clear = function (value) {
            Context.set2DRenderConfig();
            var gl = LayaGL.instance;
            RenderState2D.worldScissorTest && gl.disable(gl.SCISSOR_TEST);
            var ctx = Render.context,
                c = 0 == ctx._submits._length || Config.preserveDrawingBuffer ? ColorUtils.create(value).arrColor : window.Laya.stage._wgColor;
            c ? ctx.clearBG(c[0], c[1], c[2], c[3]) : ctx.clearBG(0, 0, 0, 0), RenderState2D.clear()
        }, ClassUtils.regClass("laya.display.Stage", Stage), ClassUtils.regClass("Laya.Stage", Stage);

        class KeyBoardManager {
            static __init__() {
                KeyBoardManager._addEvent("keydown"), KeyBoardManager._addEvent("keypress"), KeyBoardManager._addEvent("keyup")
            }

            static _addEvent(type) {
                ILaya.Browser.document.addEventListener(type, function (e) {
                    KeyBoardManager._dispatch(e, type)
                }, !0)
            }

            static _dispatch(e, type) {
                if (KeyBoardManager.enabled) {
                    KeyBoardManager._event._stoped = !1, KeyBoardManager._event.nativeEvent = e, KeyBoardManager._event.keyCode = e.keyCode || e.which || e.charCode, "keydown" === type ? KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode] = !0 : "keyup" === type && (KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode] = null);
                    for (var target = ILaya.stage.focus && null != ILaya.stage.focus.event && ILaya.stage.focus.displayedInStage ? ILaya.stage.focus : ILaya.stage, ct = target; ct;) ct.event(type, KeyBoardManager._event.setTo(type, ct, target)), ct = ct.parent
                }
            }

            static hasKeyDown(key) {
                return KeyBoardManager._pressKeys[key]
            }
        }

        KeyBoardManager._pressKeys = {}, KeyBoardManager.enabled = !0, KeyBoardManager._event = new Event;

        class LayaGLRunner {
            static uploadShaderUniforms(layaGL, commandEncoder, shaderData, uploadUnTexture) {
                for (var data = shaderData._data, shaderUniform = commandEncoder.getArrayData(), shaderCall = 0, i = 0, n = shaderUniform.length; i < n; i++) {
                    var one = shaderUniform[i];
                    if (uploadUnTexture || -1 !== one.textureID) {
                        var value = data[one.dataOffset];
                        null != value && (shaderCall += one.fun.call(one.caller, one, value))
                    }
                }
                return shaderCall
            }

            static uploadCustomUniform(layaGL, custom, index, data) {
                var shaderCall = 0, one = custom[index];
                return one && null != data && (shaderCall += one.fun.call(one.caller, one, data)), shaderCall
            }

            static uploadShaderUniformsForNative(layaGL, commandEncoder, shaderData) {
                var nType = LayaGL.UPLOAD_SHADER_UNIFORM_TYPE_ID;
                shaderData._runtimeCopyValues.length > 0 && (nType = LayaGL.UPLOAD_SHADER_UNIFORM_TYPE_DATA);
                var data = shaderData._data;
                return LayaGL.instance.uploadShaderUniforms(commandEncoder, data, nType)
            }
        }

        class SoundChannel extends EventDispatcher {
            constructor() {
                super(...arguments), this.isStopped = !1
            }

            set volume(v) {
            }

            get volume() {
                return 1
            }

            get position() {
                return 0
            }

            get duration() {
                return 0
            }

            play() {
            }

            stop() {
                this.completeHandler && this.completeHandler.run()
            }

            pause() {
            }

            resume() {
            }

            __runComplete(handler) {
                handler && handler.run()
            }
        }

        class AudioSoundChannel extends SoundChannel {
            constructor(audio) {
                super(), this._audio = null, this._onEnd = this.__onEnd.bind(this), this._resumePlay = this.__resumePlay.bind(this), audio.addEventListener("ended", this._onEnd), this._audio = audio
            }

            __onEnd(evt) {
                if (1 == this.loops) return this.completeHandler && (ILaya.systemTimer.once(10, this, this.__runComplete, [this.completeHandler], !1), this.completeHandler = null), this.stop(), void this.event(Event.COMPLETE);
                this.loops > 0 && this.loops--, this.startTime = 0, this.play()
            }

            __resumePlay() {
                if (this._audio && this._audio.removeEventListener("canplay", this._resumePlay), !this.isStopped) try {
                    this._audio.currentTime = this.startTime, Browser.container.appendChild(this._audio), this._audio.play()
                } catch (e) {
                    this.event(Event.ERROR)
                }
            }

            play() {
                this.isStopped = !1;
                try {
                    this._audio.playbackRate = ILaya.SoundManager.playbackRate, this._audio.currentTime = this.startTime
                } catch (e) {
                    return void this._audio.addEventListener("canplay", this._resumePlay)
                }
                ILaya.SoundManager.addChannel(this), Browser.container.appendChild(this._audio), "play" in this._audio && this._audio.play()
            }

            get position() {
                return this._audio ? this._audio.currentTime : 0
            }

            get duration() {
                return this._audio ? this._audio.duration : 0
            }

            stop() {
                super.stop(), this.isStopped = !0, ILaya.SoundManager.removeChannel(this), this.completeHandler = null, this._audio && ("pause" in this._audio && ILaya.Render.isConchApp && this._audio.stop(), this._audio.pause(), this._audio.removeEventListener("ended", this._onEnd), this._audio.removeEventListener("canplay", this._resumePlay), ILaya.Browser.onIE || this._audio != ILaya.AudioSound._musicAudio && ILaya.Pool.recover("audio:" + this.url, this._audio), Browser.removeElement(this._audio), this._audio = null, ILaya.SoundManager.autoReleaseSound && ILaya.SoundManager.disposeSoundLater(this.url))
            }

            pause() {
                this.isStopped = !0, ILaya.SoundManager.removeChannel(this), "pause" in this._audio && this._audio.pause(), ILaya.SoundManager.autoReleaseSound && ILaya.SoundManager.disposeSoundLater(this.url)
            }

            resume() {
                this._audio && (this.isStopped = !1, ILaya.SoundManager.addChannel(this), "play" in this._audio && this._audio.play())
            }

            set volume(v) {
                this._audio && (this._audio.volume = v)
            }

            get volume() {
                return this._audio ? this._audio.volume : 1
            }
        }

        class AudioSound extends EventDispatcher {
            constructor() {
                super(...arguments), this.loaded = !1
            }

            dispose() {
                var ad = AudioSound._audioCache[this.url];
                Pool.clearBySign("audio:" + this.url), ad && (Render.isConchApp || (ad.src = ""), delete AudioSound._audioCache[this.url])
            }

            static _initMusicAudio() {
                AudioSound._musicAudio || (AudioSound._musicAudio || (AudioSound._musicAudio = Browser.createElement("audio")), Render.isConchApp || Browser.document.addEventListener("mousedown", AudioSound._makeMusicOK))
            }

            static _makeMusicOK() {
                Browser.document.removeEventListener("mousedown", AudioSound._makeMusicOK), AudioSound._musicAudio.src ? AudioSound._musicAudio.play() : (AudioSound._musicAudio.src = "", AudioSound._musicAudio.load())
            }

            load(url) {
                var ad;
                if (url = URL.formatURL(url), this.url = url, url == ILaya.SoundManager._bgMusic ? (AudioSound._initMusicAudio(), (ad = AudioSound._musicAudio).src != url && (AudioSound._audioCache[ad.src] = null, ad = null)) : ad = AudioSound._audioCache[url], ad && ad.readyState >= 2) this.event(Event.COMPLETE); else {
                    ad || (url == ILaya.SoundManager._bgMusic ? (AudioSound._initMusicAudio(), ad = AudioSound._musicAudio) : ad = Browser.createElement("audio"), AudioSound._audioCache[url] = ad, ad.src = url), ad.addEventListener("canplaythrough", onLoaded), ad.addEventListener("error", onErr);
                    var me = this;
                    this.audio = ad, ad.load ? ad.load() : onErr()
                }

                function onLoaded() {
                    offs(), me.loaded = !0, me.event(Event.COMPLETE)
                }

                function onErr() {
                    ad.load = null, offs(), me.event(Event.ERROR)
                }

                function offs() {
                    ad.removeEventListener("canplaythrough", onLoaded), ad.removeEventListener("error", onErr)
                }
            }

            play(startTime = 0, loops = 0) {
                if (!this.url) return null;
                var ad, tAd;
                if (!(ad = this.url == ILaya.SoundManager._bgMusic ? AudioSound._musicAudio : AudioSound._audioCache[this.url])) return null;
                tAd = Pool.getItem("audio:" + this.url), Render.isConchApp ? tAd || ((tAd = Browser.createElement("audio")).src = this.url) : this.url == ILaya.SoundManager._bgMusic ? (AudioSound._initMusicAudio(), (tAd = AudioSound._musicAudio).src = this.url) : tAd = tAd || ad.cloneNode(!0);
                var channel = new AudioSoundChannel(tAd);
                return channel.url = this.url, channel.loops = loops, channel.startTime = startTime, channel.play(), ILaya.SoundManager.addChannel(channel), channel
            }

            get duration() {
                var ad;
                return (ad = AudioSound._audioCache[this.url]) ? ad.duration : 0
            }
        }

        AudioSound._audioCache = {};

        class WebAudioSoundChannel extends SoundChannel {
            constructor() {
                super(), this.bufferSource = null, this._currentTime = 0, this._volume = 1, this._startTime = 0, this._pauseTime = 0, this.context = ILaya.WebAudioSound.ctx, this._onPlayEnd = Utils.bind(this.__onPlayEnd, this), this.context.createGain ? this.gain = this.context.createGain() : this.gain = this.context.createGainNode()
            }

            play() {
                if (ILaya.SoundManager.addChannel(this), this.isStopped = !1, this._clearBufferSource(), this.audioBuffer) {
                    if (this.startTime >= this.duration) return stop();
                    var context = this.context, gain = this.gain, bufferSource = context.createBufferSource();
                    this.bufferSource = bufferSource, bufferSource.buffer = this.audioBuffer, bufferSource.connect(gain), gain && gain.disconnect(), gain.connect(context.destination), bufferSource.onended = this._onPlayEnd, this._startTime = Browser.now(), this.gain.gain.setTargetAtTime ? this.gain.gain.setTargetAtTime(this._volume, this.context.currentTime, WebAudioSoundChannel.SetTargetDelay) : this.gain.gain.value = this._volume, 0 == this.loops && (bufferSource.loop = !0), bufferSource.playbackRate.setTargetAtTime ? bufferSource.playbackRate.setTargetAtTime(ILaya.SoundManager.playbackRate, this.context.currentTime, WebAudioSoundChannel.SetTargetDelay) : bufferSource.playbackRate.value = ILaya.SoundManager.playbackRate, bufferSource.start(0, this.startTime), this._currentTime = 0
                }
            }

            __onPlayEnd() {
                if (1 == this.loops) return this.completeHandler && (ILaya.timer.once(10, this, this.__runComplete, [this.completeHandler], !1), this.completeHandler = null), this.stop(), void this.event(Event.COMPLETE);
                this.loops > 0 && this.loops--, this.startTime = 0, this.play()
            }

            get position() {
                return this.bufferSource ? (Browser.now() - this._startTime) / 1e3 + this.startTime : 0
            }

            get duration() {
                return this.audioBuffer ? this.audioBuffer.duration : 0
            }

            _clearBufferSource() {
                if (this.bufferSource) {
                    var sourceNode = this.bufferSource;
                    sourceNode.stop ? sourceNode.stop(0) : sourceNode.noteOff(0), sourceNode.disconnect(0), sourceNode.onended = null, WebAudioSoundChannel._tryCleanFailed || this._tryClearBuffer(sourceNode), this.bufferSource = null
                }
            }

            _tryClearBuffer(sourceNode) {
                if (Browser.onMac) try {
                    sourceNode.buffer = ILaya.WebAudioSound._miniBuffer
                } catch (e) {
                    WebAudioSoundChannel._tryCleanFailed = !0
                } else try {
                    sourceNode.buffer = null
                } catch (e) {
                    WebAudioSoundChannel._tryCleanFailed = !0
                }
            }

            stop() {
                super.stop(), this._clearBufferSource(), this.audioBuffer = null, this.gain && this.gain.disconnect(), this.isStopped = !0, ILaya.SoundManager.removeChannel(this), this.completeHandler = null, ILaya.SoundManager.autoReleaseSound && ILaya.SoundManager.disposeSoundLater(this.url)
            }

            pause() {
                this.isStopped || (this._pauseTime = this.position), this._clearBufferSource(), this.gain && this.gain.disconnect(), this.isStopped = !0, ILaya.SoundManager.removeChannel(this), ILaya.SoundManager.autoReleaseSound && ILaya.SoundManager.disposeSoundLater(this.url)
            }

            resume() {
                this.startTime = this._pauseTime, this.play()
            }

            set volume(v) {
                this._volume = v, this.isStopped || (this.gain.gain.setTargetAtTime ? this.gain.gain.setTargetAtTime(v, this.context.currentTime, WebAudioSoundChannel.SetTargetDelay) : this.gain.gain.value = v)
            }

            get volume() {
                return this._volume
            }
        }

        WebAudioSoundChannel._tryCleanFailed = !1, WebAudioSoundChannel.SetTargetDelay = .001;

        class WebAudioSound extends EventDispatcher {
            constructor() {
                super(...arguments), this.loaded = !1, this._disposed = !1
            }

            static decode() {
                WebAudioSound.buffs.length <= 0 || WebAudioSound.isDecoding || (WebAudioSound.isDecoding = !0, WebAudioSound.tInfo = WebAudioSound.buffs.shift(), WebAudioSound.ctx.decodeAudioData(WebAudioSound.tInfo.buffer, WebAudioSound._done, WebAudioSound._fail))
            }

            static _done(audioBuffer) {
                WebAudioSound.e.event("loaded:" + WebAudioSound.tInfo.url, audioBuffer), WebAudioSound.isDecoding = !1, WebAudioSound.decode()
            }

            static _fail() {
                WebAudioSound.e.event("err:" + WebAudioSound.tInfo.url, null), WebAudioSound.isDecoding = !1, WebAudioSound.decode()
            }

            static _playEmptySound() {
                if (null != WebAudioSound.ctx) {
                    var source = WebAudioSound.ctx.createBufferSource();
                    source.buffer = WebAudioSound._miniBuffer, source.connect(WebAudioSound.ctx.destination), source.start(0, 0, 0)
                }
            }

            static _unlock() {
                WebAudioSound._unlocked || (WebAudioSound._playEmptySound(), "running" == WebAudioSound.ctx.state && (window.document.removeEventListener("mousedown", WebAudioSound._unlock, !0), window.document.removeEventListener("touchend", WebAudioSound._unlock, !0), window.document.removeEventListener("touchstart", WebAudioSound._unlock, !0), WebAudioSound._unlocked = !0))
            }

            static initWebAudio() {
                "running" != WebAudioSound.ctx.state && (WebAudioSound._unlock(), window.document.addEventListener("mousedown", WebAudioSound._unlock, !0), window.document.addEventListener("touchend", WebAudioSound._unlock, !0), window.document.addEventListener("touchstart", WebAudioSound._unlock, !0))
            }

            load(url) {
                var me = this;
                if (url = URL.formatURL(url), this.url = url, this.audioBuffer = WebAudioSound._dataCache[url], this.audioBuffer) this._loaded(this.audioBuffer); else if (WebAudioSound.e.on("loaded:" + url, this, this._loaded), WebAudioSound.e.on("err:" + url, this, this._err), !WebAudioSound.__loadingSound[url]) {
                    WebAudioSound.__loadingSound[url] = !0;
                    var request = new XMLHttpRequest;
                    request.open("GET", url, !0), request.responseType = "arraybuffer", request.onload = function () {
                        me._disposed ? me._removeLoadEvents() : (me.data = request.response, WebAudioSound.buffs.push({
                            buffer: me.data,
                            url: me.url
                        }), WebAudioSound.decode())
                    }, request.onerror = function (e) {
                        me._err()
                    }, request.send()
                }
            }

            _err() {
                this._removeLoadEvents(), WebAudioSound.__loadingSound[this.url] = !1, this.event(Event.ERROR)
            }

            _loaded(audioBuffer) {
                this._removeLoadEvents(), this._disposed || (this.audioBuffer = audioBuffer, WebAudioSound._dataCache[this.url] = this.audioBuffer, this.loaded = !0, this.event(Event.COMPLETE))
            }

            _removeLoadEvents() {
                WebAudioSound.e.off("loaded:" + this.url, this, this._loaded), WebAudioSound.e.off("err:" + this.url, this, this._err)
            }

            __playAfterLoaded() {
                if (this.__toPlays) {
                    var i, len, toPlays, tParams;
                    for (len = (toPlays = this.__toPlays).length, i = 0; i < len; i++) (tParams = toPlays[i])[2] && !tParams[2].isStopped && this.play(tParams[0], tParams[1], tParams[2]);
                    this.__toPlays.length = 0
                }
            }

            play(startTime = 0, loops = 0, channel = null) {
                return channel = channel || new WebAudioSoundChannel, this.audioBuffer || this.url && (this.__toPlays || (this.__toPlays = []), this.__toPlays.push([startTime, loops, channel]), this.once(Event.COMPLETE, this, this.__playAfterLoaded), this.load(this.url)), channel.url = this.url, channel.loops = loops, channel.audioBuffer = this.audioBuffer, channel.startTime = startTime, channel.play(), ILaya.SoundManager.addChannel(channel), channel
            }

            get duration() {
                return this.audioBuffer ? this.audioBuffer.duration : 0
            }

            dispose() {
                this._disposed = !0, delete WebAudioSound._dataCache[this.url], delete WebAudioSound.__loadingSound[this.url], this.audioBuffer = null, this.data = null, this.__toPlays = []
            }
        }

        WebAudioSound._dataCache = {}, WebAudioSound.webAudioEnabled = window.AudioContext || window.webkitAudioContext || window.mozAudioContext, WebAudioSound.ctx = WebAudioSound.webAudioEnabled ? new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext) : void 0, WebAudioSound.buffs = [], WebAudioSound.isDecoding = !1, WebAudioSound._miniBuffer = WebAudioSound.ctx ? WebAudioSound.ctx.createBuffer(1, 1, 22050) : void 0, WebAudioSound.e = new EventDispatcher, WebAudioSound._unlocked = !1, WebAudioSound.__loadingSound = {};

        class SoundManager {
            static __init__() {
                var win = ILaya.Browser.window,
                    supportWebAudio = !!(win.AudioContext || win.webkitAudioContext || win.mozAudioContext);
                return supportWebAudio && WebAudioSound.initWebAudio(), SoundManager._soundClass = supportWebAudio ? WebAudioSound : AudioSound, AudioSound._initMusicAudio(), SoundManager._musicClass = AudioSound, supportWebAudio
            }

            static addChannel(channel) {
                SoundManager._channels.indexOf(channel) >= 0 || SoundManager._channels.push(channel)
            }

            static removeChannel(channel) {
                var i;
                for (i = SoundManager._channels.length - 1; i >= 0; i--) SoundManager._channels[i] == channel && SoundManager._channels.splice(i, 1)
            }

            static disposeSoundLater(url) {
                SoundManager._lastSoundUsedTimeDic[url] = ILaya.Browser.now(), SoundManager._isCheckingDispose || (SoundManager._isCheckingDispose = !0, ILaya.timer.loop(5e3, null, SoundManager._checkDisposeSound))
            }

            static _checkDisposeSound() {
                var key, tTime = ILaya.Browser.now(), hasCheck = !1;
                for (key in SoundManager._lastSoundUsedTimeDic) tTime - SoundManager._lastSoundUsedTimeDic[key] > 3e4 ? (delete SoundManager._lastSoundUsedTimeDic[key], SoundManager.disposeSoundIfNotUsed(key)) : hasCheck = !0;
                hasCheck || (SoundManager._isCheckingDispose = !1, ILaya.timer.clear(null, SoundManager._checkDisposeSound))
            }

            static disposeSoundIfNotUsed(url) {
                var i;
                for (i = SoundManager._channels.length - 1; i >= 0; i--) if (SoundManager._channels[i].url == url) return;
                SoundManager.destroySound(url)
            }

            static set autoStopMusic(v) {
                ILaya.stage.off(Event.BLUR, null, SoundManager._stageOnBlur), ILaya.stage.off(Event.FOCUS, null, SoundManager._stageOnFocus), ILaya.stage.off(Event.VISIBILITY_CHANGE, null, SoundManager._visibilityChange), SoundManager._autoStopMusic = v, v && (ILaya.stage.on(Event.BLUR, null, SoundManager._stageOnBlur), ILaya.stage.on(Event.FOCUS, null, SoundManager._stageOnFocus), ILaya.stage.on(Event.VISIBILITY_CHANGE, null, SoundManager._visibilityChange))
            }

            static get autoStopMusic() {
                return SoundManager._autoStopMusic
            }

            static _visibilityChange() {
                ILaya.stage.isVisibility ? SoundManager._stageOnFocus() : SoundManager._stageOnBlur()
            }

            static _stageOnBlur() {
                SoundManager._isActive = !1, SoundManager._musicChannel && (SoundManager._musicChannel.isStopped || (SoundManager._blurPaused = !0, SoundManager._musicChannel.pause())), SoundManager.stopAllSound(), ILaya.stage.once(Event.MOUSE_DOWN, null, SoundManager._stageOnFocus)
            }

            static _recoverWebAudio() {
                WebAudioSound.ctx && "running" != WebAudioSound.ctx.state && WebAudioSound.ctx.resume && WebAudioSound.ctx.resume()
            }

            static _stageOnFocus() {
                SoundManager._isActive = !0, SoundManager._recoverWebAudio(), ILaya.stage.off(Event.MOUSE_DOWN, null, SoundManager._stageOnFocus), SoundManager._blurPaused && SoundManager._musicChannel && SoundManager._musicChannel.isStopped && (SoundManager._blurPaused = !1, SoundManager._musicChannel.resume())
            }

            static set muted(value) {
                value != SoundManager._muted && (value && SoundManager.stopAllSound(), SoundManager.musicMuted = value, SoundManager._muted = value)
            }

            static get muted() {
                return SoundManager._muted
            }

            static set soundMuted(value) {
                SoundManager._soundMuted = value
            }

            static get soundMuted() {
                return SoundManager._soundMuted
            }

            static set musicMuted(value) {
                value != SoundManager._musicMuted && (value ? (SoundManager._bgMusic && SoundManager._musicChannel && !SoundManager._musicChannel.isStopped ? ILaya.Render.isConchApp ? SoundManager._musicChannel._audio && (SoundManager._musicChannel._audio.muted = !0) : SoundManager._musicChannel.pause() : SoundManager._musicChannel = null, SoundManager._musicMuted = value) : (SoundManager._musicMuted = value, SoundManager._bgMusic && SoundManager._musicChannel && (ILaya.Render.isConchApp ? SoundManager._musicChannel._audio && (SoundManager._musicChannel._audio.muted = !1) : SoundManager._musicChannel.resume())))
            }

            static get musicMuted() {
                return SoundManager._musicMuted
            }

            static get useAudioMusic() {
                return SoundManager._useAudioMusic
            }

            static set useAudioMusic(value) {
                SoundManager._useAudioMusic = value, SoundManager._musicClass = value ? AudioSound : null
            }

            static playSound(url, loops = 1, complete = null, soundClass = null, startTime = 0) {
                if (!SoundManager._isActive || !url) return null;
                if (SoundManager._muted) return null;
                if (SoundManager._recoverWebAudio(), (url = URL.formatURL(url)) == SoundManager._bgMusic) {
                    if (SoundManager._musicMuted) return null
                } else {
                    if (ILaya.Render.isConchApp) {
                        var ext = Utils.getFileExtension(url);
                        if ("wav" != ext && "ogg" != ext) return alert("The sound only supports wav or ogg format,for optimal performance reason,please refer to the official website document."), null
                    }
                    if (SoundManager._soundMuted) return null
                }
                var tSound, channel;
                return ILaya.Browser.onBDMiniGame || ILaya.Browser.onMiniGame || ILaya.Browser.onKGMiniGame || ILaya.Browser.onQGMiniGame || ILaya.Browser.onVVMiniGame || ILaya.Browser.onAlipayMiniGame || ILaya.Browser.onQQMiniGame || (tSound = ILaya.loader.getRes(url)), soundClass || (soundClass = SoundManager._soundClass), tSound || ((tSound = new soundClass).load(url), ILaya.Browser.onBDMiniGame || ILaya.Browser.onMiniGame || ILaya.Browser.onKGMiniGame || ILaya.Browser.onQGMiniGame || ILaya.Browser.onVVMiniGame || ILaya.Browser.onAlipayMiniGame || ILaya.Browser.onQQMiniGame || ILaya.Loader.cacheRes(url, tSound)), (channel = tSound.play(startTime, loops)) ? (channel.url = url, channel.volume = url == SoundManager._bgMusic ? SoundManager.musicVolume : SoundManager.soundVolume, channel.completeHandler = complete, channel) : null
            }

            static destroySound(url) {
                var tSound = ILaya.loader.getRes(url);
                tSound && (ILaya.Loader.clearRes(url), tSound.dispose())
            }

            static playMusic(url, loops = 0, complete = null, startTime = 0) {
                return url = URL.formatURL(url), SoundManager._bgMusic = url, SoundManager._musicChannel && SoundManager._musicChannel.stop(), SoundManager._musicChannel = SoundManager.playSound(url, loops, complete, SoundManager._musicClass, startTime)
            }

            static stopSound(url) {
                var i, channel;
                for (url = URL.formatURL(url), i = SoundManager._channels.length - 1; i >= 0; i--) (channel = SoundManager._channels[i]).url == url && channel.stop()
            }

            static stopAll() {
                var i;
                for (SoundManager._bgMusic = null, i = SoundManager._channels.length - 1; i >= 0; i--) SoundManager._channels[i].stop()
            }

            static stopAllSound() {
                var i, channel;
                for (i = SoundManager._channels.length - 1; i >= 0; i--) (channel = SoundManager._channels[i]).url != SoundManager._bgMusic && channel.stop()
            }

            static stopMusic() {
                SoundManager._musicChannel && SoundManager._musicChannel.stop(), SoundManager._bgMusic = null
            }

            static setSoundVolume(volume, url = null) {
                var i, channel;
                if (url) url = URL.formatURL(url), SoundManager._setVolume(url, volume); else for (SoundManager.soundVolume = volume, i = SoundManager._channels.length - 1; i >= 0; i--) (channel = SoundManager._channels[i]).url != SoundManager._bgMusic && (channel.volume = volume)
            }

            static setMusicVolume(volume) {
                SoundManager.musicVolume = volume, SoundManager._setVolume(SoundManager._bgMusic, volume)
            }

            static _setVolume(url, volume) {
                var i, channel;
                for (url = URL.formatURL(url), i = SoundManager._channels.length - 1; i >= 0; i--) (channel = SoundManager._channels[i]).url == url && (channel.volume = volume)
            }
        }

        SoundManager.musicVolume = 1, SoundManager.soundVolume = 1, SoundManager.playbackRate = 1, SoundManager._useAudioMusic = !0, SoundManager._muted = !1, SoundManager._soundMuted = !1, SoundManager._musicMuted = !1, SoundManager._bgMusic = null, SoundManager._musicChannel = null, SoundManager._channels = [], SoundManager._blurPaused = !1, SoundManager._isActive = !0, SoundManager._lastSoundUsedTimeDic = {}, SoundManager._isCheckingDispose = !1, SoundManager.autoReleaseSound = !0;

        class HttpRequest extends EventDispatcher {
            constructor() {
                super(...arguments), this._http = new XMLHttpRequest
            }

            send(url, data = null, method = "get", responseType = "text", headers = null) {
                this._responseType = responseType, this._data = null, (Browser.onVVMiniGame || Browser.onQGMiniGame || Browser.onQQMiniGame) && (url = encodeURI(url)), this._url = url;
                var _this = this, http = this._http;
                if (url = URL.getAdptedFilePath(url), http.open(method, url, !0), headers) for (var i = 0; i < headers.length; i++) http.setRequestHeader(headers[i++], headers[i]); else window.conch || (data && "string" != typeof data ? http.setRequestHeader("Content-Type", "application/json") : http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"));
                let restype = "arraybuffer" !== responseType ? "text" : "arraybuffer";
                http.responseType = restype, http.dataType && (http.dataType = restype), http.onerror = function (e) {
                    _this._onError(e)
                }, http.onabort = function (e) {
                    _this._onAbort(e)
                }, http.onprogress = function (e) {
                    _this._onProgress(e)
                }, http.onload = function (e) {
                    _this._onLoad(e)
                }, http.send(data)
            }

            _onProgress(e) {
                e && e.lengthComputable && this.event(Event.PROGRESS, e.loaded / e.total)
            }

            _onAbort(e) {
                this.error("Request was aborted by user")
            }

            _onError(e) {
                this.error("Request failed Status:" + this._http.status + " text:" + this._http.statusText)
            }

            _onLoad(e) {
                var http = this._http, status = void 0 !== http.status ? http.status : 200;
                200 === status || 204 === status || 0 === status ? this.complete() : this.error("[" + http.status + "]" + http.statusText + ":" + http.responseURL)
            }

            error(message) {
                this.clear(), console.warn(this.url, message), this.event(Event.ERROR, message)
            }

            complete() {
                this.clear();
                var flag = !0;
                try {
                    "json" === this._responseType ? this._data = JSON.parse(this._http.responseText) : "xml" === this._responseType ? this._data = Utils.parseXMLFromString(this._http.responseText) : this._data = this._http.response || this._http.responseText
                } catch (e) {
                    flag = !1, this.error(e.message)
                }
                flag && this.event(Event.COMPLETE, this._data instanceof Array ? [this._data] : this._data)
            }

            clear() {
                var http = this._http;
                http.onerror = http.onabort = http.onprogress = http.onload = null
            }

            get url() {
                return this._url
            }

            get data() {
                return this._data
            }

            get http() {
                return this._http
            }
        }

        class BitmapFont {
            constructor() {
                this._fontCharDic = {}, this._fontWidthMap = {}, this._maxWidth = 0, this._spaceWidth = 10, this.fontSize = 12, this.autoScaleSize = !1, this.letterSpacing = 0
            }

            loadFont(path, complete) {
                this._path = path, this._complete = complete, path && -1 !== path.indexOf(".fnt") ? ILaya.loader.load([{
                    url: path,
                    type: ILaya.Loader.XML
                }, {
                    url: path.replace(".fnt", ".png"),
                    type: ILaya.Loader.IMAGE
                }], Handler.create(this, this._onLoaded)) : console.error('Bitmap font configuration information must be a ".fnt" file')
            }

            _onLoaded() {
                this.parseFont(ILaya.Loader.getRes(this._path), ILaya.Loader.getRes(this._path.replace(".fnt", ".png"))), this._complete && this._complete.run()
            }

            parseFont(xml, texture) {
                if (null != xml && null != texture) {
                    this._texture = texture;
                    var tInfo = xml.getElementsByTagName("info");
                    if (!tInfo[0].getAttributeNode) return this.parseFont2(xml, texture);
                    this.fontSize = parseInt(tInfo[0].getAttributeNode("size").nodeValue);
                    var tPaddingArray = tInfo[0].getAttributeNode("padding").nodeValue.split(",");
                    this._padding = [parseInt(tPaddingArray[0]), parseInt(tPaddingArray[1]), parseInt(tPaddingArray[2]), parseInt(tPaddingArray[3])];
                    var chars = xml.getElementsByTagName("char"), i = 0;
                    for (i = 0; i < chars.length; i++) {
                        var tAttribute = chars[i], tId = parseInt(tAttribute.getAttributeNode("id").nodeValue),
                            xOffset = parseInt(tAttribute.getAttributeNode("xoffset").nodeValue) / 1,
                            yOffset = parseInt(tAttribute.getAttributeNode("yoffset").nodeValue) / 1,
                            xAdvance = parseInt(tAttribute.getAttributeNode("xadvance").nodeValue) / 1,
                            region = new Rectangle;
                        region.x = parseInt(tAttribute.getAttributeNode("x").nodeValue), region.y = parseInt(tAttribute.getAttributeNode("y").nodeValue), region.width = parseInt(tAttribute.getAttributeNode("width").nodeValue), region.height = parseInt(tAttribute.getAttributeNode("height").nodeValue);
                        var tTexture = Texture.create(texture, region.x, region.y, region.width, region.height, xOffset, yOffset);
                        this._maxWidth = Math.max(this._maxWidth, xAdvance + this.letterSpacing), this._fontCharDic[tId] = tTexture, this._fontWidthMap[tId] = xAdvance
                    }
                }
            }

            parseFont2(xml, texture) {
                if (null != xml && null != texture) {
                    this._texture = texture;
                    var tInfo = xml.getElementsByTagName("info");
                    this.fontSize = parseInt(tInfo[0].attributes.size.nodeValue);
                    var tPaddingArray = tInfo[0].attributes.padding.nodeValue.split(",");
                    this._padding = [parseInt(tPaddingArray[0]), parseInt(tPaddingArray[1]), parseInt(tPaddingArray[2]), parseInt(tPaddingArray[3])];
                    var chars = xml.getElementsByTagName("char"), i = 0;
                    for (i = 0; i < chars.length; i++) {
                        var tAttribute = chars[i].attributes, tId = parseInt(tAttribute.id.nodeValue),
                            xOffset = parseInt(tAttribute.xoffset.nodeValue) / 1,
                            yOffset = parseInt(tAttribute.yoffset.nodeValue) / 1,
                            xAdvance = parseInt(tAttribute.xadvance.nodeValue) / 1, region = new Rectangle;
                        region.x = parseInt(tAttribute.x.nodeValue), region.y = parseInt(tAttribute.y.nodeValue), region.width = parseInt(tAttribute.width.nodeValue), region.height = parseInt(tAttribute.height.nodeValue);
                        var tTexture = Texture.create(texture, region.x, region.y, region.width, region.height, xOffset, yOffset);
                        this._maxWidth = Math.max(this._maxWidth, xAdvance + this.letterSpacing), this._fontCharDic[tId] = tTexture, this._fontWidthMap[tId] = xAdvance
                    }
                }
            }

            getCharTexture(char) {
                return this._fontCharDic[char.charCodeAt(0)]
            }

            destroy() {
                if (this._texture) {
                    for (var p in this._fontCharDic) {
                        var tTexture = this._fontCharDic[p];
                        tTexture && tTexture.destroy()
                    }
                    this._texture.destroy(), this._fontCharDic = null, this._fontWidthMap = null, this._texture = null, this._complete = null, this._padding = null
                }
            }

            setSpaceWidth(spaceWidth) {
                this._spaceWidth = spaceWidth
            }

            getCharWidth(char) {
                var code = char.charCodeAt(0);
                return this._fontWidthMap[code] ? this._fontWidthMap[code] + this.letterSpacing : " " === char ? this._spaceWidth + this.letterSpacing : 0
            }

            getTextWidth(text) {
                for (var tWidth = 0, i = 0, n = text.length; i < n; i++) tWidth += this.getCharWidth(text.charAt(i));
                return tWidth
            }

            getMaxWidth() {
                return this._maxWidth
            }

            getMaxHeight() {
                return this.fontSize
            }

            _drawText(text, sprite, drawX, drawY, align, width) {
                var tTexture, tWidth = this.getTextWidth(text), dx = 0;
                "center" === align && (dx = (width - tWidth) / 2), "right" === align && (dx = width - tWidth);
                for (var tx = 0, i = 0, n = text.length; i < n; i++) (tTexture = this.getCharTexture(text.charAt(i))) && (sprite.graphics.drawImage(tTexture, drawX + tx + dx, drawY), tx += this.getCharWidth(text.charAt(i)))
            }
        }

        ClassUtils.regClass("laya.display.BitmapFont", BitmapFont), ClassUtils.regClass("Laya.BitmapFont", BitmapFont);

        class Prefab {
            create() {
                return this.json ? ILaya.SceneUtils.createByData(null, this.json) : null
            }
        }

        class Byte {
            constructor(data = null) {
                this._xd_ = !0, this._allocated_ = 8, this._pos_ = 0, this._length = 0, data ? (this._u8d_ = new Uint8Array(data), this._d_ = new DataView(this._u8d_.buffer), this._length = this._d_.byteLength) : this._resizeBuffer(this._allocated_)
            }

            static getSystemEndian() {
                if (!Byte._sysEndian) {
                    var buffer = new ArrayBuffer(2);
                    new DataView(buffer).setInt16(0, 256, !0), Byte._sysEndian = 256 === new Int16Array(buffer)[0] ? Byte.LITTLE_ENDIAN : Byte.BIG_ENDIAN
                }
                return Byte._sysEndian
            }

            get buffer() {
                var rstBuffer = this._d_.buffer;
                return rstBuffer.byteLength === this._length ? rstBuffer : rstBuffer.slice(0, this._length)
            }

            get endian() {
                return this._xd_ ? Byte.LITTLE_ENDIAN : Byte.BIG_ENDIAN
            }

            set endian(value) {
                this._xd_ = value === Byte.LITTLE_ENDIAN
            }

            set length(value) {
                this._allocated_ < value ? this._resizeBuffer(this._allocated_ = Math.floor(Math.max(value, 2 * this._allocated_))) : this._allocated_ > value && this._resizeBuffer(this._allocated_ = value), this._length = value
            }

            get length() {
                return this._length
            }

            _resizeBuffer(len) {
                try {
                    var newByteView = new Uint8Array(len);
                    null != this._u8d_ && (this._u8d_.length <= len ? newByteView.set(this._u8d_) : newByteView.set(this._u8d_.subarray(0, len))), this._u8d_ = newByteView, this._d_ = new DataView(newByteView.buffer)
                } catch (err) {
                    throw"Invalid typed array length:" + len
                }
            }

            getString() {
                return this.readString()
            }

            readString() {
                return this._rUTF(this.getUint16())
            }

            getFloat32Array(start, len) {
                return this.readFloat32Array(start, len)
            }

            readFloat32Array(start, len) {
                var end = start + len;
                end = end > this._length ? this._length : end;
                var v = new Float32Array(this._d_.buffer.slice(start, end));
                return this._pos_ = end, v
            }

            getUint8Array(start, len) {
                return this.readUint8Array(start, len)
            }

            readUint8Array(start, len) {
                var end = start + len;
                end = end > this._length ? this._length : end;
                var v = new Uint8Array(this._d_.buffer.slice(start, end));
                return this._pos_ = end, v
            }

            getInt16Array(start, len) {
                return this.readInt16Array(start, len)
            }

            readInt16Array(start, len) {
                var end = start + len;
                end = end > this._length ? this._length : end;
                var v = new Int16Array(this._d_.buffer.slice(start, end));
                return this._pos_ = end, v
            }

            getFloat32() {
                return this.readFloat32()
            }

            readFloat32() {
                if (this._pos_ + 4 > this._length) throw"getFloat32 error - Out of bounds";
                var v = this._d_.getFloat32(this._pos_, this._xd_);
                return this._pos_ += 4, v
            }

            getFloat64() {
                return this.readFloat64()
            }

            readFloat64() {
                if (this._pos_ + 8 > this._length) throw"getFloat64 error - Out of bounds";
                var v = this._d_.getFloat64(this._pos_, this._xd_);
                return this._pos_ += 8, v
            }

            writeFloat32(value) {
                this._ensureWrite(this._pos_ + 4), this._d_.setFloat32(this._pos_, value, this._xd_), this._pos_ += 4
            }

            writeFloat64(value) {
                this._ensureWrite(this._pos_ + 8), this._d_.setFloat64(this._pos_, value, this._xd_), this._pos_ += 8
            }

            getInt32() {
                return this.readInt32()
            }

            readInt32() {
                if (this._pos_ + 4 > this._length) throw"getInt32 error - Out of bounds";
                var float = this._d_.getInt32(this._pos_, this._xd_);
                return this._pos_ += 4, float
            }

            getUint32() {
                return this.readUint32()
            }

            readUint32() {
                if (this._pos_ + 4 > this._length) throw"getUint32 error - Out of bounds";
                var v = this._d_.getUint32(this._pos_, this._xd_);
                return this._pos_ += 4, v
            }

            writeInt32(value) {
                this._ensureWrite(this._pos_ + 4), this._d_.setInt32(this._pos_, value, this._xd_), this._pos_ += 4
            }

            writeUint32(value) {
                this._ensureWrite(this._pos_ + 4), this._d_.setUint32(this._pos_, value, this._xd_), this._pos_ += 4
            }

            getInt16() {
                return this.readInt16()
            }

            readInt16() {
                if (this._pos_ + 2 > this._length) throw"getInt16 error - Out of bounds";
                var us = this._d_.getInt16(this._pos_, this._xd_);
                return this._pos_ += 2, us
            }

            getUint16() {
                return this.readUint16()
            }

            readUint16() {
                if (this._pos_ + 2 > this._length) throw"getUint16 error - Out of bounds";
                var us = this._d_.getUint16(this._pos_, this._xd_);
                return this._pos_ += 2, us
            }

            writeUint16(value) {
                this._ensureWrite(this._pos_ + 2), this._d_.setUint16(this._pos_, value, this._xd_), this._pos_ += 2
            }

            writeInt16(value) {
                this._ensureWrite(this._pos_ + 2), this._d_.setInt16(this._pos_, value, this._xd_), this._pos_ += 2
            }

            getUint8() {
                return this.readUint8()
            }

            readUint8() {
                if (this._pos_ + 1 > this._length) throw"getUint8 error - Out of bounds";
                return this._u8d_[this._pos_++]
            }

            writeUint8(value) {
                this._ensureWrite(this._pos_ + 1), this._d_.setUint8(this._pos_, value), this._pos_++
            }

            _getUInt8(pos) {
                return this._readUInt8(pos)
            }

            _readUInt8(pos) {
                return this._d_.getUint8(pos)
            }

            _getUint16(pos) {
                return this._readUint16(pos)
            }

            _readUint16(pos) {
                return this._d_.getUint16(pos, this._xd_)
            }

            _getMatrix() {
                return this._readMatrix()
            }

            _readMatrix() {
                return new Matrix(this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32())
            }

            _rUTF(len) {
                var c, c2, c3, max = this._pos_ + len, f = String.fromCharCode, u = this._u8d_, strs = [], n = 0;
                for (strs.length = 1e3; this._pos_ < max;) (c = u[this._pos_++]) < 128 ? 0 != c && (strs[n++] = f(c)) : c < 224 ? strs[n++] = f((63 & c) << 6 | 127 & u[this._pos_++]) : c < 240 ? (c2 = u[this._pos_++], strs[n++] = f((31 & c) << 12 | (127 & c2) << 6 | 127 & u[this._pos_++])) : (c2 = u[this._pos_++], c3 = u[this._pos_++], strs[n++] = f((15 & c) << 18 | (127 & c2) << 12 | c3 << 6 & 127 | 127 & u[this._pos_++]));
                return strs.length = n, strs.join("")
            }

            getCustomString(len) {
                return this.readCustomString(len)
            }

            readCustomString(len) {
                for (var c, v = "", ulen = 0, f = String.fromCharCode, u = this._u8d_; len > 0;) if ((c = u[this._pos_]) < 128) v += f(c), this._pos_++, len--; else for (ulen = c - 128, this._pos_++, len -= ulen; ulen > 0;) c = u[this._pos_++], v += f(u[this._pos_++] << 8 | c), ulen--;
                return v
            }

            get pos() {
                return this._pos_
            }

            set pos(value) {
                this._pos_ = value
            }

            get bytesAvailable() {
                return this._length - this._pos_
            }

            clear() {
                this._pos_ = 0, this.length = 0
            }

            __getBuffer() {
                return this._d_.buffer
            }

            writeUTFBytes(value) {
                for (var i = 0, sz = (value += "").length; i < sz; i++) {
                    var c = value.charCodeAt(i);
                    c <= 127 ? this.writeByte(c) : c <= 2047 ? (this._ensureWrite(this._pos_ + 2), this._u8d_.set([192 | c >> 6, 128 | 63 & c], this._pos_), this._pos_ += 2) : c <= 65535 ? (this._ensureWrite(this._pos_ + 3), this._u8d_.set([224 | c >> 12, 128 | c >> 6 & 63, 128 | 63 & c], this._pos_), this._pos_ += 3) : (this._ensureWrite(this._pos_ + 4), this._u8d_.set([240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | 63 & c], this._pos_), this._pos_ += 4)
                }
            }

            writeUTFString(value) {
                var tPos = this.pos;
                this.writeUint16(1), this.writeUTFBytes(value);
                var dPos = this.pos - tPos - 2;
                this._d_.setUint16(tPos, dPos, this._xd_)
            }

            readUTFString() {
                return this.readUTFBytes(this.getUint16())
            }

            getUTFString() {
                return this.readUTFString()
            }

            readUTFBytes(len = -1) {
                if (0 === len) return "";
                var lastBytes = this.bytesAvailable;
                if (len > lastBytes) throw"readUTFBytes error - Out of bounds";
                return len = len > 0 ? len : lastBytes, this._rUTF(len)
            }

            getUTFBytes(len = -1) {
                return this.readUTFBytes(len)
            }

            writeByte(value) {
                this._ensureWrite(this._pos_ + 1), this._d_.setInt8(this._pos_, value), this._pos_ += 1
            }

            readByte() {
                if (this._pos_ + 1 > this._length) throw"readByte error - Out of bounds";
                return this._d_.getInt8(this._pos_++)
            }

            getByte() {
                return this.readByte()
            }

            _ensureWrite(lengthToEnsure) {
                this._length < lengthToEnsure && (this._length = lengthToEnsure), this._allocated_ < lengthToEnsure && (this.length = lengthToEnsure)
            }

            writeArrayBuffer(arraybuffer, offset = 0, length = 0) {
                if (offset < 0 || length < 0) throw"writeArrayBuffer error - Out of bounds";
                0 == length && (length = arraybuffer.byteLength - offset), this._ensureWrite(this._pos_ + length);
                var uint8array = new Uint8Array(arraybuffer);
                this._u8d_.set(uint8array.subarray(offset, offset + length), this._pos_), this._pos_ += length
            }

            readArrayBuffer(length) {
                var rst;
                return rst = this._u8d_.buffer.slice(this._pos_, this._pos_ + length), this._pos_ = this._pos_ + length, rst
            }
        }

        Byte.BIG_ENDIAN = "bigEndian", Byte.LITTLE_ENDIAN = "littleEndian", Byte._sysEndian = null;

        class Loader extends EventDispatcher {
            constructor() {
                super(...arguments), this._customParse = !1
            }

            static getTypeFromUrl(url) {
                var type = Utils.getFileExtension(url);
                return type ? Loader.typeMap[type] : (console.warn("Not recognize the resources suffix", url), "text")
            }

            load(url, type = null, cache = !0, group = null, ignoreCache = !1, useWorkerLoader = ILaya.WorkerLoader.enable) {
                if (url) {
                    if (Loader.setGroup(url, "666"), this._url = url, 0 === url.indexOf("data:image") ? type = Loader.IMAGE : url = URL.formatURL(url), this._type = type || (type = Loader.getTypeFromUrl(this._url)), this._cache = cache, this._useWorkerLoader = useWorkerLoader, this._data = null, useWorkerLoader && ILaya.WorkerLoader.enableWorkerLoader(), !ignoreCache && Loader.loadedMap[url]) return this._data = Loader.loadedMap[url], this.event(Event.PROGRESS, 1), void this.event(Event.COMPLETE, this._data);
                    if (group && Loader.setGroup(url, group), null != Loader.parserMap[type]) return this._customParse = !0, void (Loader.parserMap[type] instanceof Handler ? Loader.parserMap[type].runWith(this) : Loader.parserMap[type].call(null, this));
                    this._loadResourceFilter(type, url)
                } else this.onLoaded(null)
            }

            _loadResourceFilter(type, url) {
                this._loadResource(type, url)
            }

            _loadResource(type, url) {
                switch (type) {
                    case Loader.IMAGE:
                    case"htmlimage":
                    case"nativeimage":
                        this._loadImage(url);
                        break;
                    case Loader.SOUND:
                        this._loadSound(url);
                        break;
                    case Loader.TTF:
                        this._loadTTF(url);
                        break;
                    case Loader.ATLAS:
                    case Loader.PREFAB:
                    case Loader.PLF:
                        this._loadHttpRequestWhat(url, Loader.JSON);
                        break;
                    case Loader.FONT:
                        this._loadHttpRequestWhat(url, Loader.XML);
                        break;
                    case Loader.PLFB:
                        this._loadHttpRequestWhat(url, Loader.BUFFER);
                        break;
                    default:
                        this._loadHttpRequestWhat(url, type)
                }
            }

            _loadHttpRequest(url, contentType, onLoadCaller, onLoad, onProcessCaller, onProcess, onErrorCaller, onError) {
                Browser.onVVMiniGame ? this._http = new HttpRequest : this._http || (this._http = new HttpRequest), this._http.on(Event.PROGRESS, onProcessCaller, onProcess), this._http.on(Event.COMPLETE, onLoadCaller, onLoad), this._http.on(Event.ERROR, onErrorCaller, onError), this._http.send(url, null, "get", contentType)
            }

            _loadHtmlImage(url, onLoadCaller, onLoad, onErrorCaller, onError) {
                var image;

                function clear() {
                    var img = image;
                    img.onload = null, img.onerror = null, delete Loader._imgCache[url]
                }

                (image = new Browser.window.Image).crossOrigin = "", image.onload = function () {
                    clear(), onLoad.call(onLoadCaller, image)
                }, image.onerror = function () {
                    clear(), onError.call(onErrorCaller)
                }, image.src = url, Loader._imgCache[url] = image
            }

            _loadHttpRequestWhat(url, contentType) {
                Loader.preLoadedMap[url] ? this.onLoaded(Loader.preLoadedMap[url]) : this._loadHttpRequest(url, contentType, this, this.onLoaded, this, this.onProgress, this, this.onError)
            }

            _loadTTF(url) {
                url = URL.formatURL(url);
                var ttfLoader = new ILaya.TTFLoader;
                ttfLoader.complete = Handler.create(this, this.onLoaded), ttfLoader.load(url)
            }

            _loadImage(url) {
                var onLoaded, _this = this;
                url = URL.formatURL(url);
                var onError = function () {
                    _this.event(Event.ERROR, "Load image failed")
                };
                if ("nativeimage" === this._type) onLoaded = function (image) {
                    _this.onLoaded(image)
                }, this._loadHtmlImage(url, this, onLoaded, this, onError); else {
                    var ext = Utils.getFileExtension(url);
                    "ktx" === ext || "pvr" === ext ? (onLoaded = function (imageData) {
                        var format;
                        switch (ext) {
                            case"ktx":
                                format = 5;
                                break;
                            case"pvr":
                                format = 12
                        }
                        var tex = new Texture2D(0, 0, format, !1, !1);
                        tex.wrapModeU = BaseTexture.WARPMODE_CLAMP, tex.wrapModeV = BaseTexture.WARPMODE_CLAMP, tex.setCompressData(imageData), tex._setCreateURL(url), _this.onLoaded(tex)
                    }, this._loadHttpRequest(url, Loader.BUFFER, this, onLoaded, null, null, this, onError)) : (onLoaded = function (image) {
                        var tex = new Texture2D(image.width, image.height, 1, !1, !1);
                        tex.wrapModeU = BaseTexture.WARPMODE_CLAMP, tex.wrapModeV = BaseTexture.WARPMODE_CLAMP, tex.loadImageSource(image, !0), tex._setCreateURL(url), _this.onLoaded(tex)
                    }, this._loadHtmlImage(url, this, onLoaded, this, onError))
                }
            }

            _loadSound(url) {
                var sound = new SoundManager._soundClass, _this = this;

                function clear() {
                    sound.offAll()
                }

                sound.on(Event.COMPLETE, this, function () {
                    clear(), _this.onLoaded(sound)
                }), sound.on(Event.ERROR, this, function () {
                    clear(), sound.dispose(), _this.event(Event.ERROR, "Load sound failed")
                }), sound.load(url)
            }

            onProgress(value) {
                this._type === Loader.ATLAS ? this.event(Event.PROGRESS, .3 * value) : this.event(Event.PROGRESS, value)
            }

            onError(message) {
                this.event(Event.ERROR, message)
            }

            onLoaded(data = null) {
                var type = this._type;
                if (type == Loader.PLFB) this.parsePLFBData(data), this.complete(data); else if (type == Loader.PLF) this.parsePLFData(data), this.complete(data); else if (type === Loader.IMAGE) {
                    var tex = new Texture(data);
                    tex.url = this._url, this.complete(tex)
                } else if (type === Loader.SOUND || "htmlimage" === type || "nativeimage" === type) this.complete(data); else if (type === Loader.ATLAS) {
                    if (!(data instanceof Texture2D)) {
                        if (!this._data) {
                            if (this._data = data, data.meta && data.meta.image) {
                                var changeType, toloadPics = data.meta.image.split(","),
                                    split = this._url.indexOf("/") >= 0 ? "/" : "\\",
                                    idx = this._url.lastIndexOf(split),
                                    folderPath = idx >= 0 ? this._url.substr(0, idx + 1) : "";
                                Browser.onAndroid && data.meta.compressTextureAndroid && (changeType = ".ktx"), Browser.onIOS && data.meta.compressTextureIOS && (changeType = ".pvr");
                                for (var i = 0, len = toloadPics.length; i < len; i++) toloadPics[i] = changeType ? folderPath + toloadPics[i].replace(".png", changeType) : folderPath + toloadPics[i]
                            } else toloadPics = [this._url.replace(".json", ".png")];
                            toloadPics.reverse(), data.toLoads = toloadPics, data.pics = []
                        }
                        return this.event(Event.PROGRESS, .3 + 1 / toloadPics.length * .6), this._loadResourceFilter(Loader.IMAGE, toloadPics.pop())
                    }
                    if (this._data.pics.push(data), this._data.toLoads.length > 0) return this.event(Event.PROGRESS, .3 + 1 / this._data.toLoads.length * .6), this._loadResourceFilter(Loader.IMAGE, this._data.toLoads.pop());
                    var frames = this._data.frames, cleanUrl = this._url.split("?")[0],
                        directory = this._data.meta && this._data.meta.prefix ? this._data.meta.prefix : cleanUrl.substring(0, cleanUrl.lastIndexOf(".")) + "/",
                        pics = this._data.pics, atlasURL = URL.formatURL(this._url),
                        map = Loader.atlasMap[atlasURL] || (Loader.atlasMap[atlasURL] = []);
                    map.dir = directory;
                    var scaleRate = 1;
                    if (this._data.meta && this._data.meta.scale && 1 != this._data.meta.scale) for (var name in scaleRate = parseFloat(this._data.meta.scale), frames) {
                        var tTexture, obj = frames[name], tPic = pics[obj.frame.idx ? obj.frame.idx : 0],
                            url = URL.formatURL(directory + name);
                        tPic.scaleRate = scaleRate, tTexture = Texture._create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h, Loader.getRes(url)), Loader.cacheRes(url, tTexture), tTexture.url = url, map.push(url)
                    } else for (name in frames) tPic = pics[(obj = frames[name]).frame.idx ? obj.frame.idx : 0], url = URL.formatURL(directory + name), tTexture = Texture._create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h, Loader.getRes(url)), Loader.cacheRes(url, tTexture), tTexture.url = url, map.push(url);
                    delete this._data.pics, this.complete(this._data)
                } else if (type === Loader.FONT) {
                    if (!data._source) return this._data = data, this.event(Event.PROGRESS, .5), this._loadImage(this._url.replace(".fnt", ".png"));
                    var bFont = new BitmapFont;
                    bFont.parseFont(this._data, new Texture(data));
                    var tArr = this._url.split(".fnt")[0].split("/"), fontName = tArr[tArr.length - 1];
                    Text.registerBitmapFont(fontName, bFont), this._data = bFont, this.complete(this._data)
                } else if (type === Loader.PREFAB) {
                    var prefab = new Prefab;
                    prefab.json = data, this.complete(prefab)
                } else this.complete(data)
            }

            parsePLFData(plfData) {
                var type, filePath, fileDic;
                for (type in plfData) switch (fileDic = plfData[type], type) {
                    case"json":
                    case"text":
                        for (filePath in fileDic) Loader.preLoadedMap[URL.formatURL(filePath)] = fileDic[filePath];
                        break;
                    default:
                        for (filePath in fileDic) Loader.preLoadedMap[URL.formatURL(filePath)] = fileDic[filePath]
                }
            }

            parsePLFBData(plfData) {
                var byte, i, len;
                for (len = (byte = new Byte(plfData)).getInt32(), i = 0; i < len; i++) this.parseOnePLFBFile(byte)
            }

            parseOnePLFBFile(byte) {
                var fileLen, fileName, fileData;
                fileName = byte.getUTFString(), fileLen = byte.getInt32(), fileData = byte.readArrayBuffer(fileLen), Loader.preLoadedMap[URL.formatURL(fileName)] = fileData
            }

            complete(data) {
                this._data = data, this._customParse ? this.event(Event.LOADED, data instanceof Array ? [data] : data) : (Loader._loaders.push(this), Loader._isWorking || Loader.checkNext())
            }

            static checkNext() {
                Loader._isWorking = !0;
                for (var startTimer = Browser.now(); Loader._startIndex < Loader._loaders.length;) if (Browser.now(), Loader._loaders[Loader._startIndex].endLoad(), Loader._startIndex++, Browser.now() - startTimer > Loader.maxTimeOut) return console.warn("loader callback cost a long time:" + (Browser.now() - startTimer) + " url=" + Loader._loaders[Loader._startIndex - 1].url), void ILaya.systemTimer.frameOnce(1, null, Loader.checkNext);
                Loader._loaders.length = 0, Loader._startIndex = 0, Loader._isWorking = !1
            }

            endLoad(content = null) {
                content && (this._data = content), this._cache && Loader.cacheRes(this._url, this._data), this.event(Event.PROGRESS, 1), this.event(Event.COMPLETE, this.data instanceof Array ? [this.data] : this.data)
            }

            get url() {
                return this._url
            }

            get type() {
                return this._type
            }

            get cache() {
                return this._cache
            }

            get data() {
                return this._data
            }

            static clearRes(url) {
                url = URL.formatURL(url);
                var arr = Loader.getAtlas(url);
                if (arr) {
                    for (var i = 0, n = arr.length; i < n; i++) {
                        var resUrl = arr[i], tex = Loader.getRes(resUrl);
                        delete Loader.loadedMap[resUrl], tex && tex.destroy()
                    }
                    arr.length = 0, delete Loader.atlasMap[url], delete Loader.loadedMap[url]
                } else {
                    var res = Loader.loadedMap[url];
                    res && (delete Loader.loadedMap[url], res instanceof Texture && res.bitmap && res.destroy())
                }
            }

            static clearTextureRes(url) {
                url = URL.formatURL(url);
                var arr = Loader.getAtlas(url);
                if (arr && arr.length > 0) arr.forEach(function (t) {
                    var tex = Loader.getRes(t);
                    tex instanceof Texture && tex.disposeBitmap()
                }); else {
                    var t = Loader.getRes(url);
                    t instanceof Texture && t.disposeBitmap()
                }
            }

            static getRes(url) {
                return Loader.loadedMap[URL.formatURL(url)]
            }

            static getAtlas(url) {
                return Loader.atlasMap[URL.formatURL(url)]
            }

            static cacheRes(url, data) {
                url = URL.formatURL(url), null != Loader.loadedMap[url] ? console.warn("Resources already exist,is repeated loading:", url) : Loader.loadedMap[url] = data
            }

            static setGroup(url, group) {
                Loader.groupMap[group] || (Loader.groupMap[group] = []), Loader.groupMap[group].push(url)
            }

            static clearResByGroup(group) {
                if (Loader.groupMap[group]) {
                    var i, arr = Loader.groupMap[group], len = arr.length;
                    for (i = 0; i < len; i++) Loader.clearRes(arr[i]);
                    arr.length = 0
                }
            }
        }

        Loader.TEXT = "text", Loader.JSON = "json", Loader.PREFAB = "prefab", Loader.XML = "xml", Loader.BUFFER = "arraybuffer", Loader.IMAGE = "image", Loader.SOUND = "sound", Loader.ATLAS = "atlas", Loader.FONT = "font", Loader.TTF = "ttf", Loader.PLF = "plf", Loader.PLFB = "plfb", Loader.HIERARCHY = "HIERARCHY", Loader.MESH = "MESH", Loader.MATERIAL = "MATERIAL", Loader.TEXTURE2D = "TEXTURE2D", Loader.TEXTURECUBE = "TEXTURECUBE", Loader.ANIMATIONCLIP = "ANIMATIONCLIP", Loader.AVATAR = "AVATAR", Loader.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA", Loader.TERRAINRES = "TERRAIN", Loader.typeMap = {
            ttf: "ttf",
            png: "image",
            jpg: "image",
            jpeg: "image",
            ktx: "image",
            pvr: "image",
            txt: "text",
            json: "json",
            prefab: "prefab",
            xml: "xml",
            als: "atlas",
            atlas: "atlas",
            mp3: "sound",
            ogg: "sound",
            wav: "sound",
            part: "json",
            fnt: "font",
            plf: "plf",
            plfb: "plfb",
            scene: "json",
            ani: "json",
            sk: "arraybuffer"
        }, Loader.parserMap = {}, Loader.maxTimeOut = 100, Loader.groupMap = {}, Loader.loadedMap = {}, Loader.atlasMap = {}, Loader.preLoadedMap = {}, Loader._imgCache = {}, Loader._loaders = [], Loader._isWorking = !1, Loader._startIndex = 0;

        class AtlasInfoManager {
            static enable(infoFile, callback = null) {
                ILaya.loader.load(infoFile, Handler.create(null, AtlasInfoManager._onInfoLoaded, [callback]), null, Loader.JSON)
            }

            static _onInfoLoaded(callback, data) {
                var tKey, tPrefix, tArr, i, len;
                for (tKey in data) for (tPrefix = (tArr = data[tKey])[0], len = (tArr = tArr[1]).length, i = 0; i < len; i++) AtlasInfoManager._fileLoadDic[tPrefix + tArr[i]] = tKey;
                callback && callback.run()
            }

            static getFileLoadPath(file) {
                return AtlasInfoManager._fileLoadDic[file] || file
            }
        }

        AtlasInfoManager._fileLoadDic = {};

        class LoaderManager extends EventDispatcher {
            constructor() {
                super(), this.retryNum = 1, this.retryDelay = 0, this.maxLoader = 5, this._loaders = [], this._loaderCount = 0, this._resInfos = [], this._infoPool = [], this._maxPriority = 5, this._failRes = {}, this._statInfo = {
                    count: 1,
                    loaded: 1
                };
                for (var i = 0; i < this._maxPriority; i++) this._resInfos[i] = []
            }

            getProgress() {
                return this._statInfo.loaded / this._statInfo.count
            }

            resetProgress() {
                this._statInfo.count = this._statInfo.loaded = 1
            }

            create(url, complete = null, progress = null, type = null, constructParams = null, propertyParams = null, priority = 1, cache = !0) {
                this._create(url, !0, complete, progress, type, constructParams, propertyParams, priority, cache)
            }

            _create(url, mainResou, complete = null, progress = null, type = null, constructParams = null, propertyParams = null, priority = 1, cache = !0) {
                if (url instanceof Array) {
                    var allScuess = !0, items = url, itemCount = items.length, loadedCount = 0;
                    if (progress) var progress2 = Handler.create(progress.caller, progress.method, progress.args, !1);
                    for (var i = 0; i < itemCount; i++) {
                        var item = items[i];
                        "string" == typeof item && (item = items[i] = {url: item}), item.progress = 0
                    }
                    for (i = 0; i < itemCount; i++) {
                        item = items[i];
                        var progressHandler = progress ? Handler.create(null, function (item, value) {
                                item.progress = value;
                                for (var num = 0, j = 0; j < itemCount; j++) {
                                    num += items[j].progress
                                }
                                var v = num / itemCount;
                                progress2.runWith(v)
                            }, [item], !1) : null,
                            completeHandler = progress || complete ? Handler.create(null, function (item, content = null) {
                                loadedCount++, item.progress = 1, content || (allScuess = !1), loadedCount === itemCount && complete && complete.runWith(allScuess)
                            }, [item]) : null;
                        this._createOne(item.url, mainResou, completeHandler, progressHandler, item.type || type, item.constructParams || constructParams, item.propertyParams || propertyParams, item.priority || priority, cache)
                    }
                } else this._createOne(url, mainResou, complete, progress, type, constructParams, propertyParams, priority, cache)
            }

            _createOne(url, mainResou, complete = null, progress = null, type = null, constructParams = null, propertyParams = null, priority = 1, cache = !0) {
                var item = this.getRes(url);
                if (item) !mainResou && item instanceof Resource && item._addReference(), progress && progress.runWith(1), complete && complete.runWith(item); else {
                    var extension = Utils.getFileExtension(url);
                    if (type || (type = LoaderManager.createMap[extension] ? LoaderManager.createMap[extension][0] : null), !type) return void this.load(url, complete, progress, type, priority, cache);
                    if (!Loader.parserMap[type]) return void this.load(url, complete, progress, type, priority, cache);
                    this._createLoad(url, Handler.create(null, function (createRes) {
                        createRes && (!mainResou && createRes instanceof Resource && createRes._addReference(), createRes._setCreateURL(url)), complete && complete.runWith(createRes), ILaya.loader.event(url)
                    }), progress, type, constructParams, propertyParams, priority, cache, !0)
                }
            }

            load(url, complete = null, progress = null, type = null, priority = 1, cache = !0, group = null, ignoreCache = !1, useWorkerLoader = ILaya.WorkerLoader.enable) {
                if (url instanceof Array) return this._loadAssets(url, complete, progress, type, priority, cache, group);
                var content = Loader.getRes(url);
                if (ignoreCache || null == content) {
                    var original;
                    original = url, (url = AtlasInfoManager.getFileLoadPath(url)) != original && "nativeimage" !== type ? type = Loader.ATLAS : original = null;
                    var info = LoaderManager._resMap[url];
                    info ? (complete && (original ? complete && info._createListener(Event.COMPLETE, this, this._resInfoLoaded, [original, complete], !1, !1) : complete && info._createListener(Event.COMPLETE, complete.caller, complete.method, complete.args, !1, !1)), progress && info._createListener(Event.PROGRESS, progress.caller, progress.method, progress.args, !1, !1)) : ((info = this._infoPool.length ? this._infoPool.pop() : new ResInfo).url = url, info.type = type, info.cache = cache, info.group = group, info.ignoreCache = ignoreCache, info.useWorkerLoader = useWorkerLoader, info.originalUrl = original, complete && info.on(Event.COMPLETE, complete.caller, complete.method, complete.args), progress && info.on(Event.PROGRESS, progress.caller, progress.method, progress.args), LoaderManager._resMap[url] = info, priority = priority < this._maxPriority ? priority : this._maxPriority - 1, this._resInfos[priority].push(info), this._statInfo.count++, this.event(Event.PROGRESS, this.getProgress()), this._next())
                } else ILaya.systemTimer.frameOnce(1, this, function () {
                    progress && progress.runWith(1), complete && complete.runWith(content instanceof Array ? [content] : content), this._loaderCount || this.event(Event.COMPLETE)
                });
                return this
            }

            _resInfoLoaded(original, complete) {
                complete.runWith(Loader.getRes(original))
            }

            _createLoad(url, complete = null, progress = null, type = null, constructParams = null, propertyParams = null, priority = 1, cache = !0, ignoreCache = !1) {
                if (url instanceof Array) return this._loadAssets(url, complete, progress, type, priority, cache);
                var content = Loader.getRes(url);
                if (null != content) ILaya.systemTimer.frameOnce(1, this, function () {
                    progress && progress.runWith(1), complete && complete.runWith(content), this._loaderCount || this.event(Event.COMPLETE)
                }); else {
                    var info = LoaderManager._resMap[url];
                    info ? (complete && info._createListener(Event.COMPLETE, complete.caller, complete.method, complete.args, !1, !1), progress && info._createListener(Event.PROGRESS, progress.caller, progress.method, progress.args, !1, !1)) : ((info = this._infoPool.length ? this._infoPool.pop() : new ResInfo).url = url, info.type = type, info.cache = !1, info.ignoreCache = ignoreCache, info.originalUrl = null, info.group = null, info.createCache = cache, info.createConstructParams = constructParams, info.createPropertyParams = propertyParams, complete && info.on(Event.COMPLETE, complete.caller, complete.method, complete.args), progress && info.on(Event.PROGRESS, progress.caller, progress.method, progress.args), LoaderManager._resMap[url] = info, priority = priority < this._maxPriority ? priority : this._maxPriority - 1, this._resInfos[priority].push(info), this._statInfo.count++, this.event(Event.PROGRESS, this.getProgress()), this._next())
                }
                return this
            }

            _next() {
                if (!(this._loaderCount >= this.maxLoader)) {
                    for (var i = 0; i < this._maxPriority; i++) for (var infos = this._resInfos[i]; infos.length > 0;) {
                        var info = infos.shift();
                        if (info) return this._doLoad(info)
                    }
                    this._loaderCount || this.event(Event.COMPLETE)
                }
            }

            _doLoad(resInfo) {
                this._loaderCount++;
                var loader = this._loaders.length ? this._loaders.pop() : new Loader;
                loader.on(Event.COMPLETE, null, onLoaded), loader.on(Event.PROGRESS, null, function (num) {
                    resInfo.event(Event.PROGRESS, num)
                }), loader.on(Event.ERROR, null, function (msg) {
                    onLoaded(null)
                });
                var _me = this;

                function onLoaded(data = null) {
                    loader.offAll(), loader._data = null, loader._customParse = !1, _me._loaders.push(loader), _me._endLoad(resInfo, data instanceof Array ? [data] : data), _me._loaderCount--, _me._next()
                }

                loader._constructParams = resInfo.createConstructParams, loader._propertyParams = resInfo.createPropertyParams, loader._createCache = resInfo.createCache, loader.load(resInfo.url, resInfo.type, resInfo.cache, resInfo.group, resInfo.ignoreCache, resInfo.useWorkerLoader)
            }

            _endLoad(resInfo, content) {
                var url = resInfo.url;
                if (null == content) {
                    var errorCount = this._failRes[url] || 0;
                    if (errorCount < this.retryNum) return console.warn("[warn]Retry to load:", url), this._failRes[url] = errorCount + 1, void ILaya.systemTimer.once(this.retryDelay, this, this._addReTry, [resInfo], !1);
                    Loader.clearRes(url), console.warn("[error]Failed to load:", url), this.event(Event.ERROR, url)
                }
                this._failRes[url] && (this._failRes[url] = 0), delete LoaderManager._resMap[url], resInfo.originalUrl && (content = Loader.getRes(resInfo.originalUrl)), resInfo.event(Event.COMPLETE, content), resInfo.offAll(), this._infoPool.push(resInfo), this._statInfo.loaded++, this.event(Event.PROGRESS, this.getProgress())
            }

            _addReTry(resInfo) {
                this._resInfos[this._maxPriority - 1].push(resInfo), this._next()
            }

            clearRes(url) {
                Loader.clearRes(url)
            }

            clearTextureRes(url) {
                Loader.clearTextureRes(url)
            }

            getRes(url) {
                return Loader.getRes(url)
            }

            cacheRes(url, data) {
                Loader.cacheRes(url, data)
            }

            setGroup(url, group) {
                Loader.setGroup(url, group)
            }

            clearResByGroup(group) {
                Loader.clearResByGroup(group)
            }

            static cacheRes(url, data) {
                Loader.cacheRes(url, data)
            }

            clearUnLoaded() {
                for (var i = 0; i < this._maxPriority; i++) {
                    for (var infos = this._resInfos[i], j = infos.length - 1; j > -1; j--) {
                        var info = infos[j];
                        info && (info.offAll(), this._infoPool.push(info))
                    }
                    infos.length = 0
                }
                this._loaderCount = 0, LoaderManager._resMap = {}
            }

            cancelLoadByUrls(urls) {
                if (urls) for (var i = 0, n = urls.length; i < n; i++) this.cancelLoadByUrl(urls[i])
            }

            cancelLoadByUrl(url) {
                for (var i = 0; i < this._maxPriority; i++) for (var infos = this._resInfos[i], j = infos.length - 1; j > -1; j--) {
                    var info = infos[j];
                    info && info.url === url && (infos[j] = null, info.offAll(), this._infoPool.push(info))
                }
                LoaderManager._resMap[url] && delete LoaderManager._resMap[url]
            }

            _loadAssets(arr, complete = null, progress = null, type = null, priority = 1, cache = !0, group = null) {
                for (var itemCount = arr.length, loadedCount = 0, totalSize = 0, items = [], success = !0, i = 0; i < itemCount; i++) {
                    var item = arr[i];
                    "string" == typeof item && (item = {
                        url: item,
                        type: type,
                        size: 1,
                        priority: priority
                    }), item.size || (item.size = 1), item.progress = 0, totalSize += item.size, items.push(item);
                    var progressHandler = progress ? Handler.create(null, loadProgress, [item], !1) : null,
                        completeHandler = complete || progress ? Handler.create(null, loadComplete, [item]) : null;
                    this.load(item.url, completeHandler, progressHandler, item.type, item.priority || 1, cache, item.group || group, !1, item.useWorkerLoader)
                }

                function loadComplete(item, content = null) {
                    loadedCount++, item.progress = 1, content || (success = !1), loadedCount === itemCount && complete && complete.runWith(success)
                }

                function loadProgress(item, value) {
                    if (null != progress) {
                        item.progress = value;
                        for (var num = 0, j = 0; j < items.length; j++) {
                            var item1 = items[j];
                            num += item1.size * item1.progress
                        }
                        var v = num / totalSize;
                        progress.runWith(v)
                    }
                }

                return this
            }

            decodeBitmaps(urls) {
                var i, ctx, len = urls.length;
                for (ctx = ILaya.Render._context, i = 0; i < len; i++) {
                    var atlas, tex;
                    if (atlas = Loader.getAtlas(urls[i])) this._decodeTexture(atlas[0], ctx); else (tex = this.getRes(urls[i])) && tex instanceof Texture && this._decodeTexture(tex, ctx)
                }
            }

            _decodeTexture(tex, ctx) {
                var bitmap = tex.bitmap;
                if (tex && bitmap) {
                    var tImg = bitmap.source || bitmap.image;
                    if (tImg && tImg instanceof HTMLImageElement) {
                        ctx.drawImage(tImg, 0, 0, 1, 1);
                        ctx.getImageData(0, 0, 1, 1)
                    }
                }
            }
        }

        LoaderManager._resMap = {}, LoaderManager.createMap = {atlas: [null, Loader.ATLAS]};

        class ResInfo extends EventDispatcher {
        }

        class LocalStorage {
            static __init__() {
                return LocalStorage._baseClass || (LocalStorage._baseClass = Storage, Storage.init()), LocalStorage.items = LocalStorage._baseClass.items, LocalStorage.support = LocalStorage._baseClass.support, LocalStorage.support
            }

            static setItem(key, value) {
                LocalStorage._baseClass.setItem(key, value)
            }

            static getItem(key) {
                return LocalStorage._baseClass.getItem(key)
            }

            static setJSON(key, value) {
                LocalStorage._baseClass.setJSON(key, value)
            }

            static getJSON(key) {
                return LocalStorage._baseClass.getJSON(key)
            }

            static removeItem(key) {
                LocalStorage._baseClass.removeItem(key)
            }

            static clear() {
                LocalStorage._baseClass.clear()
            }
        }

        LocalStorage.support = !1;

        class Storage {
            static init() {
                try {
                    Storage.support = !0, Storage.items = window.localStorage, Storage.setItem("laya", "1"), Storage.removeItem("laya")
                } catch (e) {
                    Storage.support = !1
                }
                Storage.support || console.log("LocalStorage is not supprot or browser is private mode.")
            }

            static setItem(key, value) {
                try {
                    Storage.support && Storage.items.setItem(key, value)
                } catch (e) {
                    console.warn("set localStorage failed", e)
                }
            }

            static getItem(key) {
                return Storage.support ? Storage.items.getItem(key) : null
            }

            static setJSON(key, value) {
                try {
                    Storage.support && Storage.items.setItem(key, JSON.stringify(value))
                } catch (e) {
                    console.warn("set localStorage failed", e)
                }
            }

            static getJSON(key) {
                return JSON.parse(Storage.support ? Storage.items.getItem(key) : null)
            }

            static removeItem(key) {
                Storage.support && Storage.items.removeItem(key)
            }

            static clear() {
                Storage.support && Storage.items.clear()
            }
        }

        Storage.support = !1;

        class TTFLoader {
            load(fontPath) {
                this._url = fontPath;
                var tArr = fontPath.split(".ttf")[0].split("/");
                this.fontName = tArr[tArr.length - 1], ILaya.Render.isConchApp ? this._loadConch() : window.FontFace ? this._loadWithFontFace() : this._loadWithCSS()
            }

            _loadConch() {
                this._http = new HttpRequest, this._http.on(Event.ERROR, this, this._onErr), this._http.on(Event.COMPLETE, this, this._onHttpLoaded), this._http.send(this._url, null, "get", Loader.BUFFER)
            }

            _onHttpLoaded(data = null) {
                window.conchTextCanvas.setFontFaceFromBuffer(this.fontName, data), this._clearHttp(), this._complete()
            }

            _clearHttp() {
                this._http && (this._http.off(Event.ERROR, this, this._onErr), this._http.off(Event.COMPLETE, this, this._onHttpLoaded), this._http = null)
            }

            _onErr() {
                this._clearHttp(), this.err && (this.err.runWith("fail:" + this._url), this.err = null)
            }

            _complete() {
                ILaya.systemTimer.clear(this, this._complete), ILaya.systemTimer.clear(this, this._checkComplete), this._div && this._div.parentNode && (this._div.parentNode.removeChild(this._div), this._div = null), this.complete && (this.complete.runWith(this), this.complete = null)
            }

            _checkComplete() {
                ILaya.Browser.measureText(TTFLoader._testString, this._fontTxt).width != this._txtWidth && this._complete()
            }

            _loadWithFontFace() {
                var fontFace = new window.FontFace(this.fontName, "url('" + this._url + "')");
                document.fonts.add(fontFace);
                var self = this;
                fontFace.loaded.then(function () {
                    self._complete()
                }), fontFace.load()
            }

            _createDiv() {
                this._div = Browser.createElement("div"), this._div.innerHTML = "laya";
                var _style = this._div.style;
                _style.fontFamily = this.fontName, _style.position = "absolute", _style.left = "-100px", _style.top = "-100px", document.body.appendChild(this._div)
            }

            _loadWithCSS() {
                var fontStyle = Browser.createElement("style");
                fontStyle.type = "text/css", document.body.appendChild(fontStyle), fontStyle.textContent = "@font-face { font-family:'" + this.fontName + "'; src:url('" + this._url + "');}", this._fontTxt = "40px " + this.fontName, this._txtWidth = Browser.measureText(TTFLoader._testString, this._fontTxt).width;
                var self = this;
                fontStyle.onload = function () {
                    ILaya.systemTimer.once(1e4, self, this._complete)
                }, ILaya.systemTimer.loop(20, this, this._checkComplete), this._createDiv()
            }
        }

        TTFLoader._testString = "LayaTTFFont";

        class Ease {
            static linearNone(t, b, c, d) {
                return c * t / d + b
            }

            static linearIn(t, b, c, d) {
                return c * t / d + b
            }

            static linearInOut(t, b, c, d) {
                return c * t / d + b
            }

            static linearOut(t, b, c, d) {
                return c * t / d + b
            }

            static bounceIn(t, b, c, d) {
                return c - Ease.bounceOut(d - t, 0, c, d) + b
            }

            static bounceInOut(t, b, c, d) {
                return t < .5 * d ? .5 * Ease.bounceIn(2 * t, 0, c, d) + b : .5 * Ease.bounceOut(2 * t - d, 0, c, d) + .5 * c + b
            }

            static bounceOut(t, b, c, d) {
                return (t /= d) < 1 / 2.75 ? c * (7.5625 * t * t) + b : t < 2 / 2.75 ? c * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + b : t < 2.5 / 2.75 ? c * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + b : c * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + b
            }

            static backIn(t, b, c, d, s = 1.70158) {
                return c * (t /= d) * t * ((s + 1) * t - s) + b
            }

            static backInOut(t, b, c, d, s = 1.70158) {
                return (t /= .5 * d) < 1 ? .5 * c * (t * t * ((1 + (s *= 1.525)) * t - s)) + b : c / 2 * ((t -= 2) * t * ((1 + (s *= 1.525)) * t + s) + 2) + b
            }

            static backOut(t, b, c, d, s = 1.70158) {
                return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b
            }

            static elasticIn(t, b, c, d, a = 0, p = 0) {
                var s;
                return 0 == t ? b : 1 == (t /= d) ? b + c : (p || (p = .3 * d), !a || c > 0 && a < c || c < 0 && a < -c ? (a = c, s = p / 4) : s = p / Ease.PI2 * Math.asin(c / a), -a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p) + b)
            }

            static elasticInOut(t, b, c, d, a = 0, p = 0) {
                var s;
                return 0 == t ? b : 2 == (t /= .5 * d) ? b + c : (p || (p = d * (.3 * 1.5)), !a || c > 0 && a < c || c < 0 && a < -c ? (a = c, s = p / 4) : s = p / Ease.PI2 * Math.asin(c / a), t < 1 ? a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p) * -.5 + b : a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p) * .5 + c + b)
            }

            static elasticOut(t, b, c, d, a = 0, p = 0) {
                var s;
                return 0 == t ? b : 1 == (t /= d) ? b + c : (p || (p = .3 * d), !a || c > 0 && a < c || c < 0 && a < -c ? (a = c, s = p / 4) : s = p / Ease.PI2 * Math.asin(c / a), a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * Ease.PI2 / p) + c + b)
            }

            static strongIn(t, b, c, d) {
                return c * (t /= d) * t * t * t * t + b
            }

            static strongInOut(t, b, c, d) {
                return (t /= .5 * d) < 1 ? .5 * c * t * t * t * t * t + b : .5 * c * ((t -= 2) * t * t * t * t + 2) + b
            }

            static strongOut(t, b, c, d) {
                return c * ((t = t / d - 1) * t * t * t * t + 1) + b
            }

            static sineInOut(t, b, c, d) {
                return .5 * -c * (Math.cos(Math.PI * t / d) - 1) + b
            }

            static sineIn(t, b, c, d) {
                return -c * Math.cos(t / d * Ease.HALF_PI) + c + b
            }

            static sineOut(t, b, c, d) {
                return c * Math.sin(t / d * Ease.HALF_PI) + b
            }

            static quintIn(t, b, c, d) {
                return c * (t /= d) * t * t * t * t + b
            }

            static quintInOut(t, b, c, d) {
                return (t /= .5 * d) < 1 ? .5 * c * t * t * t * t * t + b : .5 * c * ((t -= 2) * t * t * t * t + 2) + b
            }

            static quintOut(t, b, c, d) {
                return c * ((t = t / d - 1) * t * t * t * t + 1) + b
            }

            static quartIn(t, b, c, d) {
                return c * (t /= d) * t * t * t + b
            }

            static quartInOut(t, b, c, d) {
                return (t /= .5 * d) < 1 ? .5 * c * t * t * t * t + b : .5 * -c * ((t -= 2) * t * t * t - 2) + b
            }

            static quartOut(t, b, c, d) {
                return -c * ((t = t / d - 1) * t * t * t - 1) + b
            }

            static cubicIn(t, b, c, d) {
                return c * (t /= d) * t * t + b
            }

            static cubicInOut(t, b, c, d) {
                return (t /= .5 * d) < 1 ? .5 * c * t * t * t + b : .5 * c * ((t -= 2) * t * t + 2) + b
            }

            static cubicOut(t, b, c, d) {
                return c * ((t = t / d - 1) * t * t + 1) + b
            }

            static quadIn(t, b, c, d) {
                return c * (t /= d) * t + b
            }

            static quadInOut(t, b, c, d) {
                return (t /= .5 * d) < 1 ? .5 * c * t * t + b : .5 * -c * (--t * (t - 2) - 1) + b
            }

            static quadOut(t, b, c, d) {
                return -c * (t /= d) * (t - 2) + b
            }

            static expoIn(t, b, c, d) {
                return 0 == t ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - .001 * c
            }

            static expoInOut(t, b, c, d) {
                return 0 == t ? b : t == d ? b + c : (t /= .5 * d) < 1 ? .5 * c * Math.pow(2, 10 * (t - 1)) + b : .5 * c * (2 - Math.pow(2, -10 * --t)) + b
            }

            static expoOut(t, b, c, d) {
                return t == d ? b + c : c * (1 - Math.pow(2, -10 * t / d)) + b
            }

            static circIn(t, b, c, d) {
                return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b
            }

            static circInOut(t, b, c, d) {
                return (t /= .5 * d) < 1 ? .5 * -c * (Math.sqrt(1 - t * t) - 1) + b : .5 * c * (Math.sqrt(1 - (t -= 2) * t) + 1) + b
            }

            static circOut(t, b, c, d) {
                return c * Math.sqrt(1 - (t = t / d - 1) * t) + b
            }
        }

        Ease.HALF_PI = .5 * Math.PI, Ease.PI2 = 2 * Math.PI;

        class Tween {
            constructor() {
                this.gid = 0, this.repeat = 1, this._count = 0
            }

            static to(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = !1, autoRecover = !0) {
                return Pool.getItemByClass("tween", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, !0, autoRecover, !0)
            }

            static from(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = !1, autoRecover = !0) {
                return Pool.getItemByClass("tween", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, !1, autoRecover, !0)
            }

            to(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = !1) {
                return this._create(target, props, duration, ease, complete, delay, coverBefore, !0, !1, !0)
            }

            from(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = !1) {
                return this._create(target, props, duration, ease, complete, delay, coverBefore, !1, !1, !0)
            }

            _create(target, props, duration, ease, complete, delay, coverBefore, isTo, usePool, runNow) {
                if (!target) throw new Error("Tween:target is null");
                this._target = target, this._duration = duration, this._ease = ease || props.ease || Tween.easeNone, this._complete = complete || props.complete, this._delay = delay, this._props = [], this._usedTimer = 0, this._startTimer = Browser.now(), this._usedPool = usePool, this._delayParam = null, this.update = props.update;
                var gid = target.$_GID || (target.$_GID = Utils.getGID());
                return Tween.tweenMap[gid] ? (coverBefore && Tween.clearTween(target), Tween.tweenMap[gid].push(this)) : Tween.tweenMap[gid] = [this], runNow ? delay <= 0 ? this.firstStart(target, props, isTo) : (this._delayParam = [target, props, isTo], ILaya.timer.once(delay, this, this.firstStart, this._delayParam)) : this._initProps(target, props, isTo), this
            }

            firstStart(target, props, isTo) {
                this._delayParam = null, target.destroyed ? this.clear() : (this._initProps(target, props, isTo), this._beginLoop())
            }

            _initProps(target, props, isTo) {
                for (var p in props) if ("number" == typeof target[p]) {
                    var start = isTo ? target[p] : props[p], end = isTo ? props[p] : target[p];
                    this._props.push([p, start, end - start]), isTo || (target[p] = start)
                }
            }

            _beginLoop() {
                ILaya.timer.frameLoop(1, this, this._doEase)
            }

            _doEase() {
                this._updateEase(Browser.now())
            }

            _updateEase(time) {
                var target = this._target;
                if (target) {
                    if (target.destroyed) return Tween.clearTween(target);
                    var usedTimer = this._usedTimer = time - this._startTimer - this._delay;
                    if (!(usedTimer < 0)) {
                        if (usedTimer >= this._duration) return this.complete();
                        for (var ratio = usedTimer > 0 ? this._ease(usedTimer, 0, 1, this._duration) : 0, props = this._props, i = 0, n = props.length; i < n; i++) {
                            var prop = props[i];
                            target[prop[0]] = prop[1] + ratio * prop[2]
                        }
                        this.update && this.update.run()
                    }
                }
            }

            set progress(v) {
                var uTime = v * this._duration;
                this._startTimer = Browser.now() - this._delay - uTime
            }

            complete() {
                if (this._target) {
                    ILaya.timer.runTimer(this, this.firstStart);
                    for (var target = this._target, props = this._props, handler = this._complete, i = 0, n = props.length; i < n; i++) {
                        var prop = props[i];
                        target[prop[0]] = prop[1] + prop[2]
                    }
                    this.update && this.update.run(), this._count++, 0 != this.repeat && this._count >= this.repeat ? (this.clear(), handler && handler.run()) : this.restart()
                }
            }

            pause() {
                var dTime;
                ILaya.timer.clear(this, this._beginLoop), ILaya.timer.clear(this, this._doEase), ILaya.timer.clear(this, this.firstStart), (dTime = Browser.now() - this._startTimer - this._delay) < 0 && (this._usedTimer = dTime)
            }

            setStartTime(startTime) {
                this._startTimer = startTime
            }

            static clearAll(target) {
                if (target && target.$_GID) {
                    var tweens = Tween.tweenMap[target.$_GID];
                    if (tweens) {
                        for (var i = 0, n = tweens.length; i < n; i++) tweens[i]._clear();
                        tweens.length = 0
                    }
                }
            }

            static clear(tween) {
                tween.clear()
            }

            static clearTween(target) {
                Tween.clearAll(target)
            }

            clear() {
                this._target && (this._remove(), this._clear())
            }

            _clear() {
                this.pause(), ILaya.timer.clear(this, this.firstStart), this._complete = null, this._target = null, this._ease = null, this._props = null, this._delayParam = null, this._usedPool && (this.update = null, Pool.recover("tween", this))
            }

            recover() {
                this._usedPool = !0, this._clear()
            }

            _remove() {
                var tweens = Tween.tweenMap[this._target.$_GID];
                if (tweens) for (var i = 0, n = tweens.length; i < n; i++) if (tweens[i] === this) {
                    tweens.splice(i, 1);
                    break
                }
            }

            restart() {
                if (this.pause(), this._usedTimer = 0, this._startTimer = Browser.now(), this._delayParam) ILaya.timer.once(this._delay, this, this.firstStart, this._delayParam); else {
                    for (var props = this._props, i = 0, n = props.length; i < n; i++) {
                        var prop = props[i];
                        this._target[prop[0]] = prop[1]
                    }
                    ILaya.timer.once(this._delay, this, this._beginLoop)
                }
            }

            resume() {
                this._usedTimer >= this._duration || (this._startTimer = Browser.now() - this._usedTimer - this._delay, this._delayParam ? this._usedTimer < 0 ? ILaya.timer.once(-this._usedTimer, this, this.firstStart, this._delayParam) : this.firstStart.apply(this, this._delayParam) : this._beginLoop())
            }

            static easeNone(t, b, c, d) {
                return c * t / d + b
            }
        }

        Tween.tweenMap = [];

        class Dragging {
            constructor() {
                this.ratio = .92, this.maxOffset = 60, this._dragging = !1, this._clickOnly = !0
            }

            start(target, area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio = .92) {
                this.clearTimer(), this.target = target, this.area = area, this.hasInertia = hasInertia, this.elasticDistance = area ? elasticDistance : 0, this.elasticBackTime = elasticBackTime, this.data = data, this._disableMouseEvent = disableMouseEvent, this.ratio = ratio, this._parent = target.parent, this._clickOnly = !0, this._dragging = !0, this._elasticRateX = this._elasticRateY = 1, this._lastX = this._parent.mouseX, this._lastY = this._parent.mouseY, ILaya.stage.on(Event.MOUSE_UP, this, this.onStageMouseUp), ILaya.stage.on(Event.MOUSE_OUT, this, this.onStageMouseUp), ILaya.systemTimer.frameLoop(1, this, this.loop)
            }

            clearTimer() {
                ILaya.systemTimer.clear(this, this.loop), ILaya.systemTimer.clear(this, this.tweenMove), this._tween && (this._tween.recover(), this._tween = null)
            }

            stop() {
                this._dragging && (MouseManager.instance.disableMouseEvent = !1, ILaya.stage.off(Event.MOUSE_UP, this, this.onStageMouseUp), ILaya.stage.off(Event.MOUSE_OUT, this, this.onStageMouseUp), this._dragging = !1, this.target && this.area && this.backToArea(), this.clear())
            }

            loop() {
                var point = this._parent.getMousePoint(), mouseX = point.x, mouseY = point.y,
                    offsetX = mouseX - this._lastX, offsetY = mouseY - this._lastY;
                if (this._clickOnly) {
                    if (!(Math.abs(offsetX * ILaya.stage._canvasTransform.getScaleX()) > 1 || Math.abs(offsetY * ILaya.stage._canvasTransform.getScaleY()) > 1)) return;
                    this._clickOnly = !1, this._offsets || (this._offsets = []), this._offsets.length = 0, this.target.event(Event.DRAG_START, this.data), MouseManager.instance.disableMouseEvent = this._disableMouseEvent
                } else this._offsets.push(offsetX, offsetY);
                0 === offsetX && 0 === offsetY || (this._lastX = mouseX, this._lastY = mouseY, this.target.x += offsetX * this._elasticRateX, this.target.y += offsetY * this._elasticRateY, this.area && this.checkArea(), this.target.event(Event.DRAG_MOVE, this.data))
            }

            checkArea() {
                if (this.elasticDistance <= 0) this.backToArea(); else {
                    if (this.target._x < this.area.x) var offsetX = this.area.x - this.target._x; else offsetX = this.target._x > this.area.x + this.area.width ? this.target._x - this.area.x - this.area.width : 0;
                    if (this._elasticRateX = Math.max(0, 1 - offsetX / this.elasticDistance), this.target._y < this.area.y) var offsetY = this.area.y - this.target.y; else offsetY = this.target._y > this.area.y + this.area.height ? this.target._y - this.area.y - this.area.height : 0;
                    this._elasticRateY = Math.max(0, 1 - offsetY / this.elasticDistance)
                }
            }

            backToArea() {
                this.target.x = Math.min(Math.max(this.target._x, this.area.x), this.area.x + this.area.width), this.target.y = Math.min(Math.max(this.target._y, this.area.y), this.area.y + this.area.height)
            }

            onStageMouseUp(e) {
                if (MouseManager.instance.disableMouseEvent = !1, ILaya.stage.off(Event.MOUSE_UP, this, this.onStageMouseUp), ILaya.stage.off(Event.MOUSE_OUT, this, this.onStageMouseUp), ILaya.systemTimer.clear(this, this.loop), !this._clickOnly && this.target) if (this.hasInertia) {
                    this._offsets.length < 1 && this._offsets.push(this._parent.mouseX - this._lastX, this._parent.mouseY - this._lastY), this._offsetX = this._offsetY = 0;
                    for (var len = this._offsets.length, n = Math.min(len, 6), m = this._offsets.length - n, i = len - 1; i > m; i--) this._offsetY += this._offsets[i--], this._offsetX += this._offsets[i];
                    this._offsetX = this._offsetX / n * 2, this._offsetY = this._offsetY / n * 2, Math.abs(this._offsetX) > this.maxOffset && (this._offsetX = this._offsetX > 0 ? this.maxOffset : -this.maxOffset), Math.abs(this._offsetY) > this.maxOffset && (this._offsetY = this._offsetY > 0 ? this.maxOffset : -this.maxOffset), ILaya.systemTimer.frameLoop(1, this, this.tweenMove)
                } else this.elasticDistance > 0 ? this.checkElastic() : this.clear()
            }

            checkElastic() {
                var tx = NaN, ty = NaN;
                if (this.target.x < this.area.x ? tx = this.area.x : this.target._x > this.area.x + this.area.width && (tx = this.area.x + this.area.width), this.target.y < this.area.y ? ty = this.area.y : this.target._y > this.area.y + this.area.height && (ty = this.area.y + this.area.height), isNaN(tx) && isNaN(ty)) this.clear(); else {
                    var obj = {};
                    isNaN(tx) || (obj.x = tx), isNaN(ty) || (obj.y = ty), this._tween = Tween.to(this.target, obj, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.clear), 0, !1, !1)
                }
            }

            tweenMove() {
                this._offsetX *= this.ratio * this._elasticRateX, this._offsetY *= this.ratio * this._elasticRateY, this.target.x += this._offsetX, this.target.y += this._offsetY, this.area && this.checkArea(), this.target.event(Event.DRAG_MOVE, this.data), (Math.abs(this._offsetX) < 1 && Math.abs(this._offsetY) < 1 || this._elasticRateX < .5 || this._elasticRateY < .5) && (ILaya.systemTimer.clear(this, this.tweenMove), this.elasticDistance > 0 ? this.checkElastic() : this.clear())
            }

            clear() {
                if (this.target) {
                    this.clearTimer();
                    var sp = this.target;
                    this.target = null, this._parent = null, sp.event(Event.DRAG_END, this.data)
                }
            }
        }

        class Component {
            constructor() {
                this._id = Utils.getGID(), this._resetComp()
            }

            get id() {
                return this._id
            }

            get enabled() {
                return this._enabled
            }

            set enabled(value) {
                this._enabled != value && (this._enabled = value, this.owner && (value ? this.owner.activeInHierarchy && this._onEnable() : this.owner.activeInHierarchy && this._onDisable()))
            }

            get isSingleton() {
                return !0
            }

            get destroyed() {
                return this._destroyed
            }

            _isScript() {
                return !1
            }

            _resetComp() {
                this._indexInList = -1, this._enabled = !0, this._awaked = !1, this.owner = null
            }

            _getIndexInList() {
                return this._indexInList
            }

            _setIndexInList(index) {
                this._indexInList = index
            }

            _onAdded() {
            }

            _onAwake() {
            }

            _onEnable() {
            }

            _onDisable() {
            }

            _onDestroy() {
            }

            onReset() {
            }

            _parse(data) {
            }

            _cloneTo(dest) {
            }

            _setActive(value) {
                value ? (this._awaked || (this._awaked = !0, this._onAwake()), this._enabled && this._onEnable()) : this._enabled && this._onDisable()
            }

            destroy() {
                this.owner && this.owner._destroyComponent(this)
            }

            _destroy() {
                this.owner.activeInHierarchy && this._enabled && (this._setActive(!1), this._isScript() && this.onDisable()), this._onDestroy(), this._destroyed = !0, this.onReset !== Component.prototype.onReset ? (this.onReset(), this._resetComp(), Pool.recoverByClass(this)) : this._resetComp()
            }
        }

        class AnimationBase extends Sprite {
            constructor() {
                super(), this.wrapMode = 0, this._interval = Config.animationInterval, this._isReverse = !1, this._frameRateChanged = !1, this._setBitUp(Const.DISPLAY)
            }

            play(start = 0, loop = !0, name = "") {
                this._isPlaying = !0, this._actionName = name, this.index = "string" == typeof start ? this._getFrameByLabel(start) : start, this.loop = loop, this._isReverse = this.wrapMode === AnimationBase.WRAP_REVERSE, 0 == this.index && this._isReverse && (this.index = this.count - 1), this.interval > 0 && this.timerLoop(this.interval, this, this._frameLoop, null, !0, !0)
            }

            get interval() {
                return this._interval
            }

            set interval(value) {
                this._interval != value && (this._frameRateChanged = !0, this._interval = value, this._isPlaying && value > 0 && this.timerLoop(value, this, this._frameLoop, null, !0, !0))
            }

            _getFrameByLabel(label) {
                for (var i = 0; i < this._count; i++) {
                    var item = this._labels[i];
                    if (item && item.indexOf(label) > -1) return i
                }
                return 0
            }

            _frameLoop() {
                if (this._isReverse) {
                    if (this._index--, this._index < 0) {
                        if (!this.loop) return this._index = 0, this.stop(), void this.event(Event.COMPLETE);
                        this.wrapMode == AnimationBase.WRAP_PINGPONG ? (this._index = this._count > 0 ? 1 : 0, this._isReverse = !1) : this._index = this._count - 1, this.event(Event.COMPLETE)
                    }
                } else if (this._index++, this._index >= this._count) {
                    if (!this.loop) return this._index--, this.stop(), void this.event(Event.COMPLETE);
                    this.wrapMode == AnimationBase.WRAP_PINGPONG ? (this._index = this._count - 2 >= 0 ? this._count - 2 : 0, this._isReverse = !0) : this._index = 0, this.event(Event.COMPLETE)
                }
                this.index = this._index
            }

            _setControlNode(node) {
                this._controlNode && (this._controlNode.off(Event.DISPLAY, this, this._resumePlay), this._controlNode.off(Event.UNDISPLAY, this, this._resumePlay)), this._controlNode = node, node && node != this && (node.on(Event.DISPLAY, this, this._resumePlay), node.on(Event.UNDISPLAY, this, this._resumePlay))
            }

            _setDisplay(value) {
                super._setDisplay(value), this._resumePlay()
            }

            _resumePlay() {
                this._isPlaying && (this._controlNode.displayedInStage ? this.play(this._index, this.loop, this._actionName) : this.clearTimer(this, this._frameLoop))
            }

            stop() {
                this._isPlaying = !1, this.clearTimer(this, this._frameLoop)
            }

            get isPlaying() {
                return this._isPlaying
            }

            addLabel(label, index) {
                this._labels || (this._labels = {}), this._labels[index] || (this._labels[index] = []), this._labels[index].push(label)
            }

            removeLabel(label) {
                if (label) {
                    if (this._labels) for (var name in this._labels) this._removeLabelFromList(this._labels[name], label)
                } else this._labels = null
            }

            _removeLabelFromList(list, label) {
                if (list) for (var i = list.length - 1; i >= 0; i--) list[i] == label && list.splice(i, 1)
            }

            gotoAndStop(position) {
                this.index = "string" == typeof position ? this._getFrameByLabel(position) : position, this.stop()
            }

            get index() {
                return this._index
            }

            set index(value) {
                if (this._index = value, this._displayToIndex(value), this._labels && this._labels[value]) for (var tArr = this._labels[value], i = 0, len = tArr.length; i < len; i++) this.event(Event.LABEL, tArr[i])
            }

            _displayToIndex(value) {
            }

            get count() {
                return this._count
            }

            clear() {
                return this.stop(), this._labels = null, this
            }
        }

        AnimationBase.WRAP_POSITIVE = 0, AnimationBase.WRAP_REVERSE = 1, AnimationBase.WRAP_PINGPONG = 2, ClassUtils.regClass("laya.display.AnimationBase", AnimationBase), ClassUtils.regClass("Laya.AnimationBase", AnimationBase);

        class MathUtil {
            static subtractVector3(l, r, o) {
                o[0] = l[0] - r[0], o[1] = l[1] - r[1], o[2] = l[2] - r[2]
            }

            static lerp(left, right, amount) {
                return left * (1 - amount) + right * amount
            }

            static scaleVector3(f, b, e) {
                e[0] = f[0] * b, e[1] = f[1] * b, e[2] = f[2] * b
            }

            static lerpVector3(l, r, t, o) {
                var ax = l[0], ay = l[1], az = l[2];
                o[0] = ax + t * (r[0] - ax), o[1] = ay + t * (r[1] - ay), o[2] = az + t * (r[2] - az)
            }

            static lerpVector4(l, r, t, o) {
                var ax = l[0], ay = l[1], az = l[2], aw = l[3];
                o[0] = ax + t * (r[0] - ax), o[1] = ay + t * (r[1] - ay), o[2] = az + t * (r[2] - az), o[3] = aw + t * (r[3] - aw)
            }

            static slerpQuaternionArray(a, Offset1, b, Offset2, t, out, Offset3) {
                var omega, cosom, sinom, scale0, scale1, ax = a[Offset1 + 0], ay = a[Offset1 + 1], az = a[Offset1 + 2],
                    aw = a[Offset1 + 3], bx = b[Offset2 + 0], by = b[Offset2 + 1], bz = b[Offset2 + 2],
                    bw = b[Offset2 + 3];
                return (cosom = ax * bx + ay * by + az * bz + aw * bw) < 0 && (cosom = -cosom, bx = -bx, by = -by, bz = -bz, bw = -bw), 1 - cosom > 1e-6 ? (omega = Math.acos(cosom), sinom = Math.sin(omega), scale0 = Math.sin((1 - t) * omega) / sinom, scale1 = Math.sin(t * omega) / sinom) : (scale0 = 1 - t, scale1 = t), out[Offset3 + 0] = scale0 * ax + scale1 * bx, out[Offset3 + 1] = scale0 * ay + scale1 * by, out[Offset3 + 2] = scale0 * az + scale1 * bz, out[Offset3 + 3] = scale0 * aw + scale1 * bw, out
            }

            static getRotation(x0, y0, x1, y1) {
                return Math.atan2(y1 - y0, x1 - x0) / Math.PI * 180
            }

            static sortBigFirst(a, b) {
                return a == b ? 0 : b > a ? 1 : -1
            }

            static sortSmallFirst(a, b) {
                return a == b ? 0 : b > a ? -1 : 1
            }

            static sortNumBigFirst(a, b) {
                return parseFloat(b) - parseFloat(a)
            }

            static sortNumSmallFirst(a, b) {
                return parseFloat(a) - parseFloat(b)
            }

            static sortByKey(key, bigFirst = !1, forceNum = !0) {
                var _sortFun;
                return _sortFun = bigFirst ? forceNum ? MathUtil.sortNumBigFirst : MathUtil.sortBigFirst : forceNum ? MathUtil.sortNumSmallFirst : MathUtil.sortSmallFirst, function (a, b) {
                    return _sortFun(a[key], b[key])
                }
            }
        }

        class FrameAnimation extends AnimationBase {
            constructor() {
                super(), null === FrameAnimation._sortIndexFun && (FrameAnimation._sortIndexFun = MathUtil.sortByKey("index", !1, !0))
            }

            _setUp(targetDic, animationData) {
                this._targetDic = targetDic, this._animationData = animationData, this.interval = 1e3 / animationData.frameRate, animationData.parsed ? (this._count = animationData.count, this._labels = animationData.labels, this._usedFrames = animationData.animationNewFrames) : (this._usedFrames = [], this._calculateDatas(), animationData.parsed = !0, animationData.labels = this._labels, animationData.count = this._count, animationData.animationNewFrames = this._usedFrames)
            }

            clear() {
                return super.clear(), this._targetDic = null, this._animationData = null, this
            }

            _displayToIndex(value) {
                if (this._animationData) {
                    value < 0 && (value = 0), value > this._count && (value = this._count);
                    var i, nodes = this._animationData.nodes, len = nodes.length;
                    for (i = 0; i < len; i++) this._displayNodeToFrame(nodes[i], value)
                }
            }

            _displayNodeToFrame(node, frame, targetDic = null) {
                targetDic || (targetDic = this._targetDic);
                var target = targetDic[node.target];
                if (target) {
                    var key, propFrames, value, i, frames = node.frames, keys = node.keys, len = keys.length;
                    for (i = 0; i < len; i++) value = (propFrames = frames[key = keys[i]]).length > frame ? propFrames[frame] : propFrames[propFrames.length - 1], target[key] = value;
                    var funFrames, funkeys = node.funkeys;
                    if (0 != (len = funkeys.length)) for (i = 0; i < len; i++) void 0 !== (funFrames = frames[key = funkeys[i]])[frame] && target[key] && target[key].apply(target, funFrames[frame])
                }
            }

            _calculateDatas() {
                if (this._animationData) {
                    var i, tNode, nodes = this._animationData.nodes, len = nodes.length;
                    for (this._count = 0, i = 0; i < len; i++) tNode = nodes[i], this._calculateKeyFrames(tNode);
                    this._count += 1
                }
            }

            _calculateKeyFrames(node) {
                var key, tKeyFrames, keyFrames = node.keyframes, target = node.target;
                for (key in node.frames || (node.frames = {}), node.keys ? node.keys.length = 0 : node.keys = [], node.funkeys ? node.funkeys.length = 0 : node.funkeys = [], node.initValues || (node.initValues = {}), keyFrames) {
                    var isFun = -1 != key.indexOf("()");
                    if (tKeyFrames = keyFrames[key], isFun && (key = key.substr(0, key.length - 2)), node.frames[key] || (node.frames[key] = []), isFun) {
                        node.funkeys.push(key);
                        for (var map = node.frames[key], i = 0; i < tKeyFrames.length; i++) {
                            var temp = tKeyFrames[i];
                            map[temp.index] = temp.value, temp.index > this._count && (this._count = temp.index)
                        }
                    } else this._targetDic && this._targetDic[target] && (node.initValues[key] = this._targetDic[target][key]), tKeyFrames.sort(FrameAnimation._sortIndexFun), node.keys.push(key), this._calculateNodePropFrames(tKeyFrames, node.frames[key], key, target)
                }
            }

            resetNodes() {
                if (this._targetDic && this._animationData) {
                    var i, tNode, initValues, nodes = this._animationData.nodes, len = nodes.length;
                    for (i = 0; i < len; i++) if (initValues = (tNode = nodes[i]).initValues) {
                        var key, target = this._targetDic[tNode.target];
                        if (target) for (key in initValues) target[key] = initValues[key]
                    }
                }
            }

            _calculateNodePropFrames(keyframes, frames, key, target) {
                var i, len = keyframes.length - 1;
                for (frames.length = keyframes[len].index + 1, i = 0; i < len; i++) this._dealKeyFrame(keyframes[i]), this._calculateFrameValues(keyframes[i], keyframes[i + 1], frames);
                0 == len && (frames[0] = keyframes[0].value, this._usedFrames && (this._usedFrames[keyframes[0].index] = !0)), this._dealKeyFrame(keyframes[i])
            }

            _dealKeyFrame(keyFrame) {
                keyFrame.label && "" != keyFrame.label && this.addLabel(keyFrame.label, keyFrame.index)
            }

            _calculateFrameValues(startFrame, endFrame, result) {
                var i, easeFun, start = startFrame.index, end = endFrame.index, startValue = startFrame.value,
                    dValue = endFrame.value - startFrame.value, dLen = end - start, frames = this._usedFrames;
                if (end > this._count && (this._count = end), startFrame.tween) for (null == (easeFun = Ease[startFrame.tweenMethod]) && (easeFun = Ease.linearNone), i = start; i < end; i++) result[i] = easeFun(i - start, startValue, dValue, dLen), frames && (frames[i] = !0); else for (i = start; i < end; i++) result[i] = startValue;
                frames && (frames[startFrame.index] = !0, frames[endFrame.index] = !0), result[endFrame.index] = endFrame.value
            }
        }

        ClassUtils.regClass("laya.display.FrameAnimation", FrameAnimation), ClassUtils.regClass("Laya.FrameAnimation", FrameAnimation);
        var supportWeakMap = !!WeakMap;

        class WeakObject {
            constructor() {
                this._obj = WeakObject.supportWeakMap ? new Browser.window.WeakMap : {}, WeakObject.supportWeakMap || WeakObject._maps.push(this)
            }

            static __init__() {
                WeakObject.I = new WeakObject, WeakObject.supportWeakMap || ILaya.systemTimer.loop(WeakObject.delInterval, null, WeakObject.clearCache)
            }

            static clearCache() {
                for (var i = 0, n = WeakObject._maps.length; i < n; i++) {
                    WeakObject._maps[i]._obj = {}
                }
            }

            set(key, value) {
                if (null != key) if (WeakObject.supportWeakMap) {
                    var objKey = key;
                    "string" != typeof key && "number" != typeof key || (objKey = WeakObject._keys[key]) || (objKey = WeakObject._keys[key] = {k: key}), this._obj.set(objKey, value)
                } else "string" == typeof key || "number" == typeof key ? this._obj[key] = value : (key.$_GID || (key.$_GID = Utils.getGID()), this._obj[key.$_GID] = value)
            }

            get(key) {
                if (null == key) return null;
                if (WeakObject.supportWeakMap) {
                    var objKey = "string" == typeof key || "number" == typeof key ? WeakObject._keys[key] : key;
                    return objKey ? this._obj.get(objKey) : null
                }
                return "string" == typeof key || "number" == typeof key ? this._obj[key] : this._obj[key.$_GID]
            }

            del(key) {
                if (null != key) if (WeakObject.supportWeakMap) {
                    var objKey = "string" == typeof key || "number" == typeof key ? WeakObject._keys[key] : key;
                    if (!objKey) return;
                    this._obj.delete(objKey)
                } else "string" == typeof key || "number" == typeof key ? delete this._obj[key] : delete this._obj[this._obj.$_GID]
            }

            has(key) {
                if (null == key) return !1;
                if (WeakObject.supportWeakMap) {
                    var objKey = "string" == typeof key || "number" == typeof key ? WeakObject._keys[key] : key;
                    return this._obj.has(objKey)
                }
                return "string" == typeof key || "number" == typeof key ? null != this._obj[key] : null != this._obj[this._obj.$_GID]
            }
        }

        WeakObject.supportWeakMap = supportWeakMap, WeakObject.delInterval = 6e5, WeakObject._keys = {}, WeakObject._maps = [];

        class SceneUtils {
            static __init() {
                SceneUtils._funMap = new WeakObject
            }

            static getBindFun(value) {
                var fun = SceneUtils._funMap.get(value);
                if (null == fun) {
                    var temp = '"' + value + '"',
                        str = "(function(data){if(data==null)return;with(data){try{\nreturn " + (temp = temp.replace(/^"\${|}"$/g, "").replace(/\${/g, '"+').replace(/}/g, '+"')) + "\n}catch(e){}}})";
                    fun = window.Laya._runScript(str), SceneUtils._funMap.set(value, fun)
                }
                return fun
            }

            static createByData(root, uiView) {
                var tInitTool = InitTool.create();
                if ((root = SceneUtils.createComp(uiView, root, root, null, tInitTool))._setBit(Const.NOT_READY, !0), "_idMap" in root && (root._idMap = tInitTool._idMap), uiView.animations) {
                    var i, tAni, tAniO, anilist = [], animations = uiView.animations, len = animations.length;
                    for (i = 0; i < len; i++) {
                        switch (tAni = new FrameAnimation, tAniO = animations[i], tAni._setUp(tInitTool._idMap, tAniO), root[tAniO.name] = tAni, tAni._setControlNode(root), tAniO.action) {
                            case 1:
                                tAni.play(0, !1);
                                break;
                            case 2:
                                tAni.play(0, !0)
                        }
                        anilist.push(tAni)
                    }
                    root._aniList = anilist
                }
                return "Scene" === root._$componentType && root._width > 0 && null == uiView.props.hitTestPrior && !root.mouseThrough && (root.hitTestPrior = !0), tInitTool.beginLoad(root), root
            }

            static createInitTool() {
                return InitTool.create()
            }

            static createComp(uiView, comp = null, view = null, dataMap = null, initTool = null) {
                if ("Scene3D" == uiView.type || "Sprite3D" == uiView.type) {
                    var outBatchSprits = [],
                        scene3D = ILaya.Laya.Utils3D._createSceneByJsonForMaker(uiView, outBatchSprits, initTool);
                    return "Sprite3D" == uiView.type ? ILaya.Laya.StaticBatchManager.combine(scene3D, outBatchSprits) : ILaya.Laya.StaticBatchManager.combine(null, outBatchSprits), scene3D
                }
                if (!(comp = comp || SceneUtils.getCompInstance(uiView))) return uiView.props && uiView.props.runtime ? console.warn("runtime not found:" + uiView.props.runtime) : console.warn("can not create:" + uiView.type), null;
                var child = uiView.child;
                if (child) for (var isList = "List" == comp._$componentType, i = 0, n = child.length; i < n; i++) {
                    var node = child[i];
                    if ("itemRender" in comp && ("render" == node.props.name || "render" === node.props.renderType)) comp.itemRender = node; else if ("Graphic" == node.type) ILaya.ClassUtils._addGraphicsToSprite(node, comp); else if (ILaya.ClassUtils._isDrawType(node.type)) ILaya.ClassUtils._addGraphicToSprite(node, comp, !0); else {
                        if (isList) {
                            var arr = [], tChild = SceneUtils.createComp(node, null, view, arr, initTool);
                            arr.length && (tChild._$bindData = arr)
                        } else tChild = SceneUtils.createComp(node, null, view, dataMap, initTool);
                        "Script" == node.type ? tChild instanceof Component ? comp._addComponentInstance(tChild) : "owner" in tChild ? tChild.owner = comp : "target" in tChild && (tChild.target = comp) : "mask" == node.props.renderType || "mask" == node.props.name ? comp.mask = tChild : tChild instanceof Node && comp.addChild(tChild)
                    }
                }
                var props = uiView.props;
                for (var prop in props) {
                    var value = props[prop];
                    "string" == typeof value && (value.indexOf("@node:") >= 0 || value.indexOf("@Prefab:") >= 0) ? initTool && initTool.addNodeRef(comp, prop, value) : SceneUtils.setCompValue(comp, prop, value, view, dataMap)
                }
                return comp._afterInited && comp._afterInited(), uiView.compId && initTool && initTool._idMap && (initTool._idMap[uiView.compId] = comp), comp
            }

            static setCompValue(comp, prop, value, view = null, dataMap = null) {
                if ("string" == typeof value && value.indexOf("${") > -1) {
                    if (SceneUtils._sheet || (SceneUtils._sheet = ILaya.ClassUtils.getClass("laya.data.Table")), !SceneUtils._sheet) return void console.warn("Can not find class Sheet");
                    if (dataMap) dataMap.push(comp, prop, value); else if (view) {
                        -1 == value.indexOf("].") && (value = value.replace(".", "[0]."));
                        var one, temp, watcher = new DataWatcher(comp, prop, value);
                        watcher.exe(view);
                        for (var str = value.replace(/\[.*?\]\./g, "."); null != (one = SceneUtils._parseWatchData.exec(str));) {
                            for (var key1 = one[1]; null != (temp = SceneUtils._parseKeyWord.exec(key1));) {
                                var key2 = temp[0], arr = view._watchMap[key2] || (view._watchMap[key2] = []);
                                arr.push(watcher), SceneUtils._sheet.I.notifer.on(key2, view, view.changeData, [key2])
                            }
                            (arr = view._watchMap[key1] || (view._watchMap[key1] = [])).push(watcher), SceneUtils._sheet.I.notifer.on(key1, view, view.changeData, [key1])
                        }
                    }
                } else "var" === prop && view ? view[value] = comp : comp[prop] = "true" === value || "false" !== value && value
            }

            static getCompInstance(json) {
                if ("UIView" == json.type && json.props && json.props.pageData) return SceneUtils.createByData(null, json.props.pageData);
                var runtime = json.props && json.props.runtime || json.type,
                    compClass = ILaya.ClassUtils.getClass(runtime);
                if (!compClass) throw"Can not find class " + runtime;
                if ("Script" === json.type && compClass.prototype._doAwake) {
                    var comp = Pool.createByClass(compClass);
                    return comp._destroyed = !1, comp
                }
                return json.props && "renderType" in json.props && "instance" == json.props.renderType ? (compClass.instance || (compClass.instance = new compClass), compClass.instance) : new compClass
            }
        }

        SceneUtils._parseWatchData = /\${(.*?)}/g, SceneUtils._parseKeyWord = /[a-zA-Z_][a-zA-Z0-9_]*(?:(?:\.[a-zA-Z_][a-zA-Z0-9_]*)+)/g;

        class DataWatcher {
            constructor(comp, prop, value) {
                this.comp = comp, this.prop = prop, this.value = value
            }

            exe(view) {
                var fun = SceneUtils.getBindFun(this.value);
                this.comp[this.prop] = fun.call(this, view)
            }
        }

        class InitTool {
            reset() {
                this._nodeRefList = null, this._initList = null, this._idMap = null, this._loadList = null, this._scene = null
            }

            recover() {
                this.reset(), Pool.recover("InitTool", this)
            }

            static create() {
                var tool = Pool.getItemByClass("InitTool", InitTool);
                return tool._idMap = [], tool
            }

            addLoadRes(url, type = null) {
                this._loadList || (this._loadList = []), type ? this._loadList.push({
                    url: url,
                    type: type
                }) : this._loadList.push(url)
            }

            addNodeRef(node, prop, referStr) {
                this._nodeRefList || (this._nodeRefList = []), this._nodeRefList.push([node, prop, referStr]), referStr.indexOf("@Prefab:") >= 0 && this.addLoadRes(referStr.replace("@Prefab:", ""), Loader.PREFAB)
            }

            setNodeRef() {
                if (this._nodeRefList) if (this._idMap) {
                    var i, len, tRefInfo;
                    for (len = this._nodeRefList.length, i = 0; i < len; i++) (tRefInfo = this._nodeRefList[i])[0][tRefInfo[1]] = this.getReferData(tRefInfo[2]);
                    this._nodeRefList = null
                } else this._nodeRefList = null
            }

            getReferData(referStr) {
                if (referStr.indexOf("@Prefab:") >= 0) return Loader.getRes(referStr.replace("@Prefab:", ""));
                if (referStr.indexOf("@arr:") >= 0) {
                    var list, i, len, tStr;
                    for (len = (list = (referStr = referStr.replace("@arr:", "")).split(",")).length, i = 0; i < len; i++) tStr = list[i], list[i] = tStr ? this._idMap[tStr.replace("@node:", "")] : null;
                    return list
                }
                return this._idMap[referStr.replace("@node:", "")]
            }

            addInitItem(item) {
                this._initList || (this._initList = []), this._initList.push(item)
            }

            doInits() {
                this._initList && (this._initList = null)
            }

            finish() {
                this.setNodeRef(), this.doInits(), this._scene._setBit(Const.NOT_READY, !1), this._scene.parent && this._scene.parent.activeInHierarchy && this._scene.active && this._scene._processActive(), this._scene.event("onViewCreated"), this.recover()
            }

            beginLoad(scene) {
                this._scene = scene, !this._loadList || this._loadList.length < 1 ? this.finish() : ILaya.loader.load(this._loadList, Handler.create(this, this.finish))
            }
        }

        class IStatRender {
            show(x = 0, y = 0) {
            }

            enable() {
            }

            hide() {
            }

            set_onclick(fn) {
            }

            isCanvasRender() {
                return !0
            }

            renderNotCanvas(ctx, x, y) {
            }
        }

        class StatUI extends IStatRender {
            constructor() {
                super(...arguments), this._show = !1, this._useCanvas = !1, this._height = 100, this._view = []
            }

            show(x = 0, y = 0) {
                Browser.onMiniGame || ILaya.Render.isConchApp || Browser.onBDMiniGame || Browser.onKGMiniGame || Browser.onQGMiniGame || Browser.onQQMiniGame || (this._useCanvas = !0), this._show = !0, Stat._fpsData.length = 60, this._view[0] = {
                    title: "FPS(Canvas)",
                    value: "_fpsStr",
                    color: "yellow",
                    units: "int"
                }, this._view[1] = {
                    title: "Sprite",
                    value: "_spriteStr",
                    color: "white",
                    units: "int"
                }, this._view[2] = {
                    title: "RenderBatches",
                    value: "renderBatches",
                    color: "white",
                    units: "int"
                }, this._view[3] = {
                    title: "SavedRenderBatches",
                    value: "savedRenderBatches",
                    color: "white",
                    units: "int"
                }, this._view[4] = {
                    title: "CPUMemory",
                    value: "cpuMemory",
                    color: "yellow",
                    units: "M"
                }, this._view[5] = {
                    title: "GPUMemory",
                    value: "gpuMemory",
                    color: "yellow",
                    units: "M"
                }, this._view[6] = {
                    title: "Shader",
                    value: "shaderCall",
                    color: "white",
                    units: "int"
                }, Render.is3DMode ? (this._view[0].title = "FPS(3D)", this._view[7] = {
                    title: "TriFaces",
                    value: "trianglesFaces",
                    color: "white",
                    units: "int"
                }, this._view[8] = {
                    title: "FrustumCulling",
                    value: "frustumCulling",
                    color: "white",
                    units: "int"
                }, this._view[9] = {
                    title: "OctreeNodeCulling",
                    value: "octreeNodeCulling",
                    color: "white",
                    units: "int"
                }) : (this._view[0].title = "FPS(WebGL)", this._view[7] = {
                    title: "Canvas",
                    value: "_canvasStr",
                    color: "white",
                    units: "int"
                }), this._useCanvas ? this.createUIPre(x, y) : this.createUI(x, y), this.enable()
            }

            createUIPre(x, y) {
                var pixel = Browser.pixelRatio;
                this._width = 180 * pixel, this._vx = 120 * pixel, this._height = pixel * (12 * this._view.length + 3 * pixel) + 4, StatUI._fontSize = 12 * pixel;
                for (var i = 0; i < this._view.length; i++) this._view[i].x = 4, this._view[i].y = i * StatUI._fontSize + 2 * pixel;
                this._canvas || (this._canvas = new HTMLCanvas(!0), this._canvas.size(this._width, this._height), this._ctx = this._canvas.getContext("2d"), this._ctx.textBaseline = "top", this._ctx.font = StatUI._fontSize + "px Arial", this._canvas.source.style.cssText = "pointer-events:none;background:rgba(150,150,150,0.8);z-index:100000;position: absolute;direction:ltr;left:" + x + "px;top:" + y + "px;width:" + this._width / pixel + "px;height:" + this._height / pixel + "px;"), Browser.onKGMiniGame || Browser.container.appendChild(this._canvas.source), this._first = !0, this.loop(), this._first = !1
            }

            createUI(x, y) {
                var stat = this._sp, pixel = Browser.pixelRatio;
                stat || (stat = new Sprite, this._leftText = new Text, this._leftText.pos(5, 5), this._leftText.color = "#ffffff", stat.addChild(this._leftText), this._txt = new Text, this._txt.pos(80 * pixel, 5), this._txt.color = "#ffffff", stat.addChild(this._txt), this._sp = stat), stat.pos(x, y);
                for (var text = "", i = 0; i < this._view.length; i++) {
                    text += this._view[i].title + "\n"
                }
                this._leftText.text = text;
                var width = 138 * pixel, height = pixel * (12 * this._view.length + 3 * pixel) + 4;
                this._txt.fontSize = StatUI._fontSize * pixel, this._leftText.fontSize = StatUI._fontSize * pixel, stat.size(width, height), stat.graphics.clear(), stat.graphics.alpha(.5), stat.graphics.drawRect(0, 0, width, height, "#999999"), stat.graphics.alpha(2), this.loop()
            }

            enable() {
                ILaya.systemTimer.frameLoop(1, this, this.loop)
            }

            hide() {
                this._show = !1, ILaya.systemTimer.clear(this, this.loop), this._canvas && Browser.removeElement(this._canvas.source)
            }

            set_onclick(fn) {
                this._sp && this._sp.on("click", this._sp, fn), this._canvas && (this._canvas.source.onclick = fn, this._canvas.source.style.pointerEvents = "")
            }

            loop() {
                Stat._count++;
                var timer = Browser.now();
                if (!(timer - Stat._timer < 1e3)) {
                    var count = Stat._count;
                    if (Stat.FPS = Math.round(1e3 * count / (timer - Stat._timer)), this._show) {
                        Stat.trianglesFaces = Math.round(Stat.trianglesFaces / count), this._useCanvas ? Stat.renderBatches = Math.round(Stat.renderBatches / count) : Stat.renderBatches = Math.round(Stat.renderBatches / count) - 1, Stat.savedRenderBatches = Math.round(Stat.savedRenderBatches / count), Stat.shaderCall = Math.round(Stat.shaderCall / count), Stat.spriteRenderUseCacheCount = Math.round(Stat.spriteRenderUseCacheCount / count), Stat.canvasNormal = Math.round(Stat.canvasNormal / count), Stat.canvasBitmap = Math.round(Stat.canvasBitmap / count), Stat.canvasReCache = Math.ceil(Stat.canvasReCache / count), Stat.frustumCulling = Math.round(Stat.frustumCulling / count), Stat.octreeNodeCulling = Math.round(Stat.octreeNodeCulling / count);
                        var delay = Stat.FPS > 0 ? Math.floor(1e3 / Stat.FPS).toString() : " ";
                        Stat._fpsStr = Stat.FPS + (Stat.renderSlow ? " slow" : "") + " " + delay, Stat._spriteStr = Stat.spriteCount + (Stat.spriteRenderUseCacheCount ? "/" + Stat.spriteRenderUseCacheCount : ""), Stat._canvasStr = Stat.canvasReCache + "/" + Stat.canvasNormal + "/" + Stat.canvasBitmap, Stat.cpuMemory = Resource.cpuMemory, Stat.gpuMemory = Resource.gpuMemory, this._useCanvas ? this.renderInfoPre() : this.renderInfo(), Stat.clear()
                    }
                    Stat._count = 0, Stat._timer = timer
                }
            }

            renderInfoPre() {
                var one, value, i = 0;
                if (this._canvas) {
                    var ctx = this._ctx;
                    for (ctx.clearRect(this._first ? 0 : this._vx, 0, this._width, this._height), i = 0; i < this._view.length; i++) one = this._view[i], this._first && (ctx.fillStyle = "white", ctx.fillText(one.title, one.x, one.y)), ctx.fillStyle = one.color, value = Stat[one.value], "M" == one.units && (value = Math.floor(value / 1048576 * 100) / 100 + " M"), ctx.fillText(value + "", one.x + this._vx, one.y)
                }
            }

            renderInfo() {
                for (var text = "", i = 0; i < this._view.length; i++) {
                    var one = this._view[i], value = Stat[one.value];
                    "M" == one.units && (value = Math.floor(value / 1048576 * 100) / 100 + " M"), "K" == one.units && (value = Math.floor(value / 1024 * 100) / 100 + " K"), text += value + "\n"
                }
                this._txt.text = text
            }

            isCanvasRender() {
                return this._useCanvas
            }

            renderNotCanvas(ctx, x, y) {
                this._show && this._sp && this._sp.render(ctx, 0, 0)
            }
        }

        StatUI._fontSize = 12;

        class Timer {
            constructor(autoActive = !0) {
                this.scale = 1, this.currTimer = Date.now(), this.currFrame = 0, this._delta = 0, this._lastTimer = Date.now(), this._map = [], this._handlers = [], this._temp = [], this._count = 0, autoActive && Timer.gSysTimer && Timer.gSysTimer.frameLoop(1, this, this._update)
            }

            get delta() {
                return this._delta
            }

            _update() {
                if (this.scale <= 0) return this._lastTimer = Date.now(), void (this._delta = 0);
                var frame = this.currFrame = this.currFrame + this.scale, now = Date.now(),
                    awake = now - this._lastTimer > 3e4;
                this._delta = (now - this._lastTimer) * this.scale;
                var timer = this.currTimer = this.currTimer + this._delta;
                this._lastTimer = now;
                var handlers = this._handlers;
                this._count = 0;
                for (var i = 0, n = handlers.length; i < n; i++) {
                    var handler = handlers[i];
                    if (null !== handler.method) {
                        var t = handler.userFrame ? frame : timer;
                        if (t >= handler.exeTime) if (handler.repeat) if (!handler.jumpFrame || awake) handler.exeTime += handler.delay, handler.run(!1), t > handler.exeTime && (handler.exeTime += Math.ceil((t - handler.exeTime) / handler.delay) * handler.delay); else for (; t >= handler.exeTime;) handler.exeTime += handler.delay, handler.run(!1); else handler.run(!0)
                    } else this._count++
                }
                (this._count > 30 || frame % 200 == 0) && this._clearHandlers()
            }

            _clearHandlers() {
                for (var handlers = this._handlers, i = 0, n = handlers.length; i < n; i++) {
                    var handler = handlers[i];
                    null !== handler.method ? this._temp.push(handler) : this._recoverHandler(handler)
                }
                this._handlers = this._temp, handlers.length = 0, this._temp = handlers
            }

            _recoverHandler(handler) {
                this._map[handler.key] == handler && (this._map[handler.key] = null), handler.clear(), Timer._pool.push(handler)
            }

            _create(useFrame, repeat, delay, caller, method, args, coverBefore) {
                if (!delay) return method.apply(caller, args), null;
                if (coverBefore) {
                    var handler = this._getHandler(caller, method);
                    if (handler) return handler.repeat = repeat, handler.userFrame = useFrame, handler.delay = delay, handler.caller = caller, handler.method = method, handler.args = args, handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + Date.now() - this._lastTimer), handler
                }
                return (handler = Timer._pool.length > 0 ? Timer._pool.pop() : new TimerHandler).repeat = repeat, handler.userFrame = useFrame, handler.delay = delay, handler.caller = caller, handler.method = method, handler.args = args, handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + Date.now() - this._lastTimer), this._indexHandler(handler), this._handlers.push(handler), handler
            }

            _indexHandler(handler) {
                var caller = handler.caller, method = handler.method,
                    cid = caller ? caller.$_GID || (caller.$_GID = ILaya.Utils.getGID()) : 0,
                    mid = method.$_TID || (method.$_TID = 1e5 * Timer._mid++);
                handler.key = cid + mid, this._map[handler.key] = handler
            }

            once(delay, caller, method, args = null, coverBefore = !0) {
                this._create(!1, !1, delay, caller, method, args, coverBefore)
            }

            loop(delay, caller, method, args = null, coverBefore = !0, jumpFrame = !1) {
                var handler = this._create(!1, !0, delay, caller, method, args, coverBefore);
                handler && (handler.jumpFrame = jumpFrame)
            }

            frameOnce(delay, caller, method, args = null, coverBefore = !0) {
                this._create(!0, !1, delay, caller, method, args, coverBefore)
            }

            frameLoop(delay, caller, method, args = null, coverBefore = !0) {
                this._create(!0, !0, delay, caller, method, args, coverBefore)
            }

            toString() {
                return " handlers:" + this._handlers.length + " pool:" + Timer._pool.length
            }

            clear(caller, method) {
                var handler = this._getHandler(caller, method);
                handler && (this._map[handler.key] = null, handler.key = 0, handler.clear())
            }

            clearAll(caller) {
                if (caller) for (var i = 0, n = this._handlers.length; i < n; i++) {
                    var handler = this._handlers[i];
                    handler.caller === caller && (this._map[handler.key] = null, handler.key = 0, handler.clear())
                }
            }

            _getHandler(caller, method) {
                var cid = caller ? caller.$_GID || (caller.$_GID = ILaya.Utils.getGID()) : 0,
                    mid = method.$_TID || (method.$_TID = 1e5 * Timer._mid++);
                return this._map[cid + mid]
            }

            callLater(caller, method, args = null) {
                CallLater.I.callLater(caller, method, args)
            }

            runCallLater(caller, method) {
                CallLater.I.runCallLater(caller, method)
            }

            runTimer(caller, method) {
                var handler = this._getHandler(caller, method);
                handler && null != handler.method && (this._map[handler.key] = null, handler.run(!0))
            }

            pause() {
                this.scale = 0
            }

            resume() {
                this.scale = 1
            }
        }

        Timer.gSysTimer = null, Timer._pool = [], Timer._mid = 1;

        class TimerHandler {
            clear() {
                this.caller = null, this.method = null, this.args = null
            }

            run(withClear) {
                var caller = this.caller;
                if (caller && caller.destroyed) return this.clear();
                var method = this.method, args = this.args;
                withClear && this.clear(), null != method && (args ? method.apply(caller, args) : method.call(caller))
            }
        }

        class SkinSV extends Value2D {
            constructor(type) {
                super(ShaderDefines2D.SKINMESH, 0), this.offsetX = 300, this.offsetY = 0;
                var gl = WebGLContext.mainContext, _vlen = 8 * CONST3D2D.BYTES_PE;
                this.position = [2, gl.FLOAT, !1, _vlen, 0], this.texcoord = [2, gl.FLOAT, !1, _vlen, 2 * CONST3D2D.BYTES_PE], this.color = [4, gl.FLOAT, !1, _vlen, 4 * CONST3D2D.BYTES_PE]
            }
        }

        class PrimitiveSV extends Value2D {
            constructor(args) {
                super(ShaderDefines2D.PRIMITIVE, 0), this._attribLocation = ["position", 0, "attribColor", 1]
            }
        }

        class TextureSV extends Value2D {
            constructor(subID = 0) {
                super(ShaderDefines2D.TEXTURE2D, subID), this.strength = 0, this.blurInfo = null, this.colorMat = null, this.colorAlpha = null, this._attribLocation = ["posuv", 0, "attribColor", 1, "attribFlags", 2]
            }

            clear() {
                this.texture = null, this.shader = null, this.defines._value = this.subID + (WebGL.shaderHighPrecision ? ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION : 0)
            }
        }

        class InlcudeFile {
            constructor(txt) {
                this.codes = {}, this.funs = {}, this.curUseID = -1, this.funnames = "", this.script = txt;
                for (var ofs, end, begin = 0; !((begin = txt.indexOf("#begin", begin)) < 0);) {
                    for (end = begin + 5; !((end = txt.indexOf("#end", end)) < 0) && "i" === txt.charAt(end + 4);) end += 5;
                    if (end < 0) throw"add include err,no #end:" + txt;
                    ofs = txt.indexOf("\n", begin);
                    var words = ILaya.ShaderCompile.splitToWords(txt.substr(begin, ofs - begin), null);
                    "code" == words[1] ? this.codes[words[2]] = txt.substr(ofs + 1, end - ofs - 1) : "function" == words[1] && (ofs = txt.indexOf("function", begin), ofs += "function".length, this.funs[words[3]] = txt.substr(ofs + 1, end - ofs - 1), this.funnames += words[3] + ";"), begin = end + 1
                }
            }

            getWith(name = null) {
                var r = name ? this.codes[name] : this.script;
                if (!r) throw"get with error:" + name;
                return r
            }

            getFunsScript(funsdef) {
                var r = "";
                for (var i in this.funs) funsdef.indexOf(i + ";") >= 0 && (r += this.funs[i]);
                return r
            }
        }

        class ShaderNode {
            constructor(includefiles) {
                this.childs = [], this.text = "", this.useFuns = "", this.z = 0, this.includefiles = includefiles
            }

            setParent(parent) {
                parent.childs.push(this), this.z = parent.z + 1, this.parent = parent
            }

            setCondition(condition, type) {
                condition && (this.conditionType = type, condition = condition.replace(/(\s*$)/g, ""), this.condition = function () {
                    return this[condition]
                }, this.condition.__condition = condition)
            }

            toscript(def, out) {
                return this._toscript(def, out, ++ShaderNode.__id)
            }

            _toscript(def, out, id) {
                if (this.childs.length < 1 && !this.text) return out;
                out.length;
                if (this.condition) {
                    var ifdef = !!this.condition.call(def);
                    if (this.conditionType === ILaya.ShaderCompile.IFDEF_ELSE && (ifdef = !ifdef), !ifdef) return out
                }
                if (this.text && out.push(this.text), this.childs.length > 0 && this.childs.forEach(function (o, index, arr) {
                    o._toscript(def, out, id)
                }), this.includefiles.length > 0 && this.useFuns.length > 0) for (var funsCode, i = 0, n = this.includefiles.length; i < n; i++) this.includefiles[i].curUseID != id && (funsCode = this.includefiles[i].file.getFunsScript(this.useFuns)).length > 0 && (this.includefiles[i].curUseID = id, out[0] = funsCode + out[0]);
                return out
            }
        }

        ShaderNode.__id = 1;

        class ShaderCompile {
            constructor(vs, ps, nameMap) {
                this.defs = {};
                let _this = this;

                function _compile(script) {
                    script = script.replace(ShaderCompile._clearCR, "");
                    var includefiles = [], top = new ShaderNode(includefiles);
                    return _this._compileToTree(top, script.split("\n"), 0, includefiles, _this.defs), top
                }

                var startTime = Date.now();
                this._VS = _compile(vs), this._PS = _compile(ps), this._nameMap = nameMap, Date.now() - startTime > 2 && console.log("ShaderCompile use time:" + (Date.now() - startTime) + "  size:" + vs.length + "/" + ps.length)
            }

            static __init__() {
                var gl = LayaGL.instance;
                ShaderCompile.shaderParamsMap = {
                    float: gl.FLOAT,
                    int: gl.INT,
                    bool: gl.BOOL,
                    vec2: gl.FLOAT_VEC2,
                    vec3: gl.FLOAT_VEC3,
                    vec4: gl.FLOAT_VEC4,
                    ivec2: gl.INT_VEC2,
                    ivec3: gl.INT_VEC3,
                    ivec4: gl.INT_VEC4,
                    bvec2: gl.BOOL_VEC2,
                    bvec3: gl.BOOL_VEC3,
                    bvec4: gl.BOOL_VEC4,
                    mat2: gl.FLOAT_MAT2,
                    mat3: gl.FLOAT_MAT3,
                    mat4: gl.FLOAT_MAT4,
                    sampler2D: gl.SAMPLER_2D,
                    samplerCube: gl.SAMPLER_CUBE
                }
            }

            static _parseOne(attributes, uniforms, words, i, word, b) {
                var one = {
                    type: ShaderCompile.shaderParamsMap[words[i + 1]],
                    name: words[i + 2],
                    size: isNaN(parseInt(words[i + 3])) ? 1 : parseInt(words[i + 3])
                };
                return b && ("attribute" == word ? attributes.push(one) : uniforms.push(one)), ":" == words[i + 3] && (one.type = words[i + 4], i += 2), i += 2
            }

            static addInclude(fileName, txt) {
                if (!txt || 0 === txt.length) throw new Error("add shader include file err:" + fileName);
                if (ShaderCompile.includes[fileName]) throw new Error("add shader include file err, has add:" + fileName);
                ShaderCompile.includes[fileName] = new InlcudeFile(txt)
            }

            static preGetParams(vs, ps) {
                var i, n, text = [vs, ps], result = {}, attributes = [], uniforms = [], definesInfo = {},
                    definesName = [];
                result.attributes = attributes, result.uniforms = uniforms, result.defines = definesInfo;
                for (var s = 0; s < 2; s++) {
                    text[s] = text[s].replace(ShaderCompile._removeAnnotation, "");
                    var tempelse, words = text[s].match(ShaderCompile._reg);
                    for (i = 0, n = words.length; i < n; i++) {
                        var word = words[i];
                        if ("attribute" == word || "uniform" == word) i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, !0); else {
                            if ("#define" == word) {
                                definesName[word = words[++i]] = 1;
                                continue
                            }
                            if ("#ifdef" == word) {
                                definesInfo[tempelse = words[++i]] = definesInfo[tempelse] || [];
                                for (i++; i < n; i++) if ("attribute" == (word = words[i]) || "uniform" == word) i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, definesName[tempelse]); else if ("#else" == word) for (i++; i < n; i++) if ("attribute" == (word = words[i]) || "uniform" == word) i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, !definesName[tempelse]); else if ("#endif" == word) break
                            }
                        }
                    }
                }
                return result
            }

            static splitToWords(str, block) {
                for (var c, word, out = [], ofs = -1, i = 0, n = str.length; i < n; i++) if (c = str.charAt(i), " \t=+-*/&%!<>()'\",;".indexOf(c) >= 0) {
                    if (ofs >= 0 && i - ofs > 1 && (word = str.substr(ofs, i - ofs), out.push(word)), '"' == c || "'" == c) {
                        var ofs2 = str.indexOf(c, i + 1);
                        if (ofs2 < 0) throw"Sharder err:" + str;
                        out.push(str.substr(i + 1, ofs2 - i - 1)), i = ofs2, ofs = -1;
                        continue
                    }
                    "(" == c && block && out.length > 0 && (word = out[out.length - 1] + ";", "vec4;main;".indexOf(word) < 0 && (block.useFuns += word)), ofs = -1
                } else ofs < 0 && (ofs = i);
                return ofs < n && n - ofs > 1 && (word = str.substr(ofs, n - ofs), out.push(word)), out
            }

            _compileToTree(parent, lines, start, includefiles, defs) {
                var node, preNode, text, name, fname, ofs, words, noUseNode, i, n, j;
                for (i = start; i < lines.length; i++) if (!((text = lines[i]).length < 1) && 0 !== (ofs = text.indexOf("//"))) {
                    if (ofs >= 0 && (text = text.substr(0, ofs)), node = noUseNode || new ShaderNode(includefiles), noUseNode = null, node.text = text, node.noCompile = !0, (ofs = text.indexOf("#")) >= 0) {
                        for (name = "#", j = ofs + 1, n = text.length; j < n; j++) {
                            var c = text.charAt(j);
                            if (" " === c || "\t" === c || "?" === c) break;
                            name += c
                        }
                        switch (node.name = name, name) {
                            case"#ifdef":
                            case"#ifndef":
                                if (node.src = text, node.noCompile = null != text.match(/[!&|()=<>]/), node.noCompile ? console.log("function():Boolean{return " + text.substr(ofs + node.name.length) + "}") : (words = text.replace(/^\s*/, "").split(/\s+/), node.setCondition(words[1], "#ifdef" === name ? ShaderCompile.IFDEF_YES : ShaderCompile.IFDEF_ELSE), node.text = "//" + node.text), node.setParent(parent), parent = node, defs) for (words = text.substr(j).split(ShaderCompile._splitToWordExps3), j = 0; j < words.length; j++) (text = words[j]).length && (defs[text] = !0);
                                continue;
                            case"#if":
                                if (node.src = text, node.noCompile = !0, node.setParent(parent), parent = node, defs) for (words = text.substr(j).split(ShaderCompile._splitToWordExps3), j = 0; j < words.length; j++) (text = words[j]).length && "defined" != text && (defs[text] = !0);
                                continue;
                            case"#else":
                                node.src = text, preNode = (parent = parent.parent).childs[parent.childs.length - 1], node.noCompile = preNode.noCompile, node.noCompile || (node.condition = preNode.condition, node.conditionType = preNode.conditionType == ShaderCompile.IFDEF_YES ? ShaderCompile.IFDEF_ELSE : ShaderCompile.IFDEF_YES, node.text = "//" + node.text + " " + preNode.text + " " + node.conditionType), node.setParent(parent), parent = node;
                                continue;
                            case"#endif":
                                preNode = (parent = parent.parent).childs[parent.childs.length - 1], node.noCompile = preNode.noCompile, node.noCompile || (node.text = "//" + node.text), node.setParent(parent);
                                continue;
                            case"#include":
                                words = ShaderCompile.splitToWords(text, null);
                                var inlcudeFile = ShaderCompile.includes[words[1]];
                                if (!inlcudeFile) throw"ShaderCompile error no this include file:" + words[1];
                                if ((ofs = words[0].indexOf("?")) < 0) {
                                    node.setParent(parent), text = inlcudeFile.getWith("with" == words[2] ? words[3] : null), this._compileToTree(node, text.split("\n"), 0, includefiles, defs), node.text = "";
                                    continue
                                }
                                node.setCondition(words[0].substr(ofs + 1), ShaderCompile.IFDEF_YES), node.text = inlcudeFile.getWith("with" == words[2] ? words[3] : null);
                                break;
                            case"#import":
                                fname = (words = ShaderCompile.splitToWords(text, null))[1], includefiles.push({
                                    node: node,
                                    file: ShaderCompile.includes[fname],
                                    ofs: node.text.length
                                });
                                continue
                        }
                    } else {
                        if ((preNode = parent.childs[parent.childs.length - 1]) && !preNode.name) {
                            includefiles.length > 0 && ShaderCompile.splitToWords(text, preNode), noUseNode = node, preNode.text += "\n" + text;
                            continue
                        }
                        includefiles.length > 0 && ShaderCompile.splitToWords(text, node)
                    }
                    node.setParent(parent)
                }
            }

            createShader(define, shaderName, createShader, bindAttrib) {
                var defMap = {}, defineStr = "";
                if (define) for (var i in define) defineStr += "#define " + i + "\n", defMap[i] = !0;
                var vs = this._VS.toscript(defMap, []), ps = this._PS.toscript(defMap, []);
                return (createShader || Shader.create)(defineStr + vs.join("\n"), defineStr + ps.join("\n"), shaderName, this._nameMap, bindAttrib)
            }
        }

        ShaderCompile.IFDEF_NO = 0, ShaderCompile.IFDEF_YES = 1, ShaderCompile.IFDEF_ELSE = 2, ShaderCompile.IFDEF_PARENT = 3, ShaderCompile._removeAnnotation = new RegExp("(/\\*([^*]|[\\r\\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+/)|(//.*)", "g"), ShaderCompile._reg = new RegExp("(\".*\")|('.*')|([#\\w\\*-\\.+/()=<>{}\\\\]+)|([,;:\\\\])", "g"), ShaderCompile._splitToWordExps = new RegExp("[(\".*\")]+|[('.*')]+|([ \\t=\\+\\-*/&%!<>!%(),;])", "g"), ShaderCompile.includes = {}, ShaderCompile._clearCR = new RegExp("\r", "g"), ShaderCompile._splitToWordExps3 = new RegExp("[ \\t=\\+\\-*/&%!<>!%(),;\\|]", "g");

        class WorkerLoader extends EventDispatcher {
            constructor() {
                super(), this.worker = new Worker(WorkerLoader.workerPath);
                let me = this;
                this.worker.onmessage = function (evt) {
                    me.workerMessage(evt.data)
                }
            }

            static __init__() {
                return null == WorkerLoader._preLoadFun && (!!Worker && (WorkerLoader._preLoadFun = Loader.prototype._loadImage, Loader.prototype._loadImage = WorkerLoader.prototype._loadImage, WorkerLoader.I || (WorkerLoader.I = new WorkerLoader), !0))
            }

            static workerSupported() {
                return !!Worker
            }

            static enableWorkerLoader() {
                WorkerLoader._tryEnabled || (WorkerLoader.enable = !0, WorkerLoader._tryEnabled = !0)
            }

            static set enable(value) {
                WorkerLoader._enable != value && (WorkerLoader._enable = value, value && null == WorkerLoader._preLoadFun && (WorkerLoader._enable = WorkerLoader.__init__()))
            }

            static get enable() {
                return WorkerLoader._enable
            }

            workerMessage(data) {
                if (data) switch (data.type) {
                    case"Image":
                        this.imageLoaded(data);
                        break;
                    case"Disable":
                        WorkerLoader.enable = !1
                }
            }

            imageLoaded(data) {
                if (data.dataType && "imageBitmap" == data.dataType) {
                    var imageData = data.imageBitmap, tex = new Texture2D;
                    tex.loadImageSource(imageData), console.log("load:", data.url), this.event(data.url, tex)
                } else this.event(data.url, null)
            }

            loadImage(url) {
                this.worker.postMessage(url)
            }

            _loadImage(url) {
                var _this = this;
                if (this._useWorkerLoader && WorkerLoader._enable) {
                    url = URL.formatURL(url);
                    var onload = function (image) {
                        WorkerLoader.I.off(url, _this, onload), image ? _this.onLoaded(image) : WorkerLoader._preLoadFun.call(_this, url)
                    };
                    WorkerLoader.I.on(url, _this, onload), WorkerLoader.I.loadImage(url)
                } else WorkerLoader._preLoadFun.call(_this, url)
            }
        }

        WorkerLoader.workerPath = "libs/workerloader.js", WorkerLoader._enable = !1, WorkerLoader._tryEnabled = !1;

        class Mouse {
            static set cursor(cursorStr) {
                Mouse._style.cursor = cursorStr
            }

            static get cursor() {
                return Mouse._style.cursor
            }

            static __init__() {
            }

            static hide() {
                "none" != Mouse.cursor && (Mouse._preCursor = Mouse.cursor, Mouse.cursor = "none")
            }

            static show() {
                "none" == Mouse.cursor && (Mouse._preCursor ? Mouse.cursor = Mouse._preCursor : Mouse.cursor = "auto")
            }
        }

        class MeshParticle2D extends Mesh2D {
            constructor(maxNum) {
                super(MeshParticle2D.const_stride, 4 * maxNum * MeshParticle2D.const_stride, 4), this.canReuse = !0, this.setAttributes(MeshParticle2D._fixattriInfo), this.createQuadIB(maxNum), this._quadNum = maxNum
            }

            static __init__() {
                var gl = LayaGL.instance;
                MeshParticle2D._fixattriInfo = [gl.FLOAT, 4, 0, gl.FLOAT, 3, 16, gl.FLOAT, 3, 28, gl.FLOAT, 4, 40, gl.FLOAT, 4, 56, gl.FLOAT, 3, 72, gl.FLOAT, 2, 84, gl.FLOAT, 4, 92, gl.FLOAT, 1, 108, gl.FLOAT, 1, 112]
            }

            setMaxParticleNum(maxNum) {
                this._vb._resizeBuffer(4 * maxNum * MeshParticle2D.const_stride, !1), this.createQuadIB(maxNum)
            }

            static getAMesh(maxNum) {
                if (MeshParticle2D._POOL.length) {
                    var ret = MeshParticle2D._POOL.pop();
                    return ret.setMaxParticleNum(maxNum), ret
                }
                return new MeshParticle2D(maxNum)
            }

            releaseMesh() {
                this._vb.setByteLength(0), this.vertNum = 0, this.indexNum = 0, MeshParticle2D._POOL.push(this)
            }

            destroy() {
                this._ib.destroy(), this._vb.destroy(), this._vb.deleteBuffer()
            }
        }

        MeshParticle2D.const_stride = 116, MeshParticle2D._POOL = [];

        class HTMLImage extends Bitmap {
        }

        HTMLImage.create = function (width, height, format) {
            var tex = new Texture2D(width, height, format, !1, !1);
            return tex.wrapModeU = BaseTexture.WARPMODE_CLAMP, tex.wrapModeV = BaseTexture.WARPMODE_CLAMP, tex
        };

        class Laya {
            static __init(_classs) {
                _classs.forEach(function (o) {
                    o.__init$ && o.__init$()
                })
            }

            static init(width, height, ...plugins) {
                if (!Laya._isinit) {
                    Laya._isinit = !0, ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = Laya._arrayBufferSlice), Browser.__init__();
                    var mainCanv = Browser.mainCanvas = new HTMLCanvas(!0), style = mainCanv.source.style;
                    style.position = "absolute", style.top = style.left = "0px", style.background = "#000000", Browser.onKGMiniGame || Browser.onAlipayMiniGame || Browser.container.appendChild(mainCanv.source), Browser.canvas = new HTMLCanvas(!0), Browser.context = Browser.canvas.getContext("2d"), Browser.supportWebAudio = SoundManager.__init__(), Browser.supportLocalStorage = LocalStorage.__init__(), Laya.systemTimer = new Timer(!1), exports.systemTimer = Timer.gSysTimer = Laya.systemTimer, Laya.startTimer = new Timer(!1), Laya.physicsTimer = new Timer(!1), Laya.updateTimer = new Timer(!1), Laya.lateTimer = new Timer(!1), Laya.timer = new Timer(!1), exports.startTimer = ILaya.startTimer = Laya.startTimer, exports.lateTimer = ILaya.lateTimer = Laya.lateTimer, exports.updateTimer = ILaya.updateTimer = Laya.updateTimer, ILaya.systemTimer = Laya.systemTimer, exports.timer = ILaya.timer = Laya.timer, exports.physicsTimer = ILaya.physicsTimer = Laya.physicsTimer, Laya.loader = new LoaderManager, ILaya.Laya = Laya, exports.loader = ILaya.loader = Laya.loader, WeakObject.__init__(), SceneUtils.__init(), Mouse.__init__(), WebGL.inner_enable();
                    for (var i = 0, n = plugins.length; i < n; i++) plugins[i] && plugins[i].enable && plugins[i].enable();
                    return ILaya.Render.isConchApp && Laya.enableNative(), CacheManger.beginCheck(), exports.stage = Laya.stage = new Stage, ILaya.stage = Laya.stage, Utils.gStage = Laya.stage, URL.rootPath = URL._basePath = Laya._getUrlPath(), MeshQuadTexture.__int__(), MeshVG.__init__(), MeshTexture.__init__(), Laya.render = new Render(0, 0, Browser.mainCanvas), exports.render = Laya.render, Laya.stage.size(width, height), window.stage = Laya.stage, WebGLContext.__init__(), MeshParticle2D.__init__(), ShaderCompile.__init__(), RenderSprite.__init__(), KeyBoardManager.__init__(), MouseManager.instance.__init__(Laya.stage, Render.canvas), Input.__init__(), SoundManager.autoStopMusic = !0, Stat._StatRender = new StatUI, Value2D._initone(ShaderDefines2D.TEXTURE2D, TextureSV), Value2D._initone(ShaderDefines2D.TEXTURE2D | ShaderDefines2D.FILTERGLOW, TextureSV), Value2D._initone(ShaderDefines2D.PRIMITIVE, PrimitiveSV), Value2D._initone(ShaderDefines2D.SKINMESH, SkinSV), Render.canvas
                }
            }

            static _getUrlPath() {
                var location = Browser.window.location, pathName = location.pathname;
                return pathName = ":" == pathName.charAt(2) ? pathName.substring(1) : pathName, URL.getPath("file:" == location.protocol ? pathName : location.protocol + "//" + location.host + location.pathname)
            }

            static _arrayBufferSlice(start, end) {
                var arrU8List = new Uint8Array(this, start, end - start), newU8List = new Uint8Array(arrU8List.length);
                return newU8List.set(arrU8List), newU8List.buffer
            }

            static set alertGlobalError(value) {
                var erralert = 0;
                Browser.window.onerror = value ? function (msg, url, line, column, detail) {
                    erralert++ < 5 && detail && this.alert("出错啦，请把此信息截图给研发商\n" + msg + "\n" + detail.stack)
                } : null
            }

            static _runScript(script) {
                return Browser.window[Laya._evcode](script)
            }

            static enableDebugPanel(debugJsPath = "libs/laya.debugtool.js") {
                if (Laya.DebugPanel) Laya.DebugPanel.enable(); else {
                    var script = Browser.createElement("script");
                    script.onload = function () {
                        Laya.DebugPanel.enable()
                    }, script.src = debugJsPath, Browser.document.body.appendChild(script)
                }
            }

            static enableNative() {
                Laya.isNativeRender_enable || (Laya.isNativeRender_enable = !0, WebGLContext.__init_native(), Shader.prototype.uploadTexture2D = function (value) {
                    var gl = LayaGL.instance;
                    gl.bindTexture(gl.TEXTURE_2D, value)
                }, RenderState2D.width = Browser.window.innerWidth, RenderState2D.height = Browser.window.innerHeight, Browser.measureText = function (txt, font) {
                    return window.conchTextCanvas.font = font, window.conchTextCanvas.measureText(txt)
                }, Stage.clear = function (color) {
                    Context.set2DRenderConfig();
                    var c = ColorUtils.create(color).arrColor, gl = LayaGL.instance;
                    c && gl.clearColor(c[0], c[1], c[2], c[3]), gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT), RenderState2D.clear()
                }, Sprite.drawToCanvas = Sprite.drawToTexture = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
                    offsetX -= sprite.x, offsetY -= sprite.y, offsetX |= 0, offsetY |= 0, canvasWidth |= 0, canvasHeight |= 0;
                    var canv = new HTMLCanvas(!1), ctx = canv.getContext("2d");
                    return canv.size(canvasWidth, canvasHeight), ctx.asBitmap = !0, ctx._targets.start(), RenderSprite.renders[_renderType]._fun(sprite, ctx, offsetX, offsetY), ctx.flush(), ctx._targets.end(), ctx._targets.restore(), canv
                }, Object.defineProperty(RenderTexture2D.prototype, "uv", {
                    get: function () {
                        return this._uv
                    }, set: function (v) {
                        this._uv = v
                    }
                }), HTMLCanvas.prototype.getTexture = function () {
                    return this._texture || (this._texture = this.context._targets, this._texture.uv = RenderTexture2D.flipyuv, this._texture.bitmap = this._texture), this._texture
                }, Render.supportWebGLPlusRendering && (LayaGLRunner.uploadShaderUniforms = LayaGLRunner.uploadShaderUniformsForNative))
            }
        }

        Laya.stage = null, Laya.systemTimer = null, Laya.startTimer = null, Laya.physicsTimer = null, Laya.updateTimer = null, Laya.lateTimer = null, Laya.timer = null, Laya.loader = null, Laya.version = "2.2.0beta4", Laya._isinit = !1, Laya.isWXOpenDataContext = !1, Laya.isWXPosMsg = !1, Laya.__classmap = null, Laya.Config = Config, Laya.TextRender = TextRender, Laya.EventDispatcher = EventDispatcher, Laya.SoundChannel = SoundChannel, Laya.Stage = Stage, Laya.Render = Render, Laya.Browser = Browser, Laya.Sprite = Sprite, Laya.Node = Node, Laya.Context = Context, Laya.WebGL = WebGL, Laya.Handler = Handler, Laya.RunDriver = RunDriver, Laya.Utils = Utils, Laya.Input = Input, Laya.Loader = Loader, Laya.LocalStorage = LocalStorage, Laya.SoundManager = SoundManager, Laya.URL = URL, Laya.Event = Event, Laya.Matrix = Matrix, Laya.HTMLImage = HTMLImage, Laya.Laya = Laya, Laya._evcode = "eval", Laya.isNativeRender_enable = !1, Laya.__classmap = ILaya.__classMap, ILaya.Timer = Timer, ILaya.Dragging = Dragging, ILaya.GraphicsBounds = GraphicsBounds, ILaya.Sprite = Sprite, ILaya.TextRender = TextRender, ILaya.Loader = Loader, ILaya.TTFLoader = TTFLoader, ILaya.WebAudioSound = WebAudioSound, ILaya.SoundManager = SoundManager, ILaya.ShaderCompile = ShaderCompile, ILaya.ClassUtils = ClassUtils, ILaya.SceneUtils = SceneUtils, ILaya.Context = Context, ILaya.Render = Render, ILaya.MouseManager = MouseManager, ILaya.Text = Text, ILaya.Browser = Browser, ILaya.WebGL = WebGL, ILaya.AudioSound = AudioSound, ILaya.Pool = Pool, ILaya.Utils = Utils, ILaya.Graphics = Graphics, ILaya.Submit = Submit, ILaya.Stage = Stage, ILaya.Resource = Resource, ILaya.WorkerLoader = WorkerLoader;
        var libs = window._layalibs;
        if (libs) {
            libs.sort(function (a, b) {
                return a.i - b.i
            });
            for (var j = 0; j < libs.length; j++) libs[j].f(window, window.document, Laya)
        }
        let win = window;
        win.Laya ? (win.Laya.Laya = Laya, Object.assign(win.Laya, Laya)) : win.Laya = Laya;
        var __init = Laya.__init, init = Laya.init, version = Laya.version, alertGlobalError = Laya.alertGlobalError,
            enableDebugPanel = Laya.enableDebugPanel;

        function _static(_class, def) {
            for (var i = 0, sz = def.length; i < sz; i += 2) if ("length" == def[i]) _class.length = def[i + 1].call(_class); else {
                function tmp() {
                    var name = def[i], getfn = def[i + 1];
                    Object.defineProperty(_class, name, {
                        get: function () {
                            return delete this[name], this[name] = getfn.call(this)
                        }, set: function (v) {
                            delete this[name], this[name] = v
                        }, enumerable: !0, configurable: !0
                    })
                }

                tmp()
            }
        }

        class Script extends Component {
            get isSingleton() {
                return !1
            }

            _onAwake() {
                this.onAwake(), this.onStart !== Script.prototype.onStart && ILaya.startTimer.callLater(this, this.onStart)
            }

            _onEnable() {
                var proto = Script.prototype;
                this.onTriggerEnter !== proto.onTriggerEnter && this.owner.on(Event.TRIGGER_ENTER, this, this.onTriggerEnter), this.onTriggerStay !== proto.onTriggerStay && this.owner.on(Event.TRIGGER_STAY, this, this.onTriggerStay), this.onTriggerExit !== proto.onTriggerExit && this.owner.on(Event.TRIGGER_EXIT, this, this.onTriggerExit), this.onMouseDown !== proto.onMouseDown && this.owner.on(Event.MOUSE_DOWN, this, this.onMouseDown), this.onMouseUp !== proto.onMouseUp && this.owner.on(Event.MOUSE_UP, this, this.onMouseUp), this.onClick !== proto.onClick && this.owner.on(Event.CLICK, this, this.onClick), this.onStageMouseDown !== proto.onStageMouseDown && ILaya.stage.on(Event.MOUSE_DOWN, this, this.onStageMouseDown), this.onStageMouseUp !== proto.onStageMouseUp && ILaya.stage.on(Event.MOUSE_UP, this, this.onStageMouseUp), this.onStageClick !== proto.onStageClick && ILaya.stage.on(Event.CLICK, this, this.onStageClick), this.onStageMouseMove !== proto.onStageMouseMove && ILaya.stage.on(Event.MOUSE_MOVE, this, this.onStageMouseMove), this.onDoubleClick !== proto.onDoubleClick && this.owner.on(Event.DOUBLE_CLICK, this, this.onDoubleClick), this.onRightClick !== proto.onRightClick && this.owner.on(Event.RIGHT_CLICK, this, this.onRightClick), this.onMouseMove !== proto.onMouseMove && this.owner.on(Event.MOUSE_MOVE, this, this.onMouseMove), this.onMouseOver !== proto.onMouseOver && this.owner.on(Event.MOUSE_OVER, this, this.onMouseOver), this.onMouseOut !== proto.onMouseOut && this.owner.on(Event.MOUSE_OUT, this, this.onMouseOut), this.onKeyDown !== proto.onKeyDown && ILaya.stage.on(Event.KEY_DOWN, this, this.onKeyDown), this.onKeyPress !== proto.onKeyPress && ILaya.stage.on(Event.KEY_PRESS, this, this.onKeyPress), this.onKeyUp !== proto.onKeyUp && ILaya.stage.on(Event.KEY_UP, this, this.onKeyUp), this.onUpdate !== proto.onUpdate && ILaya.updateTimer.frameLoop(1, this, this.onUpdate), this.onLateUpdate !== proto.onLateUpdate && ILaya.lateTimer.frameLoop(1, this, this.onLateUpdate), this.onPreRender !== proto.onPreRender && ILaya.lateTimer.frameLoop(1, this, this.onPreRender)
            }

            _onDisable() {
                this.owner.offAllCaller(this), ILaya.stage.offAllCaller(this), ILaya.startTimer.clearAll(this), ILaya.updateTimer.clearAll(this), ILaya.lateTimer.clearAll(this)
            }

            _isScript() {
                return !0
            }

            _onDestroy() {
                this.onDestroy()
            }

            onAwake() {
            }

            onEnable() {
            }

            onStart() {
            }

            onTriggerEnter(other, self, contact) {
            }

            onTriggerStay(other, self, contact) {
            }

            onTriggerExit(other, self, contact) {
            }

            onMouseDown(e) {
            }

            onMouseUp(e) {
            }

            onClick(e) {
            }

            onStageMouseDown(e) {
            }

            onStageMouseUp(e) {
            }

            onStageClick(e) {
            }

            onStageMouseMove(e) {
            }

            onDoubleClick(e) {
            }

            onRightClick(e) {
            }

            onMouseMove(e) {
            }

            onMouseOver(e) {
            }

            onMouseOut(e) {
            }

            onKeyDown(e) {
            }

            onKeyPress(e) {
            }

            onKeyUp(e) {
            }

            onUpdate() {
            }

            onLateUpdate() {
            }

            onPreRender() {
            }

            onPostRender() {
            }

            onDisable() {
            }

            onDestroy() {
            }
        }

        class GraphicAnimation extends FrameAnimation {
            constructor() {
                super(...arguments), this._nodeIDAniDic = {}
            }

            _parseNodeList(uiView) {
                this._nodeList || (this._nodeList = []), this._nodeDefaultProps[uiView.compId] = uiView.props, uiView.compId && this._nodeList.push(uiView.compId);
                var childs = uiView.child;
                if (childs) {
                    var i, len = childs.length;
                    for (i = 0; i < len; i++) this._parseNodeList(childs[i])
                }
            }

            _calGraphicData(aniData) {
                var key;
                if (this._setUp(null, aniData), this._createGraphicData(), this._nodeIDAniDic) for (key in this._nodeIDAniDic) this._nodeIDAniDic[key] = null
            }

            _createGraphicData() {
                var i, preGraphic, gList = [], len = this.count, animationDataNew = this._usedFrames;
                for (animationDataNew || (animationDataNew = []), i = 0; i < len; i++) !animationDataNew[i] && preGraphic || (preGraphic = this._createFrameGraphic(i)), gList.push(preGraphic);
                this._gList = gList
            }

            _createFrameGraphic(frame) {
                var g = new Graphics;
                return GraphicAnimation._rootMatrix || (GraphicAnimation._rootMatrix = new Matrix), this._updateNodeGraphic(this._rootNode, frame, GraphicAnimation._rootMatrix, g), g
            }

            _updateNodeGraphic(node, frame, parentTransfrom, g, alpha = 1) {
                var tNodeG, tResultTransform, tTex;
                (tNodeG = this._nodeGDic[node.compId] = this._getNodeGraphicData(node.compId, frame, this._nodeGDic[node.compId])).resultTransform || (tNodeG.resultTransform = new Matrix), tResultTransform = tNodeG.resultTransform, Matrix.mul(tNodeG.transform, parentTransfrom, tResultTransform);
                var tGraphicAlpha = tNodeG.alpha * alpha;
                if (!(tGraphicAlpha < .01)) {
                    tNodeG.skin && (tTex = this._getTextureByUrl(tNodeG.skin)) && (tResultTransform._checkTransform() ? (g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height, tResultTransform, tGraphicAlpha), tNodeG.resultTransform = null) : g.drawTexture(tTex, tResultTransform.tx, tResultTransform.ty, tNodeG.width, tNodeG.height, null, tGraphicAlpha));
                    var i, len, childs = node.child;
                    if (childs) for (len = childs.length, i = 0; i < len; i++) this._updateNodeGraphic(childs[i], frame, tResultTransform, g, tGraphicAlpha)
                }
            }

            _updateNoChilds(tNodeG, g) {
                if (tNodeG.skin) {
                    var tTex = this._getTextureByUrl(tNodeG.skin);
                    if (tTex) {
                        var tTransform = tNodeG.transform;
                        tTransform._checkTransform(), !tTransform._bTransform ? g.drawTexture(tTex, tTransform.tx, tTransform.ty, tNodeG.width, tNodeG.height, null, tNodeG.alpha) : g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height, tTransform.clone(), tNodeG.alpha)
                    }
                }
            }

            _updateNodeGraphic2(node, frame, g) {
                var tNodeG;
                if (tNodeG = this._nodeGDic[node.compId] = this._getNodeGraphicData(node.compId, frame, this._nodeGDic[node.compId]), node.child) {
                    var onlyTranslate, hasTrans, ifSave, tTransform = tNodeG.transform;
                    tTransform._checkTransform(), hasTrans = (onlyTranslate = !tTransform._bTransform) && (0 != tTransform.tx || 0 != tTransform.ty), (ifSave = tTransform._bTransform || 1 != tNodeG.alpha) && g.save(), 1 != tNodeG.alpha && g.alpha(tNodeG.alpha), onlyTranslate ? hasTrans && g.translate(tTransform.tx, tTransform.ty) : g.transform(tTransform.clone());
                    var tTex, i, len, childs = node.child;
                    if (tNodeG.skin && (tTex = this._getTextureByUrl(tNodeG.skin)) && g.drawImage(tTex, 0, 0, tNodeG.width, tNodeG.height), childs) for (len = childs.length, i = 0; i < len; i++) this._updateNodeGraphic2(childs[i], frame, g);
                    ifSave ? g.restore() : onlyTranslate ? hasTrans && g.translate(-tTransform.tx, -tTransform.ty) : g.transform(tTransform.clone().invert())
                } else this._updateNoChilds(tNodeG, g)
            }

            _calculateKeyFrames(node) {
                super._calculateKeyFrames(node), this._nodeIDAniDic[node.target] = node
            }

            getNodeDataByID(nodeID) {
                return this._nodeIDAniDic[nodeID]
            }

            _getParams(obj, params, frame, obj2) {
                var rst = GraphicAnimation._temParam;
                rst.length = params.length;
                var i, len = params.length;
                for (i = 0; i < len; i++) rst[i] = this._getObjVar(obj, params[i][0], frame, params[i][1], obj2);
                return rst
            }

            _getObjVar(obj, key, frame, noValue, obj2) {
                if (key in obj) {
                    var vArr = obj[key];
                    return frame >= vArr.length && (frame = vArr.length - 1), obj[key][frame]
                }
                return key in obj2 ? obj2[key] : noValue
            }

            _getNodeGraphicData(nodeID, frame, rst) {
                rst || (rst = new GraphicNode), rst.transform ? rst.transform.identity() : rst.transform = new Matrix;
                var node = this.getNodeDataByID(nodeID);
                if (!node) return rst;
                var width, height, tex, frameData = node.frames,
                    params = this._getParams(frameData, GraphicAnimation._drawTextureCmd, frame, this._nodeDefaultProps[nodeID]),
                    url = params[0], px = params[5], py = params[6], aX = params[13], aY = params[14], sx = params[7],
                    sy = params[8], rotate = params[9], skewX = params[11], skewY = params[12];
                width = params[3], height = params[4], 0 != width && 0 != height || (url = null), -1 == width && (width = 0), -1 == height && (height = 0), rst.skin = url, rst.width = width, rst.height = height, url && ((tex = this._getTextureByUrl(url)) ? (width || (width = tex.sourceWidth), height || (height = tex.sourceHeight)) : console.warn("lost skin:", url, ",you may load pics first")), rst.alpha = params[10];
                var m = rst.transform;
                0 != aX && (px = aX * width), 0 != aY && (py = aY * height), 0 == px && 0 == py || m.translate(-px, -py);
                var tm = null;
                if (rotate || 1 !== sx || 1 !== sy || skewX || skewY) {
                    (tm = GraphicAnimation._tempMt).identity(), tm._bTransform = !0;
                    var skx = .0174532922222222 * (rotate - skewX), sky = .0174532922222222 * (rotate + skewY),
                        cx = Math.cos(sky), ssx = Math.sin(sky), cy = Math.sin(skx), ssy = Math.cos(skx);
                    tm.a = sx * cx, tm.b = sx * ssx, tm.c = -sy * cy, tm.d = sy * ssy, tm.tx = tm.ty = 0
                }
                return tm && (m = Matrix.mul(m, tm, m)), m.translate(params[1], params[2]), rst
            }

            _getTextureByUrl(url) {
                return Loader.getRes(url)
            }

            setAniData(uiView, aniName = null) {
                if (uiView.animations) {
                    this._nodeDefaultProps = {}, this._nodeGDic = {}, this._nodeList && (this._nodeList.length = 0), this._rootNode = uiView, this._parseNodeList(uiView);
                    var i, tAniO, aniDic = {}, anilist = [], animations = uiView.animations, len = animations.length;
                    for (i = 0; i < len; i++) if (tAniO = animations[i], this._labels = null, (!aniName || aniName == tAniO.name) && tAniO) {
                        try {
                            this._calGraphicData(tAniO)
                        } catch (e) {
                            console.warn("parse animation fail:" + tAniO.name + ",empty animation created"), this._gList = []
                        }
                        var frameO = {};
                        frameO.interval = 1e3 / tAniO.frameRate, frameO.frames = this._gList, frameO.labels = this._labels, frameO.name = tAniO.name, anilist.push(frameO), aniDic[tAniO.name] = frameO
                    }
                    this.animationList = anilist, this.animationDic = aniDic
                }
                GraphicAnimation._temParam.length = 0
            }

            parseByData(aniData) {
                var rootNode, aniO;
                rootNode = aniData.nodeRoot, aniO = aniData.aniO, delete aniData.nodeRoot, delete aniData.aniO, this._nodeDefaultProps = {}, this._nodeGDic = {}, this._nodeList && (this._nodeList.length = 0), this._rootNode = rootNode, this._parseNodeList(rootNode), this._labels = null;
                try {
                    this._calGraphicData(aniO)
                } catch (e) {
                    console.warn("parse animation fail:" + aniO.name + ",empty animation created"), this._gList = []
                }
                var frameO = aniData;
                return frameO.interval = 1e3 / aniO.frameRate, frameO.frames = this._gList, frameO.labels = this._labels, frameO.name = aniO.name, frameO
            }

            setUpAniData(uiView) {
                if (uiView.animations) {
                    var i, tAniO, aniDic = {}, anilist = [], animations = uiView.animations, len = animations.length;
                    for (i = 0; i < len; i++) if (tAniO = animations[i]) {
                        var frameO = {};
                        frameO.name = tAniO.name, frameO.aniO = tAniO, frameO.nodeRoot = uiView, anilist.push(frameO), aniDic[tAniO.name] = frameO
                    }
                    this.animationList = anilist, this.animationDic = aniDic
                }
            }

            _clear() {
                this.animationList = null, this.animationDic = null, this._gList = null, this._nodeGDic = null
            }

            static parseAnimationByData(animationObject) {
                var rst;
                return GraphicAnimation._I || (GraphicAnimation._I = new GraphicAnimation), rst = GraphicAnimation._I.parseByData(animationObject), GraphicAnimation._I._clear(), rst
            }

            static parseAnimationData(aniData) {
                var rst;
                return GraphicAnimation._I || (GraphicAnimation._I = new GraphicAnimation), GraphicAnimation._I.setUpAniData(aniData), (rst = {}).animationList = GraphicAnimation._I.animationList, rst.animationDic = GraphicAnimation._I.animationDic, GraphicAnimation._I._clear(), rst
            }
        }

        GraphicAnimation._drawTextureCmd = [["skin", null], ["x", 0], ["y", 0], ["width", -1], ["height", -1], ["pivotX", 0], ["pivotY", 0], ["scaleX", 1], ["scaleY", 1], ["rotation", 0], ["alpha", 1], ["skewX", 0], ["skewY", 0], ["anchorX", 0], ["anchorY", 0]], GraphicAnimation._temParam = [], GraphicAnimation._tempMt = new Matrix;

        class GraphicNode {
            constructor() {
                this.alpha = 1
            }
        }

        class Animation extends AnimationBase {
            constructor() {
                super(), this._setControlNode(this)
            }

            destroy(destroyChild = !0) {
                this.stop(), super.destroy(destroyChild), this._frames = null, this._labels = null
            }

            play(start = 0, loop = !0, name = "") {
                name && this._setFramesFromCache(name, !0), super.play(start, loop, name)
            }

            _setFramesFromCache(name, showWarn = !1) {
                if (this._url && (name = this._url + "#" + name), name && Animation.framesMap[name]) {
                    var tAniO = Animation.framesMap[name];
                    return tAniO instanceof Array ? (this._frames = Animation.framesMap[name], this._count = this._frames.length) : (tAniO.nodeRoot && (Animation.framesMap[name] = GraphicAnimation.parseAnimationByData(tAniO), tAniO = Animation.framesMap[name]), this._frames = tAniO.frames, this._count = this._frames.length, this._frameRateChanged || (this._interval = tAniO.interval), this._labels = this._copyLabels(tAniO.labels)), !0
                }
                return showWarn && console.log("ani not found:", name), !1
            }

            _copyLabels(labels) {
                if (!labels) return null;
                var rst, key;
                for (key in rst = {}, labels) rst[key] = Utils.copyArray([], labels[key]);
                return rst
            }

            _frameLoop() {
                this._visible && this._style.alpha > .01 && this._frames && super._frameLoop()
            }

            _displayToIndex(value) {
                this._frames && (this.graphics = this._frames[value])
            }

            get frames() {
                return this._frames
            }

            set frames(value) {
                this._frames = value, value && (this._count = value.length, this._actionName && this._setFramesFromCache(this._actionName, !0), this.index = this._index)
            }

            set source(value) {
                value.indexOf(".ani") > -1 ? this.loadAnimation(value) : value.indexOf(".json") > -1 || value.indexOf("als") > -1 || value.indexOf("atlas") > -1 ? this.loadAtlas(value) : this.loadImages(value.split(","))
            }

            set autoAnimation(value) {
                this.play(0, !0, value)
            }

            set autoPlay(value) {
                value ? this.play() : this.stop()
            }

            clear() {
                return super.clear(), this.stop(), this.graphics = null, this._frames = null, this._labels = null, this
            }

            loadImages(urls, cacheName = "") {
                return this._url = "", this._setFramesFromCache(cacheName) || (this.frames = Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] : Animation.createFrames(urls, cacheName)), this
            }

            loadAtlas(url, loaded = null, cacheName = "") {
                this._url = "";
                var _this = this;
                if (!_this._setFramesFromCache(cacheName)) {
                    function onLoaded(loadUrl) {
                        url === loadUrl && (_this.frames = Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] : Animation.createFrames(url, cacheName), loaded && loaded.run())
                    }

                    Loader.getAtlas(url) ? onLoaded(url) : ILaya.loader.load(url, Handler.create(null, onLoaded, [url]), null, Loader.ATLAS)
                }
                return this
            }

            loadAnimation(url, loaded = null, atlas = null) {
                this._url = url;
                return this._actionName || (this._actionName = ""), this._setFramesFromCache(this._actionName) ? (this._setFramesFromCache(this._actionName, !0), this.index = 0, loaded && loaded.run()) : !atlas || Loader.getAtlas(atlas) ? this._loadAnimationData(url, loaded, atlas) : ILaya.loader.load(atlas, Handler.create(this, this._loadAnimationData, [url, loaded, atlas]), null, Loader.ATLAS), this
            }

            _loadAnimationData(url, loaded = null, atlas = null) {
                if (!atlas || Loader.getAtlas(atlas)) {
                    var _this = this;
                    Loader.getRes(url) ? onLoaded(url) : ILaya.loader.load(url, Handler.create(null, onLoaded, [url]), null, Loader.JSON)
                } else console.warn("atlas load fail:" + atlas);

                function onLoaded(loadUrl) {
                    if (Loader.getRes(loadUrl)) {
                        if (url === loadUrl) {
                            var tAniO;
                            if (Animation.framesMap[url + "#"]) _this._setFramesFromCache(_this._actionName, !0), _this.index = 0, _this._resumePlay(); else {
                                var aniData = GraphicAnimation.parseAnimationData(Loader.getRes(url));
                                if (!aniData) return;
                                var i, defaultO, aniList = aniData.animationList, len = aniList.length;
                                for (i = 0; i < len; i++) tAniO = aniList[i], Animation.framesMap[url + "#" + tAniO.name] = tAniO, defaultO || (defaultO = tAniO);
                                defaultO && (Animation.framesMap[url + "#"] = defaultO, _this._setFramesFromCache(_this._actionName, !0), _this.index = 0), _this._resumePlay()
                            }
                            loaded && loaded.run()
                        }
                        Loader.clearRes(url)
                    } else Animation.framesMap[url + "#"] && (_this._setFramesFromCache(this._actionName, !0), _this.index = 0, _this._resumePlay(), loaded && loaded.run())
                }
            }

            static createFrames(url, name) {
                var arr;
                if ("string" == typeof url) {
                    var atlas = Loader.getAtlas(url);
                    if (atlas && atlas.length) {
                        arr = [];
                        for (var i = 0, n = atlas.length; i < n; i++) {
                            var g = new Graphics;
                            g.drawImage(Loader.getRes(atlas[i]), 0, 0), arr.push(g)
                        }
                    }
                } else if (url instanceof Array) for (arr = [], i = 0, n = url.length; i < n; i++) (g = new Graphics).loadImage(url[i], 0, 0), arr.push(g);
                return name && (Animation.framesMap[name] = arr), arr
            }

            static clearCache(key) {
                var val, cache = Animation.framesMap, key2 = key + "#";
                for (val in cache) val !== key && 0 !== val.indexOf(key2) || delete Animation.framesMap[val]
            }
        }

        Animation.framesMap = {}, ILaya.regClass(Animation), ClassUtils.regClass("laya.display.Animation", Animation), ClassUtils.regClass("Laya.Animation", Animation);

        class EffectAnimation extends FrameAnimation {
            constructor() {
                super(...arguments), this._initData = {}
            }

            set target(v) {
                this._target && this._target.off(EffectAnimation.EFFECT_BEGIN, this, this._onOtherBegin), this._target = v, this._target && this._target.on(EffectAnimation.EFFECT_BEGIN, this, this._onOtherBegin), this._addEvent()
            }

            get target() {
                return this._target
            }

            _onOtherBegin(effect) {
                effect !== this && this.stop()
            }

            set playEvent(event) {
                this._playEvent = event, event && this._addEvent()
            }

            _addEvent() {
                this._target && this._playEvent && (this._setControlNode(this._target), this._target.on(this._playEvent, this, this._onPlayAction))
            }

            _onPlayAction() {
                this.play(0, !1)
            }

            play(start = 0, loop = !0, name = "") {
                this._target && (this._target.event(EffectAnimation.EFFECT_BEGIN, [this]), this._recordInitData(), super.play(start, loop, name))
            }

            _recordInitData() {
                var i, len, key;
                if (this._aniKeys) for (len = this._aniKeys.length, i = 0; i < len; i++) key = this._aniKeys[i], this._initData[key] = this._target[key]
            }

            set effectClass(classStr) {
                if (this._effectClass = ClassUtils.getClass(classStr), this._effectClass) {
                    var uiData = this._effectClass.uiView;
                    if (uiData) {
                        var aniData = uiData.animations;
                        if (aniData && aniData[0]) {
                            var data = aniData[0];
                            this._setUp({}, data), data.nodes && data.nodes[0] && (this._aniKeys = data.nodes[0].keys)
                        }
                    }
                }
            }

            set effectData(uiData) {
                if (uiData) {
                    var aniData = uiData.animations;
                    if (aniData && aniData[0]) {
                        var data = aniData[0];
                        this._setUp({}, data), data.nodes && data.nodes[0] && (this._aniKeys = data.nodes[0].keys)
                    }
                }
            }

            _displayToIndex(value) {
                if (this._animationData) {
                    value < 0 && (value = 0), value > this._count && (value = this._count);
                    var i, nodes = this._animationData.nodes, len = nodes.length;
                    for (len = len > 1 ? 1 : len, i = 0; i < len; i++) this._displayNodeToFrame(nodes[i], value)
                }
            }

            _displayNodeToFrame(node, frame, targetDic = null) {
                if (this._target) {
                    var key, propFrames, value, i, tSecondFrame, easeFun, tKeyFrames, startFrame, endFrame,
                        target = this._target, frames = node.frames, keys = node.keys, len = keys.length,
                        secondFrames = node.secondFrames;
                    for (i = 0; i < len; i++) propFrames = frames[key = keys[i]], -1 == (tSecondFrame = secondFrames[key]) ? value = this._initData[key] : frame < tSecondFrame ? (startFrame = (tKeyFrames = node.keyframes[key])[0]).tween ? (null == (easeFun = Ease[startFrame.tweenMethod]) && (easeFun = Ease.linearNone), endFrame = tKeyFrames[1], value = easeFun(frame, this._initData[key], endFrame.value - this._initData[key], endFrame.index)) : value = this._initData[key] : value = propFrames.length > frame ? propFrames[frame] : propFrames[propFrames.length - 1], target[key] = value
                }
            }

            _calculateKeyFrames(node) {
                super._calculateKeyFrames(node);
                var key, tKeyFrames, keyFrames = node.keyframes, secondFrames = (node.target, {});
                for (key in node.secondFrames = secondFrames, keyFrames) (tKeyFrames = keyFrames[key]).length <= 1 ? secondFrames[key] = -1 : secondFrames[key] = tKeyFrames[1].index
            }
        }

        EffectAnimation.EFFECT_BEGIN = "effectbegin", ClassUtils.regClass("laya.display.EffectAnimation", EffectAnimation), ClassUtils.regClass("Laya.EffectAnimation", EffectAnimation);

        class SceneLoader extends EventDispatcher {
            constructor() {
                super(), this._completeHandler = new Handler(this, this.onOneLoadComplete), this.reset()
            }

            reset() {
                this._toLoadList = [], this._isLoading = !1, this.totalCount = 0
            }

            get leftCount() {
                return this._isLoading ? this._toLoadList.length + 1 : this._toLoadList.length
            }

            get loadedCount() {
                return this.totalCount - this.leftCount
            }

            load(url, is3D = !1, ifCheck = !0) {
                var i, len;
                if (url instanceof Array) for (len = url.length, i = 0; i < len; i++) this._addToLoadList(url[i], is3D); else this._addToLoadList(url, is3D);
                ifCheck && this._checkNext()
            }

            _addToLoadList(url, is3D = !1) {
                this._toLoadList.indexOf(url) >= 0 || Loader.getRes(url) || (is3D ? this._toLoadList.push({url: url}) : this._toLoadList.push(url), this.totalCount++)
            }

            _checkNext() {
                if (!this._isLoading) {
                    if (0 == this._toLoadList.length) return void this.event(Event.COMPLETE);
                    var tItem;
                    "string" == typeof (tItem = this._toLoadList.pop()) ? this.loadOne(tItem) : this.loadOne(tItem.url, !0)
                }
            }

            loadOne(url, is3D = !1) {
                this._curUrl = url;
                var type = Utils.getFileExtension(this._curUrl);
                is3D ? ILaya.loader.create(url, this._completeHandler) : SceneLoader.LoadableExtensions[type] ? ILaya.loader.load(url, this._completeHandler, null, SceneLoader.LoadableExtensions[type]) : url != AtlasInfoManager.getFileLoadPath(url) || SceneLoader.No3dLoadTypes[type] || !LoaderManager.createMap[type] ? ILaya.loader.load(url, this._completeHandler) : ILaya.loader.create(url, this._completeHandler)
            }

            onOneLoadComplete() {
                this._isLoading = !1, Loader.getRes(this._curUrl) || console.log("Fail to load:", this._curUrl);
                var dataO, type = Utils.getFileExtension(this._curUrl);
                SceneLoader.LoadableExtensions[type] && ((dataO = Loader.getRes(this._curUrl)) && dataO instanceof Prefab && (dataO = dataO.json), dataO && (dataO.loadList && this.load(dataO.loadList, !1, !1), dataO.loadList3D && this.load(dataO.loadList3D, !0, !1)));
                "sk" == type && this.load(this._curUrl.replace(".sk", ".png"), !1, !1), this.event(Event.PROGRESS, this.getProgress()), this._checkNext()
            }

            getProgress() {
                return this.loadedCount / this.totalCount
            }
        }

        SceneLoader.LoadableExtensions = {
            scene: Loader.JSON,
            scene3d: Loader.JSON,
            ani: Loader.JSON,
            ui: Loader.JSON,
            prefab: Loader.PREFAB
        }, SceneLoader.No3dLoadTypes = {png: !0, jpg: !0, txt: !0};

        class Scene extends Sprite {
            constructor(createChildren = !0) {
                super(), this.autoDestroyAtClosed = !1, this.url = null, this._viewCreated = !1, this._$componentType = "Scene", this._setBit(Const.NOT_READY, !0), Scene.unDestroyedScenes.push(this), this._scene = this, createChildren && this.createChildren()
            }

            createChildren() {
            }

            loadScene(path) {
                var url = path.indexOf(".") > -1 ? path : path + ".scene", view = ILaya.loader.getRes(url);
                if (view) this.createView(view); else {
                    ILaya.loader.resetProgress();
                    var loader = new SceneLoader;
                    loader.on(Event.COMPLETE, this, this._onSceneLoaded, [url]), loader.load(url)
                }
            }

            _onSceneLoaded(url) {
                this.createView(ILaya.Loader.getRes(url))
            }

            createView(view) {
                view && !this._viewCreated && (this._viewCreated = !0, SceneUtils.createByData(this, view))
            }

            getNodeByID(id) {
                return this._idMap ? this._idMap[id] : null
            }

            open(closeOther = !0, param = null) {
                closeOther && Scene.closeAll(), Scene.root.addChild(this), this.onOpened(param)
            }

            onOpened(param) {
            }

            close(type = null) {
                this.onClosed(type), this.autoDestroyAtClosed ? this.destroy() : this.removeSelf()
            }

            onClosed(type = null) {
            }

            destroy(destroyChild = !0) {
                this._idMap = null, super.destroy(destroyChild);
                for (var list = Scene.unDestroyedScenes, i = list.length - 1; i > -1; i--) if (list[i] === this) return void list.splice(i, 1)
            }

            set scaleX(value) {
                super.get_scaleX() != value && (super.set_scaleX(value), this.event(Event.RESIZE))
            }

            get scaleX() {
                return super.scaleX
            }

            set scaleY(value) {
                super.get_scaleY() != value && (super.set_scaleY(value), this.event(Event.RESIZE))
            }

            get scaleY() {
                return super.scaleY
            }

            get width() {
                if (this._width) return this._width;
                for (var max = 0, i = this.numChildren - 1; i > -1; i--) {
                    var comp = this.getChildAt(i);
                    comp._visible && (max = Math.max(comp._x + comp.width * comp.scaleX, max))
                }
                return max
            }

            set width(value) {
                super.get_width() != value && (super.set_width(value), this.callLater(this._sizeChanged))
            }

            get height() {
                if (this._height) return this._height;
                for (var max = 0, i = this.numChildren - 1; i > -1; i--) {
                    var comp = this.getChildAt(i);
                    comp._visible && (max = Math.max(comp._y + comp.height * comp.scaleY, max))
                }
                return max
            }

            set height(value) {
                super.get_height() != value && (super.set_height(value), this.callLater(this._sizeChanged))
            }

            _sizeChanged() {
                this.event(Event.RESIZE)
            }

            static get root() {
                return Scene._root || (Scene._root = ILaya.stage.addChild(new Sprite), Scene._root.name = "root", ILaya.stage.on("resize", null, () => {
                    Scene._root.size(ILaya.stage.width, ILaya.stage.height), Scene._root.event(Event.RESIZE)
                }), Scene._root.size(ILaya.stage.width, ILaya.stage.height), Scene._root.event(Event.RESIZE)), Scene._root
            }

            get timer() {
                return this._timer || ILaya.timer
            }

            set timer(value) {
                this._timer = value
            }

            static load(url, complete = null, progress = null) {
                ILaya.loader.resetProgress();
                var loader = new SceneLoader;

                function onProgress(value) {
                    Scene._loadPage && Scene._loadPage.event("progress", value), progress && progress.runWith(value)
                }

                loader.on(Event.PROGRESS, null, onProgress), loader.once(Event.COMPLETE, null, function () {
                    loader.off(Event.PROGRESS, null, onProgress);
                    var obj = ILaya.Loader.getRes(url);
                    if (!obj) throw"Can not find scene:" + url;
                    if (!obj.props) throw"Scene data is error:" + url;
                    var runtime = obj.props.runtime ? obj.props.runtime : obj.type,
                        clas = ILaya.ClassUtils.getClass(runtime);
                    if ("instance" == obj.props.renderType) var scene = clas.instance || (clas.instance = new clas); else scene = new clas;
                    if (!(scene && scene instanceof Node)) throw"Can not find scene:" + runtime;
                    scene.url = url, scene._getBit(Const.NOT_READY) ? (scene.on("onViewCreated", null, function () {
                        complete && complete.runWith(scene)
                    }), scene.createView(obj)) : complete && complete.runWith(scene), Scene.hideLoadingPage()
                }), loader.load(url)
            }

            static open(url, closeOther = !0, param = null, complete = null, progress = null) {
                if (param instanceof Handler) {
                    var temp = complete;
                    complete = param, param = temp
                }
                Scene.showLoadingPage(), Scene.load(url, Handler.create(null, this._onSceneLoaded, [closeOther, complete, param]), progress)
            }

            static _onSceneLoaded(closeOther, complete, param, scene) {
                scene.open(closeOther, param), complete && complete.runWith(scene)
            }

            static close(url, name = "") {
                for (var flag = !1, list = Scene.unDestroyedScenes, i = 0, n = list.length; i < n; i++) {
                    var scene = list[i];
                    scene && scene.parent && scene.url === url && scene.name == name && (scene.close(), flag = !0)
                }
                return flag
            }

            static closeAll() {
                for (var root = Scene.root, i = 0, n = root.numChildren; i < n; i++) {
                    var scene = root.getChildAt(0);
                    scene instanceof Scene ? scene.close() : scene.removeSelf()
                }
            }

            static destroy(url, name = "") {
                for (var flag = !1, list = Scene.unDestroyedScenes, i = 0, n = list.length; i < n; i++) {
                    var scene = list[i];
                    scene.url === url && scene.name == name && (scene.destroy(), flag = !0)
                }
                return flag
            }

            static gc() {
                Resource.destroyUnusedResources()
            }

            static setLoadingPage(loadPage) {
                Scene._loadPage != loadPage && (Scene._loadPage = loadPage)
            }

            static showLoadingPage(param = null, delay = 500) {
                Scene._loadPage && (ILaya.systemTimer.clear(null, Scene._showLoading), ILaya.systemTimer.clear(null, Scene._hideLoading), ILaya.systemTimer.once(delay, null, Scene._showLoading, [param], !1))
            }

            static _showLoading(param) {
                ILaya.stage.addChild(Scene._loadPage), Scene._loadPage.onOpened(param)
            }

            static _hideLoading() {
                Scene._loadPage.close()
            }

            static hideLoadingPage(delay = 500) {
                Scene._loadPage && (ILaya.systemTimer.clear(null, Scene._showLoading), ILaya.systemTimer.clear(null, Scene._hideLoading), ILaya.systemTimer.once(delay, null, Scene._hideLoading))
            }
        }

        Scene.unDestroyedScenes = [], ILaya.regClass(Scene), ClassUtils.regClass("laya.display.Scene", Scene), ClassUtils.regClass("Laya.Scene", Scene);

        class DrawCanvasCmd {
            constructor() {
                this._paramData = null
            }

            static create(texture, x, y, width, height) {
                return null
            }

            recover() {
                this._graphicsCmdEncoder = null, Pool.recover("DrawCanvasCmd", this)
            }

            get cmdID() {
                return DrawCanvasCmd.ID
            }
        }

        DrawCanvasCmd.ID = "DrawCanvasCmd", DrawCanvasCmd._DRAW_IMAGE_CMD_ENCODER_ = null, DrawCanvasCmd._PARAM_TEXTURE_POS_ = 2, DrawCanvasCmd._PARAM_VB_POS_ = 5;

        class DrawParticleCmd {
            static create(_temp) {
                var cmd = Pool.getItemByClass("DrawParticleCmd", DrawParticleCmd);
                return cmd._templ = _temp, cmd
            }

            recover() {
                this._templ = null, Pool.recover("DrawParticleCmd", this)
            }

            run(context, gx, gy) {
                context.drawParticle(gx, gy, this._templ)
            }

            get cmdID() {
                return DrawParticleCmd.ID
            }
        }

        DrawParticleCmd.ID = "DrawParticleCmd";

        class FilterSetterBase {
            constructor() {
            }

            paramChanged() {
                Laya.systemTimer.callLater(this, this.buildFilter)
            }

            buildFilter() {
                this._target && this.addFilter(this._target)
            }

            addFilter(sprite) {
                var preFilters;
                sprite && (sprite.filters ? (preFilters = sprite.filters).indexOf(this._filter) < 0 && (preFilters.push(this._filter), sprite.filters = Utils.copyArray([], preFilters)) : sprite.filters = [this._filter])
            }

            removeFilter(sprite) {
                sprite && (sprite.filters = null)
            }

            set target(value) {
                this._target != value && (this._target = value, this.paramChanged())
            }
        }

        class BlurFilterGLRender {
            render(rt, ctx, width, height, filter) {
                var shaderValue = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);
                this.setShaderInfo(shaderValue, filter, rt.width, rt.height), ctx.drawTarget(rt, 0, 0, width, height, Matrix.EMPTY.identity(), shaderValue)
            }

            setShaderInfo(shader, filter, w, h) {
                shader.defines.add(Filter.BLUR);
                var sv = shader;
                BlurFilterGLRender.blurinfo[0] = w, BlurFilterGLRender.blurinfo[1] = h, sv.blurInfo = BlurFilterGLRender.blurinfo;
                var sigma = filter.strength / 3, sigma2 = sigma * sigma;
                filter.strength_sig2_2sig2_gauss1[0] = filter.strength, filter.strength_sig2_2sig2_gauss1[1] = sigma2, filter.strength_sig2_2sig2_gauss1[2] = 2 * sigma2, filter.strength_sig2_2sig2_gauss1[3] = 1 / (2 * Math.PI * sigma2), sv.strength_sig2_2sig2_gauss1 = filter.strength_sig2_2sig2_gauss1
            }
        }

        BlurFilterGLRender.blurinfo = new Array(2);

        class BlurFilter extends Filter {
            constructor(strength = 4) {
                super(), this.strength_sig2_2sig2_gauss1 = [], this.strength = strength, this._glRender = new BlurFilterGLRender
            }

            get type() {
                return Filter.BLUR
            }

            getStrenth_sig2_2sig2_native() {
                this.strength_sig2_native || (this.strength_sig2_native = new Float32Array(4));
                var sigma = this.strength / 3, sigma2 = sigma * sigma;
                return this.strength_sig2_native[0] = this.strength, this.strength_sig2_native[1] = sigma2, this.strength_sig2_native[2] = 2 * sigma2, this.strength_sig2_native[3] = 1 / (2 * Math.PI * sigma2), this.strength_sig2_native
            }
        }

        class EffectBase extends Component {
            constructor() {
                super(...arguments), this.duration = 1e3, this.delay = 0, this.repeat = 0, this.autoDestroyAtComplete = !0
            }

            _onAwake() {
                this.target = this.target || this.owner, this.autoDestroyAtComplete && (this._comlete = Handler.create(this.target, this.target.destroy, null, !1)), this.eventName ? this.owner.on(this.eventName, this, this._exeTween) : this._exeTween()
            }

            _exeTween() {
                this._tween = this._doTween(), this._tween.repeat = this.repeat
            }

            _doTween() {
                return null
            }

            onReset() {
                this.duration = 1e3, this.delay = 0, this.repeat = 0, this.ease = null, this.target = null, this.eventName && (this.owner.off(this.eventName, this, this._exeTween), this.eventName = null), this._comlete && (this._comlete.recover(), this._comlete = null), this._tween && (this._tween.clear(), this._tween = null)
            }
        }

        class GlowFilterGLRender {
            setShaderInfo(shader, w, h, data) {
                shader.defines.add(data.type);
                var sv = shader;
                sv.u_blurInfo1 = data._sv_blurInfo1;
                var info2 = data._sv_blurInfo2;
                info2[0] = w, info2[1] = h, sv.u_blurInfo2 = info2, sv.u_color = data.getColor()
            }

            render(rt, ctx, width, height, filter) {
                var w = width, h = height, svBlur = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);
                this.setShaderInfo(svBlur, w, h, filter);
                var svCP = Value2D.create(ShaderDefines2D.TEXTURE2D, 0), matI = Matrix.TEMP.identity();
                ctx.drawTarget(rt, 0, 0, w, h, matI, svBlur), ctx.drawTarget(rt, 0, 0, w, h, matI, svCP)
            }
        }

        class GlowFilter extends Filter {
            constructor(color, blur = 4, offX = 6, offY = 6) {
                super(), this._elements = new Float32Array(9), this._sv_blurInfo1 = new Array(4), this._sv_blurInfo2 = [0, 0, 1, 0], this._color = new ColorUtils(color), this.blur = Math.min(blur, 20), this.offX = offX, this.offY = offY, this._sv_blurInfo1[0] = this._sv_blurInfo1[1] = this.blur, this._sv_blurInfo1[2] = offX, this._sv_blurInfo1[3] = -offY, this._glRender = new GlowFilterGLRender
            }

            get type() {
                return BlurFilter.GLOW
            }

            get offY() {
                return this._elements[6]
            }

            set offY(value) {
                this._elements[6] = value, this._sv_blurInfo1[3] = -value
            }

            get offX() {
                return this._elements[5]
            }

            set offX(value) {
                this._elements[5] = value, this._sv_blurInfo1[2] = value
            }

            getColor() {
                return this._color.arrColor
            }

            get blur() {
                return this._elements[4]
            }

            set blur(value) {
                this._elements[4] = value, this._sv_blurInfo1[0] = this._sv_blurInfo1[1] = value
            }

            getColorNative() {
                this._color_native || (this._color_native = new Float32Array(4));
                var color = this.getColor();
                return this._color_native[0] = color[0], this._color_native[1] = color[1], this._color_native[2] = color[2], this._color_native[3] = color[3], this._color_native
            }

            getBlurInfo1Native() {
                return this._blurInof1_native || (this._blurInof1_native = new Float32Array(4)), this._blurInof1_native[0] = this._blurInof1_native[1] = this.blur, this._blurInof1_native[2] = this.offX, this._blurInof1_native[3] = this.offY, this._blurInof1_native
            }

            getBlurInfo2Native() {
                return this._blurInof2_native || (this._blurInof2_native = new Float32Array(4)), this._blurInof2_native[2] = 1, this._blurInof2_native
            }
        }

        class KeyLocation {
        }

        KeyLocation.STANDARD = 0, KeyLocation.LEFT = 1, KeyLocation.RIGHT = 2, KeyLocation.NUM_PAD = 3;

        class Keyboard {
        }

        Keyboard.NUMBER_0 = 48, Keyboard.NUMBER_1 = 49, Keyboard.NUMBER_2 = 50, Keyboard.NUMBER_3 = 51, Keyboard.NUMBER_4 = 52, Keyboard.NUMBER_5 = 53, Keyboard.NUMBER_6 = 54, Keyboard.NUMBER_7 = 55, Keyboard.NUMBER_8 = 56, Keyboard.NUMBER_9 = 57, Keyboard.A = 65, Keyboard.B = 66, Keyboard.C = 67, Keyboard.D = 68, Keyboard.E = 69, Keyboard.F = 70, Keyboard.G = 71, Keyboard.H = 72, Keyboard.I = 73, Keyboard.J = 74, Keyboard.K = 75, Keyboard.L = 76, Keyboard.M = 77, Keyboard.N = 78, Keyboard.O = 79, Keyboard.P = 80, Keyboard.Q = 81, Keyboard.R = 82, Keyboard.S = 83, Keyboard.T = 84, Keyboard.U = 85, Keyboard.V = 86, Keyboard.W = 87, Keyboard.X = 88, Keyboard.Y = 89, Keyboard.Z = 90, Keyboard.F1 = 112, Keyboard.F2 = 113, Keyboard.F3 = 114, Keyboard.F4 = 115, Keyboard.F5 = 116, Keyboard.F6 = 117, Keyboard.F7 = 118, Keyboard.F8 = 119, Keyboard.F9 = 120, Keyboard.F10 = 121, Keyboard.F11 = 122, Keyboard.F12 = 123, Keyboard.F13 = 124, Keyboard.F14 = 125, Keyboard.F15 = 126, Keyboard.NUMPAD = 21, Keyboard.NUMPAD_0 = 96, Keyboard.NUMPAD_1 = 97, Keyboard.NUMPAD_2 = 98, Keyboard.NUMPAD_3 = 99, Keyboard.NUMPAD_4 = 100, Keyboard.NUMPAD_5 = 101, Keyboard.NUMPAD_6 = 102, Keyboard.NUMPAD_7 = 103, Keyboard.NUMPAD_8 = 104, Keyboard.NUMPAD_9 = 105, Keyboard.NUMPAD_ADD = 107, Keyboard.NUMPAD_DECIMAL = 110, Keyboard.NUMPAD_DIVIDE = 111, Keyboard.NUMPAD_ENTER = 108, Keyboard.NUMPAD_MULTIPLY = 106, Keyboard.NUMPAD_SUBTRACT = 109, Keyboard.SEMICOLON = 186, Keyboard.EQUAL = 187, Keyboard.COMMA = 188, Keyboard.MINUS = 189, Keyboard.PERIOD = 190, Keyboard.SLASH = 191, Keyboard.BACKQUOTE = 192, Keyboard.LEFTBRACKET = 219, Keyboard.BACKSLASH = 220, Keyboard.RIGHTBRACKET = 221, Keyboard.QUOTE = 222, Keyboard.ALTERNATE = 18, Keyboard.BACKSPACE = 8, Keyboard.CAPS_LOCK = 20, Keyboard.COMMAND = 15, Keyboard.CONTROL = 17, Keyboard.DELETE = 46, Keyboard.ENTER = 13, Keyboard.ESCAPE = 27, Keyboard.PAGE_UP = 33, Keyboard.PAGE_DOWN = 34, Keyboard.END = 35, Keyboard.HOME = 36, Keyboard.LEFT = 37, Keyboard.UP = 38, Keyboard.RIGHT = 39, Keyboard.DOWN = 40, Keyboard.SHIFT = 16, Keyboard.SPACE = 32, Keyboard.TAB = 9, Keyboard.INSERT = 45;

        class QuickTestTool {
            constructor() {
            }

            static getMCDName(type) {
                return QuickTestTool._typeToNameDic[type]
            }

            static showRenderTypeInfo(type, force = !1) {
                if (force || !QuickTestTool.showedDic[type]) {
                    if (QuickTestTool.showedDic[type] = !0, !QuickTestTool._rendertypeToStrDic[type]) {
                        var tType, arr = [];
                        for (tType = 1; tType <= type;) tType & type && arr.push(QuickTestTool.getMCDName(tType & type)), tType <<= 1;
                        QuickTestTool._rendertypeToStrDic[type] = arr.join(",")
                    }
                    console.log("cmd:", QuickTestTool._rendertypeToStrDic[type])
                }
            }

            static __init__() {
                QuickTestTool._typeToNameDic[SpriteConst.ALPHA] = "ALPHA", QuickTestTool._typeToNameDic[SpriteConst.TRANSFORM] = "TRANSFORM", QuickTestTool._typeToNameDic[SpriteConst.TEXTURE] = "TEXTURE", QuickTestTool._typeToNameDic[SpriteConst.GRAPHICS] = "GRAPHICS", QuickTestTool._typeToNameDic[SpriteConst.ONECHILD] = "ONECHILD", QuickTestTool._typeToNameDic[SpriteConst.CHILDS] = "CHILDS", QuickTestTool._typeToNameDic[SpriteConst.TRANSFORM | SpriteConst.ALPHA] = "TRANSFORM|ALPHA", QuickTestTool._typeToNameDic[SpriteConst.CANVAS] = "CANVAS", QuickTestTool._typeToNameDic[SpriteConst.BLEND] = "BLEND", QuickTestTool._typeToNameDic[SpriteConst.FILTERS] = "FILTERS", QuickTestTool._typeToNameDic[SpriteConst.MASK] = "MASK", QuickTestTool._typeToNameDic[SpriteConst.CLIP] = "CLIP", QuickTestTool._typeToNameDic[SpriteConst.LAYAGL3D] = "LAYAGL3D"
            }

            render(context, x, y) {
                QuickTestTool._addType(this._renderType), QuickTestTool.showRenderTypeInfo(this._renderType), RenderSprite.renders[this._renderType]._fun(this, context, x + this._x, y + this._y), this._repaint = 0
            }

            _stageRender(context, x, y) {
                QuickTestTool._countStart(), QuickTestTool._PreStageRender.call(ILaya.stage, context, x, y), QuickTestTool._countEnd()
            }

            static _countStart() {
                var key;
                for (key in QuickTestTool._countDic) QuickTestTool._countDic[key] = 0
            }

            static _countEnd() {
                QuickTestTool._i++, QuickTestTool._i > 60 && (QuickTestTool.showCountInfo(), QuickTestTool._i = 0)
            }

            static _addType(type) {
                QuickTestTool._countDic[type] ? QuickTestTool._countDic[type] += 1 : QuickTestTool._countDic[type] = 1
            }

            static showCountInfo() {
                var key;
                for (key in console.log("==================="), QuickTestTool._countDic) console.log("count:" + QuickTestTool._countDic[key]), QuickTestTool.showRenderTypeInfo(key, !0)
            }

            static enableQuickTest() {
                QuickTestTool.__init__(), Sprite.prototype.render = QuickTestTool.prototype.render, QuickTestTool._PreStageRender = Stage.prototype.render, Stage.prototype.render = QuickTestTool.prototype._stageRender
            }
        }

        QuickTestTool.showedDic = {}, QuickTestTool._rendertypeToStrDic = {}, QuickTestTool._typeToNameDic = {}, QuickTestTool._countDic = {}, QuickTestTool._i = 0;

        class ResourceVersion {
            static enable(manifestFile, callback, type = 2) {
                ResourceVersion.type = type, ILaya.loader.load(manifestFile, Handler.create(null, ResourceVersion.onManifestLoaded, [callback]), null, Loader.JSON)
            }

            static onManifestLoaded(callback, data) {
                ResourceVersion.manifest = data, URL.customFormat = ResourceVersion.addVersionPrefix, callback.run(), data || console.warn("资源版本清单文件不存在，不使用资源版本管理。忽略ERR_FILE_NOT_FOUND错误。")
            }

            static addVersionPrefix(originURL) {
                return originURL = URL.getAdptedFilePath(originURL), ResourceVersion.manifest && ResourceVersion.manifest[originURL] ? ResourceVersion.type == ResourceVersion.FILENAME_VERSION ? ResourceVersion.manifest[originURL] : ResourceVersion.manifest[originURL] + "/" + originURL : originURL
            }
        }

        ResourceVersion.FOLDER_VERSION = 1, ResourceVersion.FILENAME_VERSION = 2, ResourceVersion.type = ResourceVersion.FOLDER_VERSION;

        class Socket extends EventDispatcher {
            constructor(host = null, port = 0, byteClass = null, protocols = null) {
                super(), this.disableInput = !1, this.protocols = [], this._byteClass = byteClass || Byte, this.protocols = protocols, this.endian = Socket.BIG_ENDIAN, host && port > 0 && port < 65535 && this.connect(host, port)
            }

            get input() {
                return this._input
            }

            get output() {
                return this._output
            }

            get connected() {
                return this._connected
            }

            get endian() {
                return this._endian
            }

            set endian(value) {
                this._endian = value, null != this._input && (this._input.endian = value), null != this._output && (this._output.endian = value)
            }

            connect(host, port) {
                var url = "ws://" + host + ":" + port;
                this.connectByUrl(url)
            }

            connectByUrl(url) {
                null != this._socket && this.close(), this._socket && this.cleanSocket(), this.protocols && 0 != this.protocols.length ? this._socket = new Browser.window.WebSocket(url, this.protocols) : this._socket = new Browser.window.WebSocket(url), this._socket.binaryType = "arraybuffer", this._output = new this._byteClass, this._output.endian = this.endian, this._input = new this._byteClass, this._input.endian = this.endian, this._addInputPosition = 0, this._socket.onopen = (e => {
                    this._onOpen(e)
                }), this._socket.onmessage = (msg => {
                    this._onMessage(msg)
                }), this._socket.onclose = (e => {
                    this._onClose(e)
                }), this._socket.onerror = (e => {
                    this._onError(e)
                })
            }

            cleanSocket() {
                this.close(), this._connected = !1, this._socket.onopen = null, this._socket.onmessage = null, this._socket.onclose = null, this._socket.onerror = null, this._socket = null
            }

            close() {
                if (null != this._socket) try {
                    this._socket.close()
                } catch (e) {
                }
            }

            _onOpen(e) {
                this._connected = !0, this.event(Event.OPEN, e)
            }

            _onMessage(msg) {
                if (msg && msg.data) {
                    var data = msg.data;
                    if (this.disableInput && data) this.event(Event.MESSAGE, data); else {
                        this._input.length > 0 && this._input.bytesAvailable < 1 && (this._input.clear(), this._addInputPosition = 0);
                        var pre = this._input.pos;
                        !this._addInputPosition && (this._addInputPosition = 0), this._input.pos = this._addInputPosition, data && ("string" == typeof data ? this._input.writeUTFBytes(data) : this._input.writeArrayBuffer(data), this._addInputPosition = this._input.pos, this._input.pos = pre), this.event(Event.MESSAGE, data)
                    }
                }
            }

            _onClose(e) {
                this._connected = !1, this.event(Event.CLOSE, e)
            }

            _onError(e) {
                this.event(Event.ERROR, e)
            }

            send(data) {
                this._socket.send(data)
            }

            flush() {
                if (this._output && this._output.length > 0) {
                    var evt;
                    try {
                        this._socket && this._socket.send(this._output.__getBuffer().slice(0, this._output.length))
                    } catch (e) {
                        evt = e
                    }
                    this._output.endian = this.endian, this._output.clear(), evt && this.event(Event.ERROR, evt)
                }
            }
        }

        Socket.LITTLE_ENDIAN = "littleEndian", Socket.BIG_ENDIAN = "bigEndian";

        class HTMLChar {
            constructor() {
                this.reset()
            }

            setData(char, w, h, style) {
                return this.char = char, this.charNum = char.charCodeAt(0), this.x = this.y = 0, this.width = w, this.height = h, this.style = style, this.isWord = !HTMLChar._isWordRegExp.test(char), this
            }

            reset() {
                return this.x = this.y = this.width = this.height = 0, this.isWord = !1, this.char = null, this.charNum = 0, this.style = null, this
            }

            recover() {
                Pool.recover("HTMLChar", this.reset())
            }

            static create() {
                return Pool.getItemByClass("HTMLChar", HTMLChar)
            }

            _isChar() {
                return !0
            }

            _getCSSStyle() {
                return this.style
            }
        }

        HTMLChar._isWordRegExp = new RegExp("[\\w.]", "");

        class Log {
            static enable() {
                Log._logdiv || (Log._logdiv = Browser.createElement("div"), Log._logdiv.style.cssText = "border:white;padding:4px;overflow-y:auto;z-index:1000000;background:rgba(100,100,100,0.6);color:white;position: absolute;left:0px;top:0px;width:50%;height:50%;", Browser.document.body.appendChild(Log._logdiv), Log._btn = Browser.createElement("button"), Log._btn.innerText = "Hide", Log._btn.style.cssText = "z-index:1000001;position: absolute;left:10px;top:10px;", Log._btn.onclick = Log.toggle, Browser.document.body.appendChild(Log._btn))
            }

            static toggle() {
                var style = Log._logdiv.style;
                "" === style.display ? (Log._btn.innerText = "Show", style.display = "none") : (Log._btn.innerText = "Hide", style.display = "")
            }

            static print(value) {
                Log._logdiv && (Log._count >= Log.maxCount && Log.clear(), Log._count++, Log._logdiv.innerText += value + "\n", Log.autoScrollToBottom && Log._logdiv.scrollHeight - Log._logdiv.scrollTop - Log._logdiv.clientHeight < 50 && (Log._logdiv.scrollTop = Log._logdiv.scrollHeight))
            }

            static clear() {
                Log._logdiv.innerText = "", Log._count = 0
            }
        }

        Log._count = 0, Log.maxCount = 50, Log.autoScrollToBottom = !0;
        let DATANUM = 300;

        class PerfData {
            constructor(id, color, name, scale) {
                this.scale = 1, this.datas = new Array(DATANUM), this.datapos = 0, this.id = id, this.color = color, this.name = name, this.scale = scale
            }

            addData(v) {
                this.datas[this.datapos] = v, this.datapos++, this.datapos %= DATANUM
            }
        }

        class PerfHUD extends Sprite {
            constructor() {
                super(), this.datas = [], this.xdata = new Array(PerfHUD.DATANUM), this.ydata = new Array(PerfHUD.DATANUM), this.hud_width = 800, this.hud_height = 200, this.gMinV = 0, this.gMaxV = 100, this.textSpace = 40, this.sttm = 0, PerfHUD.inst = this, this._renderType |= SpriteConst.CUSTOM, this._setRenderType(this._renderType), this._setCustomRender(), this.addDataDef(0, 16777215, "frame", 1), this.addDataDef(1, 65280, "update", 1), this.addDataDef(2, 16711680, "flush", 1), PerfHUD._now = performance ? performance.now.bind(performance) : Date.now
            }

            now() {
                return PerfHUD._now()
            }

            start() {
                this.sttm = PerfHUD._now()
            }

            end(i) {
                var dt = PerfHUD._now() - this.sttm;
                this.updateValue(i, dt)
            }

            config(w, h) {
                this.hud_width = w, this.hud_height = h
            }

            addDataDef(id, color, name, scale) {
                this.datas[id] = new PerfData(id, color, name, scale)
            }

            updateValue(id, v) {
                this.datas[id].addData(v)
            }

            v2y(v) {
                this._y, this.hud_height, this.gMinV, this.gMaxV;
                return this._y + this.hud_height * (1 - (v - this.gMinV) / this.gMaxV)
            }

            drawHLine(ctx, v, color, text) {
                var sx = this._x, sy = (this._x, this.hud_width, this.v2y(v));
                ctx.fillText(text, sx, sy - 6, null, "green", null), sx += this.textSpace, ctx.fillStyle = color, ctx.fillRect(sx, sy, this._x + this.hud_width, 1, null)
            }

            customRender(ctx, x, y) {
                var now = performance.now();
                PerfHUD._lastTm <= 0 && (PerfHUD._lastTm = now), this.updateValue(0, now - PerfHUD._lastTm), PerfHUD._lastTm = now, ctx.save(), ctx.fillRect(this._x, this._y, this.hud_width, this.hud_height + 4, "#000000cc"), ctx.globalAlpha = .9, this.drawHLine(ctx, 0, "green", "    0"), this.drawHLine(ctx, 10, "green", "  10"), this.drawHLine(ctx, 16.667, "red", " "), this.drawHLine(ctx, 20, "green", "50|20"), this.drawHLine(ctx, 33.334, "yellow", ""), this.drawHLine(ctx, 16.667 * 3, "yellow", ""), this.drawHLine(ctx, 66.668, "yellow", ""), this.drawHLine(ctx, 50, "green", "20|50"), this.drawHLine(ctx, 100, "green", "10|100");
                for (var di = 0, sz = this.datas.length; di < sz; di++) {
                    var cd = this.datas[di];
                    if (cd) {
                        var dtlen = cd.datas.length, dx = (this.hud_width - this.textSpace) / dtlen, cx = cd.datapos,
                            _cx = this._x + this.textSpace;
                        ctx.fillStyle = cd.color;
                        for (var dtsz = dtlen; cx < dtsz; cx++) {
                            var sty = this.v2y(cd.datas[cx] * cd.scale);
                            ctx.fillRect(_cx, sty, dx, this.hud_height + this._y - sty, null), _cx += dx
                        }
                        for (cx = 0; cx < cd.datapos; cx++) sty = this.v2y(cd.datas[cx] * cd.scale), ctx.fillRect(_cx, sty, dx, this.hud_height + this._y - sty, null), _cx += dx
                    }
                }
                ctx.restore()
            }
        }

        PerfHUD._lastTm = 0, PerfHUD._now = null, PerfHUD.DATANUM = 300, PerfHUD.drawTexTm = 0;

        class PoolCache {
            constructor() {
                this.maxCount = 1e3
            }

            getCacheList() {
                return Pool.getPoolBySign(this.sign)
            }

            tryDispose(force) {
                var list;
                (list = Pool.getPoolBySign(this.sign)).length > this.maxCount && list.splice(this.maxCount, list.length - this.maxCount)
            }

            static addPoolCacheManager(sign, maxCount = 100) {
                var cache;
                (cache = new PoolCache).sign = sign, cache.maxCount = maxCount, CacheManger.regCacheByFunction(Utils.bind(cache.tryDispose, cache), Utils.bind(cache.getCacheList, cache))
            }
        }

        class TimeLine extends EventDispatcher {
            constructor() {
                super(...arguments), this._tweenDic = {}, this._tweenDataList = [], this._currTime = 0, this._lastTime = 0, this._startTime = 0, this._index = 0, this._gidIndex = 0, this._firstTweenDic = {}, this._startTimeSort = !1, this._endTimeSort = !1, this._loopKey = !1, this.scale = 1, this._frameRate = 60, this._frameIndex = 0, this._total = 0
            }

            static to(target, props, duration, ease = null, offset = 0) {
                return (new TimeLine).to(target, props, duration, ease, offset)
            }

            static from(target, props, duration, ease = null, offset = 0) {
                return (new TimeLine).from(target, props, duration, ease, offset)
            }

            to(target, props, duration, ease = null, offset = 0) {
                return this._create(target, props, duration, ease, offset, !0)
            }

            from(target, props, duration, ease = null, offset = 0) {
                return this._create(target, props, duration, ease, offset, !1)
            }

            _create(target, props, duration, ease, offset, isTo) {
                var tTweenData = Pool.getItemByClass("tweenData", tweenData);
                return tTweenData.isTo = isTo, tTweenData.type = 0, tTweenData.target = target, tTweenData.duration = duration, tTweenData.data = props, tTweenData.startTime = this._startTime + offset, tTweenData.endTime = tTweenData.startTime + tTweenData.duration, tTweenData.ease = ease, this._startTime = Math.max(tTweenData.endTime, this._startTime), this._tweenDataList.push(tTweenData), this._startTimeSort = !0, this._endTimeSort = !0, this
            }

            addLabel(label, offset) {
                var tTweenData = Pool.getItemByClass("tweenData", tweenData);
                return tTweenData.type = 1, tTweenData.data = label, tTweenData.endTime = tTweenData.startTime = this._startTime + offset, this._labelDic || (this._labelDic = {}), this._labelDic[label] = tTweenData, this._tweenDataList.push(tTweenData), this
            }

            removeLabel(label) {
                if (this._labelDic && this._labelDic[label]) {
                    var tTweenData = this._labelDic[label];
                    if (tTweenData) {
                        var tIndex = this._tweenDataList.indexOf(tTweenData);
                        tIndex > -1 && this._tweenDataList.splice(tIndex, 1)
                    }
                    delete this._labelDic[label]
                }
            }

            gotoTime(time) {
                if (null != this._tweenDataList && 0 != this._tweenDataList.length) {
                    var tTween, tObject, tTweenDataCopyList, tTweenData;
                    for (var p in this._firstTweenDic) if (tObject = this._firstTweenDic[p]) for (var tDataP in tObject) tDataP in tObject.diyTarget && (tObject.diyTarget[tDataP] = tObject[tDataP]);
                    for (p in this._tweenDic) (tTween = this._tweenDic[p]).clear(), delete this._tweenDic[p];
                    if (this._index = 0, this._gidIndex = 0, this._currTime = time, this._lastTime = Browser.now(), null == this._endTweenDataList || this._endTimeSort) {
                        this._endTimeSort = !1, this._endTweenDataList = tTweenDataCopyList = this._tweenDataList.concat(), tTweenDataCopyList.sort(function (paraA, paraB) {
                            return paraA.endTime > paraB.endTime ? 1 : paraA.endTime < paraB.endTime ? -1 : 0
                        })
                    } else tTweenDataCopyList = this._endTweenDataList;
                    for (var i = 0, n = tTweenDataCopyList.length; i < n; i++) if (0 == (tTweenData = tTweenDataCopyList[i]).type) {
                        if (!(time >= tTweenData.endTime)) break;
                        this._index = Math.max(this._index, i + 1);
                        var props = tTweenData.data;
                        if (tTweenData.isTo) for (var tP in props) tTweenData.target[tP] = props[tP]
                    }
                    for (i = 0, n = this._tweenDataList.length; i < n; i++) 0 == (tTweenData = this._tweenDataList[i]).type && time >= tTweenData.startTime && time < tTweenData.endTime && (this._index = Math.max(this._index, i + 1), this._gidIndex++, (tTween = Pool.getItemByClass("tween", Tween))._create(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete, [this._gidIndex]), 0, !1, tTweenData.isTo, !0, !1), tTween.setStartTime(this._currTime - (time - tTweenData.startTime)), tTween._updateEase(this._currTime), tTween.gid = this._gidIndex, this._tweenDic[this._gidIndex] = tTween)
                }
            }

            gotoLabel(Label) {
                if (null != this._labelDic) {
                    var tLabelData = this._labelDic[Label];
                    tLabelData && this.gotoTime(tLabelData.startTime)
                }
            }

            pause() {
                ILaya.timer.clear(this, this._update)
            }

            resume() {
                this.play(this._currTime, this._loopKey)
            }

            play(timeOrLabel = 0, loop = !1) {
                if (this._tweenDataList) {
                    if (this._startTimeSort) {
                        this._startTimeSort = !1, this._tweenDataList.sort(function (paraA, paraB) {
                            return paraA.startTime > paraB.startTime ? 1 : paraA.startTime < paraB.startTime ? -1 : 0
                        });
                        for (var i = 0, n = this._tweenDataList.length; i < n; i++) {
                            var tTweenData = this._tweenDataList[i];
                            if (null != tTweenData && 0 == tTweenData.type) {
                                var tTarget = tTweenData.target,
                                    gid = tTarget.$_GID || (tTarget.$_GID = Utils.getGID()), tSrcData = null;
                                for (var p in null == this._firstTweenDic[gid] ? ((tSrcData = {}).diyTarget = tTarget, this._firstTweenDic[gid] = tSrcData) : tSrcData = this._firstTweenDic[gid], tTweenData.data) null == tSrcData[p] && (tSrcData[p] = tTarget[p])
                            }
                        }
                    }
                    "string" == typeof timeOrLabel ? this.gotoLabel(timeOrLabel) : this.gotoTime(timeOrLabel), this._loopKey = loop, this._lastTime = Browser.now(), ILaya.timer.frameLoop(1, this, this._update)
                }
            }

            _update() {
                if (this._currTime >= this._startTime) {
                    if (!this._loopKey) {
                        for (var p in this._tweenDic) (tTween = this._tweenDic[p]).complete();
                        return this._complete(), void this.pause()
                    }
                    if (this._complete(), !this._tweenDataList) return;
                    this.gotoTime(0)
                }
                var tTween, tNow = Browser.now(), tFrameTime = tNow - this._lastTime,
                    tCurrTime = this._currTime += tFrameTime * this.scale;
                for (p in this._lastTime = tNow, this._tweenDic) (tTween = this._tweenDic[p])._updateEase(tCurrTime);
                if (0 != this._tweenDataList.length && this._index < this._tweenDataList.length) {
                    var tTweenData = this._tweenDataList[this._index];
                    tCurrTime >= tTweenData.startTime && (this._index++, 0 == tTweenData.type ? (this._gidIndex++, (tTween = Pool.getItemByClass("tween", Tween))._create(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete, [this._gidIndex]), 0, !1, tTweenData.isTo, !0, !1), tTween.setStartTime(tCurrTime), tTween.gid = this._gidIndex, this._tweenDic[this._gidIndex] = tTween, tTween._updateEase(tCurrTime)) : this.event(Event.LABEL, tTweenData.data))
                }
            }

            _animComplete(index) {
                this._tweenDic[index] && delete this._tweenDic[index]
            }

            _complete() {
                this.event(Event.COMPLETE)
            }

            get index() {
                return this._frameIndex
            }

            set index(value) {
                this._frameIndex = value, this.gotoTime(this._frameIndex / this._frameRate * 1e3)
            }

            get total() {
                return this._total = Math.floor(this._startTime / 1e3 * this._frameRate), this._total
            }

            reset() {
                var p, i, len;
                if (this._labelDic) for (p in this._labelDic) delete this._labelDic[p];
                for (p in this._tweenDic) this._tweenDic[p].clear(), delete this._tweenDic[p];
                for (p in this._firstTweenDic) delete this._firstTweenDic[p];
                if (this._endTweenDataList = null, this._tweenDataList && this._tweenDataList.length) for (len = this._tweenDataList.length, i = 0; i < len; i++) this._tweenDataList[i] && this._tweenDataList[i].destroy();
                this._tweenDataList.length = 0, this._currTime = 0, this._lastTime = 0, this._startTime = 0, this._index = 0, this._gidIndex = 0, this.scale = 1, ILaya.timer.clear(this, this._update)
            }

            destroy() {
                this.reset(), this._labelDic = null, this._tweenDic = null, this._tweenDataList = null, this._firstTweenDic = null
            }
        }

        class tweenData {
            constructor() {
                this.type = 0, this.isTo = !0
            }

            destroy() {
                this.target = null, this.ease = null, this.data = null, this.isTo = !0, this.type = 0, Pool.recover("tweenData", this)
            }
        }

        class ArabicReshaper {
            characterMapContains(c) {
                for (var i = 0; i < ArabicReshaper.charsMap.length; ++i) if (ArabicReshaper.charsMap[i][0] === c) return !0;
                return !1
            }

            getCharRep(c) {
                for (var i = 0; i < ArabicReshaper.charsMap.length; ++i) if (ArabicReshaper.charsMap[i][0] === c) return ArabicReshaper.charsMap[i];
                return !1
            }

            getCombCharRep(c1, c2) {
                for (var i = 0; i < ArabicReshaper.combCharsMap.length; ++i) if (ArabicReshaper.combCharsMap[i][0][0] === c1 && ArabicReshaper.combCharsMap[i][0][1] === c2) return ArabicReshaper.combCharsMap[i];
                return !1
            }

            isTransparent(c) {
                for (var i = 0; i < ArabicReshaper.transChars.length; ++i) if (ArabicReshaper.transChars[i] === c) return !0;
                return !1
            }

            getOriginalCharsFromCode(code) {
                var j;
                for (j = 0; j < ArabicReshaper.charsMap.length; ++j) if (ArabicReshaper.charsMap[j].indexOf(code) > -1) return String.fromCharCode(ArabicReshaper.charsMap[j][0]);
                for (j = 0; j < ArabicReshaper.combCharsMap.length; ++j) if (ArabicReshaper.combCharsMap[j].indexOf(code) > -1) return String.fromCharCode(ArabicReshaper.combCharsMap[j][0][0]) + String.fromCharCode(ArabicReshaper.combCharsMap[j][0][1]);
                return String.fromCharCode(code)
            }

            convertArabic(normal) {
                for (var crep, combcrep, shaped = "", i = 0; i < normal.length; ++i) {
                    var current = normal.charCodeAt(i);
                    if (this.characterMapContains(current)) {
                        for (var prev = null, next = null, prevID = i - 1, nextID = i + 1; prevID >= 0 && this.isTransparent(normal.charCodeAt(prevID)); --prevID) ;
                        for ((!(crep = !!(prev = prevID >= 0 ? normal.charCodeAt(prevID) : null) && this.getCharRep(prev)) || null == crep[2] && null == crep[3]) && (prev = null); nextID < normal.length && this.isTransparent(normal.charCodeAt(nextID)); ++nextID) ;
                        if ((!(crep = !!(next = nextID < normal.length ? normal.charCodeAt(nextID) : null) && this.getCharRep(next)) || null == crep[3] && null == crep[4]) && (next = null), 1604 === current && null != next && (1570 === next || 1571 === next || 1573 === next || 1575 === next)) {
                            combcrep = this.getCombCharRep(current, next), shaped += null != prev ? String.fromCharCode(combcrep[4]) : String.fromCharCode(combcrep[1]), ++i;
                            continue
                        }
                        if (crep = this.getCharRep(current), null != prev && null != next && null != crep[3]) {
                            shaped += String.fromCharCode(crep[3]);
                            continue
                        }
                        if (null != prev && null != crep[4]) {
                            shaped += String.fromCharCode(crep[4]);
                            continue
                        }
                        if (null != next && null != crep[2]) {
                            shaped += String.fromCharCode(crep[2]);
                            continue
                        }
                        shaped += String.fromCharCode(crep[1])
                    } else shaped += String.fromCharCode(current)
                }
                return shaped
            }

            convertArabicBack(apfb) {
                var selectedChar, i, toReturn = "";
                for (i = 0; i < apfb.length; ++i) selectedChar = apfb.charCodeAt(i), toReturn += this.getOriginalCharsFromCode(selectedChar);
                return toReturn
            }
        }

        ArabicReshaper.charsMap = [[1569, 65152, null, null, null], [1570, 65153, null, null, 65154], [1571, 65155, null, null, 65156], [1572, 65157, null, null, 65158], [1573, 65159, null, null, 65160], [1574, 65161, 65163, 65164, 65162], [1575, 65165, null, null, 65166], [1576, 65167, 65169, 65170, 65168], [1577, 65171, null, null, 65172], [1578, 65173, 65175, 65176, 65174], [1579, 65177, 65179, 65180, 65178], [1580, 65181, 65183, 65184, 65182], [1581, 65185, 65187, 65188, 65186], [1582, 65189, 65191, 65192, 65190], [1583, 65193, null, null, 65194], [1584, 65195, null, null, 65196], [1585, 65197, null, null, 65198], [1586, 65199, null, null, 65200], [1587, 65201, 65203, 65204, 65202], [1588, 65205, 65207, 65208, 65206], [1589, 65209, 65211, 65212, 65210], [1590, 65213, 65215, 65216, 65214], [1591, 65217, 65219, 65220, 65218], [1592, 65221, 65223, 65224, 65222], [1593, 65225, 65227, 65228, 65226], [1594, 65229, 65231, 65232, 65230], [1600, 1600, 1600, 1600, 1600], [1601, 65233, 65235, 65236, 65234], [1602, 65237, 65239, 65240, 65238], [1603, 65241, 65243, 65244, 65242], [1604, 65245, 65247, 65248, 65246], [1605, 65249, 65251, 65252, 65250], [1606, 65253, 65255, 65256, 65254], [1607, 65257, 65259, 65260, 65258], [1608, 65261, null, null, 65262], [1609, 65263, null, null, 65264], [1610, 65265, 65267, 65268, 65266], [1662, 64342, 64344, 64345, 64343], [1740, 64508, 64510, 64511, 64509], [1670, 64378, 64380, 64381, 64379], [1705, 64398, 64400, 64401, 64399], [1711, 64402, 64404, 64405, 64403], [1688, 64394, null, null, 64395]], ArabicReshaper.combCharsMap = [[[1604, 1570], 65269, null, null, 65270], [[1604, 1571], 65271, null, null, 65272], [[1604, 1573], 65273, null, null, 65274], [[1604, 1575], 65275, null, null, 65276]], ArabicReshaper.transChars = [1552, 1554, 1555, 1556, 1557, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1648, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1759, 1760, 1761, 1762, 1763, 1764, 1767, 1768, 1770, 1771, 1772, 1773];

        class MatirxArray {
            static ArrayMul(a, b, o) {
                if (a) if (b) for (var ai0, ai1, ai2, ai3, i = 0; i < 4; i++) ai0 = a[i], ai1 = a[i + 4], ai2 = a[i + 8], ai3 = a[i + 12], o[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3], o[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7], o[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11], o[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15]; else MatirxArray.copyArray(a, o); else MatirxArray.copyArray(b, o)
            }

            static copyArray(f, t) {
                if (f && t) for (var i = 0; i < f.length; i++) t[i] = f[i]
            }
        }

        return exports.AlphaCmd = AlphaCmd, exports.Animation = Animation, exports.AnimationBase = AnimationBase, exports.ArabicReshaper = ArabicReshaper, exports.AtlasGrid = AtlasGrid, exports.AtlasInfoManager = AtlasInfoManager, exports.AudioSound = AudioSound, exports.AudioSoundChannel = AudioSoundChannel, exports.BasePoly = BasePoly, exports.BaseShader = BaseShader, exports.BaseTexture = BaseTexture, exports.Bezier = Bezier, exports.Bitmap = Bitmap, exports.BitmapFont = BitmapFont, exports.BlendMode = BlendMode, exports.BlurFilter = BlurFilter, exports.BlurFilterGLRender = BlurFilterGLRender, exports.BlurFilterSetter = class extends FilterSetterBase {
            constructor() {
                super(), this._strength = 4, this._filter = new BlurFilter(this.strength)
            }

            buildFilter() {
                this._filter = new BlurFilter(this.strength), super.buildFilter()
            }

            get strength() {
                return this._strength
            }

            set strength(value) {
                this._strength = value
            }
        }, exports.BoundsStyle = BoundsStyle, exports.Browser = Browser, exports.Buffer = Buffer, exports.Buffer2D = Buffer2D, exports.BufferState2D = BufferState2D, exports.BufferStateBase = BufferStateBase, exports.ButtonEffect = class {
            constructor() {
                this._curState = 0, this.effectScale = 1.5, this.tweenTime = 300
            }

            set target(tar) {
                this._tar = tar, tar.on(Event.MOUSE_DOWN, this, this.toChangedState), tar.on(Event.MOUSE_UP, this, this.toInitState), tar.on(Event.MOUSE_OUT, this, this.toInitState)
            }

            toChangedState() {
                this._curState = 1, this._curTween && Tween.clear(this._curTween), this._curTween = Tween.to(this._tar, {
                    scaleX: this.effectScale,
                    scaleY: this.effectScale
                }, this.tweenTime, Ease[this.effectEase], Handler.create(this, this.tweenComplete))
            }

            toInitState() {
                2 != this._curState && (this._curTween && Tween.clear(this._curTween), this._curState = 2, this._curTween = Tween.to(this._tar, {
                    scaleX: 1,
                    scaleY: 1
                }, this.tweenTime, Ease[this.backEase], Handler.create(this, this.tweenComplete)))
            }

            tweenComplete() {
                this._curState = 0, this._curTween = null
            }
        }, exports.Byte = Byte, exports.CONST3D2D = CONST3D2D, exports.CacheManger = CacheManger, exports.CacheStyle = CacheStyle, exports.CallLater = CallLater, exports.CharRenderInfo = CharRenderInfo, exports.CharRender_Canvas = CharRender_Canvas, exports.CharRender_Native = CharRender_Native, exports.CharSubmitCache = CharSubmitCache, exports.ClassUtils = ClassUtils, exports.ClipRectCmd = ClipRectCmd, exports.ColorFilter = ColorFilter, exports.ColorFilterSetter = class extends FilterSetterBase {
            constructor() {
                super(), this._brightness = 0, this._contrast = 0, this._saturation = 0, this._hue = 0, this._red = 0, this._green = 0, this._blue = 0, this._alpha = 0, this._filter = new ColorFilter
            }

            buildFilter() {
                this._filter.reset(), this._filter.color(this.red, this.green, this.blue, this.alpha), this._filter.adjustHue(this.hue), this._filter.adjustContrast(this.contrast), this._filter.adjustBrightness(this.brightness), this._filter.adjustSaturation(this.saturation), super.buildFilter()
            }

            get brightness() {
                return this._brightness
            }

            set brightness(value) {
                this._brightness = value, this.paramChanged()
            }

            get contrast() {
                return this._contrast
            }

            set contrast(value) {
                this._contrast = value, this.paramChanged()
            }

            get saturation() {
                return this._saturation
            }

            set saturation(value) {
                this._saturation = value, this.paramChanged()
            }

            get hue() {
                return this._hue
            }

            set hue(value) {
                this._hue = value, this.paramChanged()
            }

            get red() {
                return this._red
            }

            set red(value) {
                this._red = value, this.paramChanged()
            }

            get green() {
                return this._green
            }

            set green(value) {
                this._green = value, this.paramChanged()
            }

            get blue() {
                return this._blue
            }

            set blue(value) {
                this._blue = value, this.paramChanged()
            }

            get color() {
                return this._color
            }

            set color(value) {
                var colorO;
                this._color = value, colorO = ColorUtils.create(value), this._red = 255 * colorO.arrColor[0], this._green = 255 * colorO.arrColor[1], this._blue = 255 * colorO.arrColor[2], this.paramChanged()
            }

            get alpha() {
                return this._alpha
            }

            set alpha(value) {
                this._alpha = value, this.paramChanged()
            }
        }, exports.ColorUtils = ColorUtils, exports.CommandEncoder = class {
            constructor(layagl, reserveSize, adjustSize, isSyncToRenderThread) {
                this._idata = []
            }

            getArrayData() {
                return this._idata
            }

            getPtrID() {
                return 0
            }

            beginEncoding() {
            }

            endEncoding() {
            }

            clearEncoding() {
                this._idata.length = 0
            }

            getCount() {
                return this._idata.length
            }

            add_ShaderValue(o) {
                this._idata.push(o)
            }

            addShaderUniform(one) {
                this.add_ShaderValue(one)
            }
        }, exports.CommonScript = class extends Component {
            get isSingleton() {
                return !1
            }

            constructor() {
                super()
            }

            onAwake() {
            }

            onEnable() {
            }

            onStart() {
            }

            onUpdate() {
            }

            onLateUpdate() {
            }

            onDisable() {
            }

            onDestroy() {
            }
        }, exports.Component = Component, exports.Config = Config, exports.Const = Const, exports.Context = Context, exports.Dragging = Dragging, exports.Draw9GridTexture = Draw9GridTexture, exports.DrawCanvasCmd = DrawCanvasCmd, exports.DrawCircleCmd = DrawCircleCmd, exports.DrawCurvesCmd = DrawCurvesCmd, exports.DrawImageCmd = DrawImageCmd, exports.DrawLineCmd = DrawLineCmd, exports.DrawLinesCmd = DrawLinesCmd, exports.DrawParticleCmd = DrawParticleCmd, exports.DrawPathCmd = DrawPathCmd, exports.DrawPieCmd = DrawPieCmd, exports.DrawPolyCmd = DrawPolyCmd, exports.DrawRectCmd = DrawRectCmd, exports.DrawStyle = DrawStyle, exports.DrawTextureCmd = DrawTextureCmd, exports.DrawTexturesCmd = DrawTexturesCmd, exports.DrawTrianglesCmd = DrawTrianglesCmd, exports.Earcut = Earcut, exports.EarcutNode = EarcutNode, exports.Ease = Ease, exports.EffectAnimation = EffectAnimation, exports.EffectBase = EffectBase, exports.Event = Event, exports.EventDispatcher = EventDispatcher, exports.FadeIn = class extends EffectBase {
            _doTween() {
                return this.target.alpha = 0, Tween.to(this.target, {alpha: 1}, this.duration, Ease[this.ease], this._comlete, this.delay)
            }
        }, exports.FadeOut = class extends EffectBase {
            _doTween() {
                return this.target.alpha = 1, Tween.to(this.target, {alpha: 0}, this.duration, Ease[this.ease], this._comlete, this.delay)
            }
        }, exports.FillBorderTextCmd = FillBorderTextCmd, exports.FillBorderWordsCmd = FillBorderWordsCmd, exports.FillTextCmd = FillTextCmd, exports.FillTextureCmd = FillTextureCmd, exports.FillWordsCmd = FillWordsCmd, exports.Filter = Filter, exports.FilterSetterBase = FilterSetterBase, exports.FontInfo = FontInfo, exports.FrameAnimation = FrameAnimation, exports.GlowFilter = GlowFilter, exports.GlowFilterGLRender = GlowFilterGLRender, exports.GlowFilterSetter = class extends FilterSetterBase {
            constructor() {
                super(), this._color = "#ff0000", this._blur = 4, this._offX = 6, this._offY = 6, this._filter = new GlowFilter(this._color)
            }

            buildFilter() {
                this._filter = new GlowFilter(this.color, this.blur, this.offX, this.offY), super.buildFilter()
            }

            get color() {
                return this._color
            }

            set color(value) {
                this._color = value, this.paramChanged()
            }

            get blur() {
                return this._blur
            }

            set blur(value) {
                this._blur = value, this.paramChanged()
            }

            get offX() {
                return this._offX
            }

            set offX(value) {
                this._offX = value, this.paramChanged()
            }

            get offY() {
                return this._offY
            }

            set offY(value) {
                this._offY = value, this.paramChanged()
            }
        }, exports.GrahamScan = GrahamScan, exports.GraphicAnimation = GraphicAnimation, exports.Graphics = Graphics, exports.GraphicsBounds = GraphicsBounds, exports.HTMLCanvas = HTMLCanvas, exports.HTMLChar = HTMLChar, exports.HTMLImage = HTMLImage, exports.Handler = Handler, exports.HitArea = HitArea, exports.HttpRequest = HttpRequest, exports.ICharRender = ICharRender, exports.ILaya = ILaya, exports.IStatRender = IStatRender, exports.IndexBuffer2D = IndexBuffer2D, exports.InlcudeFile = InlcudeFile, exports.Input = Input, exports.KeyBoardManager = KeyBoardManager, exports.KeyLocation = KeyLocation,exports.Keyboard = Keyboard,exports.Laya = Laya,exports.LayaGL = LayaGL,exports.LayaGLQuickRunner = LayaGLQuickRunner,exports.LayaGLRunner = LayaGLRunner,exports.LayaGPU = LayaGPU,exports.Loader = Loader,exports.LoaderManager = LoaderManager,exports.LocalStorage = LocalStorage,exports.Log = Log,exports.MathUtil = MathUtil,exports.MatirxArray = MatirxArray,exports.Matrix = Matrix,exports.Mesh2D = Mesh2D,exports.MeshParticle2D = MeshParticle2D,exports.MeshQuadTexture = MeshQuadTexture,exports.MeshTexture = MeshTexture,exports.MeshVG = MeshVG,exports.Mouse = Mouse,exports.MouseManager = MouseManager,exports.Node = Node,exports.Path = Path,exports.PerfData = PerfData,exports.PerfHUD = PerfHUD,exports.Point = Point,exports.Pool = Pool,exports.PoolCache = PoolCache,exports.Prefab = Prefab,exports.PrimitiveSV = PrimitiveSV,exports.QuickTestTool = QuickTestTool,exports.Rectangle = Rectangle,exports.Render = Render,exports.RenderInfo = RenderInfo,exports.RenderSprite = RenderSprite,exports.RenderState2D = RenderState2D,exports.RenderTexture2D = RenderTexture2D,exports.Resource = Resource,exports.ResourceVersion = ResourceVersion,exports.RestoreCmd = RestoreCmd,exports.RotateCmd = RotateCmd,exports.RunDriver = RunDriver,exports.SaveBase = SaveBase,exports.SaveClipRect = SaveClipRect,exports.SaveCmd = SaveCmd,exports.SaveMark = SaveMark,exports.SaveTransform = SaveTransform,exports.SaveTranslate = SaveTranslate,exports.ScaleCmd = ScaleCmd,exports.Scene = Scene,exports.SceneLoader = SceneLoader,exports.SceneUtils = SceneUtils,exports.Script = Script,exports.Shader = Shader,exports.Shader2D = Shader2D,exports.Shader2X = Shader2X,exports.ShaderCompile = ShaderCompile,exports.ShaderDefines2D = ShaderDefines2D,exports.ShaderDefinesBase = ShaderDefinesBase,exports.ShaderNode = ShaderNode,exports.ShaderValue = class {
            constructor() {
            }
        },exports.SkinMeshBuffer = SkinMeshBuffer,exports.SkinSV = SkinSV,exports.Socket = Socket,exports.Sound = class extends EventDispatcher {
            load(url) {
            }

            play(startTime = 0, loops = 0) {
                return null
            }

            get duration() {
                return 0
            }

            dispose() {
            }
        },exports.SoundChannel = SoundChannel,exports.SoundManager = SoundManager,exports.SoundNode = class extends Sprite {
            constructor() {
                super(), this.visible = !1, this.on(Event.ADDED, this, this._onParentChange), this.on(Event.REMOVED, this, this._onParentChange)
            }

            _onParentChange() {
                this.target = this.parent
            }

            play(loops = 1, complete = null) {
                isNaN(loops) && (loops = 1), this.url && (this.stop(), this._channel = SoundManager.playSound(this.url, loops, complete))
            }

            stop() {
                this._channel && !this._channel.isStopped && this._channel.stop(), this._channel = null
            }

            _setPlayAction(tar, event, action, add = !0) {
                this[action] && tar && (add ? tar.on(event, this, this[action]) : tar.off(event, this, this[action]))
            }

            _setPlayActions(tar, events, action, add = !0) {
                if (tar && events) {
                    var i, len, eventArr = events.split(",");
                    for (len = eventArr.length, i = 0; i < len; i++) this._setPlayAction(tar, eventArr[i], action, add)
                }
            }

            set playEvent(events) {
                this._playEvents = events, events && this._tar && this._setPlayActions(this._tar, events, "play")
            }

            set target(tar) {
                this._tar && (this._setPlayActions(this._tar, this._playEvents, "play", !1), this._setPlayActions(this._tar, this._stopEvents, "stop", !1)), this._tar = tar, this._tar && (this._setPlayActions(this._tar, this._playEvents, "play", !0), this._setPlayActions(this._tar, this._stopEvents, "stop", !0))
            }

            set stopEvent(events) {
                this._stopEvents = events, events && this._tar && this._setPlayActions(this._tar, events, "stop")
            }
        },exports.Sprite = Sprite,exports.SpriteConst = SpriteConst,exports.SpriteStyle = SpriteStyle,exports.Stage = Stage,exports.Stat = Stat,exports.StatUI = StatUI,exports.StringKey = StringKey,exports.StrokeTextCmd = StrokeTextCmd,exports.Submit = Submit,exports.SubmitBase = SubmitBase,exports.SubmitCMD = SubmitCMD,exports.SubmitCanvas = SubmitCanvas,exports.SubmitKey = SubmitKey,exports.SubmitTarget = SubmitTarget,exports.SubmitTexture = SubmitTexture,exports.System = class {
            static changeDefinition(name, classObj) {
                window.Laya[name] = classObj;
                var str = name + "=classObj";
                window.eval(str)
            }
        },exports.TTFLoader = TTFLoader,exports.Text = Text,exports.TextAtlas = TextAtlas,exports.TextRender = TextRender,exports.TextStyle = TextStyle,exports.TextTexture = TextTexture,exports.Texture = Texture,exports.Texture2D = Texture2D,exports.TextureSV = TextureSV,exports.TimeLine = TimeLine,exports.Timer = Timer,exports.TouchManager = TouchManager,exports.TransformCmd = TransformCmd,exports.TranslateCmd = TranslateCmd,exports.Tween = Tween,exports.URL = URL,exports.Utils = Utils,exports.Value2D = Value2D,exports.VectorGraphManager = VectorGraphManager,exports.VertexArrayObject = class {
            constructor() {
            }
        },exports.VertexBuffer2D = VertexBuffer2D,exports.WeakObject = WeakObject,exports.WebAudioSound = WebAudioSound,exports.WebAudioSoundChannel = WebAudioSoundChannel,exports.WebGL = WebGL,exports.WebGLCacheAsNormalCanvas = WebGLCacheAsNormalCanvas,exports.WebGLContext = WebGLContext,exports.WebGLRTMgr = WebGLRTMgr,exports.WordText = WordText,exports.WorkerLoader = WorkerLoader,exports.__init = __init,exports._static = _static,exports.alertGlobalError = alertGlobalError,exports.enableDebugPanel = enableDebugPanel,exports.init = init,exports.isWXOpenDataContext = void 0,exports.isWXPosMsg = void 0,exports.version = version,exports.static = _static,exports
    }({});
});
define("libs/laya.d3.js", function (require, module, exports) {
    !function (exports, Laya) {
        "use strict";

        class MathUtils3D {
            constructor() {
            }

            static isZero(v) {
                return Math.abs(v) < MathUtils3D.zeroTolerance
            }

            static nearEqual(n1, n2) {
                return !!MathUtils3D.isZero(n1 - n2)
            }

            static fastInvSqrt(value) {
                return MathUtils3D.isZero(value) ? value : 1 / Math.sqrt(value)
            }
        }

        MathUtils3D.zeroTolerance = 1e-6, MathUtils3D.MaxValue = 3.40282347e38, MathUtils3D.MinValue = -3.40282347e38;

        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x, this.y = y
            }

            setValue(x, y) {
                this.x = x, this.y = y
            }

            static scale(a, b, out) {
                out.x = a.x * b, out.y = a.y * b
            }

            fromArray(array, offset = 0) {
                this.x = array[offset + 0], this.y = array[offset + 1]
            }

            cloneTo(destObject) {
                var destVector2 = destObject;
                destVector2.x = this.x, destVector2.y = this.y
            }

            static dot(a, b) {
                return a.x * b.x + a.y * b.y
            }

            static normalize(s, out) {
                var x = s.x, y = s.y, len = x * x + y * y;
                len > 0 && (len = 1 / Math.sqrt(len), out.x = x * len, out.y = y * len)
            }

            static scalarLength(a) {
                var x = a.x, y = a.y;
                return Math.sqrt(x * x + y * y)
            }

            clone() {
                var destVector2 = new Vector2;
                return this.cloneTo(destVector2), destVector2
            }

            forNativeElement(nativeElements = null) {
                nativeElements ? (this.elements = nativeElements, this.elements[0] = this.x, this.elements[1] = this.y) : this.elements = new Float32Array([this.x, this.y]), Vector2.rewriteNumProperty(this, "x", 0), Vector2.rewriteNumProperty(this, "y", 1)
            }

            static rewriteNumProperty(proto, name, index) {
                Object.defineProperty(proto, name, {
                    get: function () {
                        return this.elements[index]
                    }, set: function (v) {
                        this.elements[index] = v
                    }
                })
            }
        }

        Vector2.ZERO = new Vector2(0, 0), Vector2.ONE = new Vector2(1, 1);

        class Vector4 {
            constructor(x = 0, y = 0, z = 0, w = 0) {
                this.x = x, this.y = y, this.z = z, this.w = w
            }

            setValue(x, y, z, w) {
                this.x = x, this.y = y, this.z = z, this.w = w
            }

            fromArray(array, offset = 0) {
                this.x = array[offset + 0], this.y = array[offset + 1], this.z = array[offset + 2], this.w = array[offset + 3]
            }

            cloneTo(destObject) {
                var destVector4 = destObject;
                destVector4.x = this.x, destVector4.y = this.y, destVector4.z = this.z, destVector4.w = this.w
            }

            clone() {
                var destVector4 = new Vector4;
                return this.cloneTo(destVector4), destVector4
            }

            static lerp(a, b, t, out) {
                var ax = a.x, ay = a.y, az = a.z, aw = a.w;
                out.x = ax + t * (b.x - ax), out.y = ay + t * (b.y - ay), out.z = az + t * (b.z - az), out.w = aw + t * (b.w - aw)
            }

            static transformByM4x4(vector4, m4x4, out) {
                var vx = vector4.x, vy = vector4.y, vz = vector4.z, vw = vector4.w, me = m4x4.elements;
                out.x = vx * me[0] + vy * me[4] + vz * me[8] + vw * me[12], out.y = vx * me[1] + vy * me[5] + vz * me[9] + vw * me[13], out.z = vx * me[2] + vy * me[6] + vz * me[10] + vw * me[14], out.w = vx * me[3] + vy * me[7] + vz * me[11] + vw * me[15]
            }

            static equals(a, b) {
                return MathUtils3D.nearEqual(Math.abs(a.x), Math.abs(b.x)) && MathUtils3D.nearEqual(Math.abs(a.y), Math.abs(b.y)) && MathUtils3D.nearEqual(Math.abs(a.z), Math.abs(b.z)) && MathUtils3D.nearEqual(Math.abs(a.w), Math.abs(b.w))
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }

            lengthSquared() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }

            static normalize(s, out) {
                var len = s.length();
                len > 0 && (out.x = s.x * len, out.y = s.y * len, out.z = s.z * len, out.w = s.w * len)
            }

            static add(a, b, out) {
                out.x = a.x + b.x, out.y = a.y + b.y, out.z = a.z + b.z, out.w = a.w + b.w
            }

            static subtract(a, b, out) {
                out.x = a.x - b.x, out.y = a.y - b.y, out.z = a.z - b.z, out.w = a.w - b.w
            }

            static multiply(a, b, out) {
                out.x = a.x * b.x, out.y = a.y * b.y, out.z = a.z * b.z, out.w = a.w * b.w
            }

            static scale(a, b, out) {
                out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out.w = a.w * b
            }

            static Clamp(value, min, max, out) {
                var x = value.x, y = value.y, z = value.z, w = value.w, mineX = min.x, mineY = min.y, mineZ = min.z,
                    mineW = min.w, maxeX = max.x, maxeY = max.y, maxeZ = max.z, maxeW = max.w;
                x = (x = x > maxeX ? maxeX : x) < mineX ? mineX : x, y = (y = y > maxeY ? maxeY : y) < mineY ? mineY : y, z = (z = z > maxeZ ? maxeZ : z) < mineZ ? mineZ : z, w = (w = w > maxeW ? maxeW : w) < mineW ? mineW : w, out.x = x, out.y = y, out.z = z, out.w = w
            }

            static distanceSquared(value1, value2) {
                var x = value1.x - value2.x, y = value1.y - value2.y, z = value1.z - value2.z, w = value1.w - value2.w;
                return x * x + y * y + z * z + w * w
            }

            static distance(value1, value2) {
                var x = value1.x - value2.x, y = value1.y - value2.y, z = value1.z - value2.z, w = value1.w - value2.w;
                return Math.sqrt(x * x + y * y + z * z + w * w)
            }

            static dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
            }

            static min(a, b, out) {
                out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out.z = Math.min(a.z, b.z), out.w = Math.min(a.w, b.w)
            }

            static max(a, b, out) {
                out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out.z = Math.max(a.z, b.z), out.w = Math.max(a.w, b.w)
            }

            forNativeElement(nativeElements = null) {
                nativeElements ? (this.elements = nativeElements, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z, this.elements[3] = this.w) : this.elements = new Float32Array([this.x, this.y, this.z, this.w]), Vector2.rewriteNumProperty(this, "x", 0), Vector2.rewriteNumProperty(this, "y", 1), Vector2.rewriteNumProperty(this, "z", 2), Vector2.rewriteNumProperty(this, "w", 3)
            }
        }

        Vector4.ZERO = new Vector4, Vector4.ONE = new Vector4(1, 1, 1, 1), Vector4.UnitX = new Vector4(1, 0, 0, 0), Vector4.UnitY = new Vector4(0, 1, 0, 0), Vector4.UnitZ = new Vector4(0, 0, 1, 0), Vector4.UnitW = new Vector4(0, 0, 0, 1);

        class Vector3 {
            constructor(x = 0, y = 0, z = 0, nativeElements = null) {
                this.x = x, this.y = y, this.z = z
            }

            static distanceSquared(value1, value2) {
                var x = value1.x - value2.x, y = value1.y - value2.y, z = value1.z - value2.z;
                return x * x + y * y + z * z
            }

            static distance(value1, value2) {
                var x = value1.x - value2.x, y = value1.y - value2.y, z = value1.z - value2.z;
                return Math.sqrt(x * x + y * y + z * z)
            }

            static min(a, b, out) {
                out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out.z = Math.min(a.z, b.z)
            }

            static max(a, b, out) {
                out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out.z = Math.max(a.z, b.z)
            }

            static transformQuat(source, rotation, out) {
                var x = source.x, y = source.y, z = source.z, qx = rotation.x, qy = rotation.y, qz = rotation.z,
                    qw = rotation.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z,
                    iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
                out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz, out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx
            }

            static scalarLength(a) {
                var x = a.x, y = a.y, z = a.z;
                return Math.sqrt(x * x + y * y + z * z)
            }

            static scalarLengthSquared(a) {
                var x = a.x, y = a.y, z = a.z;
                return x * x + y * y + z * z
            }

            static normalize(s, out) {
                var x = s.x, y = s.y, z = s.z, len = x * x + y * y + z * z;
                len > 0 && (len = 1 / Math.sqrt(len), out.x = s.x * len, out.y = s.y * len, out.z = s.z * len)
            }

            static multiply(a, b, out) {
                out.x = a.x * b.x, out.y = a.y * b.y, out.z = a.z * b.z
            }

            static scale(a, b, out) {
                out.x = a.x * b, out.y = a.y * b, out.z = a.z * b
            }

            static lerp(a, b, t, out) {
                var ax = a.x, ay = a.y, az = a.z;
                out.x = ax + t * (b.x - ax), out.y = ay + t * (b.y - ay), out.z = az + t * (b.z - az)
            }

            static transformV3ToV3(vector, transform, result) {
                var intermediate = Vector3._tempVector4;
                Vector3.transformV3ToV4(vector, transform, intermediate), result.x = intermediate.x, result.y = intermediate.y, result.z = intermediate.z
            }

            static transformV3ToV4(vector, transform, result) {
                var vectorX = vector.x, vectorY = vector.y, vectorZ = vector.z, transformElem = transform.elements;
                result.x = vectorX * transformElem[0] + vectorY * transformElem[4] + vectorZ * transformElem[8] + transformElem[12], result.y = vectorX * transformElem[1] + vectorY * transformElem[5] + vectorZ * transformElem[9] + transformElem[13], result.z = vectorX * transformElem[2] + vectorY * transformElem[6] + vectorZ * transformElem[10] + transformElem[14], result.w = vectorX * transformElem[3] + vectorY * transformElem[7] + vectorZ * transformElem[11] + transformElem[15]
            }

            static TransformNormal(normal, transform, result) {
                var normalX = normal.x, normalY = normal.y, normalZ = normal.z, transformElem = transform.elements;
                result.x = normalX * transformElem[0] + normalY * transformElem[4] + normalZ * transformElem[8], result.y = normalX * transformElem[1] + normalY * transformElem[5] + normalZ * transformElem[9], result.z = normalX * transformElem[2] + normalY * transformElem[6] + normalZ * transformElem[10]
            }

            static transformCoordinate(coordinate, transform, result) {
                var coordinateX = coordinate.x, coordinateY = coordinate.y, coordinateZ = coordinate.z,
                    transformElem = transform.elements,
                    w = coordinateX * transformElem[3] + coordinateY * transformElem[7] + coordinateZ * transformElem[11] + transformElem[15];
                result.x = coordinateX * transformElem[0] + coordinateY * transformElem[4] + coordinateZ * transformElem[8] + transformElem[12] / w, result.y = coordinateX * transformElem[1] + coordinateY * transformElem[5] + coordinateZ * transformElem[9] + transformElem[13] / w, result.z = coordinateX * transformElem[2] + coordinateY * transformElem[6] + coordinateZ * transformElem[10] + transformElem[14] / w
            }

            static Clamp(value, min, max, out) {
                var x = value.x, y = value.y, z = value.z, mineX = min.x, mineY = min.y, mineZ = min.z, maxeX = max.x,
                    maxeY = max.y, maxeZ = max.z;
                x = (x = x > maxeX ? maxeX : x) < mineX ? mineX : x, y = (y = y > maxeY ? maxeY : y) < mineY ? mineY : y, z = (z = z > maxeZ ? maxeZ : z) < mineZ ? mineZ : z, out.x = x, out.y = y, out.z = z
            }

            static add(a, b, out) {
                out.x = a.x + b.x, out.y = a.y + b.y, out.z = a.z + b.z
            }

            static subtract(a, b, o) {
                o.x = a.x - b.x, o.y = a.y - b.y, o.z = a.z - b.z
            }

            static cross(a, b, o) {
                var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
                o.x = ay * bz - az * by, o.y = az * bx - ax * bz, o.z = ax * by - ay * bx
            }

            static dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z
            }

            static equals(a, b) {
                return MathUtils3D.nearEqual(a.x, b.x) && MathUtils3D.nearEqual(a.y, b.y) && MathUtils3D.nearEqual(a.z, b.z)
            }

            setValue(x, y, z) {
                this.x = x, this.y = y, this.z = z
            }

            fromArray(array, offset = 0) {
                this.x = array[offset + 0], this.y = array[offset + 1], this.z = array[offset + 2]
            }

            cloneTo(destObject) {
                var destVector3 = destObject;
                destVector3.x = this.x, destVector3.y = this.y, destVector3.z = this.z
            }

            clone() {
                var destVector3 = new Vector3;
                return this.cloneTo(destVector3), destVector3
            }

            toDefault() {
                this.x = 0, this.y = 0, this.z = 0
            }

            forNativeElement(nativeElements = null) {
                nativeElements ? (this.elements = nativeElements, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z) : this.elements = new Float32Array([this.x, this.y, this.z]), Vector2.rewriteNumProperty(this, "x", 0), Vector2.rewriteNumProperty(this, "y", 1), Vector2.rewriteNumProperty(this, "z", 2)
            }
        }

        Vector3._tempVector4 = new Vector4, Vector3._ZERO = new Vector3(0, 0, 0), Vector3._ONE = new Vector3(1, 1, 1), Vector3._NegativeUnitX = new Vector3(-1, 0, 0), Vector3._UnitX = new Vector3(1, 0, 0), Vector3._UnitY = new Vector3(0, 1, 0), Vector3._UnitZ = new Vector3(0, 0, 1), Vector3._ForwardRH = new Vector3(0, 0, -1), Vector3._ForwardLH = new Vector3(0, 0, 1), Vector3._Up = new Vector3(0, 1, 0);

        class Config3D {
            constructor() {
                this._defaultPhysicsMemory = 16, this._editerEnvironment = !1, this.isAntialias = !0, this.isAlpha = !1, this.premultipliedAlpha = !0, this.isStencil = !0, this.octreeCulling = !1, this.octreeInitialSize = 64, this.octreeInitialCenter = new Vector3(0, 0, 0), this.octreeMinNodeSize = 2, this.octreeLooseness = 1.25, this.debugFrustumCulling = !1
            }

            get defaultPhysicsMemory() {
                return this._defaultPhysicsMemory
            }

            set defaultPhysicsMemory(value) {
                if (value < 16) throw"defaultPhysicsMemory must large than 16M";
                this._defaultPhysicsMemory = value
            }

            cloneTo(dest) {
                var destConfig3D = dest;
                destConfig3D._defaultPhysicsMemory = this._defaultPhysicsMemory, destConfig3D._editerEnvironment = this._editerEnvironment, destConfig3D.isAntialias = this.isAntialias, destConfig3D.isAlpha = this.isAlpha, destConfig3D.premultipliedAlpha = this.premultipliedAlpha, destConfig3D.isStencil = this.isStencil, destConfig3D.octreeCulling = this.octreeCulling, this.octreeInitialCenter.cloneTo(destConfig3D.octreeInitialCenter), destConfig3D.octreeInitialSize = this.octreeInitialSize, destConfig3D.octreeMinNodeSize = this.octreeMinNodeSize, destConfig3D.octreeLooseness = this.octreeLooseness, destConfig3D.debugFrustumCulling = this.debugFrustumCulling
            }

            clone() {
                var dest = new Config3D;
                return this.cloneTo(dest), dest
            }
        }

        Config3D._default = new Config3D, window.Config3D = Config3D;

        class ILaya3D {
        }

        ILaya3D.Scene3D = null, ILaya3D.MeshRenderStaticBatchManager = null, ILaya3D.MeshRenderDynamicBatchManager = null, ILaya3D.SubMeshDynamicBatch = null, ILaya3D.Laya3D = null, ILaya3D.Matrix4x4 = null;

        class DynamicBatchManager {
            constructor() {
                this._batchRenderElementPool = []
            }

            static _registerManager(manager) {
                DynamicBatchManager._managers.push(manager)
            }

            _clear() {
                this._batchRenderElementPoolIndex = 0
            }

            _getBatchRenderElementFromPool() {
                throw"StaticBatch:must override this function."
            }

            dispose() {
            }
        }

        DynamicBatchManager._managers = [];

        class BufferState extends Laya.BufferStateBase {
            constructor() {
                super()
            }

            applyVertexBuffer(vertexBuffer) {
                if (Laya.BufferStateBase._curBindedBufferState !== this) throw"BufferState: must call bind() function first.";
                var gl = Laya.LayaGL.instance, valueData = vertexBuffer.vertexDeclaration._shaderValues.getData();
                for (var k in vertexBuffer.bind(), valueData) {
                    var loc = parseInt(k), attribute = valueData[k];
                    gl.enableVertexAttribArray(loc), gl.vertexAttribPointer(loc, attribute[0], attribute[1], !!attribute[2], attribute[3], attribute[4])
                }
            }

            applyVertexBuffers(vertexBuffers) {
                if (Laya.BufferStateBase._curBindedBufferState !== this) throw"BufferState: must call bind() function first.";
                for (var gl = Laya.LayaGL.instance, i = 0, n = vertexBuffers.length; i < n; i++) {
                    var verBuf = vertexBuffers[i], valueData = verBuf.vertexDeclaration._shaderValues.getData();
                    for (var k in verBuf.bind(), valueData) {
                        var loc = parseInt(k), attribute = valueData[k];
                        gl.enableVertexAttribArray(loc), gl.vertexAttribPointer(loc, attribute[0], attribute[1], !!attribute[2], attribute[3], attribute[4])
                    }
                }
            }

            applyInstanceVertexBuffer(vertexBuffer) {
                if (Laya.LayaGL.layaGPUInstance.supportInstance()) {
                    if (Laya.BufferStateBase._curBindedBufferState !== this) throw"BufferState: must call bind() function first.";
                    var gl = Laya.LayaGL.instance, valueData = vertexBuffer.vertexDeclaration._shaderValues.getData();
                    for (var k in vertexBuffer.bind(), valueData) {
                        var loc = parseInt(k), attribute = valueData[k];
                        gl.enableVertexAttribArray(loc), gl.vertexAttribPointer(loc, attribute[0], attribute[1], !!attribute[2], attribute[3], attribute[4]), Laya.LayaGL.layaGPUInstance.vertexAttribDivisor(loc, 1)
                    }
                }
            }

            applyIndexBuffer(indexBuffer) {
                if (Laya.BufferStateBase._curBindedBufferState !== this) throw"BufferState: must call bind() function first.";
                this._bindedIndexBuffer !== indexBuffer && (indexBuffer._bindForVAO(), this._bindedIndexBuffer = indexBuffer)
            }
        }

        class GeometryElement {
            constructor() {
                this._destroyed = !1
            }

            get destroyed() {
                return this._destroyed
            }

            _getType() {
                throw"GeometryElement:must override it."
            }

            _prepareRender(state) {
                return !0
            }

            _render(state) {
                throw"GeometryElement:must override it."
            }

            destroy() {
                this._destroyed || (this._destroyed = !0)
            }
        }

        GeometryElement._typeCounter = 0;

        class IndexBuffer3D extends Laya.Buffer {
            constructor(indexType, indexCount, bufferUsage = 35044, canRead = !1) {
                var byteLength;
                if (super(), this._indexType = indexType, this._indexCount = indexCount, this._bufferUsage = bufferUsage, this._bufferType = Laya.LayaGL.instance.ELEMENT_ARRAY_BUFFER, this._canRead = canRead, indexType == IndexBuffer3D.INDEXTYPE_USHORT) this._indexTypeByteCount = 2; else {
                    if (indexType != IndexBuffer3D.INDEXTYPE_UBYTE) throw new Error("unidentification index type.");
                    this._indexTypeByteCount = 1
                }
                byteLength = this._indexTypeByteCount * indexCount, this._byteLength = byteLength;
                var curBufSta = Laya.BufferStateBase._curBindedBufferState;
                curBufSta ? curBufSta._bindedIndexBuffer === this ? Laya.LayaGL.instance.bufferData(this._bufferType, byteLength, this._bufferUsage) : (curBufSta.unBind(), this.bind(), Laya.LayaGL.instance.bufferData(this._bufferType, byteLength, this._bufferUsage), curBufSta.bind()) : (this.bind(), Laya.LayaGL.instance.bufferData(this._bufferType, byteLength, this._bufferUsage)), canRead && (indexType == IndexBuffer3D.INDEXTYPE_USHORT ? this._buffer = new Uint16Array(indexCount) : indexType == IndexBuffer3D.INDEXTYPE_UBYTE && (this._buffer = new Uint8Array(indexCount)))
            }

            get indexType() {
                return this._indexType
            }

            get indexTypeByteCount() {
                return this._indexTypeByteCount
            }

            get indexCount() {
                return this._indexCount
            }

            get canRead() {
                return this._canRead
            }

            _bindForVAO() {
                if (!Laya.BufferStateBase._curBindedBufferState) throw"IndexBuffer3D: must bind current BufferState.";
                var gl = Laya.LayaGL.instance;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._glBuffer)
            }

            bind() {
                if (Laya.BufferStateBase._curBindedBufferState) throw"IndexBuffer3D: must unbind current BufferState.";
                if (Laya.Buffer._bindedIndexBuffer !== this._glBuffer) {
                    var gl = Laya.LayaGL.instance;
                    return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._glBuffer), Laya.Buffer._bindedIndexBuffer = this._glBuffer, !0
                }
                return !1
            }

            setData(data, bufferOffset = 0, dataStartIndex = 0, dataCount = 4294967295) {
                var byteCount;
                this._indexType == IndexBuffer3D.INDEXTYPE_USHORT ? (byteCount = 2, 0 === dataStartIndex && 4294967295 === dataCount || (data = new Uint16Array(data.buffer, dataStartIndex * byteCount, dataCount))) : this._indexType == IndexBuffer3D.INDEXTYPE_UBYTE && (byteCount = 1, 0 === dataStartIndex && 4294967295 === dataCount || (data = new Uint8Array(data.buffer, dataStartIndex * byteCount, dataCount)));
                var curBufSta = Laya.BufferStateBase._curBindedBufferState;
                if (curBufSta ? curBufSta._bindedIndexBuffer === this ? Laya.LayaGL.instance.bufferSubData(this._bufferType, bufferOffset * byteCount, data) : (curBufSta.unBind(), this.bind(), Laya.LayaGL.instance.bufferSubData(this._bufferType, bufferOffset * byteCount, data), curBufSta.bind()) : (this.bind(), Laya.LayaGL.instance.bufferSubData(this._bufferType, bufferOffset * byteCount, data)), this._canRead) if (0 !== bufferOffset || 0 !== dataStartIndex || 4294967295 !== dataCount) {
                    var maxLength = this._buffer.length - bufferOffset;
                    dataCount > maxLength && (dataCount = maxLength);
                    for (var i = 0; i < dataCount; i++) this._buffer[bufferOffset + i] = data[i]
                } else this._buffer = data
            }

            getData() {
                if (this._canRead) return this._buffer;
                throw new Error("Can't read data from VertexBuffer with only write flag!")
            }

            destroy() {
                super.destroy(), this._buffer = null
            }
        }

        IndexBuffer3D.INDEXTYPE_UBYTE = "ubyte", IndexBuffer3D.INDEXTYPE_USHORT = "ushort";

        class VertexBuffer3D extends Laya.Buffer {
            constructor(byteLength, bufferUsage, canRead = !1) {
                super(), this._vertexCount = 0, this._vertexDeclaration = null, this._float32Reader = null;
                var gl = Laya.LayaGL.instance;
                this._vertexCount = -1, this._bufferUsage = bufferUsage, this._bufferType = gl.ARRAY_BUFFER, this._canRead = canRead, this._byteLength = byteLength, this.bind(), gl.bufferData(this._bufferType, this._byteLength, this._bufferUsage), canRead && (this._buffer = new Uint8Array(byteLength), this._float32Reader = new Float32Array(this._buffer.buffer))
            }

            get vertexDeclaration() {
                return this._vertexDeclaration
            }

            set vertexDeclaration(value) {
                this._vertexDeclaration !== value && (this._vertexDeclaration = value, this._vertexCount = value ? this._byteLength / value.vertexStride : -1)
            }

            get vertexCount() {
                return this._vertexCount
            }

            get canRead() {
                return this._canRead
            }

            bind() {
                if (Laya.Buffer._bindedVertexBuffer !== this._glBuffer) {
                    var gl = Laya.LayaGL.instance;
                    return gl.bindBuffer(gl.ARRAY_BUFFER, this._glBuffer), Laya.Buffer._bindedVertexBuffer = this._glBuffer, !0
                }
                return !1
            }

            setData(buffer, bufferOffset = 0, dataStartIndex = 0, dataCount = 4294967295) {
                if (this.bind(), 0 !== dataStartIndex || 4294967295 !== dataCount) {
                    var subData = new Uint8Array(buffer, dataStartIndex, dataCount);
                    Laya.LayaGL.instance.bufferSubData(this._bufferType, bufferOffset, subData), this._canRead && this._buffer.set(subData, bufferOffset)
                } else Laya.LayaGL.instance.bufferSubData(this._bufferType, bufferOffset, buffer), this._canRead && this._buffer.set(new Uint8Array(buffer), bufferOffset)
            }

            getUint8Data() {
                if (this._canRead) return this._buffer;
                throw new Error("Can't read data from VertexBuffer with only write flag!")
            }

            getFloat32Data() {
                if (this._canRead) return this._float32Reader;
                throw new Error("Can't read data from VertexBuffer with only write flag!")
            }

            markAsUnreadbale() {
                this._canRead = !1, this._buffer = null, this._float32Reader = null
            }

            destroy() {
                super.destroy(), this._buffer = null, this._float32Reader = null, this._vertexDeclaration = null
            }
        }

        VertexBuffer3D.DATATYPE_FLOAT32ARRAY = 0, VertexBuffer3D.DATATYPE_UINT8ARRAY = 1;

        class VertexElementFormat {
            static __init__() {
                var gl = Laya.LayaGL.instance;
                VertexElementFormat._elementInfos = {
                    single: [1, gl.FLOAT, 0],
                    vector2: [2, gl.FLOAT, 0],
                    vector3: [3, gl.FLOAT, 0],
                    vector4: [4, gl.FLOAT, 0],
                    color: [4, gl.FLOAT, 0],
                    byte4: [4, gl.UNSIGNED_BYTE, 0],
                    short2: [2, gl.FLOAT, 0],
                    short4: [4, gl.FLOAT, 0],
                    normalizedshort2: [2, gl.FLOAT, 0],
                    normalizedshort4: [4, gl.FLOAT, 0],
                    halfvector2: [2, gl.FLOAT, 0],
                    halfvector4: [4, gl.FLOAT, 0]
                }
            }

            static getElementInfos(element) {
                var info = VertexElementFormat._elementInfos[element];
                if (info) return info;
                throw"VertexElementFormat: this vertexElementFormat is not implement."
            }
        }

        VertexElementFormat.Single = "single", VertexElementFormat.Vector2 = "vector2", VertexElementFormat.Vector3 = "vector3", VertexElementFormat.Vector4 = "vector4", VertexElementFormat.Color = "color", VertexElementFormat.Byte4 = "byte4", VertexElementFormat.Short2 = "short2", VertexElementFormat.Short4 = "short4", VertexElementFormat.NormalizedShort2 = "normalizedshort2", VertexElementFormat.NormalizedShort4 = "normalizedshort4", VertexElementFormat.HalfVector2 = "halfvector2", VertexElementFormat.HalfVector4 = "halfvector4";

        class Matrix3x3 {
            constructor() {
                var e = this.elements = new Float32Array(9);
                e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1
            }

            static createRotationQuaternion(rotation, out) {
                var rotX = rotation.x, rotY = rotation.y, rotZ = rotation.z, rotW = rotation.w, xx = rotX * rotX,
                    yy = rotY * rotY, zz = rotZ * rotZ, xy = rotX * rotY, zw = rotZ * rotW, zx = rotZ * rotX,
                    yw = rotY * rotW, yz = rotY * rotZ, xw = rotX * rotW, resultE = out.elements;
                resultE[0] = 1 - 2 * (yy + zz), resultE[1] = 2 * (xy + zw), resultE[2] = 2 * (zx - yw), resultE[3] = 2 * (xy - zw), resultE[4] = 1 - 2 * (zz + xx), resultE[5] = 2 * (yz + xw), resultE[6] = 2 * (zx + yw), resultE[7] = 2 * (yz - xw), resultE[8] = 1 - 2 * (yy + xx)
            }

            static createFromTranslation(trans, out) {
                out.elements;
                out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 1, out[5] = 0, out[6] = trans.x, out[7] = trans.y, out[8] = 1
            }

            static createFromRotation(rad, out) {
                var e = out.elements, s = Math.sin(rad), c = Math.cos(rad);
                e[0] = c, e[1] = s, e[2] = 0, e[3] = -s, e[4] = c, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1
            }

            static createFromScaling(scale, out) {
                var e = out.elements;
                e[0] = scale.x, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = scale.y, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = scale.z
            }

            static createFromMatrix4x4(sou, out) {
                var souE = sou.elements, outE = out.elements;
                outE[0] = souE[0], outE[1] = souE[1], outE[2] = souE[2], outE[3] = souE[4], outE[4] = souE[5], outE[5] = souE[6], outE[6] = souE[8], outE[7] = souE[9], outE[8] = souE[10]
            }

            static multiply(left, right, out) {
                var l = left.elements, r = right.elements, e = out.elements, l11 = l[0], l12 = l[1], l13 = l[2],
                    l21 = l[3], l22 = l[4], l23 = l[5], l31 = l[6], l32 = l[7], l33 = l[8], r11 = r[0], r12 = r[1],
                    r13 = r[2], r21 = r[3], r22 = r[4], r23 = r[5], r31 = r[6], r32 = r[7], r33 = r[8];
                e[0] = r11 * l11 + r12 * l21 + r13 * l31, e[1] = r11 * l12 + r12 * l22 + r13 * r32, e[2] = r11 * l13 + r12 * l23 + r13 * l33, e[3] = r21 * l11 + r22 * l21 + r23 * l31, e[4] = r21 * l12 + r22 * l22 + r23 * l32, e[5] = r21 * l13 + r22 * l23 + r23 * l33, e[6] = r31 * l11 + r32 * l21 + r33 * l31, e[7] = r31 * l12 + r32 * l22 + r33 * l32, e[8] = r31 * l13 + r32 * l23 + r33 * l33
            }

            determinant() {
                var f = this.elements, a00 = f[0], a01 = f[1], a02 = f[2], a10 = f[3], a11 = f[4], a12 = f[5],
                    a20 = f[6], a21 = f[7], a22 = f[8];
                return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20)
            }

            translate(trans, out) {
                var e = out.elements, f = this.elements, a00 = f[0], a01 = f[1], a02 = f[2], a10 = f[3], a11 = f[4],
                    a12 = f[5], a20 = f[6], a21 = f[7], a22 = f[8], x = trans.x, y = trans.y;
                e[0] = a00, e[1] = a01, e[2] = a02, e[3] = a10, e[4] = a11, e[5] = a12, e[6] = x * a00 + y * a10 + a20, e[7] = x * a01 + y * a11 + a21, e[8] = x * a02 + y * a12 + a22
            }

            rotate(rad, out) {
                var e = out.elements, f = this.elements, a00 = f[0], a01 = f[1], a02 = f[2], a10 = f[3], a11 = f[4],
                    a12 = f[5], a20 = f[6], a21 = f[7], a22 = f[8], s = Math.sin(rad), c = Math.cos(rad);
                e[0] = c * a00 + s * a10, e[1] = c * a01 + s * a11, e[2] = c * a02 + s * a12, e[3] = c * a10 - s * a00, e[4] = c * a11 - s * a01, e[5] = c * a12 - s * a02, e[6] = a20, e[7] = a21, e[8] = a22
            }

            scale(scale, out) {
                var e = out.elements, f = this.elements, x = scale.x, y = scale.y;
                e[0] = x * f[0], e[1] = x * f[1], e[2] = x * f[2], e[3] = y * f[3], e[4] = y * f[4], e[5] = y * f[5], e[6] = f[6], e[7] = f[7], e[8] = f[8]
            }

            invert(out) {
                var e = out.elements, f = this.elements, a00 = f[0], a01 = f[1], a02 = f[2], a10 = f[3], a11 = f[4],
                    a12 = f[5], a20 = f[6], a21 = f[7], a22 = f[8], b01 = a22 * a11 - a12 * a21,
                    b11 = -a22 * a10 + a12 * a20, b21 = a21 * a10 - a11 * a20, det = a00 * b01 + a01 * b11 + a02 * b21;
                det || (out = null), det = 1 / det, e[0] = b01 * det, e[1] = (-a22 * a01 + a02 * a21) * det, e[2] = (a12 * a01 - a02 * a11) * det, e[3] = b11 * det, e[4] = (a22 * a00 - a02 * a20) * det, e[5] = (-a12 * a00 + a02 * a10) * det, e[6] = b21 * det, e[7] = (-a21 * a00 + a01 * a20) * det, e[8] = (a11 * a00 - a01 * a10) * det
            }

            transpose(out) {
                var e = out.elements, f = this.elements;
                if (out === this) {
                    var a01 = f[1], a02 = f[2], a12 = f[5];
                    e[1] = f[3], e[2] = f[6], e[3] = a01, e[5] = f[7], e[6] = a02, e[7] = a12
                } else e[0] = f[0], e[1] = f[3], e[2] = f[6], e[3] = f[1], e[4] = f[4], e[5] = f[7], e[6] = f[2], e[7] = f[5], e[8] = f[8]
            }

            identity() {
                var e = this.elements;
                e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1
            }

            cloneTo(destObject) {
                var i, s, d;
                if ((s = this.elements) !== (d = destObject.elements)) for (i = 0; i < 9; ++i) d[i] = s[i]
            }

            clone() {
                var dest = new Matrix3x3;
                return this.cloneTo(dest), dest
            }

            static lookAt(eye, target, up, out) {
                Vector3.subtract(eye, target, Matrix3x3._tempV30), Vector3.normalize(Matrix3x3._tempV30, Matrix3x3._tempV30), Vector3.cross(up, Matrix3x3._tempV30, Matrix3x3._tempV31), Vector3.normalize(Matrix3x3._tempV31, Matrix3x3._tempV31), Vector3.cross(Matrix3x3._tempV30, Matrix3x3._tempV31, Matrix3x3._tempV32);
                var v0 = Matrix3x3._tempV30, v1 = Matrix3x3._tempV31, v2 = Matrix3x3._tempV32, me = out.elements;
                me[0] = v1.x, me[3] = v1.y, me[6] = v1.z, me[1] = v2.x, me[4] = v2.y, me[7] = v2.z, me[2] = v0.x, me[5] = v0.y, me[8] = v0.z
            }
        }

        Matrix3x3.DEFAULT = new Matrix3x3, Matrix3x3._tempV30 = new Vector3, Matrix3x3._tempV31 = new Vector3, Matrix3x3._tempV32 = new Vector3;

        class Quaternion {
            constructor(x = 0, y = 0, z = 0, w = 1, nativeElements = null) {
                this.x = x, this.y = y, this.z = z, this.w = w
            }

            static createFromYawPitchRoll(yaw, pitch, roll, out) {
                var halfRoll = .5 * roll, halfPitch = .5 * pitch, halfYaw = .5 * yaw, sinRoll = Math.sin(halfRoll),
                    cosRoll = Math.cos(halfRoll), sinPitch = Math.sin(halfPitch), cosPitch = Math.cos(halfPitch),
                    sinYaw = Math.sin(halfYaw), cosYaw = Math.cos(halfYaw);
                out.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll, out.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll, out.z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll, out.w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll
            }

            static multiply(left, right, out) {
                var lx = left.x, ly = left.y, lz = left.z, lw = left.w, rx = right.x, ry = right.y, rz = right.z,
                    rw = right.w, a = ly * rz - lz * ry, b = lz * rx - lx * rz, c = lx * ry - ly * rx,
                    d = lx * rx + ly * ry + lz * rz;
                out.x = lx * rw + rx * lw + a, out.y = ly * rw + ry * lw + b, out.z = lz * rw + rz * lw + c, out.w = lw * rw - d
            }

            static arcTanAngle(x, y) {
                return 0 == x ? 1 == y ? Math.PI / 2 : -Math.PI / 2 : x > 0 ? Math.atan(y / x) : x < 0 ? y > 0 ? Math.atan(y / x) + Math.PI : Math.atan(y / x) - Math.PI : 0
            }

            static angleTo(from, location, angle) {
                Vector3.subtract(location, from, Quaternion.TEMPVector30), Vector3.normalize(Quaternion.TEMPVector30, Quaternion.TEMPVector30), angle.x = Math.asin(Quaternion.TEMPVector30.y), angle.y = Quaternion.arcTanAngle(-Quaternion.TEMPVector30.z, -Quaternion.TEMPVector30.x)
            }

            static createFromAxisAngle(axis, rad, out) {
                rad *= .5;
                var s = Math.sin(rad);
                out.x = s * axis.x, out.y = s * axis.y, out.z = s * axis.z, out.w = Math.cos(rad)
            }

            static createFromMatrix4x4(mat, out) {
                var sqrt, half, me = mat.elements, scale = me[0] + me[5] + me[10];
                scale > 0 ? (sqrt = Math.sqrt(scale + 1), out.w = .5 * sqrt, sqrt = .5 / sqrt, out.x = (me[6] - me[9]) * sqrt, out.y = (me[8] - me[2]) * sqrt, out.z = (me[1] - me[4]) * sqrt) : me[0] >= me[5] && me[0] >= me[10] ? (half = .5 / (sqrt = Math.sqrt(1 + me[0] - me[5] - me[10])), out.x = .5 * sqrt, out.y = (me[1] + me[4]) * half, out.z = (me[2] + me[8]) * half, out.w = (me[6] - me[9]) * half) : me[5] > me[10] ? (half = .5 / (sqrt = Math.sqrt(1 + me[5] - me[0] - me[10])), out.x = (me[4] + me[1]) * half, out.y = .5 * sqrt, out.z = (me[9] + me[6]) * half, out.w = (me[8] - me[2]) * half) : (half = .5 / (sqrt = Math.sqrt(1 + me[10] - me[0] - me[5])), out.x = (me[8] + me[2]) * half, out.y = (me[9] + me[6]) * half, out.z = .5 * sqrt, out.w = (me[1] - me[4]) * half)
            }

            static slerp(left, right, t, out) {
                var omega, cosom, sinom, scale0, scale1, ax = left.x, ay = left.y, az = left.z, aw = left.w,
                    bx = right.x, by = right.y, bz = right.z, bw = right.w;
                return (cosom = ax * bx + ay * by + az * bz + aw * bw) < 0 && (cosom = -cosom, bx = -bx, by = -by, bz = -bz, bw = -bw), 1 - cosom > 1e-6 ? (omega = Math.acos(cosom), sinom = Math.sin(omega), scale0 = Math.sin((1 - t) * omega) / sinom, scale1 = Math.sin(t * omega) / sinom) : (scale0 = 1 - t, scale1 = t), out.x = scale0 * ax + scale1 * bx, out.y = scale0 * ay + scale1 * by, out.z = scale0 * az + scale1 * bz, out.w = scale0 * aw + scale1 * bw, out
            }

            static lerp(left, right, amount, out) {
                var inverse = 1 - amount;
                Quaternion.dot(left, right) >= 0 ? (out.x = inverse * left.x + amount * right.x, out.y = inverse * left.y + amount * right.y, out.z = inverse * left.z + amount * right.z, out.w = inverse * left.w + amount * right.w) : (out.x = inverse * left.x - amount * right.x, out.y = inverse * left.y - amount * right.y, out.z = inverse * left.z - amount * right.z, out.w = inverse * left.w - amount * right.w), out.normalize(out)
            }

            static add(left, right, out) {
                out.x = left.x + right.x, out.y = left.y + right.y, out.z = left.z + right.z, out.w = left.w + right.w
            }

            static dot(left, right) {
                return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w
            }

            scaling(scaling, out) {
                out.x = this.x * scaling, out.y = this.y * scaling, out.z = this.z * scaling, out.w = this.w * scaling
            }

            normalize(out) {
                var len = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                len > 0 && (len = 1 / Math.sqrt(len), out.x = this.x * len, out.y = this.y * len, out.z = this.z * len, out.w = this.w * len)
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }

            rotateX(rad, out) {
                rad *= .5;
                var bx = Math.sin(rad), bw = Math.cos(rad);
                out.x = this.x * bw + this.w * bx, out.y = this.y * bw + this.z * bx, out.z = this.z * bw - this.y * bx, out.w = this.w * bw - this.x * bx
            }

            rotateY(rad, out) {
                rad *= .5;
                var by = Math.sin(rad), bw = Math.cos(rad);
                out.x = this.x * bw - this.z * by, out.y = this.y * bw + this.w * by, out.z = this.z * bw + this.x * by, out.w = this.w * bw - this.y * by
            }

            rotateZ(rad, out) {
                rad *= .5;
                var bz = Math.sin(rad), bw = Math.cos(rad);
                out.x = this.x * bw + this.y * bz, out.y = this.y * bw - this.x * bz, out.z = this.z * bw + this.w * bz, out.w = this.w * bw - this.z * bz
            }

            getYawPitchRoll(out) {
                Vector3.transformQuat(Vector3._ForwardRH, this, Quaternion.TEMPVector31), Vector3.transformQuat(Vector3._Up, this, Quaternion.TEMPVector32);
                var upe = Quaternion.TEMPVector32;
                Quaternion.angleTo(Vector3._ZERO, Quaternion.TEMPVector31, Quaternion.TEMPVector33);
                var angle = Quaternion.TEMPVector33;
                angle.x == Math.PI / 2 ? (angle.y = Quaternion.arcTanAngle(upe.z, upe.x), angle.z = 0) : angle.x == -Math.PI / 2 ? (angle.y = Quaternion.arcTanAngle(-upe.z, -upe.x), angle.z = 0) : (ILaya3D.Matrix4x4.createRotationY(-angle.y, ILaya3D.Matrix4x4.TEMPMatrix0), ILaya3D.Matrix4x4.createRotationX(-angle.x, ILaya3D.Matrix4x4.TEMPMatrix1), Vector3.transformCoordinate(Quaternion.TEMPVector32, ILaya3D.Matrix4x4.TEMPMatrix0, Quaternion.TEMPVector32), Vector3.transformCoordinate(Quaternion.TEMPVector32, ILaya3D.Matrix4x4.TEMPMatrix1, Quaternion.TEMPVector32), angle.z = Quaternion.arcTanAngle(upe.y, -upe.x)), angle.y <= -Math.PI && (angle.y = Math.PI), angle.z <= -Math.PI && (angle.z = Math.PI), angle.y >= Math.PI && angle.z >= Math.PI && (angle.y = 0, angle.z = 0, angle.x = Math.PI - angle.x);
                var oe = out;
                oe.x = angle.y, oe.y = angle.x, oe.z = angle.z
            }

            invert(out) {
                var a0 = this.x, a1 = this.y, a2 = this.z, a3 = this.w, dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3,
                    invDot = dot ? 1 / dot : 0;
                out.x = -a0 * invDot, out.y = -a1 * invDot, out.z = -a2 * invDot, out.w = a3 * invDot
            }

            identity() {
                this.x = 0, this.y = 0, this.z = 0, this.w = 1
            }

            fromArray(array, offset = 0) {
                this.x = array[offset + 0], this.y = array[offset + 1], this.z = array[offset + 2], this.w = array[offset + 3]
            }

            cloneTo(destObject) {
                this !== destObject && (destObject.x = this.x, destObject.y = this.y, destObject.z = this.z, destObject.w = this.w)
            }

            clone() {
                var dest = new Quaternion;
                return this.cloneTo(dest), dest
            }

            equals(b) {
                return MathUtils3D.nearEqual(this.x, b.x) && MathUtils3D.nearEqual(this.y, b.y) && MathUtils3D.nearEqual(this.z, b.z) && MathUtils3D.nearEqual(this.w, b.w)
            }

            static rotationLookAt(forward, up, out) {
                Quaternion.lookAt(Vector3._ZERO, forward, up, out)
            }

            static lookAt(eye, target, up, out) {
                Matrix3x3.lookAt(eye, target, up, Quaternion._tempMatrix3x3), Quaternion.rotationMatrix(Quaternion._tempMatrix3x3, out)
            }

            lengthSquared() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }

            static invert(value, out) {
                var lengthSq = value.lengthSquared();
                MathUtils3D.isZero(lengthSq) || (lengthSq = 1 / lengthSq, out.x = -value.x * lengthSq, out.y = -value.y * lengthSq, out.z = -value.z * lengthSq, out.w = value.w * lengthSq)
            }

            static rotationMatrix(matrix3x3, out) {
                var sqrt, half, me = matrix3x3.elements, m11 = me[0], m12 = me[1], m13 = me[2], m21 = me[3],
                    m22 = me[4], m23 = me[5], m31 = me[6], m32 = me[7], m33 = me[8], scale = m11 + m22 + m33;
                scale > 0 ? (sqrt = Math.sqrt(scale + 1), out.w = .5 * sqrt, sqrt = .5 / sqrt, out.x = (m23 - m32) * sqrt, out.y = (m31 - m13) * sqrt, out.z = (m12 - m21) * sqrt) : m11 >= m22 && m11 >= m33 ? (half = .5 / (sqrt = Math.sqrt(1 + m11 - m22 - m33)), out.x = .5 * sqrt, out.y = (m12 + m21) * half, out.z = (m13 + m31) * half, out.w = (m23 - m32) * half) : m22 > m33 ? (half = .5 / (sqrt = Math.sqrt(1 + m22 - m11 - m33)), out.x = (m21 + m12) * half, out.y = .5 * sqrt, out.z = (m32 + m23) * half, out.w = (m31 - m13) * half) : (half = .5 / (sqrt = Math.sqrt(1 + m33 - m11 - m22)), out.x = (m31 + m13) * half, out.y = (m32 + m23) * half, out.z = .5 * sqrt, out.w = (m12 - m21) * half)
            }

            forNativeElement(nativeElements = null) {
                nativeElements ? (this.elements = nativeElements, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z, this.elements[3] = this.w) : this.elements = new Float32Array([this.x, this.y, this.z, this.w]), Vector2.rewriteNumProperty(this, "x", 0), Vector2.rewriteNumProperty(this, "y", 1), Vector2.rewriteNumProperty(this, "z", 2), Vector2.rewriteNumProperty(this, "w", 3)
            }
        }

        Quaternion.TEMPVector30 = new Vector3, Quaternion.TEMPVector31 = new Vector3, Quaternion.TEMPVector32 = new Vector3, Quaternion.TEMPVector33 = new Vector3, Quaternion._tempMatrix3x3 = new Matrix3x3, Quaternion.DEFAULT = new Quaternion, Quaternion.NAN = new Quaternion(NaN, NaN, NaN, NaN);

        class Matrix4x4 {
            constructor(m11 = 1, m12 = 0, m13 = 0, m14 = 0, m21 = 0, m22 = 1, m23 = 0, m24 = 0, m31 = 0, m32 = 0, m33 = 1, m34 = 0, m41 = 0, m42 = 0, m43 = 0, m44 = 1, elements = null) {
                var e = this.elements = elements || new Float32Array(16);
                e[0] = m11, e[1] = m12, e[2] = m13, e[3] = m14, e[4] = m21, e[5] = m22, e[6] = m23, e[7] = m24, e[8] = m31, e[9] = m32, e[10] = m33, e[11] = m34, e[12] = m41, e[13] = m42, e[14] = m43, e[15] = m44
            }

            static createRotationX(rad, out) {
                var oe = out.elements, s = Math.sin(rad), c = Math.cos(rad);
                oe[1] = oe[2] = oe[3] = oe[4] = oe[7] = oe[8] = oe[11] = oe[12] = oe[13] = oe[14] = 0, oe[0] = oe[15] = 1, oe[5] = oe[10] = c, oe[6] = s, oe[9] = -s
            }

            static createRotationY(rad, out) {
                var oe = out.elements, s = Math.sin(rad), c = Math.cos(rad);
                oe[1] = oe[3] = oe[4] = oe[6] = oe[7] = oe[9] = oe[11] = oe[12] = oe[13] = oe[14] = 0, oe[5] = oe[15] = 1, oe[0] = oe[10] = c, oe[2] = -s, oe[8] = s
            }

            static createRotationZ(rad, out) {
                var oe = out.elements, s = Math.sin(rad), c = Math.cos(rad);
                oe[2] = oe[3] = oe[6] = oe[7] = oe[8] = oe[9] = oe[11] = oe[12] = oe[13] = oe[14] = 0, oe[10] = oe[15] = 1, oe[0] = oe[5] = c, oe[1] = s, oe[4] = -s
            }

            static createRotationYawPitchRoll(yaw, pitch, roll, result) {
                Quaternion.createFromYawPitchRoll(yaw, pitch, roll, Matrix4x4._tempQuaternion), Matrix4x4.createRotationQuaternion(Matrix4x4._tempQuaternion, result)
            }

            static createRotationAxis(axis, angle, result) {
                var x = axis.x, y = axis.y, z = axis.z, cos = Math.cos(angle), sin = Math.sin(angle), xx = x * x,
                    yy = y * y, zz = z * z, xy = x * y, xz = x * z, yz = y * z, resultE = result.elements;
                resultE[3] = resultE[7] = resultE[11] = resultE[12] = resultE[13] = resultE[14] = 0, resultE[15] = 1, resultE[0] = xx + cos * (1 - xx), resultE[1] = xy - cos * xy + sin * z, resultE[2] = xz - cos * xz - sin * y, resultE[4] = xy - cos * xy - sin * z, resultE[5] = yy + cos * (1 - yy), resultE[6] = yz - cos * yz + sin * x, resultE[8] = xz - cos * xz + sin * y, resultE[9] = yz - cos * yz - sin * x, resultE[10] = zz + cos * (1 - zz)
            }

            setRotation(rotation) {
                var rotationX = rotation.x, rotationY = rotation.y, rotationZ = rotation.z, rotationW = rotation.w,
                    xx = rotationX * rotationX, yy = rotationY * rotationY, zz = rotationZ * rotationZ,
                    xy = rotationX * rotationY, zw = rotationZ * rotationW, zx = rotationZ * rotationX,
                    yw = rotationY * rotationW, yz = rotationY * rotationZ, xw = rotationX * rotationW,
                    e = this.elements;
                e[0] = 1 - 2 * (yy + zz), e[1] = 2 * (xy + zw), e[2] = 2 * (zx - yw), e[4] = 2 * (xy - zw), e[5] = 1 - 2 * (zz + xx), e[6] = 2 * (yz + xw), e[8] = 2 * (zx + yw), e[9] = 2 * (yz - xw), e[10] = 1 - 2 * (yy + xx)
            }

            setPosition(position) {
                var e = this.elements;
                e[12] = position.x, e[13] = position.y, e[14] = position.z
            }

            static createRotationQuaternion(rotation, result) {
                var resultE = result.elements, rotationX = rotation.x, rotationY = rotation.y, rotationZ = rotation.z,
                    rotationW = rotation.w, xx = rotationX * rotationX, yy = rotationY * rotationY,
                    zz = rotationZ * rotationZ, xy = rotationX * rotationY, zw = rotationZ * rotationW,
                    zx = rotationZ * rotationX, yw = rotationY * rotationW, yz = rotationY * rotationZ,
                    xw = rotationX * rotationW;
                resultE[3] = resultE[7] = resultE[11] = resultE[12] = resultE[13] = resultE[14] = 0, resultE[15] = 1, resultE[0] = 1 - 2 * (yy + zz), resultE[1] = 2 * (xy + zw), resultE[2] = 2 * (zx - yw), resultE[4] = 2 * (xy - zw), resultE[5] = 1 - 2 * (zz + xx), resultE[6] = 2 * (yz + xw), resultE[8] = 2 * (zx + yw), resultE[9] = 2 * (yz - xw), resultE[10] = 1 - 2 * (yy + xx)
            }

            static createTranslate(trans, out) {
                var oe = out.elements;
                oe[4] = oe[8] = oe[1] = oe[9] = oe[2] = oe[6] = oe[3] = oe[7] = oe[11] = 0, oe[0] = oe[5] = oe[10] = oe[15] = 1, oe[12] = trans.x, oe[13] = trans.y, oe[14] = trans.z
            }

            static createScaling(scale, out) {
                var oe = out.elements;
                oe[0] = scale.x, oe[5] = scale.y, oe[10] = scale.z, oe[1] = oe[4] = oe[8] = oe[12] = oe[9] = oe[13] = oe[2] = oe[6] = oe[14] = oe[3] = oe[7] = oe[11] = 0, oe[15] = 1
            }

            static multiply(left, right, out) {
                var l = right.elements, r = left.elements, e = out.elements, l11 = l[0], l12 = l[1], l13 = l[2],
                    l14 = l[3], l21 = l[4], l22 = l[5], l23 = l[6], l24 = l[7], l31 = l[8], l32 = l[9], l33 = l[10],
                    l34 = l[11], l41 = l[12], l42 = l[13], l43 = l[14], l44 = l[15], r11 = r[0], r12 = r[1], r13 = r[2],
                    r14 = r[3], r21 = r[4], r22 = r[5], r23 = r[6], r24 = r[7], r31 = r[8], r32 = r[9], r33 = r[10],
                    r34 = r[11], r41 = r[12], r42 = r[13], r43 = r[14], r44 = r[15];
                e[0] = l11 * r11 + l12 * r21 + l13 * r31 + l14 * r41, e[1] = l11 * r12 + l12 * r22 + l13 * r32 + l14 * r42, e[2] = l11 * r13 + l12 * r23 + l13 * r33 + l14 * r43, e[3] = l11 * r14 + l12 * r24 + l13 * r34 + l14 * r44, e[4] = l21 * r11 + l22 * r21 + l23 * r31 + l24 * r41, e[5] = l21 * r12 + l22 * r22 + l23 * r32 + l24 * r42, e[6] = l21 * r13 + l22 * r23 + l23 * r33 + l24 * r43, e[7] = l21 * r14 + l22 * r24 + l23 * r34 + l24 * r44, e[8] = l31 * r11 + l32 * r21 + l33 * r31 + l34 * r41, e[9] = l31 * r12 + l32 * r22 + l33 * r32 + l34 * r42, e[10] = l31 * r13 + l32 * r23 + l33 * r33 + l34 * r43, e[11] = l31 * r14 + l32 * r24 + l33 * r34 + l34 * r44, e[12] = l41 * r11 + l42 * r21 + l43 * r31 + l44 * r41, e[13] = l41 * r12 + l42 * r22 + l43 * r32 + l44 * r42, e[14] = l41 * r13 + l42 * r23 + l43 * r33 + l44 * r43, e[15] = l41 * r14 + l42 * r24 + l43 * r34 + l44 * r44
            }

            static multiplyForNative(left, right, out) {
                Laya.LayaGL.instance.matrix4x4Multiply(left.elements, right.elements, out.elements)
            }

            static createFromQuaternion(rotation, out) {
                var e = out.elements, x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w, x2 = x + x,
                    y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2,
                    zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
                e[0] = 1 - yy - zz, e[1] = yx + wz, e[2] = zx - wy, e[3] = 0, e[4] = yx - wz, e[5] = 1 - xx - zz, e[6] = zy + wx, e[7] = 0, e[8] = zx + wy, e[9] = zy - wx, e[10] = 1 - xx - yy, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1
            }

            static createAffineTransformation(trans, rot, scale, out) {
                var oe = out.elements, x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z,
                    xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2,
                    wy = w * y2, wz = w * z2, sx = scale.x, sy = scale.y, sz = scale.z;
                oe[0] = (1 - (yy + zz)) * sx, oe[1] = (xy + wz) * sx, oe[2] = (xz - wy) * sx, oe[3] = 0, oe[4] = (xy - wz) * sy, oe[5] = (1 - (xx + zz)) * sy, oe[6] = (yz + wx) * sy, oe[7] = 0, oe[8] = (xz + wy) * sz, oe[9] = (yz - wx) * sz, oe[10] = (1 - (xx + yy)) * sz, oe[11] = 0, oe[12] = trans.x, oe[13] = trans.y, oe[14] = trans.z, oe[15] = 1
            }

            static createLookAt(eye, target, up, out) {
                var oE = out.elements, xaxis = Matrix4x4._tempVector0, yaxis = Matrix4x4._tempVector1,
                    zaxis = Matrix4x4._tempVector2;
                Vector3.subtract(eye, target, zaxis), Vector3.normalize(zaxis, zaxis), Vector3.cross(up, zaxis, xaxis), Vector3.normalize(xaxis, xaxis), Vector3.cross(zaxis, xaxis, yaxis), out.identity(), oE[0] = xaxis.x, oE[4] = xaxis.y, oE[8] = xaxis.z, oE[1] = yaxis.x, oE[5] = yaxis.y, oE[9] = yaxis.z, oE[2] = zaxis.x, oE[6] = zaxis.y, oE[10] = zaxis.z, oE[12] = -Vector3.dot(xaxis, eye), oE[13] = -Vector3.dot(yaxis, eye), oE[14] = -Vector3.dot(zaxis, eye)
            }

            static createPerspective(fov, aspect, znear, zfar, out) {
                var yScale = 1 / Math.tan(.5 * fov), halfWidth = znear / (yScale / aspect), halfHeight = znear / yScale;
                Matrix4x4.createPerspectiveOffCenter(-halfWidth, halfWidth, -halfHeight, halfHeight, znear, zfar, out)
            }

            static createPerspectiveOffCenter(left, right, bottom, top, znear, zfar, out) {
                var oe = out.elements, zRange = zfar / (zfar - znear);
                oe[1] = oe[2] = oe[3] = oe[4] = oe[6] = oe[7] = oe[12] = oe[13] = oe[15] = 0, oe[0] = 2 * znear / (right - left), oe[5] = 2 * znear / (top - bottom), oe[8] = (left + right) / (right - left), oe[9] = (top + bottom) / (top - bottom), oe[10] = -zRange, oe[11] = -1, oe[14] = -znear * zRange
            }

            static createOrthoOffCenter(left, right, bottom, top, znear, zfar, out) {
                var oe = out.elements, zRange = 1 / (zfar - znear);
                oe[1] = oe[2] = oe[3] = oe[4] = oe[6] = oe[8] = oe[7] = oe[9] = oe[11] = 0, oe[15] = 1, oe[0] = 2 / (right - left), oe[5] = 2 / (top - bottom), oe[10] = -zRange, oe[12] = (left + right) / (left - right), oe[13] = (top + bottom) / (bottom - top), oe[14] = -znear * zRange
            }

            getElementByRowColumn(row, column) {
                if (row < 0 || row > 3) throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
                if (column < 0 || column > 3) throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
                return this.elements[4 * row + column]
            }

            setElementByRowColumn(row, column, value) {
                if (row < 0 || row > 3) throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
                if (column < 0 || column > 3) throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
                this.elements[4 * row + column] = value
            }

            equalsOtherMatrix(other) {
                var e = this.elements, oe = other.elements;
                return MathUtils3D.nearEqual(e[0], oe[0]) && MathUtils3D.nearEqual(e[1], oe[1]) && MathUtils3D.nearEqual(e[2], oe[2]) && MathUtils3D.nearEqual(e[3], oe[3]) && MathUtils3D.nearEqual(e[4], oe[4]) && MathUtils3D.nearEqual(e[5], oe[5]) && MathUtils3D.nearEqual(e[6], oe[6]) && MathUtils3D.nearEqual(e[7], oe[7]) && MathUtils3D.nearEqual(e[8], oe[8]) && MathUtils3D.nearEqual(e[9], oe[9]) && MathUtils3D.nearEqual(e[10], oe[10]) && MathUtils3D.nearEqual(e[11], oe[11]) && MathUtils3D.nearEqual(e[12], oe[12]) && MathUtils3D.nearEqual(e[13], oe[13]) && MathUtils3D.nearEqual(e[14], oe[14]) && MathUtils3D.nearEqual(e[15], oe[15])
            }

            decomposeTransRotScale(translation, rotation, scale) {
                var rotationMatrix = Matrix4x4._tempMatrix4x4;
                return this.decomposeTransRotMatScale(translation, rotationMatrix, scale) ? (Quaternion.createFromMatrix4x4(rotationMatrix, rotation), !0) : (rotation.identity(), !1)
            }

            decomposeTransRotMatScale(translation, rotationMatrix, scale) {
                var e = this.elements, te = translation, re = rotationMatrix.elements, se = scale;
                te.x = e[12], te.y = e[13], te.z = e[14];
                var m11 = e[0], m12 = e[1], m13 = e[2], m21 = e[4], m22 = e[5], m23 = e[6], m31 = e[8], m32 = e[9],
                    m33 = e[10], sX = se.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13),
                    sY = se.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23),
                    sZ = se.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
                if (MathUtils3D.isZero(sX) || MathUtils3D.isZero(sY) || MathUtils3D.isZero(sZ)) return re[1] = re[2] = re[3] = re[4] = re[6] = re[7] = re[8] = re[9] = re[11] = re[12] = re[13] = re[14] = 0, re[0] = re[5] = re[10] = re[15] = 1, !1;
                var at = Matrix4x4._tempVector0;
                at.x = m31 / sZ, at.y = m32 / sZ, at.z = m33 / sZ;
                var tempRight = Matrix4x4._tempVector1;
                tempRight.x = m11 / sX, tempRight.y = m12 / sX, tempRight.z = m13 / sX;
                var up = Matrix4x4._tempVector2;
                Vector3.cross(at, tempRight, up);
                var right = Matrix4x4._tempVector1;
                return Vector3.cross(up, at, right), re[3] = re[7] = re[11] = re[12] = re[13] = re[14] = 0, re[15] = 1, re[0] = right.x, re[1] = right.y, re[2] = right.z, re[4] = up.x, re[5] = up.y, re[6] = up.z, re[8] = at.x, re[9] = at.y, re[10] = at.z, re[0] * m11 + re[1] * m12 + re[2] * m13 < 0 && (se[0] = -sX), re[4] * m21 + re[5] * m22 + re[6] * m23 < 0 && (se[1] = -sY), re[8] * m31 + re[9] * m32 + re[10] * m33 < 0 && (se[2] = -sZ), !0
            }

            decomposeYawPitchRoll(yawPitchRoll) {
                var pitch = Math.asin(-this.elements[9]);
                yawPitchRoll.y = pitch, Math.cos(pitch) > MathUtils3D.zeroTolerance ? (yawPitchRoll.z = Math.atan2(this.elements[1], this.elements[5]), yawPitchRoll.x = Math.atan2(this.elements[8], this.elements[10])) : (yawPitchRoll.z = Math.atan2(-this.elements[4], this.elements[0]), yawPitchRoll.x = 0)
            }

            normalize() {
                var v = this.elements, c = v[0], d = v[1], e = v[2], g = Math.sqrt(c * c + d * d + e * e);
                if (!g) return v[0] = 0, v[1] = 0, void (v[2] = 0);
                1 != g && (g = 1 / g, v[0] = c * g, v[1] = d * g, v[2] = e * g)
            }

            transpose() {
                var e, t;
                return t = (e = this.elements)[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
            }

            invert(out) {
                var ae = this.elements, oe = out.elements, a00 = ae[0], a01 = ae[1], a02 = ae[2], a03 = ae[3],
                    a10 = ae[4], a11 = ae[5], a12 = ae[6], a13 = ae[7], a20 = ae[8], a21 = ae[9], a22 = ae[10],
                    a23 = ae[11], a30 = ae[12], a31 = ae[13], a32 = ae[14], a33 = ae[15], b00 = a00 * a11 - a01 * a10,
                    b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11,
                    b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30,
                    b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31,
                    b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32,
                    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                0 !== Math.abs(det) && (det = 1 / det, oe[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det, oe[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det, oe[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det, oe[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det, oe[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det, oe[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det, oe[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det, oe[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det, oe[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det, oe[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det, oe[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det, oe[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det, oe[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det, oe[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det, oe[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det, oe[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det)
            }

            static billboard(objectPosition, cameraPosition, cameraRight, cameraUp, cameraForward, mat) {
                Vector3.subtract(objectPosition, cameraPosition, Matrix4x4._tempVector0);
                var lengthSq = Vector3.scalarLengthSquared(Matrix4x4._tempVector0);
                MathUtils3D.isZero(lengthSq) ? (Vector3.scale(cameraForward, -1, Matrix4x4._tempVector1), Matrix4x4._tempVector1.cloneTo(Matrix4x4._tempVector0)) : Vector3.scale(Matrix4x4._tempVector0, 1 / Math.sqrt(lengthSq), Matrix4x4._tempVector0), Vector3.cross(cameraUp, Matrix4x4._tempVector0, Matrix4x4._tempVector2), Vector3.normalize(Matrix4x4._tempVector2, Matrix4x4._tempVector2), Vector3.cross(Matrix4x4._tempVector0, Matrix4x4._tempVector2, Matrix4x4._tempVector3);
                var crosse = Matrix4x4._tempVector2, finale = Matrix4x4._tempVector3, diffee = Matrix4x4._tempVector0,
                    obpose = objectPosition, mate = mat.elements;
                mate[0] = crosse.x, mate[1] = crosse.y, mate[2] = crosse.z, mate[3] = 0, mate[4] = finale.x, mate[5] = finale.y, mate[6] = finale.z, mate[7] = 0, mate[8] = diffee.x, mate[9] = diffee.y, mate[10] = diffee.z, mate[11] = 0, mate[12] = obpose.x, mate[13] = obpose.y, mate[14] = obpose.z, mate[15] = 1
            }

            identity() {
                var e = this.elements;
                e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0, e[0] = e[5] = e[10] = e[15] = 1
            }

            cloneTo(destObject) {
                var i, s, d;
                if ((s = this.elements) !== (d = destObject.elements)) for (i = 0; i < 16; ++i) d[i] = s[i]
            }

            clone() {
                var dest = new Matrix4x4;
                return this.cloneTo(dest), dest
            }

            static translation(v3, out) {
                var oe = out.elements;
                oe[0] = oe[5] = oe[10] = oe[15] = 1, oe[12] = v3.x, oe[13] = v3.y, oe[14] = v3.z
            }

            getTranslationVector(out) {
                var me = this.elements;
                out.x = me[12], out.y = me[13], out.z = me[14]
            }

            setTranslationVector(translate) {
                var me = this.elements, ve = translate;
                me[12] = ve.x, me[13] = ve.y, me[14] = ve.z
            }

            getForward(out) {
                var me = this.elements;
                out.x = -me[8], out.y = -me[9], out.z = -me[10]
            }

            setForward(forward) {
                var me = this.elements;
                me[8] = -forward.x, me[9] = -forward.y, me[10] = -forward.z
            }
        }

        Matrix4x4._tempMatrix4x4 = new Matrix4x4, Matrix4x4.TEMPMatrix0 = new Matrix4x4, Matrix4x4.TEMPMatrix1 = new Matrix4x4, Matrix4x4._tempVector0 = new Vector3, Matrix4x4._tempVector1 = new Vector3, Matrix4x4._tempVector2 = new Vector3, Matrix4x4._tempVector3 = new Vector3, Matrix4x4._tempQuaternion = new Quaternion, Matrix4x4.DEFAULT = new Matrix4x4, Matrix4x4.ZERO = new Matrix4x4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        class DefineDatas {
            constructor() {
                this.value = 0
            }

            add(define) {
                this.value |= define
            }

            remove(define) {
                this.value &= ~define
            }

            has(define) {
                return (this.value & define) > 0
            }

            cloneTo(destObject) {
                destObject.value = this.value
            }

            clone() {
                var dest = new DefineDatas;
                return this.cloneTo(dest), dest
            }
        }

        class ShaderData {
            constructor(ownerResource = null) {
                this._ownerResource = null, this._data = null, this._defineDatas = new DefineDatas, this._runtimeCopyValues = [], this._ownerResource = ownerResource, this._initData()
            }

            _initData() {
                this._data = new Object
            }

            getData() {
                return this._data
            }

            addDefine(define) {
                this._defineDatas.add(define)
            }

            removeDefine(define) {
                this._defineDatas.remove(define)
            }

            hasDefine(define) {
                return (this._defineDatas.value & define) > 0
            }

            clearDefine() {
                this._defineDatas.value = 0
            }

            getBool(index) {
                return this._data[index]
            }

            setBool(index, value) {
                this._data[index] = value
            }

            getInt(index) {
                return this._data[index]
            }

            setInt(index, value) {
                this._data[index] = value
            }

            getNumber(index) {
                return this._data[index]
            }

            setNumber(index, value) {
                this._data[index] = value
            }

            getVector2(index) {
                return this._data[index]
            }

            setVector2(index, value) {
                this._data[index] = value
            }

            getVector3(index) {
                return this._data[index]
            }

            setVector3(index, value) {
                this._data[index] = value
            }

            getVector(index) {
                return this._data[index]
            }

            setVector(index, value) {
                this._data[index] = value
            }

            getQuaternion(index) {
                return this._data[index]
            }

            setQuaternion(index, value) {
                this._data[index] = value
            }

            getMatrix4x4(index) {
                return this._data[index]
            }

            setMatrix4x4(index, value) {
                this._data[index] = value
            }

            getBuffer(shaderIndex) {
                return this._data[shaderIndex]
            }

            setBuffer(index, value) {
                this._data[index] = value
            }

            setTexture(index, value) {
                var lastValue = this._data[index];
                this._data[index] = value, this._ownerResource && this._ownerResource.referenceCount > 0 && (lastValue && lastValue._removeReference(), value && value._addReference())
            }

            getTexture(index) {
                return this._data[index]
            }

            setAttribute(index, value) {
                this._data[index] = value
            }

            getAttribute(index) {
                return this._data[index]
            }

            getLength() {
                return this._data.length
            }

            setLength(value) {
                this._data.length = value
            }

            cloneTo(destObject) {
                var dest = destObject, destData = dest._data;
                for (var k in this._data) {
                    var value = this._data[k];
                    if (null != value) if ("number" == typeof value) destData[k] = value; else if ("number" == typeof value) destData[k] = value; else if ("boolean" == typeof value) destData[k] = value; else if (value instanceof Vector2) {
                        var v2 = destData[k] || (destData[k] = new Vector2);
                        value.cloneTo(v2), destData[k] = v2
                    } else if (value instanceof Vector3) {
                        var v3 = destData[k] || (destData[k] = new Vector3);
                        value.cloneTo(v3), destData[k] = v3
                    } else if (value instanceof Vector4) {
                        var v4 = destData[k] || (destData[k] = new Vector4);
                        value.cloneTo(v4), destData[k] = v4
                    } else if (value instanceof Matrix4x4) {
                        var mat = destData[k] || (destData[k] = new Matrix4x4);
                        value.cloneTo(mat), destData[k] = mat
                    } else value instanceof Laya.BaseTexture && (destData[k] = value)
                }
                this._defineDatas.cloneTo(dest._defineDatas)
            }

            clone() {
                var dest = new ShaderData;
                return this.cloneTo(dest), dest
            }

            cloneToForNative(destObject) {
                var dest = destObject;
                this._int32Data.length - dest._int32Data.length > 0 && dest.needRenewArrayBufferForNative(this._int32Data.length), dest._int32Data.set(this._int32Data, 0);
                var destData = dest._nativeArray, dataCount = this._nativeArray.length;
                destData.length = dataCount;
                for (var i = 0; i < dataCount; i++) {
                    var value = this._nativeArray[i];
                    if (value) if ("number" == typeof value) destData[i] = value, dest.setNumber(i, value); else if ("number" == typeof value) destData[i] = value, dest.setInt(i, value); else if ("boolean" == typeof value) destData[i] = value, dest.setBool(i, value); else if (value instanceof Vector2) {
                        var v2 = destData[i] || (destData[i] = new Vector2);
                        value.cloneTo(v2), destData[i] = v2, dest.setVector2(i, v2)
                    } else if (value instanceof Vector3) {
                        var v3 = destData[i] || (destData[i] = new Vector3);
                        value.cloneTo(v3), destData[i] = v3, dest.setVector3(i, v3)
                    } else if (value instanceof Vector4) {
                        var v4 = destData[i] || (destData[i] = new Vector4);
                        value.cloneTo(v4), destData[i] = v4, dest.setVector(i, v4)
                    } else if (value instanceof Matrix4x4) {
                        var mat = destData[i] || (destData[i] = new Matrix4x4);
                        value.cloneTo(mat), destData[i] = mat, dest.setMatrix4x4(i, mat)
                    } else value instanceof Laya.BaseTexture && (destData[i] = value, dest.setTexture(i, value))
                }
                this._defineDatas.cloneTo(dest._defineDatas)
            }

            _initDataForNative() {
                this._frameCount = -1, this._runtimeCopyValues.length = 0, this._nativeArray = [], this._data = new ArrayBuffer(32), this._int32Data = new Int32Array(this._data), this._float32Data = new Float32Array(this._data), Laya.LayaGL.instance.createArrayBufferRef(this._data, Laya.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0)
            }

            needRenewArrayBufferForNative(index) {
                if (index >= this._int32Data.length) {
                    var nByteLen = 4 * (index + 1), pre = this._int32Data, preConchRef = this._data.conchRef,
                        prePtrID = this._data._ptrID;
                    this._data = new ArrayBuffer(nByteLen), this._int32Data = new Int32Array(this._data), this._float32Data = new Float32Array(this._data), this._data.conchRef = preConchRef, this._data._ptrID = prePtrID, pre && this._int32Data.set(pre, 0), window.conch.updateArrayBufferRef(this._data._ptrID, preConchRef.isSyncToRender(), this._data)
                }
            }

            getDataForNative() {
                return this._nativeArray
            }

            getIntForNative(index) {
                return this._int32Data[index]
            }

            setIntForNative(index, value) {
                this.needRenewArrayBufferForNative(index), this._int32Data[index] = value, this._nativeArray[index] = value
            }

            getBoolForNative(index) {
                return 1 == this._int32Data[index]
            }

            setBoolForNative(index, value) {
                this.needRenewArrayBufferForNative(index), this._int32Data[index] = value ? 1 : 0, this._nativeArray[index] = value
            }

            getNumberForNative(index) {
                return this._float32Data[index]
            }

            setNumberForNative(index, value) {
                this.needRenewArrayBufferForNative(index), this._float32Data[index] = value, this._nativeArray[index] = value
            }

            getMatrix4x4ForNative(index) {
                return this._nativeArray[index]
            }

            setMatrix4x4ForNative(index, value) {
                this.needRenewArrayBufferForNative(index), this._nativeArray[index] = value;
                var nPtrID = this.setReferenceForNative(value.elements);
                this._int32Data[index] = nPtrID
            }

            getVectorForNative(index) {
                return this._nativeArray[index]
            }

            setVectorForNative(index, value) {
                this.needRenewArrayBufferForNative(index), this._nativeArray[index] = value, value.elements || value.forNativeElement();
                var nPtrID = this.setReferenceForNative(value.elements);
                this._int32Data[index] = nPtrID
            }

            getVector2ForNative(index) {
                return this._nativeArray[index]
            }

            setVector2ForNative(index, value) {
                this.needRenewArrayBufferForNative(index), this._nativeArray[index] = value, value.elements || value.forNativeElement();
                var nPtrID = this.setReferenceForNative(value.elements);
                this._int32Data[index] = nPtrID
            }

            getVector3ForNative(index) {
                return this._nativeArray[index]
            }

            setVector3ForNative(index, value) {
                this.needRenewArrayBufferForNative(index), this._nativeArray[index] = value, value.elements || value.forNativeElement();
                var nPtrID = this.setReferenceForNative(value.elements);
                this._int32Data[index] = nPtrID
            }

            getQuaternionForNative(index) {
                return this._nativeArray[index]
            }

            setQuaternionForNative(index, value) {
                this.needRenewArrayBufferForNative(index), this._nativeArray[index] = value, value.elements || value.forNativeElement();
                var nPtrID = this.setReferenceForNative(value.elements);
                this._int32Data[index] = nPtrID
            }

            getBufferForNative(shaderIndex) {
                return this._nativeArray[shaderIndex]
            }

            setBufferForNative(index, value) {
                this.needRenewArrayBufferForNative(index), this._nativeArray[index] = value;
                var nPtrID = this.setReferenceForNative(value);
                this._int32Data[index] = nPtrID
            }

            getAttributeForNative(index) {
                return this._nativeArray[index]
            }

            setAttributeForNative(index, value) {
                this._nativeArray[index] = value, value._ptrID || Laya.LayaGL.instance.createArrayBufferRef(value, Laya.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0), Laya.LayaGL.instance.syncBufferToRenderThread(value), this._int32Data[index] = value._ptrID
            }

            getTextureForNative(index) {
                return this._nativeArray[index]
            }

            setTextureForNative(index, value) {
                if (value) {
                    this.needRenewArrayBufferForNative(index);
                    var lastValue = this._nativeArray[index];
                    this._nativeArray[index] = value, this._int32Data[index] = value._glTexture.id, this._ownerResource && this._ownerResource.referenceCount > 0 && (lastValue && lastValue._removeReference(), value && value._addReference())
                }
            }

            setReferenceForNative(value) {
                this.clearRuntimeCopyArray();
                var nRefID = 0, nPtrID = 0;
                return ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ ? (Laya.LayaGL.instance.createArrayBufferRefs(value, Laya.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, Laya.LayaGL.ARRAY_BUFFER_REF_REFERENCE), nRefID = 0, nPtrID = value.getPtrID(nRefID)) : (Laya.LayaGL.instance.createArrayBufferRefs(value, Laya.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, Laya.LayaGL.ARRAY_BUFFER_REF_COPY), nRefID = value.getRefNum() - 1, nPtrID = value.getPtrID(nRefID), this._runtimeCopyValues.push({
                    obj: value,
                    refID: nRefID,
                    ptrID: nPtrID
                })), Laya.LayaGL.instance.syncBufferToRenderThread(value, nRefID), nPtrID
            }

            static setRuntimeValueMode(bReference) {
                ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ = bReference
            }

            clearRuntimeCopyArray() {
                var currentFrame = Laya.LayaGL.instance.getFrameCount();
                if (this._frameCount != currentFrame) {
                    this._frameCount = currentFrame;
                    for (var i = 0, n = this._runtimeCopyValues.length; i < n; i++) {
                        this._runtimeCopyValues[i].obj.clearRefNum()
                    }
                    this._runtimeCopyValues.length = 0
                }
            }
        }

        ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ = !0;

        class VertexDeclaration {
            constructor(vertexStride, vertexElements) {
                this._id = ++VertexDeclaration._uniqueIDCounter, this._vertexElementsDic = {}, this._vertexStride = vertexStride, this._vertexElements = vertexElements;
                var count = vertexElements.length;
                this._shaderValues = new ShaderData(null);
                for (var j = 0; j < count; j++) {
                    var vertexElement = vertexElements[j], name = vertexElement._elementUsage;
                    this._vertexElementsDic[name] = vertexElement;
                    var value = new Int32Array(5),
                        elmentInfo = VertexElementFormat.getElementInfos(vertexElement._elementFormat);
                    value[0] = elmentInfo[0], value[1] = elmentInfo[1], value[2] = elmentInfo[2], value[3] = this._vertexStride, value[4] = vertexElement._offset, this._shaderValues.setAttribute(name, value)
                }
            }

            get id() {
                return this._id
            }

            get vertexStride() {
                return this._vertexStride
            }

            get vertexElementCount() {
                return this._vertexElements.length
            }

            getVertexElementByIndex(index) {
                return this._vertexElements[index]
            }

            getVertexElementByUsage(usage) {
                return this._vertexElementsDic[usage]
            }
        }

        VertexDeclaration._uniqueIDCounter = 1;

        class VertexElement {
            get offset() {
                return this._offset
            }

            get elementFormat() {
                return this._elementFormat
            }

            get elementUsage() {
                return this._elementUsage
            }

            constructor(offset, elementFormat, elementUsage) {
                this._offset = offset, this._elementFormat = elementFormat, this._elementUsage = elementUsage
            }
        }

        class VertexMesh {
            static __init__() {
                VertexMesh.instanceWorldMatrixDeclaration = new VertexDeclaration(64, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW0), new VertexElement(16, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW1), new VertexElement(32, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW2), new VertexElement(48, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW3)]), VertexMesh.instanceMVPMatrixDeclaration = new VertexDeclaration(64, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_MVPMATRIX_ROW0), new VertexElement(16, VertexElementFormat.Vector4, VertexMesh.MESH_MVPMATRIX_ROW1), new VertexElement(32, VertexElementFormat.Vector4, VertexMesh.MESH_MVPMATRIX_ROW2), new VertexElement(48, VertexElementFormat.Vector4, VertexMesh.MESH_MVPMATRIX_ROW3)])
            }

            static getVertexDeclaration(vertexFlag, compatible = !0) {
                var verDec = VertexMesh._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")];
                if (!verDec) {
                    for (var subFlags = vertexFlag.split(","), offset = 0, elements = [], i = 0, n = subFlags.length; i < n; i++) {
                        var element;
                        switch (subFlags[i]) {
                            case"POSITION":
                                element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0), offset += 12;
                                break;
                            case"NORMAL":
                                element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_NORMAL0), offset += 12;
                                break;
                            case"COLOR":
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_COLOR0), offset += 16;
                                break;
                            case"UV":
                                element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0), offset += 8;
                                break;
                            case"UV1":
                                element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE1), offset += 8;
                                break;
                            case"BLENDWEIGHT":
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDWEIGHT0), offset += 16;
                                break;
                            case"BLENDINDICES":
                                compatible ? (element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDINDICES0), offset += 16) : (element = new VertexElement(offset, VertexElementFormat.Byte4, VertexMesh.MESH_BLENDINDICES0), offset += 4);
                                break;
                            case"TANGENT":
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_TANGENT0), offset += 16;
                                break;
                            default:
                                throw"VertexMesh: unknown vertex flag."
                        }
                        elements.push(element)
                    }
                    verDec = new VertexDeclaration(offset, elements), VertexMesh._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")] = verDec
                }
                return verDec
            }
        }

        VertexMesh.MESH_POSITION0 = 0, VertexMesh.MESH_COLOR0 = 1, VertexMesh.MESH_TEXTURECOORDINATE0 = 2, VertexMesh.MESH_NORMAL0 = 3, VertexMesh.MESH_TANGENT0 = 4, VertexMesh.MESH_BLENDINDICES0 = 5, VertexMesh.MESH_BLENDWEIGHT0 = 6, VertexMesh.MESH_TEXTURECOORDINATE1 = 7, VertexMesh.MESH_WORLDMATRIX_ROW0 = 8, VertexMesh.MESH_WORLDMATRIX_ROW1 = 9, VertexMesh.MESH_WORLDMATRIX_ROW2 = 10, VertexMesh.MESH_WORLDMATRIX_ROW3 = 11, VertexMesh.MESH_MVPMATRIX_ROW0 = 12, VertexMesh.MESH_MVPMATRIX_ROW1 = 13, VertexMesh.MESH_MVPMATRIX_ROW2 = 14, VertexMesh.MESH_MVPMATRIX_ROW3 = 15, VertexMesh._vertexDeclarationMap = {};

        class SubMeshDynamicBatch extends GeometryElement {
            constructor() {
                super(), this._bufferState = new BufferState;
                var gl = Laya.LayaGL.instance,
                    maxByteCount = VertexMesh.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT").vertexStride * SubMeshDynamicBatch.maxIndicesCount;
                this._vertices = new Float32Array(maxByteCount / 4), this._vertexBuffer = new VertexBuffer3D(maxByteCount, gl.DYNAMIC_DRAW), this._indices = new Int16Array(SubMeshDynamicBatch.maxIndicesCount), this._indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, this._indices.length, gl.DYNAMIC_DRAW);
                var memorySize = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                Laya.Resource._addMemory(memorySize, memorySize)
            }

            static __init__() {
                SubMeshDynamicBatch.instance = new SubMeshDynamicBatch
            }

            _getBatchVertices(vertexDeclaration, batchVertices, batchOffset, transform, element, subMesh) {
                var vertexFloatCount = vertexDeclaration.vertexStride / 4,
                    oriVertexes = subMesh._vertexBuffer.getFloat32Data(),
                    multiSubMesh = (element.render.lightmapScaleOffset, element._dynamicMultiSubMesh),
                    vertexCount = element._dynamicVertexCount;
                element._computeWorldPositionsAndNormals(this._positionOffset, this._normalOffset, multiSubMesh, vertexCount);
                for (var worldPositions = element._dynamicWorldPositions, worldNormals = element._dynamicWorldNormals, indices = subMesh._indices, i = 0; i < vertexCount; i++) {
                    var oriOffset = (multiSubMesh ? indices[i] : i) * vertexFloatCount,
                        bakeOffset = (i + batchOffset) * vertexFloatCount, oriOff = 3 * i,
                        bakOff = bakeOffset + this._positionOffset;
                    batchVertices[bakOff] = worldPositions[oriOff], batchVertices[bakOff + 1] = worldPositions[oriOff + 1], batchVertices[bakOff + 2] = worldPositions[oriOff + 2], -1 !== this._normalOffset && (batchVertices[bakOff = bakeOffset + this._normalOffset] = worldNormals[oriOff], batchVertices[bakOff + 1] = worldNormals[oriOff + 1], batchVertices[bakOff + 2] = worldNormals[oriOff + 2]), -1 !== this._colorOffset && (bakOff = bakeOffset + this._colorOffset, oriOff = oriOffset + this._colorOffset, batchVertices[bakOff] = oriVertexes[oriOff], batchVertices[bakOff + 1] = oriVertexes[oriOff + 1], batchVertices[bakOff + 2] = oriVertexes[oriOff + 2], batchVertices[bakOff + 3] = oriVertexes[oriOff + 3]), -1 !== this._uv0Offset && (bakOff = bakeOffset + this._uv0Offset, oriOff = oriOffset + this._uv0Offset, batchVertices[bakOff] = oriVertexes[oriOff], batchVertices[bakOff + 1] = oriVertexes[oriOff + 1]), -1 !== this._sTangentOffset && (bakOff = bakeOffset + this._sTangentOffset, oriOff = oriOffset + this._sTangentOffset, batchVertices[bakOff] = oriVertexes[oriOff], batchVertices[bakOff + 1] = oriVertexes[oriOff + 1], batchVertices[bakOff + 2] = oriVertexes[oriOff + 2], batchVertices[bakOff + 3] = oriVertexes[oriOff + 3], bakOff = bakeOffset + this._sTangentOffset, oriOff = oriOffset + this._sTangentOffset, batchVertices[bakOff] = oriVertexes[oriOff], batchVertices[bakOff + 1] = oriVertexes[oriOff + 1], batchVertices[bakOff + 2] = oriVertexes[oriOff + 2], batchVertices[bakOff + 3] = oriVertexes[oriOff + 3])
                }
            }

            _getBatchIndices(batchIndices, batchIndexCount, batchVertexCount, transform, subMesh, multiSubMesh) {
                var k, m, batchOffset, subIndices = subMesh._indices, isInvert = transform._isFrontFaceInvert;
                if (multiSubMesh) if (isInvert) for (k = 0, m = subIndices.length; k < m; k += 3) {
                    var index = batchVertexCount + k;
                    batchIndices[batchOffset = batchIndexCount + k] = index, batchIndices[batchOffset + 1] = index + 2, batchIndices[batchOffset + 2] = index + 1
                } else for (k = m, m = subIndices.length; k < m; k += 3) index = batchVertexCount + k, batchIndices[batchOffset = batchIndexCount + k] = index, batchIndices[batchOffset + 1] = index + 1, batchIndices[batchOffset + 2] = index + 2; else if (isInvert) for (k = 0, m = subIndices.length; k < m; k += 3) batchIndices[batchOffset = batchIndexCount + k] = batchVertexCount + subIndices[k], batchIndices[batchOffset + 1] = batchVertexCount + subIndices[k + 2], batchIndices[batchOffset + 2] = batchVertexCount + subIndices[k + 1]; else for (k = m, m = subIndices.length; k < m; k += 3) batchIndices[batchOffset = batchIndexCount + k] = batchVertexCount + subIndices[k], batchIndices[batchOffset + 1] = batchVertexCount + subIndices[k + 1], batchIndices[batchOffset + 2] = batchVertexCount + subIndices[k + 2]
            }

            _flush(vertexCount, indexCount) {
                var gl = Laya.LayaGL.instance;
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, vertexCount * this._vertexBuffer.vertexDeclaration.vertexStride), this._indexBuffer.setData(this._indices, 0, 0, indexCount), gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0)
            }

            _prepareRender(state) {
                var vertexDeclaration = state.renderElement.vertexBatchVertexDeclaration;
                this._bufferState = ILaya3D.MeshRenderDynamicBatchManager.instance._getBufferState(vertexDeclaration), this._positionOffset = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_POSITION0)._offset / 4;
                var normalElement = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_NORMAL0);
                this._normalOffset = normalElement ? normalElement._offset / 4 : -1;
                var colorElement = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_COLOR0);
                this._colorOffset = colorElement ? colorElement._offset / 4 : -1;
                var uv0Element = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TEXTURECOORDINATE0);
                this._uv0Offset = uv0Element ? uv0Element._offset / 4 : -1;
                var uv1Element = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TEXTURECOORDINATE1);
                this._uv1Offset = uv1Element ? uv1Element._offset / 4 : -1;
                var tangentElement = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TANGENT0);
                return this._sTangentOffset = tangentElement ? tangentElement._offset / 4 : -1, !0
            }

            _render(context) {
                this._bufferState.bind();
                for (var element = context.renderElement, vertexDeclaration = element.vertexBatchVertexDeclaration, batchElements = element.vertexBatchElementList, batchVertexCount = 0, batchIndexCount = 0, renderBatchCount = (vertexDeclaration.vertexStride, 0), elementCount = batchElements.length, i = 0; i < elementCount; i++) {
                    var subElement = batchElements[i], subMesh = subElement._geometry, indexCount = subMesh._indexCount;
                    batchIndexCount + indexCount > SubMeshDynamicBatch.maxIndicesCount && (this._flush(batchVertexCount, batchIndexCount), renderBatchCount++, Laya.Stat.trianglesFaces += batchIndexCount / 3, batchVertexCount = batchIndexCount = 0);
                    var transform = subElement._transform;
                    this._getBatchVertices(vertexDeclaration, this._vertices, batchVertexCount, transform, subElement, subMesh), this._getBatchIndices(this._indices, batchIndexCount, batchVertexCount, transform, subMesh, subElement._dynamicMultiSubMesh), batchVertexCount += subElement._dynamicVertexCount, batchIndexCount += indexCount
                }
                this._flush(batchVertexCount, batchIndexCount), renderBatchCount++, Laya.Stat.renderBatches += renderBatchCount, Laya.Stat.savedRenderBatches += elementCount - renderBatchCount, Laya.Stat.trianglesFaces += batchIndexCount / 3
            }
        }

        SubMeshDynamicBatch.maxAllowVertexCount = 10, SubMeshDynamicBatch.maxAllowAttribueCount = 900, SubMeshDynamicBatch.maxIndicesCount = 32e3;

        class BatchMark {
            constructor() {
                this.updateMark = -1, this.indexInList = -1, this.batched = !1
            }
        }

        class SubMeshInstanceBatch extends GeometryElement {
            constructor() {
                super(), this.maxInstanceCount = 1024, this.instanceWorldMatrixData = new Float32Array(16 * this.maxInstanceCount), this.instanceMVPMatrixData = new Float32Array(16 * this.maxInstanceCount);
                var gl = Laya.LayaGL.instance;
                this.instanceWorldMatrixBuffer = new VertexBuffer3D(4 * this.instanceWorldMatrixData.length, gl.DYNAMIC_DRAW), this.instanceMVPMatrixBuffer = new VertexBuffer3D(4 * this.instanceMVPMatrixData.length, gl.DYNAMIC_DRAW), this.instanceWorldMatrixBuffer.vertexDeclaration = VertexMesh.instanceWorldMatrixDeclaration, this.instanceMVPMatrixBuffer.vertexDeclaration = VertexMesh.instanceMVPMatrixDeclaration
            }

            static __init__() {
                SubMeshInstanceBatch.instance = new SubMeshInstanceBatch
            }

            _render(state) {
                var gl = Laya.LayaGL.instance, element = state.renderElement, subMesh = element.instanceSubMesh,
                    count = element.instanceBatchElementList.length, indexCount = subMesh._indexCount;
                subMesh._mesh._instanceBufferState.bind(), Laya.LayaGL.layaGPUInstance.drawElementsInstanced(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 2 * subMesh._indexStart, count), Laya.Stat.renderBatches++, Laya.Stat.savedRenderBatches += count - 1, Laya.Stat.trianglesFaces += indexCount * count / 3
            }
        }

        class Color {
            constructor(r = 1, g = 1, b = 1, a = 1) {
                this.r = r, this.g = g, this.b = b, this.a = a
            }

            static gammaToLinearSpace(value) {
                return value <= .04045 ? value / 12.92 : value < 1 ? Math.pow((value + .055) / 1.055, 2.4) : Math.pow(value, 2.4)
            }

            static linearToGammaSpace(value) {
                return value <= 0 ? 0 : value <= .0031308 ? 12.92 * value : value <= 1 ? 1.055 * Math.pow(value, .41666) - .055 : Math.pow(value, .41666)
            }

            toLinear(out) {
                out.r = Color.gammaToLinearSpace(this.r), out.g = Color.gammaToLinearSpace(this.g), out.b = Color.gammaToLinearSpace(this.b)
            }

            toGamma(out) {
                out.r = Color.linearToGammaSpace(this.r), out.g = Color.linearToGammaSpace(this.g), out.b = Color.linearToGammaSpace(this.b)
            }

            cloneTo(destObject) {
                var destColor = destObject;
                destColor.r = this.r, destColor.g = this.g, destColor.b = this.b, destColor.a = this.a
            }

            clone() {
                var dest = new Color;
                return this.cloneTo(dest), dest
            }

            forNativeElement() {
            }
        }

        Color.RED = new Color(1, 0, 0, 1), Color.GREEN = new Color(0, 1, 0, 1), Color.BLUE = new Color(0, 0, 1, 1), Color.CYAN = new Color(0, 1, 1, 1), Color.YELLOW = new Color(1, .92, .016, 1), Color.MAGENTA = new Color(1, 0, 1, 1), Color.GRAY = new Color(.5, .5, .5, 1), Color.WHITE = new Color(1, 1, 1, 1), Color.BLACK = new Color(0, 0, 0, 1);

        class TextureGenerator {
            constructor() {
            }

            static lightAttenTexture(x, y, maxX, maxY, index, data) {
                var sqrRange = x / maxX, atten = 1 / (1 + 25 * sqrRange);
                sqrRange >= .64 && (sqrRange > 1 ? atten = 0 : atten *= 1 - (sqrRange - .64) / .36), data[index] = Math.floor(255 * atten + .5)
            }

            static haloTexture(x, y, maxX, maxY, index, data) {
                var xFac = (x - (maxX >>= 1)) / maxX, yFac = (y - (maxY >>= 1)) / maxY,
                    sqrRange = xFac * xFac + yFac * yFac;
                sqrRange > 1 && (sqrRange = 1), data[index] = Math.floor(255 * (1 - sqrRange) + .5)
            }

            static _generateTexture2D(texture, textureWidth, textureHeight, func) {
                var index = 0, size = 0;
                switch (texture.format) {
                    case Laya.BaseTexture.FORMAT_R8G8B8:
                        size = 3;
                        break;
                    case Laya.BaseTexture.FORMAT_R8G8B8A8:
                        size = 4;
                        break;
                    case Laya.BaseTexture.FORMAT_ALPHA8:
                        size = 1;
                        break;
                    default:
                        throw"GeneratedTexture._generateTexture: unkonw texture format."
                }
                for (var data = new Uint8Array(textureWidth * textureHeight * size), y = 0; y < textureHeight; y++) for (var x = 0; x < textureWidth; x++) func(x, y, textureWidth, textureHeight, index, data), index += size;
                texture.setPixels(data)
            }
        }

        class Utils3D {
            static _convertToLayaVec3(bVector, out, inverseX) {
                out.x = inverseX ? -bVector.x() : bVector.x(), out.y = bVector.y(), out.z = bVector.z()
            }

            static _convertToBulletVec3(lVector, out, inverseX) {
                out.setValue(inverseX ? -lVector.x : lVector.x, lVector.y, lVector.z)
            }

            static _rotationTransformScaleSkinAnimation(tx, ty, tz, qx, qy, qz, qw, sx, sy, sz, outArray, outOffset) {
                var i, ai0, ai1, ai2, ai3, re = Utils3D._tempArray16_0, se = Utils3D._tempArray16_1,
                    tse = Utils3D._tempArray16_2, x2 = qx + qx, y2 = qy + qy, z2 = qz + qz, xx = qx * x2, yx = qy * x2,
                    yy = qy * y2, zx = qz * x2, zy = qz * y2, zz = qz * z2, wx = qw * x2, wy = qw * y2, wz = qw * z2;
                for (re[15] = 1, re[0] = 1 - yy - zz, re[1] = yx + wz, re[2] = zx - wy, re[4] = yx - wz, re[5] = 1 - xx - zz, re[6] = zy + wx, re[8] = zx + wy, re[9] = zy - wx, re[10] = 1 - xx - yy, se[15] = 1, se[0] = sx, se[5] = sy, se[10] = sz, i = 0; i < 4; i++) ai0 = re[i], ai1 = re[i + 4], ai2 = re[i + 8], ai3 = re[i + 12], tse[i] = ai0, tse[i + 4] = ai1, tse[i + 8] = ai2, tse[i + 12] = ai0 * tx + ai1 * ty + ai2 * tz + ai3;
                for (i = 0; i < 4; i++) ai0 = tse[i], ai1 = tse[i + 4], ai2 = tse[i + 8], ai3 = tse[i + 12], outArray[i + outOffset] = ai0 * se[0] + ai1 * se[1] + ai2 * se[2] + ai3 * se[3], outArray[i + outOffset + 4] = ai0 * se[4] + ai1 * se[5] + ai2 * se[6] + ai3 * se[7], outArray[i + outOffset + 8] = ai0 * se[8] + ai1 * se[9] + ai2 * se[10] + ai3 * se[11], outArray[i + outOffset + 12] = ai0 * se[12] + ai1 * se[13] + ai2 * se[14] + ai3 * se[15]
            }

            static _computeBoneAndAnimationDatasByBindPoseMatrxix(bones, curData, inverGlobalBindPose, outBonesDatas, outAnimationDatas, boneIndexToMesh) {
                var i, parentOffset, offset = 0, matOffset = 0, boneLength = bones.length;
                for (i = 0; i < boneLength; offset += bones[i].keyframeWidth, matOffset += 16, i++) Utils3D._rotationTransformScaleSkinAnimation(curData[offset + 0], curData[offset + 1], curData[offset + 2], curData[offset + 3], curData[offset + 4], curData[offset + 5], curData[offset + 6], curData[offset + 7], curData[offset + 8], curData[offset + 9], outBonesDatas, matOffset), 0 != i && (parentOffset = 16 * bones[i].parentIndex, Utils3D.mulMatrixByArray(outBonesDatas, parentOffset, outBonesDatas, matOffset, outBonesDatas, matOffset));
                var n = inverGlobalBindPose.length;
                for (i = 0; i < n; i++) Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas, 16 * boneIndexToMesh[i], inverGlobalBindPose[i], outAnimationDatas, 16 * i)
            }

            static _computeAnimationDatasByArrayAndMatrixFast(inverGlobalBindPose, bonesDatas, outAnimationDatas, boneIndexToMesh) {
                for (var i = 0, n = inverGlobalBindPose.length; i < n; i++) Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas, 16 * boneIndexToMesh[i], inverGlobalBindPose[i], outAnimationDatas, 16 * i)
            }

            static _computeBoneAndAnimationDatasByBindPoseMatrxixOld(bones, curData, inverGlobalBindPose, outBonesDatas, outAnimationDatas) {
                var i, parentOffset, offset = 0, matOffset = 0, boneLength = bones.length;
                for (i = 0; i < boneLength; offset += bones[i].keyframeWidth, matOffset += 16, i++) Utils3D._rotationTransformScaleSkinAnimation(curData[offset + 7], curData[offset + 8], curData[offset + 9], curData[offset + 3], curData[offset + 4], curData[offset + 5], curData[offset + 6], curData[offset + 0], curData[offset + 1], curData[offset + 2], outBonesDatas, matOffset), 0 != i && (parentOffset = 16 * bones[i].parentIndex, Utils3D.mulMatrixByArray(outBonesDatas, parentOffset, outBonesDatas, matOffset, outBonesDatas, matOffset));
                var n = inverGlobalBindPose.length;
                for (i = 0; i < n; i++) {
                    var arrayOffset = 16 * i;
                    Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas, arrayOffset, inverGlobalBindPose[i], outAnimationDatas, arrayOffset)
                }
            }

            static _computeAnimationDatasByArrayAndMatrixFastOld(inverGlobalBindPose, bonesDatas, outAnimationDatas) {
                for (var n = inverGlobalBindPose.length, i = 0; i < n; i++) {
                    var arrayOffset = 16 * i;
                    Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas, arrayOffset, inverGlobalBindPose[i], outAnimationDatas, arrayOffset)
                }
            }

            static _computeRootAnimationData(bones, curData, animationDatas) {
                for (var i = 0, offset = 0, matOffset = 0, boneLength = bones.length; i < boneLength; offset += bones[i].keyframeWidth, matOffset += 16, i++) Utils3D.createAffineTransformationArray(curData[offset + 0], curData[offset + 1], curData[offset + 2], curData[offset + 3], curData[offset + 4], curData[offset + 5], curData[offset + 6], curData[offset + 7], curData[offset + 8], curData[offset + 9], animationDatas, matOffset)
            }

            static transformVector3ArrayByQuat(sourceArray, sourceOffset, rotation, outArray, outOffset) {
                var x = sourceArray[sourceOffset], y = sourceArray[sourceOffset + 1], z = sourceArray[sourceOffset + 2],
                    qx = rotation.x, qy = rotation.y, qz = rotation.z, qw = rotation.w, ix = qw * x + qy * z - qz * y,
                    iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
                outArray[outOffset] = ix * qw + iw * -qx + iy * -qz - iz * -qy, outArray[outOffset + 1] = iy * qw + iw * -qy + iz * -qx - ix * -qz, outArray[outOffset + 2] = iz * qw + iw * -qz + ix * -qy - iy * -qx
            }

            static mulMatrixByArray(leftArray, leftOffset, rightArray, rightOffset, outArray, outOffset) {
                var i, ai0, ai1, ai2, ai3;
                if (outArray === rightArray) {
                    for (rightArray = Utils3D._tempArray16_3, i = 0; i < 16; ++i) rightArray[i] = outArray[outOffset + i];
                    rightOffset = 0
                }
                for (i = 0; i < 4; i++) ai0 = leftArray[leftOffset + i], ai1 = leftArray[leftOffset + i + 4], ai2 = leftArray[leftOffset + i + 8], ai3 = leftArray[leftOffset + i + 12], outArray[outOffset + i] = ai0 * rightArray[rightOffset + 0] + ai1 * rightArray[rightOffset + 1] + ai2 * rightArray[rightOffset + 2] + ai3 * rightArray[rightOffset + 3], outArray[outOffset + i + 4] = ai0 * rightArray[rightOffset + 4] + ai1 * rightArray[rightOffset + 5] + ai2 * rightArray[rightOffset + 6] + ai3 * rightArray[rightOffset + 7], outArray[outOffset + i + 8] = ai0 * rightArray[rightOffset + 8] + ai1 * rightArray[rightOffset + 9] + ai2 * rightArray[rightOffset + 10] + ai3 * rightArray[rightOffset + 11], outArray[outOffset + i + 12] = ai0 * rightArray[rightOffset + 12] + ai1 * rightArray[rightOffset + 13] + ai2 * rightArray[rightOffset + 14] + ai3 * rightArray[rightOffset + 15]
            }

            static mulMatrixByArrayFast(leftArray, leftOffset, rightArray, rightOffset, outArray, outOffset) {
                var i, ai0, ai1, ai2, ai3;
                for (i = 0; i < 4; i++) ai0 = leftArray[leftOffset + i], ai1 = leftArray[leftOffset + i + 4], ai2 = leftArray[leftOffset + i + 8], ai3 = leftArray[leftOffset + i + 12], outArray[outOffset + i] = ai0 * rightArray[rightOffset + 0] + ai1 * rightArray[rightOffset + 1] + ai2 * rightArray[rightOffset + 2] + ai3 * rightArray[rightOffset + 3], outArray[outOffset + i + 4] = ai0 * rightArray[rightOffset + 4] + ai1 * rightArray[rightOffset + 5] + ai2 * rightArray[rightOffset + 6] + ai3 * rightArray[rightOffset + 7], outArray[outOffset + i + 8] = ai0 * rightArray[rightOffset + 8] + ai1 * rightArray[rightOffset + 9] + ai2 * rightArray[rightOffset + 10] + ai3 * rightArray[rightOffset + 11], outArray[outOffset + i + 12] = ai0 * rightArray[rightOffset + 12] + ai1 * rightArray[rightOffset + 13] + ai2 * rightArray[rightOffset + 14] + ai3 * rightArray[rightOffset + 15]
            }

            static mulMatrixByArrayAndMatrixFast(leftArray, leftOffset, rightMatrix, outArray, outOffset) {
                var i, ai0, ai1, ai2, ai3, rightMatrixE = rightMatrix.elements, m11 = rightMatrixE[0],
                    m12 = rightMatrixE[1], m13 = rightMatrixE[2], m14 = rightMatrixE[3], m21 = rightMatrixE[4],
                    m22 = rightMatrixE[5], m23 = rightMatrixE[6], m24 = rightMatrixE[7], m31 = rightMatrixE[8],
                    m32 = rightMatrixE[9], m33 = rightMatrixE[10], m34 = rightMatrixE[11], m41 = rightMatrixE[12],
                    m42 = rightMatrixE[13], m43 = rightMatrixE[14], m44 = rightMatrixE[15], ai0LeftOffset = leftOffset,
                    ai1LeftOffset = leftOffset + 4, ai2LeftOffset = leftOffset + 8, ai3LeftOffset = leftOffset + 12,
                    ai0OutOffset = outOffset, ai1OutOffset = outOffset + 4, ai2OutOffset = outOffset + 8,
                    ai3OutOffset = outOffset + 12;
                for (i = 0; i < 4; i++) ai0 = leftArray[ai0LeftOffset + i], ai1 = leftArray[ai1LeftOffset + i], ai2 = leftArray[ai2LeftOffset + i], ai3 = leftArray[ai3LeftOffset + i], outArray[ai0OutOffset + i] = ai0 * m11 + ai1 * m12 + ai2 * m13 + ai3 * m14, outArray[ai1OutOffset + i] = ai0 * m21 + ai1 * m22 + ai2 * m23 + ai3 * m24, outArray[ai2OutOffset + i] = ai0 * m31 + ai1 * m32 + ai2 * m33 + ai3 * m34, outArray[ai3OutOffset + i] = ai0 * m41 + ai1 * m42 + ai2 * m43 + ai3 * m44
            }

            static createAffineTransformationArray(tX, tY, tZ, rX, rY, rZ, rW, sX, sY, sZ, outArray, outOffset) {
                var x2 = rX + rX, y2 = rY + rY, z2 = rZ + rZ, xx = rX * x2, xy = rX * y2, xz = rX * z2, yy = rY * y2,
                    yz = rY * z2, zz = rZ * z2, wx = rW * x2, wy = rW * y2, wz = rW * z2;
                outArray[outOffset + 0] = (1 - (yy + zz)) * sX, outArray[outOffset + 1] = (xy + wz) * sX, outArray[outOffset + 2] = (xz - wy) * sX, outArray[outOffset + 3] = 0, outArray[outOffset + 4] = (xy - wz) * sY, outArray[outOffset + 5] = (1 - (xx + zz)) * sY, outArray[outOffset + 6] = (yz + wx) * sY, outArray[outOffset + 7] = 0, outArray[outOffset + 8] = (xz + wy) * sZ, outArray[outOffset + 9] = (yz - wx) * sZ, outArray[outOffset + 10] = (1 - (xx + yy)) * sZ, outArray[outOffset + 11] = 0, outArray[outOffset + 12] = tX, outArray[outOffset + 13] = tY, outArray[outOffset + 14] = tZ, outArray[outOffset + 15] = 1
            }

            static transformVector3ArrayToVector3ArrayCoordinate(source, sourceOffset, transform, result, resultOffset) {
                var coordinateX = source[sourceOffset + 0], coordinateY = source[sourceOffset + 1],
                    coordinateZ = source[sourceOffset + 2], transformElem = transform.elements,
                    w = coordinateX * transformElem[3] + coordinateY * transformElem[7] + coordinateZ * transformElem[11] + transformElem[15];
                result[resultOffset] = coordinateX * transformElem[0] + coordinateY * transformElem[4] + coordinateZ * transformElem[8] + transformElem[12] / w, result[resultOffset + 1] = coordinateX * transformElem[1] + coordinateY * transformElem[5] + coordinateZ * transformElem[9] + transformElem[13] / w, result[resultOffset + 2] = coordinateX * transformElem[2] + coordinateY * transformElem[6] + coordinateZ * transformElem[10] + transformElem[14] / w
            }

            static transformLightingMapTexcoordArray(source, sourceOffset, lightingMapScaleOffset, result, resultOffset) {
                result[resultOffset + 0] = source[sourceOffset + 0] * lightingMapScaleOffset.x + lightingMapScaleOffset.z, result[resultOffset + 1] = 1 - ((1 - source[sourceOffset + 1]) * lightingMapScaleOffset.y + lightingMapScaleOffset.w)
            }

            static getURLVerion(url) {
                var index = url.indexOf("?");
                return index >= 0 ? url.substr(index) : null
            }

            static _createAffineTransformationArray(trans, rot, scale, outE) {
                var x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2,
                    xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2,
                    wz = w * z2, sx = scale.x, sy = scale.y, sz = scale.z;
                outE[0] = (1 - (yy + zz)) * sx, outE[1] = (xy + wz) * sx, outE[2] = (xz - wy) * sx, outE[3] = 0, outE[4] = (xy - wz) * sy, outE[5] = (1 - (xx + zz)) * sy, outE[6] = (yz + wx) * sy, outE[7] = 0, outE[8] = (xz + wy) * sz, outE[9] = (yz - wx) * sz, outE[10] = (1 - (xx + yy)) * sz, outE[11] = 0, outE[12] = trans.x, outE[13] = trans.y, outE[14] = trans.z, outE[15] = 1
            }

            static _mulMatrixArray(leftMatrixE, rightMatrix, outArray, outOffset) {
                var i, ai0, ai1, ai2, ai3, rightMatrixE = rightMatrix.elements, m11 = rightMatrixE[0],
                    m12 = rightMatrixE[1], m13 = rightMatrixE[2], m14 = rightMatrixE[3], m21 = rightMatrixE[4],
                    m22 = rightMatrixE[5], m23 = rightMatrixE[6], m24 = rightMatrixE[7], m31 = rightMatrixE[8],
                    m32 = rightMatrixE[9], m33 = rightMatrixE[10], m34 = rightMatrixE[11], m41 = rightMatrixE[12],
                    m42 = rightMatrixE[13], m43 = rightMatrixE[14], m44 = rightMatrixE[15], ai0OutOffset = outOffset,
                    ai1OutOffset = outOffset + 4, ai2OutOffset = outOffset + 8, ai3OutOffset = outOffset + 12;
                for (i = 0; i < 4; i++) ai0 = leftMatrixE[i], ai1 = leftMatrixE[i + 4], ai2 = leftMatrixE[i + 8], ai3 = leftMatrixE[i + 12], outArray[ai0OutOffset + i] = ai0 * m11 + ai1 * m12 + ai2 * m13 + ai3 * m14, outArray[ai1OutOffset + i] = ai0 * m21 + ai1 * m22 + ai2 * m23 + ai3 * m24, outArray[ai2OutOffset + i] = ai0 * m31 + ai1 * m32 + ai2 * m33 + ai3 * m34, outArray[ai3OutOffset + i] = ai0 * m41 + ai1 * m42 + ai2 * m43 + ai3 * m44
            }

            static arcTanAngle(x, y) {
                return 0 == x ? 1 == y ? Math.PI / 2 : -Math.PI / 2 : x > 0 ? Math.atan(y / x) : x < 0 ? y > 0 ? Math.atan(y / x) + Math.PI : Math.atan(y / x) - Math.PI : 0
            }

            static angleTo(from, location, angle) {
                Vector3.subtract(location, from, Quaternion.TEMPVector30), Vector3.normalize(Quaternion.TEMPVector30, Quaternion.TEMPVector30), angle.x = Math.asin(Quaternion.TEMPVector30.y), angle.y = Utils3D.arcTanAngle(-Quaternion.TEMPVector30.z, -Quaternion.TEMPVector30.x)
            }

            static transformQuat(source, rotation, out) {
                var re = rotation, x = source.x, y = source.y, z = source.z, qx = re[0], qy = re[1], qz = re[2],
                    qw = re[3], ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z,
                    iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
                out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz, out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx
            }

            static quaternionWeight(f, weight, e) {
                e.x = f.x * weight, e.y = f.y * weight, e.z = f.z * weight, e.w = f.w
            }

            static quaternionConjugate(value, result) {
                result.x = -value.x, result.y = -value.y, result.z = -value.z, result.w = value.w
            }

            static scaleWeight(s, w, out) {
                var sX = s.x, sY = s.y, sZ = s.z;
                out.x = sX > 0 ? Math.pow(Math.abs(sX), w) : -Math.pow(Math.abs(sX), w), out.y = sY > 0 ? Math.pow(Math.abs(sY), w) : -Math.pow(Math.abs(sY), w), out.z = sZ > 0 ? Math.pow(Math.abs(sZ), w) : -Math.pow(Math.abs(sZ), w)
            }

            static scaleBlend(sa, sb, w, out) {
                var saw = Utils3D._tempVector3_0, sbw = Utils3D._tempVector3_1;
                Utils3D.scaleWeight(sa, 1 - w, saw), Utils3D.scaleWeight(sb, w, sbw);
                var sng = w > .5 ? sb : sa;
                out.x = sng.x > 0 ? Math.abs(saw.x * sbw.x) : -Math.abs(saw.x * sbw.x), out.y = sng.y > 0 ? Math.abs(saw.y * sbw.y) : -Math.abs(saw.y * sbw.y), out.z = sng.z > 0 ? Math.abs(saw.z * sbw.z) : -Math.abs(saw.z * sbw.z)
            }

            static matrix4x4MultiplyFFF(a, b, e) {
                var i, ai0, ai1, ai2, ai3;
                if (e === b) for (b = new Float32Array(16), i = 0; i < 16; ++i) b[i] = e[i];
                var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8],
                    b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
                for (i = 0; i < 4; i++) ai0 = a[i], ai1 = a[i + 4], ai2 = a[i + 8], ai3 = a[i + 12], e[i] = ai0 * b0 + ai1 * b1 + ai2 * b2 + ai3 * b3, e[i + 4] = ai0 * b4 + ai1 * b5 + ai2 * b6 + ai3 * b7, e[i + 8] = ai0 * b8 + ai1 * b9 + ai2 * b10 + ai3 * b11, e[i + 12] = ai0 * b12 + ai1 * b13 + ai2 * b14 + ai3 * b15
            }

            static matrix4x4MultiplyFFFForNative(a, b, e) {
                Laya.LayaGL.instance.matrix4x4Multiply(a, b, e)
            }

            static matrix4x4MultiplyMFM(left, right, out) {
                Utils3D.matrix4x4MultiplyFFF(left.elements, right, out.elements)
            }

            static _buildTexture2D(width, height, format, colorFunc, mipmaps = !1) {
                var texture = new Laya.Texture2D(width, height, format, mipmaps, !0);
                return texture.anisoLevel = 1, texture.filterMode = Laya.BaseTexture.FILTERMODE_POINT, TextureGenerator._generateTexture2D(texture, width, height, colorFunc), texture
            }

            static _drawBound(debugLine, boundBox, color) {
                debugLine.lineCount + 12 > debugLine.maxLineCount && (debugLine.maxLineCount += 12);
                var start = Utils3D._tempVector3_0, end = Utils3D._tempVector3_1, min = boundBox.min,
                    max = boundBox.max;
                start.setValue(min.x, min.y, min.z), end.setValue(max.x, min.y, min.z), debugLine.addLine(start, end, color, color), start.setValue(min.x, min.y, min.z), end.setValue(min.x, min.y, max.z), debugLine.addLine(start, end, color, color), start.setValue(max.x, min.y, min.z), end.setValue(max.x, min.y, max.z), debugLine.addLine(start, end, color, color), start.setValue(min.x, min.y, max.z), end.setValue(max.x, min.y, max.z), debugLine.addLine(start, end, color, color), start.setValue(min.x, min.y, min.z), end.setValue(min.x, max.y, min.z), debugLine.addLine(start, end, color, color), start.setValue(min.x, min.y, max.z), end.setValue(min.x, max.y, max.z), debugLine.addLine(start, end, color, color), start.setValue(max.x, min.y, min.z), end.setValue(max.x, max.y, min.z), debugLine.addLine(start, end, color, color), start.setValue(max.x, min.y, max.z), end.setValue(max.x, max.y, max.z), debugLine.addLine(start, end, color, color), start.setValue(min.x, max.y, min.z), end.setValue(max.x, max.y, min.z), debugLine.addLine(start, end, color, color), start.setValue(min.x, max.y, min.z), end.setValue(min.x, max.y, max.z), debugLine.addLine(start, end, color, color), start.setValue(max.x, max.y, min.z), end.setValue(max.x, max.y, max.z), debugLine.addLine(start, end, color, color), start.setValue(min.x, max.y, max.z), end.setValue(max.x, max.y, max.z), debugLine.addLine(start, end, color, color)
            }

            static _getHierarchyPath(rootSprite, checkSprite, path) {
                path.length = 0;
                for (var sprite = checkSprite; sprite !== rootSprite;) {
                    var parent = sprite._parent;
                    if (!parent) return null;
                    path.push(parent.getChildIndex(sprite)), sprite = parent
                }
                return path
            }

            static _getNodeByHierarchyPath(rootSprite, invPath) {
                for (var sprite = rootSprite, i = invPath.length - 1; i >= 0; i--) sprite = sprite.getChildAt(invPath[i]);
                return sprite
            }
        }

        Utils3D._tempVector3_0 = new Vector3, Utils3D._tempVector3_1 = new Vector3, Utils3D._tempVector3_2 = new Vector3, Utils3D._tempColor0 = new Color, Utils3D._tempArray16_0 = new Float32Array(16), Utils3D._tempArray16_1 = new Float32Array(16), Utils3D._tempArray16_2 = new Float32Array(16), Utils3D._tempArray16_3 = new Float32Array(16), Utils3D._compIdToNode = new Object;

        class Shader3D {
            constructor(name, attributeMap, uniformMap, enableInstancing) {
                this._attributeMap = null, this._uniformMap = null, this._enableInstancing = !1, this._subShaders = [], this._name = name, this._attributeMap = attributeMap, this._uniformMap = uniformMap, this._enableInstancing = enableInstancing
            }

            static propertyNameToID(name) {
                if (null != Shader3D._propertyNameMap[name]) return Shader3D._propertyNameMap[name];
                var id = Shader3D._propertyNameCounter++;
                return Shader3D._propertyNameMap[name] = id, id
            }

            static addInclude(fileName, txt) {
                txt = txt.replace(Laya.ShaderCompile._clearCR, ""), Laya.ShaderCompile.addInclude(fileName, txt)
            }

            static registerPublicDefine(name) {
                var value = Math.pow(2, Shader3D._publicCounter++);
                return Shader3D._globleDefines[value] = name, value
            }

            static compileShader(name, subShaderIndex, passIndex, publicDefine, spriteDefine, materialDefine) {
                var shader = Shader3D.find(name);
                if (shader) {
                    var subShader = shader.getSubShaderAt(subShaderIndex);
                    if (subShader) {
                        var pass = subShader._passes[passIndex];
                        pass ? Laya.WebGL.shaderHighPrecision ? pass.withCompile(publicDefine, spriteDefine, materialDefine) : pass.withCompile(publicDefine - Shader3D.SHADERDEFINE_HIGHPRECISION, spriteDefine, materialDefine) : console.warn("Shader3D: unknown passIndex.")
                    } else console.warn("Shader3D: unknown subShaderIndex.")
                } else console.warn("Shader3D: unknown shader name.")
            }

            static add(name, attributeMap = null, uniformMap = null, enableInstancing = !1) {
                return Shader3D._preCompileShader[name] = new Shader3D(name, attributeMap, uniformMap, enableInstancing)
            }

            static find(name) {
                return Shader3D._preCompileShader[name]
            }

            addSubShader(subShader) {
                this._subShaders.push(subShader), subShader._owner = this
            }

            getSubShaderAt(index) {
                return this._subShaders[index]
            }
        }

        Shader3D.RENDER_STATE_CULL = 0, Shader3D.RENDER_STATE_BLEND = 1, Shader3D.RENDER_STATE_BLEND_SRC = 2, Shader3D.RENDER_STATE_BLEND_DST = 3, Shader3D.RENDER_STATE_BLEND_SRC_RGB = 4, Shader3D.RENDER_STATE_BLEND_DST_RGB = 5, Shader3D.RENDER_STATE_BLEND_SRC_ALPHA = 6, Shader3D.RENDER_STATE_BLEND_DST_ALPHA = 7, Shader3D.RENDER_STATE_BLEND_CONST_COLOR = 8, Shader3D.RENDER_STATE_BLEND_EQUATION = 9, Shader3D.RENDER_STATE_BLEND_EQUATION_RGB = 10, Shader3D.RENDER_STATE_BLEND_EQUATION_ALPHA = 11, Shader3D.RENDER_STATE_DEPTH_TEST = 12, Shader3D.RENDER_STATE_DEPTH_WRITE = 13, Shader3D.PERIOD_CUSTOM = 0, Shader3D.PERIOD_MATERIAL = 1, Shader3D.PERIOD_SPRITE = 2, Shader3D.PERIOD_CAMERA = 3, Shader3D.PERIOD_SCENE = 4, Shader3D._propertyNameCounter = 0, Shader3D._propertyNameMap = {}, Shader3D._publicCounter = 0, Shader3D._globleDefines = [], Shader3D._preCompileShader = {}, Shader3D.debugMode = !1;

        class ShaderDefines {
            constructor(superDefines = null) {
                if (this._counter = 0, this.defines = {}, superDefines) for (var k in this._counter = superDefines._counter, superDefines.defines) this.defines[k] = superDefines.defines[k]
            }

            registerDefine(name) {
                var value = Math.pow(2, this._counter++);
                return this.defines[value] = name, value
            }
        }

        class AnimatorPlayState {
            get normalizedTime() {
                return this._normalizedTime
            }

            get duration() {
                return this._duration
            }

            constructor() {
            }

            _resetPlayState(startTime) {
                this._finish = !1, this._startPlayTime = startTime, this._elapsedTime = startTime, this._playEventIndex = 0, this._lastIsFront = !0
            }

            _cloneTo(dest) {
                dest._finish = this._finish, dest._startPlayTime = this._startPlayTime, dest._elapsedTime = this._elapsedTime, dest._playEventIndex = this._playEventIndex, dest._lastIsFront = this._lastIsFront
            }
        }

        class AnimatorControllerLayer {
            constructor(name) {
                this._defaultState = null, this._referenceCount = 0, this._statesMap = {}, this.playOnWake = !0, this._playType = -1, this._crossMark = 0, this._crossDuration = -1, this._crossNodesOwnersIndicesMap = {}, this._crossNodesOwnersCount = 0, this._crossNodesOwners = [], this._currentPlayState = null, this._states = [], this._playStateInfo = new AnimatorPlayState, this._crossPlayStateInfo = new AnimatorPlayState, this._srcCrossClipNodeIndices = [], this._destCrossClipNodeIndices = [], this.name = name, this.defaultWeight = 1, this.blendingMode = AnimatorControllerLayer.BLENDINGMODE_OVERRIDE
            }

            get defaultState() {
                return this._defaultState
            }

            set defaultState(value) {
                this._defaultState = value, this._statesMap[value.name] = value
            }

            _removeClip(clipStateInfos, statesMap, index, state) {
                var clip = state._clip, clipStateInfo = clipStateInfos[index];
                if (clipStateInfos.splice(index, 1), delete statesMap[state.name], this._animator) {
                    var frameNodes = clip._nodes, nodeOwners = clipStateInfo._nodeOwners;
                    clip._removeReference();
                    for (var i = 0, n = frameNodes.count; i < n; i++) this._animator._removeKeyframeNodeOwner(nodeOwners, frameNodes.getNodeByIndex(i))
                }
            }

            _getReferenceCount() {
                return this._referenceCount
            }

            _addReference(count = 1) {
                for (var i = 0, n = this._states.length; i < n; i++) this._states[i]._addReference(count);
                this._referenceCount += count
            }

            _removeReference(count = 1) {
                for (var i = 0, n = this._states.length; i < n; i++) this._states[i]._removeReference(count);
                this._referenceCount -= count
            }

            _clearReference() {
                this._removeReference(-this._referenceCount)
            }

            getAnimatorState(name) {
                var state = this._statesMap[name];
                return state || null
            }

            addState(state) {
                var stateName = state.name;
                if (this._statesMap[stateName]) throw"AnimatorControllerLayer:this stat's name has exist.";
                this._statesMap[stateName] = state, this._states.push(state), this._animator && (state._clip._addReference(), this._animator._getOwnersByClip(state))
            }

            removeState(state) {
                for (var states = this._states, index = -1, i = 0, n = states.length; i < n; i++) if (states[i] === state) {
                    index = i;
                    break
                }
                -1 !== index && this._removeClip(states, this._statesMap, index, state)
            }

            destroy() {
                this._clearReference(), this._statesMap = null, this._states = null, this._playStateInfo = null, this._crossPlayStateInfo = null, this._defaultState = null
            }

            cloneTo(destObject) {
                var dest = destObject;
                dest.name = this.name, dest.blendingMode = this.blendingMode, dest.defaultWeight = this.defaultWeight, dest.playOnWake = this.playOnWake
            }

            clone() {
                var dest = new AnimatorControllerLayer(this.name);
                return this.cloneTo(dest), dest
            }
        }

        AnimatorControllerLayer.BLENDINGMODE_OVERRIDE = 0, AnimatorControllerLayer.BLENDINGMODE_ADDTIVE = 1;

        class AnimatorState {
            constructor() {
                this._referenceCount = 0, this._clip = null, this._nodeOwners = [], this._currentFrameIndices = null, this._scripts = null, this.speed = 1, this.clipStart = 0, this.clipEnd = 1
            }

            get clip() {
                return this._clip
            }

            set clip(value) {
                this._clip !== value && (this._clip && this._referenceCount > 0 && this._clip._removeReference(this._referenceCount), value && (this._currentFrameIndices = new Int16Array(value._nodes.count), this._resetFrameIndices(), this._referenceCount > 0 && this._clip._addReference(this._referenceCount)), this._clip = value)
            }

            _getReferenceCount() {
                return this._referenceCount
            }

            _addReference(count = 1) {
                this._clip && this._clip._addReference(count), this._referenceCount += count
            }

            _removeReference(count = 1) {
                this._clip && this._clip._removeReference(count), this._referenceCount -= count
            }

            _clearReference() {
                this._removeReference(-this._referenceCount)
            }

            _resetFrameIndices() {
                for (var i = 0, n = this._currentFrameIndices.length; i < n; i++) this._currentFrameIndices[i] = -1
            }

            addScript(type) {
                var script = new type;
                return this._scripts = this._scripts || [], this._scripts.push(script), script
            }

            getScript(type) {
                if (this._scripts) for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type) return script
                }
                return null
            }

            getScripts(type) {
                var coms;
                if (this._scripts) for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    script instanceof type && (coms = coms || []).push(script)
                }
                return coms
            }

            cloneTo(destObject) {
                var dest = destObject;
                dest.name = this.name, dest.speed = this.speed, dest.clipStart = this.clipStart, dest.clipEnd = this.clipEnd, dest.clip = this._clip
            }

            clone() {
                var dest = new AnimatorState;
                return this.cloneTo(dest), dest
            }
        }

        class KeyframeNodeOwner {
            constructor() {
                this.indexInList = -1, this.referenceCount = 0, this.updateMark = -1, this.type = -1, this.fullPath = null, this.propertyOwner = null, this.property = null, this.defaultValue = null, this.crossFixedValue = null
            }

            saveCrossFixedValue() {
                var pro = this.propertyOwner;
                if (pro) switch (this.type) {
                    case 0:
                        for (var proPat = this.property, m = proPat.length - 1, j = 0; j < m && (pro = pro[proPat[j]]); j++) ;
                        this.crossFixedValue = pro[proPat[m]];
                        break;
                    case 1:
                        var locPos = pro.localPosition;
                        this.crossFixedValue || (this.crossFixedValue = new Vector3), this.crossFixedValue.x = locPos.x, this.crossFixedValue.y = locPos.y, this.crossFixedValue.z = locPos.z;
                        break;
                    case 2:
                        var locRot = pro.localRotation;
                        this.crossFixedValue || (this.crossFixedValue = new Quaternion), this.crossFixedValue.x = locRot.x, this.crossFixedValue.y = locRot.y, this.crossFixedValue.z = locRot.z, this.crossFixedValue.w = locRot.w;
                        break;
                    case 3:
                        var locSca = pro.localScale;
                        this.crossFixedValue || (this.crossFixedValue = new Vector3), this.crossFixedValue.x = locSca.x, this.crossFixedValue.y = locSca.y, this.crossFixedValue.z = locSca.z;
                        break;
                    case 4:
                        var locEul = pro.localRotationEuler;
                        this.crossFixedValue || (this.crossFixedValue = new Vector3), this.crossFixedValue.x = locEul.x, this.crossFixedValue.y = locEul.y, this.crossFixedValue.z = locEul.z;
                        break;
                    default:
                        throw"Animator:unknown type."
                }
            }
        }

        class Animator extends Laya.Component {
            constructor() {
                super(), this._keyframeNodeOwners = [], this._linkAvatarSpritesData = {}, this._linkAvatarSprites = [], this._renderableSprites = [], this.cullingMode = Animator.CULLINGMODE_CULLCOMPLETELY, this._controllerLayers = [], this._linkSprites = {}, this._speed = 1, this._keyframeNodeOwnerMap = {}, this._updateMark = 0
            }

            static _update(scene) {
                for (var pool = scene._animatorPool, elements = pool.elements, i = 0, n = pool.length; i < n; i++) {
                    var animator = elements[i];
                    animator && animator.enabled && animator._update()
                }
            }

            get speed() {
                return this._speed
            }

            set speed(value) {
                this._speed = value
            }

            _linkToSprites(linkSprites) {
                for (var k in linkSprites) {
                    for (var nodeOwner = this.owner, path = linkSprites[k], j = 0, m = path.length; j < m; j++) {
                        var p = path[j];
                        if ("" === p) break;
                        if (!(nodeOwner = nodeOwner.getChildByName(p))) break
                    }
                    nodeOwner && this.linkSprite3DToAvatarNode(k, nodeOwner)
                }
            }

            _addKeyframeNodeOwner(clipOwners, node, propertyOwner) {
                var nodeIndex = node._indexInList, fullPath = node.fullPath,
                    keyframeNodeOwner = this._keyframeNodeOwnerMap[fullPath];
                if (keyframeNodeOwner) keyframeNodeOwner.referenceCount++, clipOwners[nodeIndex] = keyframeNodeOwner; else {
                    for (var property = propertyOwner, i = 0, n = node.propertyCount; i < n && (property = property[node.getPropertyByIndex(i)]); i++) ;
                    (keyframeNodeOwner = this._keyframeNodeOwnerMap[fullPath] = new KeyframeNodeOwner).fullPath = fullPath, keyframeNodeOwner.indexInList = this._keyframeNodeOwners.length, keyframeNodeOwner.referenceCount = 1, keyframeNodeOwner.propertyOwner = propertyOwner;
                    var propertyCount = node.propertyCount, propertys = [];
                    for (i = 0; i < propertyCount; i++) propertys[i] = node.getPropertyByIndex(i);
                    if (keyframeNodeOwner.property = propertys, keyframeNodeOwner.type = node.type, property) if (0 === node.type) keyframeNodeOwner.defaultValue = property; else {
                        var defaultValue = new property.constructor;
                        property.cloneTo(defaultValue), keyframeNodeOwner.defaultValue = defaultValue
                    }
                    this._keyframeNodeOwners.push(keyframeNodeOwner), clipOwners[nodeIndex] = keyframeNodeOwner
                }
            }

            _removeKeyframeNodeOwner(nodeOwners, node) {
                var fullPath = node.fullPath, keyframeNodeOwner = this._keyframeNodeOwnerMap[fullPath];
                keyframeNodeOwner && (keyframeNodeOwner.referenceCount--, 0 === keyframeNodeOwner.referenceCount && (delete this._keyframeNodeOwnerMap[fullPath], this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(keyframeNodeOwner), 1)), nodeOwners[node._indexInList] = null)
            }

            _getOwnersByClip(clipStateInfo) {
                var frameNodes = clipStateInfo._clip._nodes, frameNodesCount = frameNodes.count,
                    nodeOwners = clipStateInfo._nodeOwners;
                nodeOwners.length = frameNodesCount;
                for (var i = 0; i < frameNodesCount; i++) {
                    for (var node = frameNodes.getNodeByIndex(i), property = this._avatar ? this._avatarNodeMap[this._avatar._rootNode.name] : this.owner, j = 0, m = node.ownerPathCount; j < m; j++) {
                        var ownPat = node.getOwnerPathByIndex(j);
                        if ("" === ownPat) break;
                        if (!(property = property.getChildByName(ownPat))) break
                    }
                    if (property) {
                        var propertyOwner = node.propertyOwner;
                        propertyOwner && (property = property[propertyOwner]), property && this._addKeyframeNodeOwner(nodeOwners, node, property)
                    }
                }
            }

            _updatePlayer(animatorState, playState, elapsedTime, islooping) {
                var clipDuration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart),
                    lastElapsedTime = playState._elapsedTime, elapsedPlaybackTime = lastElapsedTime + elapsedTime;
                playState._lastElapsedTime = lastElapsedTime, playState._elapsedTime = elapsedPlaybackTime;
                var normalizedTime = elapsedPlaybackTime / clipDuration;
                playState._normalizedTime = normalizedTime;
                var playTime = normalizedTime % 1;
                playState._normalizedPlayTime = playTime < 0 ? playTime + 1 : playTime, playState._duration = clipDuration;
                var scripts = animatorState._scripts;
                if (!islooping && elapsedPlaybackTime >= clipDuration) {
                    if (playState._finish = !0, playState._elapsedTime = clipDuration, playState._normalizedPlayTime = 1, scripts) for (var i = 0, n = scripts.length; i < n; i++) scripts[i].onStateExit()
                } else if (scripts) for (i = 0, n = scripts.length; i < n; i++) scripts[i].onStateUpdate()
            }

            _eventScript(scripts, events, eventIndex, endTime, front) {
                if (front) for (var n = events.length; eventIndex < n; eventIndex++) {
                    var event = events[eventIndex];
                    if (!(event.time <= endTime)) break;
                    for (var j = 0, m = scripts.length; j < m; j++) {
                        var script = scripts[j], fun = script[event.eventName];
                        fun && fun.apply(script, event.params)
                    }
                } else for (; eventIndex >= 0 && (event = events[eventIndex]).time >= endTime; eventIndex--) for (j = 0, m = scripts.length; j < m; j++) (fun = (script = scripts[j])[event.eventName]) && fun.apply(script, event.params);
                return eventIndex
            }

            _updateEventScript(stateInfo, playStateInfo) {
                var scripts = this.owner._scripts;
                if (scripts) {
                    var clip = stateInfo._clip, events = clip._animationEvents, clipDuration = clip._duration,
                        elapsedTime = playStateInfo._elapsedTime, time = elapsedTime % clipDuration,
                        loopCount = Math.abs(Math.floor(elapsedTime / clipDuration) - Math.floor(playStateInfo._lastElapsedTime / clipDuration)),
                        frontPlay = playStateInfo._elapsedTime >= playStateInfo._lastElapsedTime;
                    if (playStateInfo._lastIsFront !== frontPlay && (frontPlay ? playStateInfo._playEventIndex++ : playStateInfo._playEventIndex--, playStateInfo._lastIsFront = frontPlay), 0 == loopCount) playStateInfo._playEventIndex = this._eventScript(scripts, events, playStateInfo._playEventIndex, time, frontPlay); else if (frontPlay) {
                        this._eventScript(scripts, events, playStateInfo._playEventIndex, clipDuration, !0);
                        for (var i = 0, n = loopCount - 1; i < n; i++) this._eventScript(scripts, events, 0, clipDuration, !0);
                        playStateInfo._playEventIndex = this._eventScript(scripts, events, 0, time, !0)
                    } else {
                        this._eventScript(scripts, events, playStateInfo._playEventIndex, 0, !1);
                        var eventIndex = events.length - 1;
                        for (i = 0, n = loopCount - 1; i < n; i++) this._eventScript(scripts, events, eventIndex, 0, !1);
                        playStateInfo._playEventIndex = this._eventScript(scripts, events, eventIndex, time, !1)
                    }
                }
            }

            _updateClipDatas(animatorState, addtive, playStateInfo, scale) {
                var clip = animatorState._clip, clipDuration = clip._duration,
                    curPlayTime = animatorState.clipStart * clipDuration + playStateInfo._normalizedPlayTime * playStateInfo._duration,
                    currentFrameIndices = animatorState._currentFrameIndices,
                    frontPlay = playStateInfo._elapsedTime > playStateInfo._lastElapsedTime;
                clip._evaluateClipDatasRealTime(clip._nodes, curPlayTime, currentFrameIndices, addtive, frontPlay)
            }

            _applyFloat(pro, proName, nodeOwner, additive, weight, isFirstLayer, data) {
                if (nodeOwner.updateMark === this._updateMark) if (additive) pro[proName] += weight * data; else {
                    var oriValue = pro[proName];
                    pro[proName] = oriValue + weight * (data - oriValue)
                } else if (isFirstLayer) pro[proName] = additive ? nodeOwner.defaultValue + data : data; else if (additive) pro[proName] = nodeOwner.defaultValue + weight * data; else {
                    var defValue = nodeOwner.defaultValue;
                    pro[proName] = defValue + weight * (data - defValue)
                }
            }

            _applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, data, out) {
                if (nodeOwner.updateMark === this._updateMark) if (additive) out.x += weight * data.x, out.y += weight * data.y, out.z += weight * data.z; else {
                    var oriX = out.x, oriY = out.y, oriZ = out.z;
                    out.x = oriX + weight * (data.x - oriX), out.y = oriY + weight * (data.y - oriY), out.z = oriZ + weight * (data.z - oriZ)
                } else if (isFirstLayer) if (additive) {
                    var defValue = nodeOwner.defaultValue;
                    out.x = defValue.x + data.x, out.y = defValue.y + data.y, out.z = defValue.z + data.z
                } else out.x = data.x, out.y = data.y, out.z = data.z; else if (defValue = nodeOwner.defaultValue, additive) out.x = defValue.x + weight * data.x, out.y = defValue.y + weight * data.y, out.z = defValue.z + weight * data.z; else {
                    var defX = defValue.x, defY = defValue.y, defZ = defValue.z;
                    out.x = defX + weight * (data.x - defX), out.y = defY + weight * (data.y - defY), out.z = defZ + weight * (data.z - defZ)
                }
            }

            _applyRotation(nodeOwner, additive, weight, isFirstLayer, clipRot, localRotation) {
                if (nodeOwner.updateMark === this._updateMark) if (additive) {
                    var tempQuat = Animator._tempQuaternion1;
                    Utils3D.quaternionWeight(clipRot, weight, tempQuat), tempQuat.normalize(tempQuat), Quaternion.multiply(localRotation, tempQuat, localRotation)
                } else Quaternion.lerp(localRotation, clipRot, weight, localRotation); else if (isFirstLayer) if (additive) {
                    var defaultRot = nodeOwner.defaultValue;
                    Quaternion.multiply(defaultRot, clipRot, localRotation)
                } else localRotation.x = clipRot.x, localRotation.y = clipRot.y, localRotation.z = clipRot.z, localRotation.w = clipRot.w; else defaultRot = nodeOwner.defaultValue, additive ? (tempQuat = Animator._tempQuaternion1, Utils3D.quaternionWeight(clipRot, weight, tempQuat), tempQuat.normalize(tempQuat), Quaternion.multiply(defaultRot, tempQuat, localRotation)) : Quaternion.lerp(defaultRot, clipRot, weight, localRotation)
            }

            _applyScale(nodeOwner, additive, weight, isFirstLayer, clipSca, localScale) {
                if (nodeOwner.updateMark === this._updateMark) if (additive) {
                    var scale = Animator._tempVector31;
                    Utils3D.scaleWeight(clipSca, weight, scale), localScale.x = localScale.x * scale.x, localScale.y = localScale.y * scale.y, localScale.z = localScale.z * scale.z
                } else Utils3D.scaleBlend(localScale, clipSca, weight, localScale); else if (isFirstLayer) if (additive) {
                    var defaultSca = nodeOwner.defaultValue;
                    localScale.x = defaultSca.x * clipSca.x, localScale.y = defaultSca.y * clipSca.y, localScale.z = defaultSca.z * clipSca.z
                } else localScale.x = clipSca.x, localScale.y = clipSca.y, localScale.z = clipSca.z; else defaultSca = nodeOwner.defaultValue, additive ? (scale = Animator._tempVector31, Utils3D.scaleWeight(clipSca, weight, scale), localScale.x = defaultSca.x * scale.x, localScale.y = defaultSca.y * scale.y, localScale.z = defaultSca.z * scale.z) : Utils3D.scaleBlend(defaultSca, clipSca, weight, localScale)
            }

            _applyCrossData(nodeOwner, additive, weight, isFirstLayer, srcValue, desValue, crossWeight) {
                var pro = nodeOwner.propertyOwner;
                if (pro) {
                    switch (nodeOwner.type) {
                        case 0:
                            for (var proPat = nodeOwner.property, m = proPat.length - 1, j = 0; j < m && (pro = pro[proPat[j]]); j++) ;
                            var crossValue = srcValue + crossWeight * (desValue - srcValue);
                            this._applyFloat(pro, proPat[m], nodeOwner, additive, weight, isFirstLayer, crossValue);
                            break;
                        case 1:
                            var localPos = pro.localPosition, position = Animator._tempVector30, srcX = srcValue.x,
                                srcY = srcValue.y, srcZ = srcValue.z;
                            position.x = srcX + crossWeight * (desValue.x - srcX), position.y = srcY + crossWeight * (desValue.y - srcY), position.z = srcZ + crossWeight * (desValue.z - srcZ), this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, position, localPos), pro.localPosition = localPos;
                            break;
                        case 2:
                            var localRot = pro.localRotation, rotation = Animator._tempQuaternion0;
                            Quaternion.lerp(srcValue, desValue, crossWeight, rotation), this._applyRotation(nodeOwner, additive, weight, isFirstLayer, rotation, localRot), pro.localRotation = localRot;
                            break;
                        case 3:
                            var localSca = pro.localScale, scale = Animator._tempVector30;
                            Utils3D.scaleBlend(srcValue, desValue, crossWeight, scale), this._applyScale(nodeOwner, additive, weight, isFirstLayer, scale, localSca), pro.localScale = localSca;
                            break;
                        case 4:
                            var localEuler = pro.localRotationEuler, rotationEuler = Animator._tempVector30;
                            srcX = srcValue.x, srcY = srcValue.y, srcZ = srcValue.z, rotationEuler.x = srcX + crossWeight * (desValue.x - srcX), rotationEuler.y = srcY + crossWeight * (desValue.y - srcY), rotationEuler.z = srcZ + crossWeight * (desValue.z - srcZ), this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, rotationEuler, localEuler), pro.localRotationEuler = localEuler
                    }
                    nodeOwner.updateMark = this._updateMark
                }
            }

            _setClipDatasToNode(stateInfo, additive, weight, isFirstLayer) {
                for (var nodes = stateInfo._clip._nodes, nodeOwners = stateInfo._nodeOwners, i = 0, n = nodes.count; i < n; i++) {
                    var nodeOwner = nodeOwners[i];
                    if (nodeOwner) {
                        var pro = nodeOwner.propertyOwner;
                        if (pro) {
                            switch (nodeOwner.type) {
                                case 0:
                                    for (var proPat = nodeOwner.property, m = proPat.length - 1, j = 0; j < m && (pro = pro[proPat[j]]); j++) ;
                                    this._applyFloat(pro, proPat[m], nodeOwner, additive, weight, isFirstLayer, nodes.getNodeByIndex(i).data);
                                    break;
                                case 1:
                                    var localPos = pro.localPosition;
                                    this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, nodes.getNodeByIndex(i).data, localPos), pro.localPosition = localPos;
                                    break;
                                case 2:
                                    var localRot = pro.localRotation;
                                    this._applyRotation(nodeOwner, additive, weight, isFirstLayer, nodes.getNodeByIndex(i).data, localRot), pro.localRotation = localRot;
                                    break;
                                case 3:
                                    var localSca = pro.localScale;
                                    this._applyScale(nodeOwner, additive, weight, isFirstLayer, nodes.getNodeByIndex(i).data, localSca), pro.localScale = localSca;
                                    break;
                                case 4:
                                    var localEuler = pro.localRotationEuler;
                                    this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, nodes.getNodeByIndex(i).data, localEuler), pro.localRotationEuler = localEuler
                            }
                            nodeOwner.updateMark = this._updateMark
                        }
                    }
                }
            }

            _setCrossClipDatasToNode(controllerLayer, srcState, destState, crossWeight, isFirstLayer) {
                for (var nodeOwners = controllerLayer._crossNodesOwners, ownerCount = controllerLayer._crossNodesOwnersCount, additive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE, weight = controllerLayer.defaultWeight, destDataIndices = controllerLayer._destCrossClipNodeIndices, destNodes = destState._clip._nodes, destNodeOwners = destState._nodeOwners, srcDataIndices = controllerLayer._srcCrossClipNodeIndices, srcNodeOwners = srcState._nodeOwners, srcNodes = srcState._clip._nodes, i = 0; i < ownerCount; i++) {
                    var nodeOwner = nodeOwners[i];
                    if (nodeOwner) {
                        var srcIndex = srcDataIndices[i], destIndex = destDataIndices[i],
                            srcValue = -1 !== srcIndex ? srcNodes.getNodeByIndex(srcIndex).data : destNodeOwners[destIndex].defaultValue,
                            desValue = -1 !== destIndex ? destNodes.getNodeByIndex(destIndex).data : srcNodeOwners[srcIndex].defaultValue;
                        this._applyCrossData(nodeOwner, additive, weight, isFirstLayer, srcValue, desValue, crossWeight)
                    }
                }
            }

            _setFixedCrossClipDatasToNode(controllerLayer, destState, crossWeight, isFirstLayer) {
                for (var nodeOwners = controllerLayer._crossNodesOwners, ownerCount = controllerLayer._crossNodesOwnersCount, additive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE, weight = controllerLayer.defaultWeight, destDataIndices = controllerLayer._destCrossClipNodeIndices, destNodes = destState._clip._nodes, i = 0; i < ownerCount; i++) {
                    var nodeOwner = nodeOwners[i];
                    if (nodeOwner) {
                        var destIndex = destDataIndices[i], srcValue = nodeOwner.crossFixedValue,
                            desValue = -1 !== destIndex ? destNodes.getNodeByIndex(destIndex).data : nodeOwner.defaultValue;
                        this._applyCrossData(nodeOwner, additive, weight, isFirstLayer, srcValue, desValue, crossWeight)
                    }
                }
            }

            _revertDefaultKeyframeNodes(clipStateInfo) {
                for (var nodeOwners = clipStateInfo._nodeOwners, i = 0, n = nodeOwners.length; i < n; i++) {
                    var nodeOwner = nodeOwners[i];
                    if (nodeOwner) {
                        var pro = nodeOwner.propertyOwner;
                        if (pro) switch (nodeOwner.type) {
                            case 0:
                                for (var proPat = nodeOwner.property, m = proPat.length - 1, j = 0; j < m && (pro = pro[proPat[j]]); j++) ;
                                pro[proPat[m]] = nodeOwner.defaultValue;
                                break;
                            case 1:
                                var locPos = pro.localPosition, def = nodeOwner.defaultValue;
                                locPos.x = def.x, locPos.y = def.y, locPos.z = def.z, pro.localPosition = locPos;
                                break;
                            case 2:
                                var locRot = pro.localRotation, defQua = nodeOwner.defaultValue;
                                locRot.x = defQua.x, locRot.y = defQua.y, locRot.z = defQua.z, locRot.w = defQua.w, pro.localRotation = locRot;
                                break;
                            case 3:
                                var locSca = pro.localScale;
                                def = nodeOwner.defaultValue, locSca.x = def.x, locSca.y = def.y, locSca.z = def.z, pro.localScale = locSca;
                                break;
                            case 4:
                                var locEul = pro.localRotationEuler;
                                def = nodeOwner.defaultValue, locEul.x = def.x, locEul.y = def.y, locEul.z = def.z, pro.localRotationEuler = locEul;
                                break;
                            default:
                                throw"Animator:unknown type."
                        }
                    }
                }
            }

            _onAdded() {
                var parent = this.owner._parent;
                this.owner._setHierarchyAnimator(this, parent ? parent._hierarchyAnimator : null), this.owner._changeAnimatorToLinkSprite3DNoAvatar(this, !0, [])
            }

            _onDestroy() {
                for (var i = 0, n = this._controllerLayers.length; i < n; i++) this._controllerLayers[i]._removeReference();
                var parent = this.owner._parent;
                this.owner._clearHierarchyAnimator(this, parent ? parent._hierarchyAnimator : null)
            }

            _onEnable() {
                this.owner._scene._animatorPool.add(this);
                for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                    if (this._controllerLayers[i].playOnWake) this.getDefaultState(i) && this.play(null, i, 0)
                }
            }

            _onDisable() {
                this.owner._scene._animatorPool.remove(this)
            }

            _handleSpriteOwnersBySprite(isLink, path, sprite) {
                for (var i = 0, n = this._controllerLayers.length; i < n; i++) for (var clipStateInfos = this._controllerLayers[i]._states, j = 0, m = clipStateInfos.length; j < m; j++) {
                    var clipStateInfo = clipStateInfos[j], clip = clipStateInfo._clip, nodePath = path.join("/"),
                        ownersNodes = clip._nodesMap[nodePath];
                    if (ownersNodes) for (var nodeOwners = clipStateInfo._nodeOwners, k = 0, p = ownersNodes.length; k < p; k++) isLink ? this._addKeyframeNodeOwner(nodeOwners, ownersNodes[k], sprite) : this._removeKeyframeNodeOwner(nodeOwners, ownersNodes[k])
                }
            }

            _parse(data) {
                var avatarData = data.avatar;
                if (avatarData) {
                    this.avatar = Laya.Loader.getRes(avatarData.path);
                    var linkSprites = avatarData.linkSprites;
                    this._linkSprites = linkSprites, this._linkToSprites(linkSprites)
                }
                data.clipPaths;
                for (var play = data.playOnWake, layersData = data.layers, i = 0; i < layersData.length; i++) {
                    var layerData = layersData[i], animatorLayer = new AnimatorControllerLayer(layerData.name);
                    animatorLayer.defaultWeight = 0 === i ? 1 : layerData.weight;
                    var blendingModeData = layerData.blendingMode;
                    blendingModeData && (animatorLayer.blendingMode = blendingModeData), this.addControllerLayer(animatorLayer);
                    for (var states = layerData.states, j = 0, m = states.length; j < m; j++) {
                        var state = states[j], clipPath = state.clipPath;
                        if (clipPath) {
                            var motion, name = state.name;
                            if (motion = Laya.Loader.getRes(clipPath)) {
                                var animatorState = new AnimatorState;
                                animatorState.name = name, animatorState.clip = motion, animatorLayer.addState(animatorState), 0 === j && (this.getControllerLayer(i).defaultState = animatorState)
                            }
                        }
                    }
                    void 0 !== play && (animatorLayer.playOnWake = play)
                }
                var cullingModeData = data.cullingMode;
                void 0 !== cullingModeData && (this.cullingMode = cullingModeData)
            }

            _update() {
                var timer = this.owner._scene.timer, delta = timer._delta / 1e3;
                if (0 !== this._speed && 0 !== delta) {
                    var needRender;
                    if (this.cullingMode === Animator.CULLINGMODE_CULLCOMPLETELY) {
                        needRender = !1;
                        for (var i = 0, n = this._renderableSprites.length; i < n; i++) if (this._renderableSprites[i]._render._visible) {
                            needRender = !0;
                            break
                        }
                    } else needRender = !0;
                    this._updateMark++;
                    var timerScale = timer.scale;
                    for (i = 0, n = this._controllerLayers.length; i < n; i++) {
                        var controllerLayer = this._controllerLayers[i], playStateInfo = controllerLayer._playStateInfo,
                            crossPlayStateInfo = controllerLayer._crossPlayStateInfo;
                        switch (addtive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE, controllerLayer._playType) {
                            case 0:
                                var animatorState = controllerLayer._currentPlayState, clip = animatorState._clip,
                                    speed = this._speed * animatorState.speed, finish = playStateInfo._finish;
                                if (finish || this._updatePlayer(animatorState, playStateInfo, delta * speed, clip.islooping), needRender) {
                                    var addtive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
                                    this._updateClipDatas(animatorState, addtive, playStateInfo, timerScale * speed), this._setClipDatasToNode(animatorState, addtive, controllerLayer.defaultWeight, 0 === i), finish || this._updateEventScript(animatorState, playStateInfo)
                                }
                                break;
                            case 1:
                                clip = (animatorState = controllerLayer._currentPlayState)._clip;
                                var crossClipState = controllerLayer._crossPlayState, crossClip = crossClipState._clip,
                                    crossDuratuion = controllerLayer._crossDuration,
                                    startPlayTime = crossPlayStateInfo._startPlayTime,
                                    crossClipDuration = crossClip._duration - startPlayTime,
                                    crossScale = crossDuratuion > crossClipDuration ? crossClipDuration / crossDuratuion : 1,
                                    crossSpeed = this._speed * crossClipState.speed;
                                this._updatePlayer(crossClipState, crossPlayStateInfo, delta * crossScale * crossSpeed, crossClip.islooping);
                                var crossWeight = (crossPlayStateInfo._elapsedTime - startPlayTime) / crossScale / crossDuratuion;
                                crossWeight >= 1 ? needRender && (this._updateClipDatas(crossClipState, addtive, crossPlayStateInfo, timerScale * crossSpeed), this._setClipDatasToNode(crossClipState, addtive, controllerLayer.defaultWeight, 0 === i), controllerLayer._playType = 0, controllerLayer._currentPlayState = crossClipState, crossPlayStateInfo._cloneTo(playStateInfo)) : (playStateInfo._finish || (speed = this._speed * animatorState.speed, this._updatePlayer(animatorState, playStateInfo, delta * speed, clip.islooping), needRender && this._updateClipDatas(animatorState, addtive, playStateInfo, timerScale * speed)), needRender && (this._updateClipDatas(crossClipState, addtive, crossPlayStateInfo, timerScale * crossScale * crossSpeed), this._setCrossClipDatasToNode(controllerLayer, animatorState, crossClipState, crossWeight, 0 === i))), needRender && (this._updateEventScript(animatorState, playStateInfo), this._updateEventScript(crossClipState, crossPlayStateInfo));
                                break;
                            case 2:
                                crossClip = (crossClipState = controllerLayer._crossPlayState)._clip, crossDuratuion = controllerLayer._crossDuration, startPlayTime = crossPlayStateInfo._startPlayTime, crossScale = crossDuratuion > (crossClipDuration = crossClip._duration - startPlayTime) ? crossClipDuration / crossDuratuion : 1, crossSpeed = this._speed * crossClipState.speed, this._updatePlayer(crossClipState, crossPlayStateInfo, delta * crossScale * crossSpeed, crossClip.islooping), needRender && ((crossWeight = (crossPlayStateInfo._elapsedTime - startPlayTime) / crossScale / crossDuratuion) >= 1 ? (this._updateClipDatas(crossClipState, addtive, crossPlayStateInfo, timerScale * crossSpeed), this._setClipDatasToNode(crossClipState, addtive, 1, 0 === i), controllerLayer._playType = 0, controllerLayer._currentPlayState = crossClipState, crossPlayStateInfo._cloneTo(playStateInfo)) : (this._updateClipDatas(crossClipState, addtive, crossPlayStateInfo, timerScale * crossScale * crossSpeed), this._setFixedCrossClipDatasToNode(controllerLayer, crossClipState, crossWeight, 0 === i)), this._updateEventScript(crossClipState, crossPlayStateInfo))
                        }
                    }
                    needRender && this._avatar && (Laya.Render.supportWebGLPlusAnimation && this._updateAnimationNodeWorldMatix(this._animationNodeLocalPositions, this._animationNodeLocalRotations, this._animationNodeLocalScales, this._animationNodeWorldMatrixs, this._animationNodeParentIndices), this._updateAvatarNodesToSprite())
                }
            }

            _cloneTo(dest) {
                var animator = dest;
                animator.avatar = this.avatar, animator.cullingMode = this.cullingMode;
                for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                    var controllLayer = this._controllerLayers[i];
                    animator.addControllerLayer(controllLayer.clone());
                    for (var animatorStates = controllLayer._states, j = 0, m = animatorStates.length; j < m; j++) {
                        var state = animatorStates[j].clone(), cloneLayer = animator.getControllerLayer(i);
                        cloneLayer.addState(state), 0 == j && (cloneLayer.defaultState = state)
                    }
                }
                animator._linkSprites = this._linkSprites, animator._linkToSprites(this._linkSprites)
            }

            getDefaultState(layerIndex = 0) {
                return this._controllerLayers[layerIndex].defaultState
            }

            addState(state, layerIndex = 0) {
                this._controllerLayers[layerIndex].addState(state), console.warn("Animator:this function is discard,please use animatorControllerLayer.addState() instead.")
            }

            removeState(state, layerIndex = 0) {
                this._controllerLayers[layerIndex].removeState(state), console.warn("Animator:this function is discard,please use animatorControllerLayer.removeState() instead.")
            }

            addControllerLayer(controllderLayer) {
                this._controllerLayers.push(controllderLayer), controllderLayer._animator = this, controllderLayer._addReference();
                for (var states = controllderLayer._states, i = 0, n = states.length; i < n; i++) this._getOwnersByClip(states[i])
            }

            getControllerLayer(layerInex = 0) {
                return this._controllerLayers[layerInex]
            }

            getCurrentAnimatorPlayState(layerInex = 0) {
                return this._controllerLayers[layerInex]._playStateInfo
            }

            play(name = null, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
                var controllerLayer = this._controllerLayers[layerIndex];
                if (controllerLayer) {
                    var defaultState = controllerLayer.defaultState;
                    if (!name && !defaultState) throw new Error("Animator:must have  default clip value,please set clip property.");
                    var curPlayState = controllerLayer._currentPlayState,
                        playStateInfo = controllerLayer._playStateInfo,
                        animatorState = name ? controllerLayer._statesMap[name] : defaultState,
                        clipDuration = animatorState._clip._duration;
                    curPlayState !== animatorState ? (normalizedTime !== Number.NEGATIVE_INFINITY ? playStateInfo._resetPlayState(clipDuration * normalizedTime) : playStateInfo._resetPlayState(0), null !== curPlayState && curPlayState !== animatorState && this._revertDefaultKeyframeNodes(curPlayState), controllerLayer._playType = 0, controllerLayer._currentPlayState = animatorState) : normalizedTime !== Number.NEGATIVE_INFINITY && (playStateInfo._resetPlayState(clipDuration * normalizedTime), controllerLayer._playType = 0);
                    var scripts = animatorState._scripts;
                    if (scripts) for (var i = 0, n = scripts.length; i < n; i++) scripts[i].onStateEnter()
                } else console.warn("Invalid layerIndex " + layerIndex + ".")
            }

            crossFade(name, transitionDuration, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
                var controllerLayer = this._controllerLayers[layerIndex];
                if (controllerLayer) {
                    var destAnimatorState = controllerLayer._statesMap[name];
                    if (destAnimatorState) {
                        var playType = controllerLayer._playType;
                        if (-1 === playType) return void this.play(name, layerIndex, normalizedTime);
                        var crossPlayStateInfo = controllerLayer._crossPlayStateInfo,
                            crossNodeOwners = controllerLayer._crossNodesOwners,
                            crossNodeOwnerIndicesMap = controllerLayer._crossNodesOwnersIndicesMap,
                            srcAnimatorState = controllerLayer._currentPlayState,
                            destNodeOwners = destAnimatorState._nodeOwners,
                            destCrossClipNodeIndices = controllerLayer._destCrossClipNodeIndices,
                            destClip = destAnimatorState._clip, destNodes = destClip._nodes,
                            destNodesMap = destClip._nodesDic;
                        switch (playType) {
                            case 0:
                                var srcNodeOwners = srcAnimatorState._nodeOwners,
                                    scrCrossClipNodeIndices = controllerLayer._srcCrossClipNodeIndices,
                                    srcClip = srcAnimatorState._clip, srcNodes = srcClip._nodes,
                                    srcNodesMap = srcClip._nodesDic;
                                controllerLayer._playType = 1;
                                for (var crossMark = ++controllerLayer._crossMark, crossCount = controllerLayer._crossNodesOwnersCount = 0, i = 0, n = srcNodes.count; i < n; i++) {
                                    var srcNode = srcNodes.getNodeByIndex(i), srcIndex = srcNode._indexInList,
                                        srcNodeOwner = srcNodeOwners[srcIndex];
                                    if (srcNodeOwner) {
                                        var srcFullPath = srcNode.fullPath;
                                        scrCrossClipNodeIndices[crossCount] = srcIndex;
                                        var destNode = destNodesMap[srcFullPath];
                                        destCrossClipNodeIndices[crossCount] = destNode ? destNode._indexInList : -1, crossNodeOwnerIndicesMap[srcFullPath] = crossMark, crossNodeOwners[crossCount] = srcNodeOwner, crossCount++
                                    }
                                }
                                for (i = 0, n = destNodes.count; i < n; i++) {
                                    var destIndex = (destNode = destNodes.getNodeByIndex(i))._indexInList,
                                        destNodeOwner = destNodeOwners[destIndex];
                                    if (destNodeOwner) {
                                        var destFullPath = destNode.fullPath;
                                        srcNodesMap[destFullPath] || (scrCrossClipNodeIndices[crossCount] = -1, destCrossClipNodeIndices[crossCount] = destIndex, crossNodeOwnerIndicesMap[destFullPath] = crossMark, crossNodeOwners[crossCount] = destNodeOwner, crossCount++)
                                    }
                                }
                                break;
                            case 1:
                            case 2:
                                for (controllerLayer._playType = 2, i = 0, n = crossNodeOwners.length; i < n; i++) {
                                    var nodeOwner = crossNodeOwners[i];
                                    nodeOwner.saveCrossFixedValue(), destNode = destNodesMap[nodeOwner.fullPath], destCrossClipNodeIndices[i] = destNode ? destNode._indexInList : -1
                                }
                                for (crossCount = controllerLayer._crossNodesOwnersCount, crossMark = controllerLayer._crossMark, i = 0, n = destNodes.count; i < n; i++) (destNodeOwner = destNodeOwners[destIndex = (destNode = destNodes.getNodeByIndex(i))._indexInList]) && crossNodeOwnerIndicesMap[destFullPath = destNode.fullPath] !== crossMark && (destCrossClipNodeIndices[crossCount] = destIndex, crossNodeOwnerIndicesMap[destFullPath] = crossMark, nodeOwner = destNodeOwners[destIndex], crossNodeOwners[crossCount] = nodeOwner, nodeOwner.saveCrossFixedValue(), crossCount++)
                        }
                        controllerLayer._crossNodesOwnersCount = crossCount, controllerLayer._crossPlayState = destAnimatorState, controllerLayer._crossDuration = srcAnimatorState._clip._duration * transitionDuration, normalizedTime !== Number.NEGATIVE_INFINITY ? crossPlayStateInfo._resetPlayState(destClip._duration * normalizedTime) : crossPlayStateInfo._resetPlayState(0);
                        var scripts = destAnimatorState._scripts;
                        if (scripts) for (i = 0, n = scripts.length; i < n; i++) scripts[i].onStateEnter()
                    } else console.warn("Invalid name " + layerIndex + ".")
                } else console.warn("Invalid layerIndex " + layerIndex + ".")
            }

            get avatar() {
                return this._avatar
            }

            set avatar(value) {
                if (this._avatar !== value) if (this._avatar = value, value) this._getAvatarOwnersAndInitDatasAsync(), this.owner._changeHierarchyAnimatorAvatar(this, value); else {
                    var parent = this.owner._parent;
                    this.owner._changeHierarchyAnimatorAvatar(this, parent ? parent._hierarchyAnimator._avatar : null)
                }
            }

            _getAvatarOwnersAndInitDatasAsync() {
                for (var i = 0, n = this._controllerLayers.length; i < n; i++) for (var clipStateInfos = this._controllerLayers[i]._states, j = 0, m = clipStateInfos.length; j < m; j++) this._getOwnersByClip(clipStateInfos[j]);
                for (var k in this._avatar._cloneDatasToAnimator(this), this._linkAvatarSpritesData) {
                    var sprites = this._linkAvatarSpritesData[k];
                    if (sprites) for (var c = 0, p = sprites.length; c < p; c++) this._isLinkSpriteToAnimationNode(sprites[c], k, !0)
                }
            }

            _isLinkSpriteToAnimationNode(sprite, nodeName, isLink) {
                if (this._avatar) {
                    var node = this._avatarNodeMap[nodeName];
                    if (node) if (isLink) {
                        sprite._transform._dummy = node.transform, this._linkAvatarSprites.push(sprite);
                        var nodeTransform = node.transform, spriteTransform = sprite.transform;
                        if (!spriteTransform.owner.isStatic && nodeTransform) {
                            var spriteWorldMatrix = spriteTransform.worldMatrix,
                                ownParTra = this.owner._transform._parent;
                            if (ownParTra) Utils3D.matrix4x4MultiplyMFM(ownParTra.worldMatrix, nodeTransform.getWorldMatrix(), spriteWorldMatrix); else for (var sprWorE = spriteWorldMatrix.elements, nodWorE = nodeTransform.getWorldMatrix(), i = 0; i < 16; i++) sprWorE[i] = nodWorE[i];
                            spriteTransform.worldMatrix = spriteWorldMatrix
                        }
                    } else sprite._transform._dummy = null, this._linkAvatarSprites.splice(this._linkAvatarSprites.indexOf(sprite), 1)
                }
            }

            _isLinkSpriteToAnimationNodeData(sprite, nodeName, isLink) {
                var linkSprites = this._linkAvatarSpritesData[nodeName];
                if (isLink) linkSprites || (this._linkAvatarSpritesData[nodeName] = linkSprites = []), linkSprites.push(sprite); else {
                    var index = linkSprites.indexOf(sprite);
                    linkSprites.splice(index, 1)
                }
            }

            _updateAvatarNodesToSprite() {
                for (var i = 0, n = this._linkAvatarSprites.length; i < n; i++) {
                    var sprite = this._linkAvatarSprites[i], nodeTransform = sprite.transform._dummy,
                        spriteTransform = sprite.transform;
                    if (!spriteTransform.owner.isStatic && nodeTransform) {
                        var spriteWorldMatrix = spriteTransform.worldMatrix, ownTra = this.owner._transform;
                        Utils3D.matrix4x4MultiplyMFM(ownTra.worldMatrix, nodeTransform.getWorldMatrix(), spriteWorldMatrix), spriteTransform.worldMatrix = spriteWorldMatrix
                    }
                }
            }

            linkSprite3DToAvatarNode(nodeName, sprite3D) {
                return this._isLinkSpriteToAnimationNodeData(sprite3D, nodeName, !0), this._isLinkSpriteToAnimationNode(sprite3D, nodeName, !0), !0
            }

            unLinkSprite3DToAvatarNode(sprite3D) {
                if (sprite3D._hierarchyAnimator === this) {
                    var dummy = sprite3D.transform._dummy;
                    if (dummy) {
                        var nodeName = dummy._owner.name;
                        return this._isLinkSpriteToAnimationNodeData(sprite3D, nodeName, !1), this._isLinkSpriteToAnimationNode(sprite3D, nodeName, !1), !0
                    }
                    return !1
                }
                throw"Animator:sprite3D must belong to this Animator"
            }

            _updateAnimationNodeWorldMatix(localPositions, localRotations, localScales, worldMatrixs, parentIndices) {
                Laya.LayaGL.instance.updateAnimationNodeWorldMatix(localPositions, localRotations, localScales, parentIndices, worldMatrixs)
            }
        }

        Animator._tempVector30 = new Vector3, Animator._tempVector31 = new Vector3, Animator._tempQuaternion0 = new Quaternion, Animator._tempQuaternion1 = new Quaternion, Animator._tempVector3Array0 = new Float32Array(3), Animator._tempVector3Array1 = new Float32Array(3), Animator._tempQuaternionArray0 = new Float32Array(4), Animator._tempQuaternionArray1 = new Float32Array(4), Animator.CULLINGMODE_ALWAYSANIMATE = 0, Animator.CULLINGMODE_CULLCOMPLETELY = 2;

        class Transform3D extends Laya.EventDispatcher {
            constructor(owner) {
                super(), this._localPosition = new Vector3(0, 0, 0), this._localRotation = new Quaternion(0, 0, 0, 1), this._localScale = new Vector3(1, 1, 1), this._localRotationEuler = new Vector3(0, 0, 0), this._localMatrix = new Matrix4x4, this._position = new Vector3(0, 0, 0), this._rotation = new Quaternion(0, 0, 0, 1), this._scale = new Vector3(1, 1, 1), this._rotationEuler = new Vector3(0, 0, 0), this._worldMatrix = new Matrix4x4, this._children = null, this._parent = null, this._dummy = null, this._transformFlag = 0, this._owner = owner, this._children = [], this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, !1), this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE | Transform3D.TRANSFORM_WORLDMATRIX, !0)
            }

            get _isFrontFaceInvert() {
                var scale = this.getWorldLossyScale(), isInvert = scale.x < 0;
                return scale.y < 0 && (isInvert = !isInvert), scale.z < 0 && (isInvert = !isInvert), isInvert
            }

            get owner() {
                return this._owner
            }

            get worldNeedUpdate() {
                return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX)
            }

            get localPositionX() {
                return this._localPosition.x
            }

            set localPositionX(x) {
                this._localPosition.x = x, this.localPosition = this._localPosition
            }

            get localPositionY() {
                return this._localPosition.y
            }

            set localPositionY(y) {
                this._localPosition.y = y, this.localPosition = this._localPosition
            }

            get localPositionZ() {
                return this._localPosition.z
            }

            set localPositionZ(z) {
                this._localPosition.z = z, this.localPosition = this._localPosition
            }

            get localPosition() {
                return this._localPosition
            }

            set localPosition(value) {
                this._localPosition !== value && value.cloneTo(this._localPosition), this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !0), this._onWorldPositionTransform()
            }

            get localRotationX() {
                return this.localRotation.x
            }

            set localRotationX(x) {
                this._localRotation.x = x, this.localRotation = this._localRotation
            }

            get localRotationY() {
                return this.localRotation.y
            }

            set localRotationY(y) {
                this._localRotation.y = y, this.localRotation = this._localRotation
            }

            get localRotationZ() {
                return this.localRotation.z
            }

            set localRotationZ(z) {
                this._localRotation.z = z, this.localRotation = this._localRotation
            }

            get localRotationW() {
                return this.localRotation.w
            }

            set localRotationW(w) {
                this._localRotation.w = w, this.localRotation = this._localRotation
            }

            get localRotation() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION)) {
                    var eulerE = this._localRotationEuler;
                    Quaternion.createFromYawPitchRoll(eulerE.y / Transform3D._angleToRandin, eulerE.x / Transform3D._angleToRandin, eulerE.z / Transform3D._angleToRandin, this._localRotation), this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, !1)
                }
                return this._localRotation
            }

            set localRotation(value) {
                this._localRotation !== value && value.cloneTo(this._localRotation), this._localRotation.normalize(this._localRotation), this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, !0), this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, !1), this._onWorldRotationTransform()
            }

            get localScaleX() {
                return this._localScale.x
            }

            set localScaleX(value) {
                this._localScale.x = value, this.localScale = this._localScale
            }

            get localScaleY() {
                return this._localScale.y
            }

            set localScaleY(value) {
                this._localScale.y = value, this.localScale = this._localScale
            }

            get localScaleZ() {
                return this._localScale.z
            }

            set localScaleZ(value) {
                this._localScale.z = value, this.localScale = this._localScale
            }

            get localScale() {
                return this._localScale
            }

            set localScale(value) {
                this._localScale !== value && value.cloneTo(this._localScale), this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !0), this._onWorldScaleTransform()
            }

            get localRotationEulerX() {
                return this.localRotationEuler.x
            }

            set localRotationEulerX(value) {
                this._localRotationEuler.x = value, this.localRotationEuler = this._localRotationEuler
            }

            get localRotationEulerY() {
                return this.localRotationEuler.y
            }

            set localRotationEulerY(value) {
                this._localRotationEuler.y = value, this.localRotationEuler = this._localRotationEuler
            }

            get localRotationEulerZ() {
                return this.localRotationEuler.z
            }

            set localRotationEulerZ(value) {
                this._localRotationEuler.z = value, this.localRotationEuler = this._localRotationEuler
            }

            get localRotationEuler() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALEULER)) {
                    this._localRotation.getYawPitchRoll(Transform3D._tempVector30);
                    var euler = Transform3D._tempVector30, localRotationEuler = this._localRotationEuler;
                    localRotationEuler.x = euler.y * Transform3D._angleToRandin, localRotationEuler.y = euler.x * Transform3D._angleToRandin, localRotationEuler.z = euler.z * Transform3D._angleToRandin, this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !1)
                }
                return this._localRotationEuler
            }

            set localRotationEuler(value) {
                this._localRotationEuler !== value && value.cloneTo(this._localRotationEuler), this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !1), this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALMATRIX, !0), this._onWorldRotationTransform()
            }

            get localMatrix() {
                return this._getTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX) && (Matrix4x4.createAffineTransformation(this._localPosition, this.localRotation, this._localScale, this._localMatrix), this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !1)), this._localMatrix
            }

            set localMatrix(value) {
                this._localMatrix !== value && value.cloneTo(this._localMatrix), this._localMatrix.decomposeTransRotScale(this._localPosition, this._localRotation, this._localScale), this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !0), this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !1), this._onWorldTransform()
            }

            get position() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                    if (null != this._parent) {
                        var worldMatE = this.worldMatrix.elements;
                        this._position.x = worldMatE[12], this._position.y = worldMatE[13], this._position.z = worldMatE[14]
                    } else this._localPosition.cloneTo(this._position);
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, !1)
                }
                return this._position
            }

            set position(value) {
                if (null != this._parent) {
                    var parentInvMat = Transform3D._tempMatrix0;
                    this._parent.worldMatrix.invert(parentInvMat), Vector3.transformCoordinate(value, parentInvMat, this._localPosition)
                } else value.cloneTo(this._localPosition);
                this.localPosition = this._localPosition, this._position !== value && value.cloneTo(this._position), this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, !1)
            }

            get rotation() {
                return this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && (null != this._parent ? Quaternion.multiply(this._parent.rotation, this.localRotation, this._rotation) : this.localRotation.cloneTo(this._rotation), this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, !1)), this._rotation
            }

            set rotation(value) {
                null != this._parent ? (this._parent.rotation.invert(Transform3D._tempQuaternion0), Quaternion.multiply(Transform3D._tempQuaternion0, value, this._localRotation)) : value.cloneTo(this._localRotation), this.localRotation = this._localRotation, value !== this._rotation && value.cloneTo(this._rotation), this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, !1)
            }

            get rotationEuler() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                    this.rotation.getYawPitchRoll(Transform3D._tempVector30);
                    var eulerE = Transform3D._tempVector30, rotationEulerE = this._rotationEuler;
                    rotationEulerE.x = eulerE.y * Transform3D._angleToRandin, rotationEulerE.y = eulerE.x * Transform3D._angleToRandin, rotationEulerE.z = eulerE.z * Transform3D._angleToRandin, this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, !1)
                }
                return this._rotationEuler
            }

            set rotationEuler(value) {
                Quaternion.createFromYawPitchRoll(value.y / Transform3D._angleToRandin, value.x / Transform3D._angleToRandin, value.z / Transform3D._angleToRandin, this._rotation), this.rotation = this._rotation, this._rotationEuler !== value && value.cloneTo(this._rotationEuler), this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, !1)
            }

            get worldMatrix() {
                return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && (null != this._parent ? Matrix4x4.multiply(this._parent.worldMatrix, this.localMatrix, this._worldMatrix) : this.localMatrix.cloneTo(this._worldMatrix), this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, !1)), this._worldMatrix
            }

            set worldMatrix(value) {
                null === this._parent ? value.cloneTo(this._localMatrix) : (this._parent.worldMatrix.invert(this._localMatrix), Matrix4x4.multiply(this._localMatrix, value, this._localMatrix)), this.localMatrix = this._localMatrix, this._worldMatrix !== value && value.cloneTo(this._worldMatrix), this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, !1)
            }

            _getScaleMatrix() {
                var invRotation = Transform3D._tempQuaternion0, invRotationMat = Transform3D._tempMatrix3x30,
                    worldRotScaMat = Transform3D._tempMatrix3x31, scaMat = Transform3D._tempMatrix3x32;
                return Matrix3x3.createFromMatrix4x4(this.worldMatrix, worldRotScaMat), this.rotation.invert(invRotation), Matrix3x3.createRotationQuaternion(invRotation, invRotationMat), Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat), scaMat
            }

            _setTransformFlag(type, value) {
                value ? this._transformFlag |= type : this._transformFlag &= ~type
            }

            _getTransformFlag(type) {
                return 0 != (this._transformFlag & type)
            }

            _setParent(value) {
                if (this._parent !== value) {
                    if (this._parent) {
                        var parentChilds = this._parent._children, index = parentChilds.indexOf(this);
                        parentChilds.splice(index, 1)
                    }
                    value && (value._children.push(this), value && this._onWorldTransform()), this._parent = value
                }
            }

            _onWorldPositionRotationTransform() {
                if (!(this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER))) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, !0), this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var i = 0, n = this._children.length; i < n; i++) this._children[i]._onWorldPositionRotationTransform()
                }
            }

            _onWorldPositionScaleTransform() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDSCALE, !0), this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var i = 0, n = this._children.length; i < n; i++) this._children[i]._onWorldPositionScaleTransform()
                }
            }

            _onWorldPositionTransform() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION, !0), this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var i = 0, n = this._children.length; i < n; i++) this._children[i]._onWorldPositionTransform()
                }
            }

            _onWorldRotationTransform() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, !0), this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var i = 0, n = this._children.length; i < n; i++) this._children[i]._onWorldPositionRotationTransform()
                }
            }

            _onWorldScaleTransform() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDSCALE, !0), this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var i = 0, n = this._children.length; i < n; i++) this._children[i]._onWorldPositionScaleTransform()
                }
            }

            _onWorldTransform() {
                if (!(this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE))) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE, !0), this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var i = 0, n = this._children.length; i < n; i++) this._children[i]._onWorldTransform()
                }
            }

            translate(translation, isLocal = !0) {
                isLocal ? (Matrix4x4.createFromQuaternion(this.localRotation, Transform3D._tempMatrix0), Vector3.transformCoordinate(translation, Transform3D._tempMatrix0, Transform3D._tempVector30), Vector3.add(this.localPosition, Transform3D._tempVector30, this._localPosition), this.localPosition = this._localPosition) : (Vector3.add(this.position, translation, this._position), this.position = this._position)
            }

            rotate(rotation, isLocal = !0, isRadian = !0) {
                var rot;
                isRadian ? rot = rotation : (Vector3.scale(rotation, Math.PI / 180, Transform3D._tempVector30), rot = Transform3D._tempVector30), Quaternion.createFromYawPitchRoll(rot.y, rot.x, rot.z, Transform3D._tempQuaternion0), isLocal ? (Quaternion.multiply(this._localRotation, Transform3D._tempQuaternion0, this._localRotation), this.localRotation = this._localRotation) : (Quaternion.multiply(Transform3D._tempQuaternion0, this.rotation, this._rotation), this.rotation = this._rotation)
            }

            getForward(forward) {
                var worldMatElem = this.worldMatrix.elements;
                forward.x = -worldMatElem[8], forward.y = -worldMatElem[9], forward.z = -worldMatElem[10]
            }

            getUp(up) {
                var worldMatElem = this.worldMatrix.elements;
                up.x = worldMatElem[4], up.y = worldMatElem[5], up.z = worldMatElem[6]
            }

            getRight(right) {
                var worldMatElem = this.worldMatrix.elements;
                right.x = worldMatElem[0], right.y = worldMatElem[1], right.z = worldMatElem[2]
            }

            lookAt(target, up, isLocal = !1) {
                var eye;
                if (isLocal) {
                    if (eye = this._localPosition, Math.abs(eye.x - target.x) < MathUtils3D.zeroTolerance && Math.abs(eye.y - target.y) < MathUtils3D.zeroTolerance && Math.abs(eye.z - target.z) < MathUtils3D.zeroTolerance) return;
                    Quaternion.lookAt(this._localPosition, target, up, this._localRotation), this._localRotation.invert(this._localRotation), this.localRotation = this._localRotation
                } else {
                    var worldPosition = this.position;
                    if (eye = worldPosition, Math.abs(eye.x - target.x) < MathUtils3D.zeroTolerance && Math.abs(eye.y - target.y) < MathUtils3D.zeroTolerance && Math.abs(eye.z - target.z) < MathUtils3D.zeroTolerance) return;
                    Quaternion.lookAt(worldPosition, target, up, this._rotation), this._rotation.invert(this._rotation), this.rotation = this._rotation
                }
            }

            getWorldLossyScale() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                    if (null !== this._parent) {
                        var scaMatE = this._getScaleMatrix().elements;
                        this._scale.x = scaMatE[0], this._scale.y = scaMatE[4], this._scale.z = scaMatE[8]
                    } else this._localScale.cloneTo(this._scale);
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, !1)
                }
                return this._scale
            }

            setWorldLossyScale(value) {
                if (null !== this._parent) {
                    var scaleMat = Transform3D._tempMatrix3x33, localScaleMat = Transform3D._tempMatrix3x33,
                        localScaleMatE = localScaleMat.elements, parInvScaleMat = this._parent._getScaleMatrix();
                    parInvScaleMat.invert(parInvScaleMat), Matrix3x3.createFromScaling(value, scaleMat), Matrix3x3.multiply(parInvScaleMat, scaleMat, localScaleMat), this._localScale.x = localScaleMatE[0], this._localScale.y = localScaleMatE[4], this._localScale.z = localScaleMatE[8]
                } else value.cloneTo(this._localScale);
                this.localScale = this._localScale, this._scale !== value && value.cloneTo(this._scale), this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, !1)
            }

            get scale() {
                return console.warn("Transfrm3D: discard function,please use getWorldLossyScale instead."), this.getWorldLossyScale()
            }

            set scale(value) {
                console.warn("Transfrm3D: discard function,please use setWorldLossyScale instead."), this.setWorldLossyScale(value)
            }
        }

        Transform3D._tempVector30 = new Vector3, Transform3D._tempQuaternion0 = new Quaternion, Transform3D._tempMatrix0 = new Matrix4x4, Transform3D._tempMatrix3x30 = new Matrix3x3, Transform3D._tempMatrix3x31 = new Matrix3x3, Transform3D._tempMatrix3x32 = new Matrix3x3, Transform3D._tempMatrix3x33 = new Matrix3x3, Transform3D.TRANSFORM_LOCALQUATERNION = 1, Transform3D.TRANSFORM_LOCALEULER = 2, Transform3D.TRANSFORM_LOCALMATRIX = 4, Transform3D.TRANSFORM_WORLDPOSITION = 8, Transform3D.TRANSFORM_WORLDQUATERNION = 16, Transform3D.TRANSFORM_WORLDSCALE = 32, Transform3D.TRANSFORM_WORLDMATRIX = 64, Transform3D.TRANSFORM_WORLDEULER = 128, Transform3D._angleToRandin = 180 / Math.PI;

        class Sprite3D extends Laya.Node {
            constructor(name = null, isStatic = !1) {
                super(), this._needProcessCollisions = !1, this._needProcessTriggers = !1, this._id = ++Sprite3D._uniqueIDCounter, this._transform = new Transform3D(this), this._isStatic = isStatic, this.layer = 0, this.name = name || "New Sprite3D"
            }

            static __init__() {
            }

            static instantiate(original, parent = null, worldPositionStays = !0, position = null, rotation = null) {
                var destSprite3D = original.clone();
                parent && parent.addChild(destSprite3D);
                var transform = destSprite3D.transform;
                if (worldPositionStays) {
                    var worldMatrix = transform.worldMatrix;
                    original.transform.worldMatrix.cloneTo(worldMatrix), transform.worldMatrix = worldMatrix
                } else position && (transform.position = position), rotation && (transform.rotation = rotation);
                return destSprite3D
            }

            static load(url, complete) {
                Laya.Laya.loader.create(url, complete, null, Sprite3D.HIERARCHY)
            }

            get id() {
                return this._id
            }

            get layer() {
                return this._layer
            }

            set layer(value) {
                if (this._layer !== value) {
                    if (!(value >= 0 && value <= 30)) throw new Error("Layer value must be 0-30.");
                    this._layer = value
                }
            }

            get url() {
                return this._url
            }

            get isStatic() {
                return this._isStatic
            }

            get transform() {
                return this._transform
            }

            _setCreateURL(url) {
                this._url = Laya.URL.formatURL(url)
            }

            _changeAnimatorsToLinkSprite3D(sprite3D, isLink, path) {
                var animator = this.getComponent(Animator);
                if (animator && (animator.avatar || sprite3D._changeAnimatorToLinkSprite3DNoAvatar(animator, isLink, path)), this._parent && this._parent instanceof Sprite3D) {
                    path.unshift(this._parent.name);
                    var p = this._parent;
                    p._hierarchyAnimator && p._changeAnimatorsToLinkSprite3D(sprite3D, isLink, path)
                }
            }

            _setHierarchyAnimator(animator, parentAnimator) {
                this._changeHierarchyAnimator(animator), this._changeAnimatorAvatar(animator.avatar);
                for (var i = 0, n = this._children.length; i < n; i++) {
                    var child = this._children[i];
                    child._hierarchyAnimator == parentAnimator && child._setHierarchyAnimator(animator, parentAnimator)
                }
            }

            _clearHierarchyAnimator(animator, parentAnimator) {
                this._changeHierarchyAnimator(parentAnimator), this._changeAnimatorAvatar(parentAnimator ? parentAnimator.avatar : null);
                for (var i = 0, n = this._children.length; i < n; i++) {
                    var child = this._children[i];
                    child._hierarchyAnimator == animator && child._clearHierarchyAnimator(animator, parentAnimator)
                }
            }

            _changeHierarchyAnimatorAvatar(animator, avatar) {
                this._changeAnimatorAvatar(avatar);
                for (var i = 0, n = this._children.length; i < n; i++) {
                    var child = this._children[i];
                    child._hierarchyAnimator == animator && child._changeHierarchyAnimatorAvatar(animator, avatar)
                }
            }

            _changeAnimatorToLinkSprite3DNoAvatar(animator, isLink, path) {
                animator._handleSpriteOwnersBySprite(isLink, path, this);
                for (var i = 0, n = this._children.length; i < n; i++) {
                    var child = this._children[i], index = path.length;
                    path.push(child.name), child._changeAnimatorToLinkSprite3DNoAvatar(animator, isLink, path), path.splice(index, 1)
                }
            }

            _changeHierarchyAnimator(animator) {
                this._hierarchyAnimator = animator
            }

            _changeAnimatorAvatar(avatar) {
            }

            _onAdded() {
                if (this._parent instanceof Sprite3D) {
                    var parent3D = this._parent;
                    this.transform._setParent(parent3D.transform), parent3D._hierarchyAnimator && (!this._hierarchyAnimator && this._setHierarchyAnimator(parent3D._hierarchyAnimator, null), parent3D._changeAnimatorsToLinkSprite3D(this, !0, [this.name]))
                }
                super._onAdded()
            }

            _onRemoved() {
                if (super._onRemoved(), this._parent instanceof Sprite3D) {
                    var parent3D = this._parent;
                    this.transform._setParent(null), parent3D._hierarchyAnimator && (this._hierarchyAnimator == parent3D._hierarchyAnimator && this._clearHierarchyAnimator(parent3D._hierarchyAnimator, null), parent3D._changeAnimatorsToLinkSprite3D(this, !1, [this.name]))
                }
            }

            _parse(data, spriteMap) {
                if (void 0 !== data.isStatic && (this._isStatic = data.isStatic), void 0 !== data.active && (this.active = data.active), null != data.name && (this.name = data.name), void 0 !== data.position) {
                    var loccalPosition = this.transform.localPosition;
                    loccalPosition.fromArray(data.position), this.transform.localPosition = loccalPosition
                }
                if (void 0 !== data.rotationEuler) {
                    var localRotationEuler = this.transform.localRotationEuler;
                    localRotationEuler.fromArray(data.rotationEuler), this.transform.localRotationEuler = localRotationEuler
                }
                if (void 0 !== data.rotation) {
                    var localRotation = this.transform.localRotation;
                    localRotation.fromArray(data.rotation), this.transform.localRotation = localRotation
                }
                if (void 0 !== data.scale) {
                    var localScale = this.transform.localScale;
                    localScale.fromArray(data.scale), this.transform.localScale = localScale
                }
                null != data.layer && (this.layer = data.layer)
            }

            _cloneTo(destObject, srcRoot, dstRoot) {
                if (this.destroyed) throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
                var destSprite3D = destObject;
                destSprite3D.name = this.name, destSprite3D.destroyed = this.destroyed, destSprite3D.active = this.active;
                var destLocalPosition = destSprite3D.transform.localPosition;
                this.transform.localPosition.cloneTo(destLocalPosition), destSprite3D.transform.localPosition = destLocalPosition;
                var destLocalRotation = destSprite3D.transform.localRotation;
                this.transform.localRotation.cloneTo(destLocalRotation), destSprite3D.transform.localRotation = destLocalRotation;
                var destLocalScale = destSprite3D.transform.localScale;
                this.transform.localScale.cloneTo(destLocalScale), destSprite3D.transform.localScale = destLocalScale, destSprite3D._isStatic = this._isStatic, destSprite3D.layer = this.layer, super._cloneTo(destSprite3D, srcRoot, dstRoot)
            }

            static _createSprite3DInstance(scrSprite) {
                for (var node = scrSprite._create(), children = scrSprite._children, i = 0, n = children.length; i < n; i++) {
                    var child = Sprite3D._createSprite3DInstance(children[i]);
                    node.addChild(child)
                }
                return node
            }

            static _parseSprite3DInstance(srcRoot, dstRoot, scrSprite, dstSprite) {
                for (var srcChildren = scrSprite._children, dstChildren = dstSprite._children, i = 0, n = srcChildren.length; i < n; i++) Sprite3D._parseSprite3DInstance(srcRoot, dstRoot, srcChildren[i], dstChildren[i]);
                scrSprite._cloneTo(dstSprite, srcRoot, dstRoot)
            }

            clone() {
                var dstSprite3D = Sprite3D._createSprite3DInstance(this);
                return Sprite3D._parseSprite3DInstance(this, dstSprite3D, this, dstSprite3D), dstSprite3D
            }

            destroy(destroyChild = !0) {
                this.destroyed || (super.destroy(destroyChild), this._transform = null, this._scripts = null, this._url && Laya.Loader.clearRes(this._url))
            }

            _create() {
                return new Sprite3D
            }
        }

        Sprite3D.HIERARCHY = "HIERARCHY", Sprite3D.WORLDMATRIX = Shader3D.propertyNameToID("u_WorldMat"), Sprite3D.MVPMATRIX = Shader3D.propertyNameToID("u_MvpMatrix"), Sprite3D._uniqueIDCounter = 0;

        class RenderableSprite3D extends Sprite3D {
            constructor(name) {
                super(name)
            }

            static __init__() {
                RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW = RenderableSprite3D.shaderDefines.registerDefine("RECEIVESHADOW"), RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV = RenderableSprite3D.shaderDefines.registerDefine("SCALEOFFSETLIGHTINGMAPUV"), RenderableSprite3D.SAHDERDEFINE_LIGHTMAP = RenderableSprite3D.shaderDefines.registerDefine("LIGHTMAP")
            }

            _onInActive() {
                super._onInActive();
                var scene3D = this._scene;
                scene3D._removeRenderObject(this._render), this._render.castShadow && scene3D._removeShadowCastRenderObject(this._render)
            }

            _onActive() {
                super._onActive();
                var scene3D = this._scene;
                scene3D._addRenderObject(this._render), this._render.castShadow && scene3D._addShadowCastRenderObject(this._render)
            }

            _onActiveInScene() {
                if (super._onActiveInScene(), ILaya3D.Laya3D._editerEnvironment) {
                    var scene = this._scene, pickColor = new Vector4;
                    scene._allotPickColorByID(this.id, pickColor), scene._pickIdToSprite[this.id] = this, this._render._shaderValues.setVector(RenderableSprite3D.PICKCOLOR, pickColor)
                }
            }

            _addToInitStaticBatchManager() {
            }

            _setBelongScene(scene) {
                super._setBelongScene(scene), this._render._setBelongScene(scene)
            }

            _setUnBelongScene() {
                this._render._shaderValues.removeDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP), super._setUnBelongScene()
            }

            _changeHierarchyAnimator(animator) {
                if (this._hierarchyAnimator) {
                    var renderableSprites = this._hierarchyAnimator._renderableSprites;
                    renderableSprites.splice(renderableSprites.indexOf(this), 1)
                }
                animator && animator._renderableSprites.push(this), super._changeHierarchyAnimator(animator)
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._render._destroy(), this._render = null
            }

            _create() {
                return new RenderableSprite3D(this.name)
            }
        }

        RenderableSprite3D.LIGHTMAPSCALEOFFSET = Shader3D.propertyNameToID("u_LightmapScaleOffset"), RenderableSprite3D.LIGHTMAP = Shader3D.propertyNameToID("u_LightMap"), RenderableSprite3D.PICKCOLOR = Shader3D.propertyNameToID("u_PickColor"), RenderableSprite3D.shaderDefines = new ShaderDefines;

        class StaticBatchManager {
            constructor() {
                this._initBatchSprites = [], this._staticBatches = {}, this._batchRenderElementPoolIndex = 0, this._batchRenderElementPool = []
            }

            static _registerManager(manager) {
                StaticBatchManager._managers.push(manager)
            }

            static _addToStaticBatchQueue(sprite3D, renderableSprite3D) {
                sprite3D instanceof RenderableSprite3D && sprite3D.isStatic && renderableSprite3D.push(sprite3D);
                for (var i = 0, n = sprite3D.numChildren; i < n; i++) StaticBatchManager._addToStaticBatchQueue(sprite3D._children[i], renderableSprite3D)
            }

            static combine(staticBatchRoot, renderableSprite3Ds = null) {
                renderableSprite3Ds || (renderableSprite3Ds = [], staticBatchRoot && StaticBatchManager._addToStaticBatchQueue(staticBatchRoot, renderableSprite3Ds));
                var batchSpritesCount = renderableSprite3Ds.length;
                if (batchSpritesCount > 0) {
                    for (var i = 0; i < batchSpritesCount; i++) {
                        var renderableSprite3D = renderableSprite3Ds[i];
                        renderableSprite3D.isStatic && renderableSprite3D._addToInitStaticBatchManager()
                    }
                    for (var k = 0, m = StaticBatchManager._managers.length; k < m; k++) {
                        StaticBatchManager._managers[k]._initStaticBatchs(staticBatchRoot)
                    }
                }
            }

            _partition(items, left, right) {
                for (var pivot = items[Math.floor((right + left) / 2)]; left <= right;) {
                    for (; this._compare(items[left], pivot) < 0;) left++;
                    for (; this._compare(items[right], pivot) > 0;) right--;
                    if (left < right) {
                        var temp = items[left];
                        items[left] = items[right], items[right] = temp, left++, right--
                    } else if (left === right) {
                        left++;
                        break
                    }
                }
                return left
            }

            _quickSort(items, left, right) {
                if (items.length > 1) {
                    var index = this._partition(items, left, right), leftIndex = index - 1;
                    left < leftIndex && this._quickSort(items, left, leftIndex), index < right && this._quickSort(items, index, right)
                }
            }

            _compare(left, right) {
                throw"StaticBatch:must override this function."
            }

            _initStaticBatchs(rootSprite) {
                throw"StaticBatch:must override this function."
            }

            _getBatchRenderElementFromPool() {
                throw"StaticBatch:must override this function."
            }

            _addBatchSprite(renderableSprite3D) {
                this._initBatchSprites.push(renderableSprite3D)
            }

            _clear() {
                this._batchRenderElementPoolIndex = 0
            }

            _garbageCollection() {
                throw"StaticBatchManager: must override it."
            }

            dispose() {
                this._staticBatches = null
            }
        }

        StaticBatchManager._managers = [];

        class FrustumCulling {
            constructor() {
            }

            static __init__() {
                Laya.Render.supportWebGLPlusCulling && (FrustumCulling._cullingBufferLength = 0, FrustumCulling._cullingBuffer = new Float32Array(4096))
            }

            static _drawTraversalCullingBound(renderList, debugTool) {
                renderList.length;
                for (var renders = renderList.elements, i = 0, n = renderList.length; i < n; i++) {
                    var color = FrustumCulling._tempColor0;
                    color.r = 0, color.g = 1, color.b = 0, color.a = 1, Utils3D._drawBound(debugTool, renders[i].bounds._getBoundBox(), color)
                }
            }

            static _traversalCulling(camera, scene, context, renderList, customShader, replacementTag) {
                for (var validCount = renderList.length, renders = renderList.elements, boundFrustum = camera.boundFrustum, camPos = camera._transform.position, i = 0; i < validCount; i++) {
                    var render = renders[i];
                    if (camera._isLayerVisible(render._owner._layer) && render._enable) if (Laya.Stat.frustumCulling++, !camera.useOcclusionCulling || render._needRender(boundFrustum, context)) {
                        render._visible = !0, render._distanceForSort = Vector3.distance(render.bounds.getCenter(), camPos);
                        for (var elements = render._renderElements, j = 0, m = elements.length; j < m; j++) elements[j]._update(scene, context, customShader, replacementTag)
                    } else render._visible = !1; else render._visible = !1
                }
            }

            static renderObjectCulling(camera, scene, context, renderList, customShader, replacementTag) {
                var i, n, opaqueQueue = scene._opaqueQueue, transparentQueue = scene._transparentQueue;
                opaqueQueue.clear(), transparentQueue.clear();
                var staticBatchManagers = StaticBatchManager._managers;
                for (i = 0, n = staticBatchManagers.length; i < n; i++) staticBatchManagers[i]._clear();
                var dynamicBatchManagers = DynamicBatchManager._managers;
                for (i = 0, n = dynamicBatchManagers.length; i < n; i++) dynamicBatchManagers[i]._clear();
                var octree = scene._octree;
                if (octree && (octree.updateMotionObjects(), octree.shrinkRootIfPossible(), octree.getCollidingWithFrustum(context, customShader, replacementTag)), FrustumCulling._traversalCulling(camera, scene, context, renderList, customShader, replacementTag), FrustumCulling.debugFrustumCulling) {
                    var debugTool = scene._debugTool;
                    debugTool.clear(), octree && (octree.drawAllBounds(debugTool), octree.drawAllObjects(debugTool)), FrustumCulling._drawTraversalCullingBound(renderList, debugTool)
                }
                var count = opaqueQueue.elements.length;
                count > 0 && opaqueQueue._quickSort(0, count - 1), (count = transparentQueue.elements.length) > 0 && transparentQueue._quickSort(0, count - 1)
            }

            static renderObjectCullingNative(camera, scene, context, renderList, customShader, replacementTag) {
                var i, n, j, m, opaqueQueue = scene._opaqueQueue, transparentQueue = scene._transparentQueue;
                opaqueQueue.clear(), transparentQueue.clear();
                var staticBatchManagers = StaticBatchManager._managers;
                for (i = 0, n = staticBatchManagers.length; i < n; i++) staticBatchManagers[i]._clear();
                var dynamicBatchManagers = DynamicBatchManager._managers;
                for (i = 0, n = dynamicBatchManagers.length; i < n; i++) dynamicBatchManagers[i]._clear();
                var validCount = renderList.length, renders = renderList.elements;
                for (i = 0; i < validCount; i++) renders[i].bounds, renders[i]._updateForNative && renders[i]._updateForNative(context);
                camera.boundFrustum;
                FrustumCulling.cullingNative(camera._boundFrustumBuffer, FrustumCulling._cullingBuffer, scene._cullingBufferIndices, validCount, scene._cullingBufferResult);
                var camPos = context.camera._transform.position;
                for (i = 0; i < validCount; i++) {
                    var render = renders[i];
                    if (!camera.useOcclusionCulling || camera._isLayerVisible(render._owner._layer) && render._enable && scene._cullingBufferResult[i]) {
                        render._visible = !0, render._distanceForSort = Vector3.distance(render.bounds.getCenter(), camPos);
                        var elements = render._renderElements;
                        for (j = 0, m = elements.length; j < m; j++) {
                            elements[j]._update(scene, context, customShader, replacementTag)
                        }
                    } else render._visible = !1
                }
                var count = opaqueQueue.elements.length;
                count > 0 && opaqueQueue._quickSort(0, count - 1), (count = transparentQueue.elements.length) > 0 && transparentQueue._quickSort(0, count - 1)
            }

            static cullingNative(boundFrustumBuffer, cullingBuffer, cullingBufferIndices, cullingCount, cullingBufferResult) {
                return Laya.LayaGL.instance.culling(boundFrustumBuffer, cullingBuffer, cullingBufferIndices, cullingCount, cullingBufferResult)
            }
        }

        FrustumCulling._tempVector3 = new Vector3, FrustumCulling._tempColor0 = new Color, FrustumCulling.debugFrustumCulling = !1;

        class Plane {
            constructor(normal, d = 0) {
                this.normal = normal, this.distance = d
            }

            static createPlaneBy3P(point1, point2, point3) {
                var x1 = point2.x - point1.x, y1 = point2.y - point1.y, z1 = point2.z - point1.z,
                    x2 = point3.x - point1.x, y2 = point3.y - point1.y, z2 = point3.z - point1.z,
                    yz = y1 * z2 - z1 * y2, xz = z1 * x2 - x1 * z2, xy = x1 * y2 - y1 * x2,
                    invPyth = 1 / Math.sqrt(yz * yz + xz * xz + xy * xy), x = yz * invPyth, y = xz * invPyth,
                    z = xy * invPyth;
                Plane._TEMPVec3.x = x, Plane._TEMPVec3.y = y, Plane._TEMPVec3.z = z;
                var d = -(x * point1.x + y * point1.y + z * point1.z);
                return new Plane(Plane._TEMPVec3, d)
            }

            normalize() {
                var normalEX = this.normal.x, normalEY = this.normal.y, normalEZ = this.normal.z,
                    magnitude = 1 / Math.sqrt(normalEX * normalEX + normalEY * normalEY + normalEZ * normalEZ);
                this.normal.x = normalEX * magnitude, this.normal.y = normalEY * magnitude, this.normal.z = normalEZ * magnitude, this.distance *= magnitude
            }
        }

        Plane._TEMPVec3 = new Vector3, Plane.PlaneIntersectionType_Back = 0, Plane.PlaneIntersectionType_Front = 1, Plane.PlaneIntersectionType_Intersecting = 2;

        class Ray {
            constructor(origin, direction) {
                this.origin = origin, this.direction = direction
            }
        }

        class ContainmentType {
        }

        ContainmentType.Disjoint = 0, ContainmentType.Contains = 1, ContainmentType.Intersects = 2;

        class CollisionUtils {
            constructor() {
            }

            static distancePlaneToPoint(plane, point) {
                return Vector3.dot(plane.normal, point) - plane.distance
            }

            static distanceBoxToPoint(box, point) {
                var boxMin = box.min, boxMineX = boxMin.x, boxMineY = boxMin.y, boxMineZ = boxMin.z, boxMax = box.max,
                    boxMaxeX = boxMax.x, boxMaxeY = boxMax.y, boxMaxeZ = boxMax.z, pointeX = point.x, pointeY = point.y,
                    pointeZ = point.z, distance = 0;
                return pointeX < boxMineX && (distance += (boxMineX - pointeX) * (boxMineX - pointeX)), pointeX > boxMaxeX && (distance += (boxMaxeX - pointeX) * (boxMaxeX - pointeX)), pointeY < boxMineY && (distance += (boxMineY - pointeY) * (boxMineY - pointeY)), pointeY > boxMaxeY && (distance += (boxMaxeY - pointeY) * (boxMaxeY - pointeY)), pointeZ < boxMineZ && (distance += (boxMineZ - pointeZ) * (boxMineZ - pointeZ)), pointeZ > boxMaxeZ && (distance += (boxMaxeZ - pointeZ) * (boxMaxeZ - pointeZ)), Math.sqrt(distance)
            }

            static distanceBoxToBox(box1, box2) {
                var delta, box1Mine = box1.min, box1MineX = box1Mine.x, box1MineY = box1Mine.y, box1MineZ = box1Mine.z,
                    box1Maxe = box1.max, box1MaxeX = box1Maxe.x, box1MaxeY = box1Maxe.y, box1MaxeZ = box1Maxe.z,
                    box2Mine = box2.min, box2MineX = box2Mine.x, box2MineY = box2Mine.y, box2MineZ = box2Mine.z,
                    box2Maxe = box2.max, box2MaxeX = box2Maxe.x, box2MaxeY = box2Maxe.y, box2MaxeZ = box2Maxe.z,
                    distance = 0;
                return box1MineX > box2MaxeX ? distance += (delta = box1MineX - box2MaxeX) * delta : box2MineX > box1MaxeX && (distance += (delta = box2MineX - box1MaxeX) * delta), box1MineY > box2MaxeY ? distance += (delta = box1MineY - box2MaxeY) * delta : box2MineY > box1MaxeY && (distance += (delta = box2MineY - box1MaxeY) * delta), box1MineZ > box2MaxeZ ? distance += (delta = box1MineZ - box2MaxeZ) * delta : box2MineZ > box1MaxeZ && (distance += (delta = box2MineZ - box1MaxeZ) * delta), Math.sqrt(distance)
            }

            static distanceSphereToPoint(sphere, point) {
                var distance = Math.sqrt(Vector3.distanceSquared(sphere.center, point));
                return distance -= sphere.radius, Math.max(distance, 0)
            }

            static distanceSphereToSphere(sphere1, sphere2) {
                var distance = Math.sqrt(Vector3.distanceSquared(sphere1.center, sphere2.center));
                return distance -= sphere1.radius + sphere2.radius, Math.max(distance, 0)
            }

            static intersectsRayAndTriangleRD(ray, vertex1, vertex2, vertex3, out) {
                var rayO = ray.origin, rayOeX = rayO.x, rayOeY = rayO.y, rayOeZ = rayO.z, rayD = ray.direction,
                    rayDeX = rayD.x, rayDeY = rayD.y, rayDeZ = rayD.z, v1eX = vertex1.x, v1eY = vertex1.y,
                    v1eZ = vertex1.z, v2eX = vertex2.x, v2eY = vertex2.y, v2eZ = vertex2.z, v3eX = vertex3.x,
                    v3eY = vertex3.y, v3eZ = vertex3.z, _tempV30eX = CollisionUtils._tempV30.x,
                    _tempV30eY = CollisionUtils._tempV30.y, _tempV30eZ = CollisionUtils._tempV30.z;
                _tempV30eX = v2eX - v1eX, _tempV30eY = v2eY - v1eY, _tempV30eZ = v2eZ - v1eZ;
                var _tempV31eX = CollisionUtils._tempV31.x, _tempV31eY = CollisionUtils._tempV31.y,
                    _tempV31eZ = CollisionUtils._tempV31.z;
                _tempV31eX = v3eX - v1eX, _tempV31eY = v3eY - v1eY, _tempV31eZ = v3eZ - v1eZ;
                var _tempV32eX = CollisionUtils._tempV32.x, _tempV32eY = CollisionUtils._tempV32.y,
                    _tempV32eZ = CollisionUtils._tempV32.z,
                    determinant = _tempV30eX * (_tempV32eX = rayDeY * _tempV31eZ - rayDeZ * _tempV31eY) + _tempV30eY * (_tempV32eY = rayDeZ * _tempV31eX - rayDeX * _tempV31eZ) + _tempV30eZ * (_tempV32eZ = rayDeX * _tempV31eY - rayDeY * _tempV31eX);
                if (MathUtils3D.isZero(determinant)) return !1;
                var inversedeterminant = 1 / determinant, _tempV33eX = CollisionUtils._tempV33.x,
                    _tempV33eY = CollisionUtils._tempV33.y, _tempV33eZ = CollisionUtils._tempV33.z,
                    triangleU = (_tempV33eX = rayOeX - v1eX) * _tempV32eX + (_tempV33eY = rayOeY - v1eY) * _tempV32eY + (_tempV33eZ = rayOeZ - v1eZ) * _tempV32eZ;
                if ((triangleU *= inversedeterminant) < 0 || triangleU > 1) return !1;
                var _tempV34eX = CollisionUtils._tempV34.x, _tempV34eY = CollisionUtils._tempV34.y,
                    _tempV34eZ = CollisionUtils._tempV34.z,
                    triangleV = rayDeX * (_tempV34eX = _tempV33eY * _tempV30eZ - _tempV33eZ * _tempV30eY) + rayDeY * (_tempV34eY = _tempV33eZ * _tempV30eX - _tempV33eX * _tempV30eZ) + rayDeZ * (_tempV34eZ = _tempV33eX * _tempV30eY - _tempV33eY * _tempV30eX);
                if ((triangleV *= inversedeterminant) < 0 || triangleU + triangleV > 1) return !1;
                var raydistance = _tempV31eX * _tempV34eX + _tempV31eY * _tempV34eY + _tempV31eZ * _tempV34eZ;
                return !((raydistance *= inversedeterminant) < 0)
            }

            static intersectsRayAndTriangleRP(ray, vertex1, vertex2, vertex3, out) {
                return CollisionUtils.intersectsRayAndTriangleRD(ray, vertex1, vertex2, vertex3, void 0) ? (Vector3.scale(ray.direction, void 0, CollisionUtils._tempV30), Vector3.add(ray.origin, CollisionUtils._tempV30, out), !0) : (out = Vector3._ZERO, !1)
            }

            static intersectsRayAndPoint(ray, point) {
                Vector3.subtract(ray.origin, point, CollisionUtils._tempV30);
                var b = Vector3.dot(CollisionUtils._tempV30, ray.direction),
                    c = Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - MathUtils3D.zeroTolerance;
                return !(c > 0 && b > 0) && !(b * b - c < 0)
            }

            static intersectsRayAndRay(ray1, ray2, out) {
                var ray1o = ray1.origin, ray1oeX = ray1o.x, ray1oeY = ray1o.y, ray1oeZ = ray1o.z,
                    ray1d = ray1.direction, ray1deX = ray1d.x, ray1deY = ray1d.y, ray1deZ = ray1d.z,
                    ray2o = ray2.origin, ray2oeX = ray2o.x, ray2oeY = ray2o.y, ray2oeZ = ray2o.z,
                    ray2d = ray2.direction, ray2deX = ray2d.x, ray2deY = ray2d.y, ray2deZ = ray2d.z;
                Vector3.cross(ray1d, ray2d, CollisionUtils._tempV30);
                var tempV3 = CollisionUtils._tempV30, denominator = Vector3.scalarLength(CollisionUtils._tempV30);
                if (MathUtils3D.isZero(denominator) && MathUtils3D.nearEqual(ray2oeX, ray1oeX) && MathUtils3D.nearEqual(ray2oeY, ray1oeY) && MathUtils3D.nearEqual(ray2oeZ, ray1oeZ)) return !0;
                denominator *= denominator;
                var m11 = ray2oeX - ray1oeX, m12 = ray2oeY - ray1oeY, m13 = ray2oeZ - ray1oeZ, m21 = ray2deX,
                    m22 = ray2deY, m23 = ray2deZ, m31 = tempV3.x, m32 = tempV3.y, m33 = tempV3.z,
                    dets = m11 * m22 * m33 + m12 * m23 * m31 + m13 * m21 * m32 - m11 * m23 * m32 - m12 * m21 * m33 - m13 * m22 * m31;
                m21 = ray1deX, m22 = ray1deY, m23 = ray1deZ;
                var s = dets / denominator;
                Vector3.scale(ray1d, s, CollisionUtils._tempV30), Vector3.scale(ray2d, s, CollisionUtils._tempV31), Vector3.add(ray1o, CollisionUtils._tempV30, CollisionUtils._tempV32), Vector3.add(ray2o, CollisionUtils._tempV31, CollisionUtils._tempV33);
                var point1e = CollisionUtils._tempV32, point2e = CollisionUtils._tempV33;
                return !!(MathUtils3D.nearEqual(point2e.x, point1e.x) && MathUtils3D.nearEqual(point2e.y, point1e.y) && MathUtils3D.nearEqual(point2e.z, point1e.z))
            }

            static intersectsPlaneAndTriangle(plane, vertex1, vertex2, vertex3) {
                var test1 = CollisionUtils.intersectsPlaneAndPoint(plane, vertex1),
                    test2 = CollisionUtils.intersectsPlaneAndPoint(plane, vertex2),
                    test3 = CollisionUtils.intersectsPlaneAndPoint(plane, vertex3);
                return test1 == Plane.PlaneIntersectionType_Front && test2 == Plane.PlaneIntersectionType_Front && test3 == Plane.PlaneIntersectionType_Front ? Plane.PlaneIntersectionType_Front : test1 == Plane.PlaneIntersectionType_Back && test2 == Plane.PlaneIntersectionType_Back && test3 == Plane.PlaneIntersectionType_Back ? Plane.PlaneIntersectionType_Back : Plane.PlaneIntersectionType_Intersecting
            }

            static intersectsRayAndPlaneRD(ray, plane, out) {
                var planeNor = plane.normal, direction = Vector3.dot(planeNor, ray.direction);
                if (MathUtils3D.isZero(direction)) return 0, !1;
                var position = Vector3.dot(planeNor, ray.origin);
                return !((-plane.distance - position) / direction < 0) || (0, !1)
            }

            static intersectsRayAndPlaneRP(ray, plane, out) {
                return !!CollisionUtils.intersectsRayAndPlaneRD(ray, plane, void 0) && (Vector3.scale(ray.direction, void 0, CollisionUtils._tempV30), Vector3.add(ray.origin, CollisionUtils._tempV30, CollisionUtils._tempV31), !0)
            }

            static intersectsRayAndBoxRD(ray, box) {
                var rayoe = ray.origin, rayoeX = rayoe.x, rayoeY = rayoe.y, rayoeZ = rayoe.z, rayde = ray.direction,
                    raydeX = rayde.x, raydeY = rayde.y, raydeZ = rayde.z, boxMine = box.min, boxMineX = boxMine.x,
                    boxMineY = boxMine.y, boxMineZ = boxMine.z, boxMaxe = box.max, boxMaxeX = boxMaxe.x,
                    boxMaxeY = boxMaxe.y, boxMaxeZ = boxMaxe.z, out = 0, tmax = MathUtils3D.MaxValue;
                if (MathUtils3D.isZero(raydeX)) {
                    if (rayoeX < boxMineX || rayoeX > boxMaxeX) return -1
                } else {
                    var inverse = 1 / raydeX, t1 = (boxMineX - rayoeX) * inverse, t2 = (boxMaxeX - rayoeX) * inverse;
                    if (t1 > t2) {
                        var temp = t1;
                        t1 = t2, t2 = temp
                    }
                    if ((out = Math.max(t1, out)) > (tmax = Math.min(t2, tmax))) return -1
                }
                if (MathUtils3D.isZero(raydeY)) {
                    if (rayoeY < boxMineY || rayoeY > boxMaxeY) return -1
                } else {
                    var inverse1 = 1 / raydeY, t3 = (boxMineY - rayoeY) * inverse1, t4 = (boxMaxeY - rayoeY) * inverse1;
                    if (t3 > t4) {
                        var temp1 = t3;
                        t3 = t4, t4 = temp1
                    }
                    if ((out = Math.max(t3, out)) > (tmax = Math.min(t4, tmax))) return -1
                }
                if (MathUtils3D.isZero(raydeZ)) {
                    if (rayoeZ < boxMineZ || rayoeZ > boxMaxeZ) return -1
                } else {
                    var inverse2 = 1 / raydeZ, t5 = (boxMineZ - rayoeZ) * inverse2, t6 = (boxMaxeZ - rayoeZ) * inverse2;
                    if (t5 > t6) {
                        var temp2 = t5;
                        t5 = t6, t6 = temp2
                    }
                    if ((out = Math.max(t5, out)) > (tmax = Math.min(t6, tmax))) return -1
                }
                return out
            }

            static intersectsRayAndBoxRP(ray, box, out) {
                var distance = CollisionUtils.intersectsRayAndBoxRD(ray, box);
                return -1 === distance ? (Vector3._ZERO.cloneTo(out), distance) : (Vector3.scale(ray.direction, distance, CollisionUtils._tempV30), Vector3.add(ray.origin, CollisionUtils._tempV30, CollisionUtils._tempV31), CollisionUtils._tempV31.cloneTo(out), distance)
            }

            static intersectsRayAndSphereRD(ray, sphere) {
                var sphereR = sphere.radius;
                Vector3.subtract(ray.origin, sphere.center, CollisionUtils._tempV30);
                var b = Vector3.dot(CollisionUtils._tempV30, ray.direction),
                    c = Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - sphereR * sphereR;
                if (c > 0 && b > 0) return -1;
                var discriminant = b * b - c;
                if (discriminant < 0) return -1;
                var distance = -b - Math.sqrt(discriminant);
                return distance < 0 && (distance = 0), distance
            }

            static intersectsRayAndSphereRP(ray, sphere, out) {
                var distance = CollisionUtils.intersectsRayAndSphereRD(ray, sphere);
                return -1 === distance ? (Vector3._ZERO.cloneTo(out), distance) : (Vector3.scale(ray.direction, distance, CollisionUtils._tempV30), Vector3.add(ray.origin, CollisionUtils._tempV30, CollisionUtils._tempV31), CollisionUtils._tempV31.cloneTo(out), distance)
            }

            static intersectsSphereAndTriangle(sphere, vertex1, vertex2, vertex3) {
                var sphereC = sphere.center, sphereR = sphere.radius;
                return CollisionUtils.closestPointPointTriangle(sphereC, vertex1, vertex2, vertex3, CollisionUtils._tempV30), Vector3.subtract(CollisionUtils._tempV30, sphereC, CollisionUtils._tempV31), Vector3.dot(CollisionUtils._tempV31, CollisionUtils._tempV31) <= sphereR * sphereR
            }

            static intersectsPlaneAndPoint(plane, point) {
                var distance = Vector3.dot(plane.normal, point) + plane.distance;
                return distance > 0 ? Plane.PlaneIntersectionType_Front : distance < 0 ? Plane.PlaneIntersectionType_Back : Plane.PlaneIntersectionType_Intersecting
            }

            static intersectsPlaneAndPlane(plane1, plane2) {
                Vector3.cross(plane1.normal, plane2.normal, CollisionUtils._tempV30);
                var denominator = Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV30);
                return !MathUtils3D.isZero(denominator)
            }

            static intersectsPlaneAndPlaneRL(plane1, plane2, line) {
                var plane1nor = plane1.normal, plane2nor = plane2.normal;
                Vector3.cross(plane1nor, plane2nor, CollisionUtils._tempV34);
                var denominator = Vector3.dot(CollisionUtils._tempV34, CollisionUtils._tempV34);
                return !MathUtils3D.isZero(denominator) && (Vector3.scale(plane2nor, plane1.distance, CollisionUtils._tempV30), Vector3.scale(plane1nor, plane2.distance, CollisionUtils._tempV31), Vector3.subtract(CollisionUtils._tempV30, CollisionUtils._tempV31, CollisionUtils._tempV32), Vector3.cross(CollisionUtils._tempV32, CollisionUtils._tempV34, CollisionUtils._tempV33), Vector3.normalize(CollisionUtils._tempV34, CollisionUtils._tempV34), !0)
            }

            static intersectsPlaneAndBox(plane, box) {
                var planeD = plane.distance, planeNor = plane.normal, planeNoreX = planeNor.x, planeNoreY = planeNor.y,
                    planeNoreZ = planeNor.z, boxMine = box.min, boxMineX = boxMine.x, boxMineY = boxMine.y,
                    boxMineZ = boxMine.z, boxMaxe = box.max, boxMaxeX = boxMaxe.x, boxMaxeY = boxMaxe.y,
                    boxMaxeZ = boxMaxe.z;
                CollisionUtils._tempV30.x = planeNoreX > 0 ? boxMineX : boxMaxeX, CollisionUtils._tempV30.y = planeNoreY > 0 ? boxMineY : boxMaxeY, CollisionUtils._tempV30.z = planeNoreZ > 0 ? boxMineZ : boxMaxeZ, CollisionUtils._tempV31.x = planeNoreX > 0 ? boxMaxeX : boxMineX, CollisionUtils._tempV31.y = planeNoreY > 0 ? boxMaxeY : boxMineY, CollisionUtils._tempV31.z = planeNoreZ > 0 ? boxMaxeZ : boxMineZ;
                var distance = Vector3.dot(planeNor, CollisionUtils._tempV30);
                return distance + planeD > 0 ? Plane.PlaneIntersectionType_Front : (distance = Vector3.dot(planeNor, CollisionUtils._tempV31)) + planeD < 0 ? Plane.PlaneIntersectionType_Back : Plane.PlaneIntersectionType_Intersecting
            }

            static intersectsPlaneAndSphere(plane, sphere) {
                var sphereR = sphere.radius, distance = Vector3.dot(plane.normal, sphere.center) + plane.distance;
                return distance > sphereR ? Plane.PlaneIntersectionType_Front : distance < -sphereR ? Plane.PlaneIntersectionType_Back : Plane.PlaneIntersectionType_Intersecting
            }

            static intersectsBoxAndBox(box1, box2) {
                var box1Mine = box1.min, box1Maxe = box1.max, box2Mine = box2.min, box2Maxe = box2.max;
                return !(box1Mine.x > box2Maxe.x || box2Mine.x > box1Maxe.x) && (!(box1Mine.y > box2Maxe.y || box2Mine.y > box1Maxe.y) && !(box1Mine.z > box2Maxe.z || box2Mine.z > box1Maxe.z))
            }

            static intersectsBoxAndSphere(box, sphere) {
                var sphereC = sphere.center, sphereR = sphere.radius;
                return Vector3.Clamp(sphereC, box.min, box.max, CollisionUtils._tempV30), Vector3.distanceSquared(sphereC, CollisionUtils._tempV30) <= sphereR * sphereR
            }

            static intersectsSphereAndSphere(sphere1, sphere2) {
                var radiisum = sphere1.radius + sphere2.radius;
                return Vector3.distanceSquared(sphere1.center, sphere2.center) <= radiisum * radiisum
            }

            static boxContainsPoint(box, point) {
                var boxMine = box.min, boxMaxe = box.max;
                return boxMine.x <= point.x && boxMaxe.x >= point.x && boxMine.y <= point.y && boxMaxe.y >= point.y && boxMine.z <= point.z && boxMaxe.z >= point.z ? ContainmentType.Contains : ContainmentType.Disjoint
            }

            static boxContainsBox(box1, box2) {
                var box1Mine = box1.min, box1MineX = box1Mine.x, box1MineY = box1Mine.y, box1MineZ = box1Mine.z,
                    box1Maxe = box1.max, box1MaxeX = box1Maxe.x, box1MaxeY = box1Maxe.y, box1MaxeZ = box1Maxe.z,
                    box2Mine = box2.min, box2MineX = box2Mine.x, box2MineY = box2Mine.y, box2MineZ = box2Mine.z,
                    box2Maxe = box2.max, box2MaxeX = box2Maxe.x, box2MaxeY = box2Maxe.y, box2MaxeZ = box2Maxe.z;
                return box1MaxeX < box2MineX || box1MineX > box2MaxeX ? ContainmentType.Disjoint : box1MaxeY < box2MineY || box1MineY > box2MaxeY ? ContainmentType.Disjoint : box1MaxeZ < box2MineZ || box1MineZ > box2MaxeZ ? ContainmentType.Disjoint : box1MineX <= box2MineX && box2MaxeX <= box1MaxeX && box1MineY <= box2MineY && box2MaxeY <= box1MaxeY && box1MineZ <= box2MineZ && box2MaxeZ <= box1MaxeZ ? ContainmentType.Contains : ContainmentType.Intersects
            }

            static boxContainsSphere(box, sphere) {
                var boxMin = box.min, boxMineX = boxMin.x, boxMineY = boxMin.y, boxMineZ = boxMin.z, boxMax = box.max,
                    boxMaxeX = boxMax.x, boxMaxeY = boxMax.y, boxMaxeZ = boxMax.z, sphereC = sphere.center,
                    sphereCeX = sphereC.x, sphereCeY = sphereC.y, sphereCeZ = sphereC.z, sphereR = sphere.radius;
                return Vector3.Clamp(sphereC, boxMin, boxMax, CollisionUtils._tempV30), Vector3.distanceSquared(sphereC, CollisionUtils._tempV30) > sphereR * sphereR ? ContainmentType.Disjoint : boxMineX + sphereR <= sphereCeX && sphereCeX <= boxMaxeX - sphereR && boxMaxeX - boxMineX > sphereR && boxMineY + sphereR <= sphereCeY && sphereCeY <= boxMaxeY - sphereR && boxMaxeY - boxMineY > sphereR && boxMineZ + sphereR <= sphereCeZ && sphereCeZ <= boxMaxeZ - sphereR && boxMaxeZ - boxMineZ > sphereR ? ContainmentType.Contains : ContainmentType.Intersects
            }

            static sphereContainsPoint(sphere, point) {
                return Vector3.distanceSquared(point, sphere.center) <= sphere.radius * sphere.radius ? ContainmentType.Contains : ContainmentType.Disjoint
            }

            static sphereContainsTriangle(sphere, vertex1, vertex2, vertex3) {
                var test1 = CollisionUtils.sphereContainsPoint(sphere, vertex1),
                    test2 = CollisionUtils.sphereContainsPoint(sphere, vertex2),
                    test3 = CollisionUtils.sphereContainsPoint(sphere, vertex3);
                return test1 == ContainmentType.Contains && test2 == ContainmentType.Contains && test3 == ContainmentType.Contains ? ContainmentType.Contains : CollisionUtils.intersectsSphereAndTriangle(sphere, vertex1, vertex2, vertex3) ? ContainmentType.Intersects : ContainmentType.Disjoint
            }

            static sphereContainsBox(sphere, box) {
                var sphereC = sphere.center, sphereCeX = sphereC.x, sphereCeY = sphereC.y, sphereCeZ = sphereC.z,
                    sphereR = sphere.radius, boxMin = box.min, boxMineX = boxMin.x, boxMineY = boxMin.y,
                    boxMineZ = boxMin.z, boxMax = box.max, boxMaxeX = boxMax.x, boxMaxeY = boxMax.y,
                    boxMaxeZ = boxMax.z, _tempV30e = CollisionUtils._tempV30;
                _tempV30e.x, _tempV30e.y, _tempV30e.z;
                if (!CollisionUtils.intersectsBoxAndSphere(box, sphere)) return ContainmentType.Disjoint;
                var radiusSquared = sphereR * sphereR;
                return sphereCeX - boxMineX, sphereCeY - boxMaxeY, sphereCeZ - boxMaxeZ, Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared ? ContainmentType.Intersects : (sphereCeX - boxMaxeX, sphereCeY - boxMaxeY, sphereCeZ - boxMaxeZ, Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared ? ContainmentType.Intersects : (sphereCeX - boxMaxeX, sphereCeY - boxMineY, sphereCeZ - boxMaxeZ, Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared ? ContainmentType.Intersects : (sphereCeX - boxMineX, sphereCeY - boxMineY, sphereCeZ - boxMaxeZ, Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared ? ContainmentType.Intersects : (sphereCeX - boxMineX, sphereCeY - boxMaxeY, sphereCeZ - boxMineZ, Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared ? ContainmentType.Intersects : (sphereCeX - boxMaxeX, sphereCeY - boxMaxeY, sphereCeZ - boxMineZ, Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared ? ContainmentType.Intersects : (sphereCeX - boxMaxeX, sphereCeY - boxMineY, sphereCeZ - boxMineZ, Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared ? ContainmentType.Intersects : (sphereCeX - boxMineX, sphereCeY - boxMineY, sphereCeZ - boxMineZ, Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared ? ContainmentType.Intersects : ContainmentType.Contains)))))))
            }

            static sphereContainsSphere(sphere1, sphere2) {
                var sphere1R = sphere1.radius, sphere2R = sphere2.radius,
                    distance = Vector3.distance(sphere1.center, sphere2.center);
                return sphere1R + sphere2R < distance ? ContainmentType.Disjoint : sphere1R - sphere2R < distance ? ContainmentType.Intersects : ContainmentType.Contains
            }

            static closestPointPointTriangle(point, vertex1, vertex2, vertex3, out) {
                Vector3.subtract(vertex2, vertex1, CollisionUtils._tempV30), Vector3.subtract(vertex3, vertex1, CollisionUtils._tempV31), Vector3.subtract(point, vertex1, CollisionUtils._tempV32), Vector3.subtract(point, vertex2, CollisionUtils._tempV33), Vector3.subtract(point, vertex3, CollisionUtils._tempV34);
                var d1 = Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV32),
                    d2 = Vector3.dot(CollisionUtils._tempV31, CollisionUtils._tempV32),
                    d3 = Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV33),
                    d4 = Vector3.dot(CollisionUtils._tempV31, CollisionUtils._tempV33),
                    d5 = Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV34),
                    d6 = Vector3.dot(CollisionUtils._tempV31, CollisionUtils._tempV34);
                if (d1 <= 0 && d2 <= 0) vertex1.cloneTo(out); else if (d3 >= 0 && d4 <= d3) vertex2.cloneTo(out); else {
                    var vc = d1 * d4 - d3 * d2;
                    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                        var v = d1 / (d1 - d3);
                        return Vector3.scale(CollisionUtils._tempV30, v, out), void Vector3.add(vertex1, out, out)
                    }
                    if (d6 >= 0 && d5 <= d6) vertex3.cloneTo(out); else {
                        var vb = d5 * d2 - d1 * d6;
                        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                            var w = d2 / (d2 - d6);
                            return Vector3.scale(CollisionUtils._tempV31, w, out), void Vector3.add(vertex1, out, out)
                        }
                        var va = d3 * d6 - d5 * d4;
                        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
                            var w3 = (d4 - d3) / (d4 - d3 + (d5 - d6));
                            return Vector3.subtract(vertex3, vertex2, out), Vector3.scale(out, w3, out), void Vector3.add(vertex2, out, out)
                        }
                        var denom = 1 / (va + vb + vc), v2 = vb * denom, w2 = vc * denom;
                        Vector3.scale(CollisionUtils._tempV30, v2, CollisionUtils._tempV35), Vector3.scale(CollisionUtils._tempV31, w2, CollisionUtils._tempV36), Vector3.add(CollisionUtils._tempV35, CollisionUtils._tempV36, out), Vector3.add(vertex1, out, out)
                    }
                }
            }

            static closestPointPlanePoint(plane, point, out) {
                var planeN = plane.normal, t = Vector3.dot(planeN, point) - plane.distance;
                Vector3.scale(planeN, t, CollisionUtils._tempV30), Vector3.subtract(point, CollisionUtils._tempV30, out)
            }

            static closestPointBoxPoint(box, point, out) {
                Vector3.max(point, box.min, CollisionUtils._tempV30), Vector3.min(CollisionUtils._tempV30, box.max, out)
            }

            static closestPointSpherePoint(sphere, point, out) {
                var sphereC = sphere.center;
                Vector3.subtract(point, sphereC, out), Vector3.normalize(out, out), Vector3.scale(out, sphere.radius, out), Vector3.add(out, sphereC, out)
            }

            static closestPointSphereSphere(sphere1, sphere2, out) {
                var sphere1C = sphere1.center;
                Vector3.subtract(sphere2.center, sphere1C, out), Vector3.normalize(out, out), Vector3.scale(out, sphere1.radius, out), Vector3.add(out, sphere1C, out)
            }
        }

        CollisionUtils._tempV30 = new Vector3, CollisionUtils._tempV31 = new Vector3, CollisionUtils._tempV32 = new Vector3, CollisionUtils._tempV33 = new Vector3, CollisionUtils._tempV34 = new Vector3, CollisionUtils._tempV35 = new Vector3, CollisionUtils._tempV36 = new Vector3;

        class BoundFrustum {
            constructor(matrix) {
                this._matrix = matrix, this._near = new Plane(new Vector3), this._far = new Plane(new Vector3), this._left = new Plane(new Vector3), this._right = new Plane(new Vector3), this._top = new Plane(new Vector3), this._bottom = new Plane(new Vector3), BoundFrustum._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom)
            }

            get matrix() {
                return this._matrix
            }

            set matrix(matrix) {
                this._matrix = matrix, BoundFrustum._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom)
            }

            get near() {
                return this._near
            }

            get far() {
                return this._far
            }

            get left() {
                return this._left
            }

            get right() {
                return this._right
            }

            get top() {
                return this._top
            }

            get bottom() {
                return this._bottom
            }

            equalsBoundFrustum(other) {
                return this._matrix.equalsOtherMatrix(other.matrix)
            }

            equalsObj(obj) {
                if (obj instanceof BoundFrustum) {
                    var bf = obj;
                    return this.equalsBoundFrustum(bf)
                }
                return !1
            }

            getPlane(index) {
                switch (index) {
                    case 0:
                        return this._near;
                    case 1:
                        return this._far;
                    case 2:
                        return this._left;
                    case 3:
                        return this._right;
                    case 4:
                        return this._top;
                    case 5:
                        return this._bottom;
                    default:
                        return null
                }
            }

            static _getPlanesFromMatrix(m, np, fp, lp, rp, tp, bp) {
                var matrixE = m.elements, m11 = matrixE[0], m12 = matrixE[1], m13 = matrixE[2], m14 = matrixE[3],
                    m21 = matrixE[4], m22 = matrixE[5], m23 = matrixE[6], m24 = matrixE[7], m31 = matrixE[8],
                    m32 = matrixE[9], m33 = matrixE[10], m34 = matrixE[11], m41 = matrixE[12], m42 = matrixE[13],
                    m43 = matrixE[14], m44 = matrixE[15], nearNorE = np.normal;
                nearNorE.x = m14 + m13, nearNorE.y = m24 + m23, nearNorE.z = m34 + m33, np.distance = m44 + m43, np.normalize();
                var farNorE = fp.normal;
                farNorE.x = m14 - m13, farNorE.y = m24 - m23, farNorE.z = m34 - m33, fp.distance = m44 - m43, fp.normalize();
                var leftNorE = lp.normal;
                leftNorE.x = m14 + m11, leftNorE.y = m24 + m21, leftNorE.z = m34 + m31, lp.distance = m44 + m41, lp.normalize();
                var rightNorE = rp.normal;
                rightNorE.x = m14 - m11, rightNorE.y = m24 - m21, rightNorE.z = m34 - m31, rp.distance = m44 - m41, rp.normalize();
                var topNorE = tp.normal;
                topNorE.x = m14 - m12, topNorE.y = m24 - m22, topNorE.z = m34 - m32, tp.distance = m44 - m42, tp.normalize();
                var bottomNorE = bp.normal;
                bottomNorE.x = m14 + m12, bottomNorE.y = m24 + m22, bottomNorE.z = m34 + m32, bp.distance = m44 + m42, bp.normalize()
            }

            static _get3PlaneInterPoint(p1, p2, p3) {
                var p1Nor = p1.normal, p2Nor = p2.normal, p3Nor = p3.normal;
                Vector3.cross(p2Nor, p3Nor, BoundFrustum._tempV30), Vector3.cross(p3Nor, p1Nor, BoundFrustum._tempV31), Vector3.cross(p1Nor, p2Nor, BoundFrustum._tempV32);
                var a = Vector3.dot(p1Nor, BoundFrustum._tempV30), b = Vector3.dot(p2Nor, BoundFrustum._tempV31),
                    c = Vector3.dot(p3Nor, BoundFrustum._tempV32);
                return Vector3.scale(BoundFrustum._tempV30, -p1.distance / a, BoundFrustum._tempV33), Vector3.scale(BoundFrustum._tempV31, -p2.distance / b, BoundFrustum._tempV34), Vector3.scale(BoundFrustum._tempV32, -p3.distance / c, BoundFrustum._tempV35), Vector3.add(BoundFrustum._tempV33, BoundFrustum._tempV34, BoundFrustum._tempV36), Vector3.add(BoundFrustum._tempV35, BoundFrustum._tempV36, BoundFrustum._tempV37), BoundFrustum._tempV37
            }

            getCorners(corners) {
                BoundFrustum._get3PlaneInterPoint(this._near, this._bottom, this._right).cloneTo(corners[0]), BoundFrustum._get3PlaneInterPoint(this._near, this._top, this._right).cloneTo(corners[1]), BoundFrustum._get3PlaneInterPoint(this._near, this._top, this._left).cloneTo(corners[2]), BoundFrustum._get3PlaneInterPoint(this._near, this._bottom, this._left).cloneTo(corners[3]), BoundFrustum._get3PlaneInterPoint(this._far, this._bottom, this._right).cloneTo(corners[4]), BoundFrustum._get3PlaneInterPoint(this._far, this._top, this._right).cloneTo(corners[5]), BoundFrustum._get3PlaneInterPoint(this._far, this._top, this._left).cloneTo(corners[6]), BoundFrustum._get3PlaneInterPoint(this._far, this._bottom, this._left).cloneTo(corners[7])
            }

            containsPoint(point) {
                for (var result = Plane.PlaneIntersectionType_Front, planeResult = Plane.PlaneIntersectionType_Front, i = 0; i < 6; i++) {
                    switch (i) {
                        case 0:
                            planeResult = CollisionUtils.intersectsPlaneAndPoint(this._near, point);
                            break;
                        case 1:
                            planeResult = CollisionUtils.intersectsPlaneAndPoint(this._far, point);
                            break;
                        case 2:
                            planeResult = CollisionUtils.intersectsPlaneAndPoint(this._left, point);
                            break;
                        case 3:
                            planeResult = CollisionUtils.intersectsPlaneAndPoint(this._right, point);
                            break;
                        case 4:
                            planeResult = CollisionUtils.intersectsPlaneAndPoint(this._top, point);
                            break;
                        case 5:
                            planeResult = CollisionUtils.intersectsPlaneAndPoint(this._bottom, point)
                    }
                    switch (planeResult) {
                        case Plane.PlaneIntersectionType_Back:
                            return ContainmentType.Disjoint;
                        case Plane.PlaneIntersectionType_Intersecting:
                            result = Plane.PlaneIntersectionType_Intersecting
                    }
                }
                switch (result) {
                    case Plane.PlaneIntersectionType_Intersecting:
                        return ContainmentType.Intersects;
                    default:
                        return ContainmentType.Contains
                }
            }

            intersects(box) {
                var min = box.min, max = box.max, minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y,
                    maxZ = max.z, nearNormal = this._near.normal;
                if (this._near.distance + nearNormal.x * (nearNormal.x < 0 ? minX : maxX) + nearNormal.y * (nearNormal.y < 0 ? minY : maxY) + nearNormal.z * (nearNormal.z < 0 ? minZ : maxZ) < 0) return !1;
                var leftNormal = this._left.normal;
                if (this._left.distance + leftNormal.x * (leftNormal.x < 0 ? minX : maxX) + leftNormal.y * (leftNormal.y < 0 ? minY : maxY) + leftNormal.z * (leftNormal.z < 0 ? minZ : maxZ) < 0) return !1;
                var rightNormal = this._right.normal;
                if (this._right.distance + rightNormal.x * (rightNormal.x < 0 ? minX : maxX) + rightNormal.y * (rightNormal.y < 0 ? minY : maxY) + rightNormal.z * (rightNormal.z < 0 ? minZ : maxZ) < 0) return !1;
                var bottomNormal = this._bottom.normal;
                if (this._bottom.distance + bottomNormal.x * (bottomNormal.x < 0 ? minX : maxX) + bottomNormal.y * (bottomNormal.y < 0 ? minY : maxY) + bottomNormal.z * (bottomNormal.z < 0 ? minZ : maxZ) < 0) return !1;
                var topNormal = this._top.normal;
                if (this._top.distance + topNormal.x * (topNormal.x < 0 ? minX : maxX) + topNormal.y * (topNormal.y < 0 ? minY : maxY) + topNormal.z * (topNormal.z < 0 ? minZ : maxZ) < 0) return !1;
                var farNormal = this._far.normal;
                return !(this._far.distance + farNormal.x * (farNormal.x < 0 ? minX : maxX) + farNormal.y * (farNormal.y < 0 ? minY : maxY) + farNormal.z * (farNormal.z < 0 ? minZ : maxZ) < 0)
            }

            containsBoundBox(box) {
                for (var p = BoundFrustum._tempV30, n = BoundFrustum._tempV31, boxMin = box.min, boxMax = box.max, result = ContainmentType.Contains, i = 0; i < 6; i++) {
                    var plane = this.getPlane(i), planeNor = plane.normal;
                    if (planeNor.x >= 0 ? (p.x = boxMax.x, n.x = boxMin.x) : (p.x = boxMin.x, n.x = boxMax.x), planeNor.y >= 0 ? (p.y = boxMax.y, n.y = boxMin.y) : (p.y = boxMin.y, n.y = boxMax.y), planeNor.z >= 0 ? (p.z = boxMax.z, n.z = boxMin.z) : (p.z = boxMin.z, n.z = boxMax.z), CollisionUtils.intersectsPlaneAndPoint(plane, p) === Plane.PlaneIntersectionType_Back) return ContainmentType.Disjoint;
                    CollisionUtils.intersectsPlaneAndPoint(plane, n) === Plane.PlaneIntersectionType_Back && (result = ContainmentType.Intersects)
                }
                return result
            }

            containsBoundSphere(sphere) {
                for (var result = Plane.PlaneIntersectionType_Front, planeResult = Plane.PlaneIntersectionType_Front, i = 0; i < 6; i++) {
                    switch (i) {
                        case 0:
                            planeResult = CollisionUtils.intersectsPlaneAndSphere(this._near, sphere);
                            break;
                        case 1:
                            planeResult = CollisionUtils.intersectsPlaneAndSphere(this._far, sphere);
                            break;
                        case 2:
                            planeResult = CollisionUtils.intersectsPlaneAndSphere(this._left, sphere);
                            break;
                        case 3:
                            planeResult = CollisionUtils.intersectsPlaneAndSphere(this._right, sphere);
                            break;
                        case 4:
                            planeResult = CollisionUtils.intersectsPlaneAndSphere(this._top, sphere);
                            break;
                        case 5:
                            planeResult = CollisionUtils.intersectsPlaneAndSphere(this._bottom, sphere)
                    }
                    switch (planeResult) {
                        case Plane.PlaneIntersectionType_Back:
                            return ContainmentType.Disjoint;
                        case Plane.PlaneIntersectionType_Intersecting:
                            result = Plane.PlaneIntersectionType_Intersecting
                    }
                }
                switch (result) {
                    case Plane.PlaneIntersectionType_Intersecting:
                        return ContainmentType.Intersects;
                    default:
                        return ContainmentType.Contains
                }
            }
        }

        BoundFrustum._tempV30 = new Vector3, BoundFrustum._tempV31 = new Vector3, BoundFrustum._tempV32 = new Vector3, BoundFrustum._tempV33 = new Vector3, BoundFrustum._tempV34 = new Vector3, BoundFrustum._tempV35 = new Vector3, BoundFrustum._tempV36 = new Vector3, BoundFrustum._tempV37 = new Vector3;

        class Viewport {
            constructor(x, y, width, height) {
                this.minDepth = 0, this.maxDepth = 1, this.x = x, this.y = y, this.width = width, this.height = height
            }

            project(source, matrix, out) {
                Vector3.transformV3ToV3(source, matrix, out);
                var matrixEleme = matrix.elements,
                    a = source.x * matrixEleme[3] + source.y * matrixEleme[7] + source.z * matrixEleme[11] + matrixEleme[15];
                1 !== a && (out.x = out.x / a, out.y = out.y / a, out.z = out.z / a), out.x = .5 * (out.x + 1) * this.width + this.x, out.y = .5 * (1 - out.y) * this.height + this.y, out.z = out.z * (this.maxDepth - this.minDepth) + this.minDepth
            }

            unprojectFromMat(source, matrix, out) {
                var matrixEleme = matrix.elements;
                out.x = (source.x - this.x) / this.width * 2 - 1, out.y = -((source.y - this.y) / this.height * 2 - 1);
                var halfDepth = (this.maxDepth - this.minDepth) / 2;
                out.z = (source.z - this.minDepth - halfDepth) / halfDepth;
                var a = out.x * matrixEleme[3] + out.y * matrixEleme[7] + out.z * matrixEleme[11] + matrixEleme[15];
                Vector3.transformV3ToV3(out, matrix, out), 1 !== a && (out.x = out.x / a, out.y = out.y / a, out.z = out.z / a)
            }

            unprojectFromWVP(source, projection, view, world, out) {
                Matrix4x4.multiply(projection, view, Viewport._tempMatrix4x4), world && Matrix4x4.multiply(Viewport._tempMatrix4x4, world, Viewport._tempMatrix4x4), Viewport._tempMatrix4x4.invert(Viewport._tempMatrix4x4), this.unprojectFromMat(source, Viewport._tempMatrix4x4, out)
            }

            cloneTo(out) {
                out.x = this.x, out.y = this.y, out.width = this.width, out.height = this.height, out.minDepth = this.minDepth, out.maxDepth = this.maxDepth
            }
        }

        Viewport._tempMatrix4x4 = new Matrix4x4;

        class RenderTexture extends Laya.BaseTexture {
            constructor(width, height, format = Laya.BaseTexture.FORMAT_R8G8B8, depthStencilFormat = Laya.BaseTexture.FORMAT_DEPTH_16) {
                super(format, !1), this._inPool = !1, this._glTextureType = Laya.LayaGL.instance.TEXTURE_2D, this._width = width, this._height = height, this._depthStencilFormat = depthStencilFormat, this._create(width, height)
            }

            static get currentActive() {
                return RenderTexture._currentActive
            }

            static createFromPool(width, height, format = Laya.BaseTexture.FORMAT_R8G8B8, depthStencilFormat = Laya.BaseTexture.FORMAT_DEPTH_16, filterMode = Laya.BaseTexture.FILTERMODE_BILINEAR) {
                for (var tex, i = 0, n = RenderTexture._pool.length; i < n; i++) if ((tex = RenderTexture._pool[i])._width == width && tex._height == height && tex._format == format && tex._depthStencilFormat == depthStencilFormat && tex._filterMode == filterMode) {
                    tex._inPool = !1;
                    var end = RenderTexture._pool[n - 1];
                    return RenderTexture._pool[i] = end, RenderTexture._pool.length -= 1, tex
                }
                return (tex = new RenderTexture(width, height, format, depthStencilFormat)).filterMode = filterMode, tex.lock = !0, tex
            }

            static recoverToPool(renderTexture) {
                renderTexture._inPool || (RenderTexture._pool.push(renderTexture), renderTexture._inPool = !0)
            }

            get depthStencilFormat() {
                return this._depthStencilFormat
            }

            get defaulteTexture() {
                return Laya.Texture2D.grayTexture
            }

            _texImage2D(gl, glTextureType, width, height) {
                switch (this._format) {
                    case Laya.BaseTexture.FORMAT_R8G8B8:
                        gl.texImage2D(glTextureType, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
                        break;
                    case Laya.BaseTexture.FORMAT_R8G8B8A8:
                        gl.texImage2D(glTextureType, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                        break;
                    case Laya.BaseTexture.FORMAT_ALPHA8:
                        gl.texImage2D(glTextureType, 0, gl.ALPHA, width, height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, null);
                        break;
                    case Laya.BaseTexture.RENDERTEXTURE_FORMAT_RGBA_HALF_FLOAT:
                        Laya.LayaGL.layaGPUInstance._isWebGL2 ? gl.texImage2D(this._glTextureType, 0, gl.RGBA16F, width, height, 0, gl.RGBA, gl.HALF_FLOAT, null) : gl.texImage2D(this._glTextureType, 0, gl.RGBA, width, height, 0, gl.RGBA, Laya.LayaGL.layaGPUInstance._oesTextureHalfFloat.HALF_FLOAT_OES, null)
                }
            }

            _create(width, height) {
                var gl = Laya.LayaGL.instance;
                if (this._frameBuffer = gl.createFramebuffer(), Laya.WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture), this._texImage2D(gl, this._glTextureType, width, height), this._setGPUMemory(width * height * 4), gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, 0), this._depthStencilFormat !== Laya.BaseTexture.FORMAT_DEPTHSTENCIL_NONE) switch (this._depthStencilBuffer = gl.createRenderbuffer(), gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthStencilBuffer), this._depthStencilFormat) {
                    case Laya.BaseTexture.FORMAT_DEPTH_16:
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._depthStencilBuffer);
                        break;
                    case Laya.BaseTexture.FORMAT_STENCIL_8:
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, width, height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._depthStencilBuffer);
                        break;
                    case Laya.BaseTexture.FORMAT_DEPTHSTENCIL_16_8:
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._depthStencilBuffer);
                        break;
                    default:
                        throw"RenderTexture: unkonw depth format."
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, null), gl.bindRenderbuffer(gl.RENDERBUFFER, null), this._setWarpMode(gl.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(gl.TEXTURE_WRAP_T, this._wrapModeV), this._setFilterMode(this._filterMode), this._setAnisotropy(this._anisoLevel), this._readyed = !0, this._activeResource()
            }

            _start() {
                var gl = Laya.LayaGL.instance;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer), RenderTexture._currentActive = this, this._readyed = !1
            }

            _end() {
                var gl = Laya.LayaGL.instance;
                gl.bindFramebuffer(gl.FRAMEBUFFER, null), RenderTexture._currentActive = null, this._readyed = !0
            }

            getData(x, y, width, height, out) {
                if (Laya.Render.isConchApp && 2 == window.conchConfig.threadMode) throw"native 2 thread mode use getDataAsync";
                var gl = Laya.LayaGL.instance;
                return gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer), gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE ? (gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, out), gl.bindFramebuffer(gl.FRAMEBUFFER, null), out) : (gl.bindFramebuffer(gl.FRAMEBUFFER, null), null)
            }

            getDataAsync(x, y, width, height, callBack) {
                var gl = Laya.LayaGL.instance;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer), gl.readPixelsAsync(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, function (data) {
                    callBack(new Uint8Array(data))
                }), gl.bindFramebuffer(gl.FRAMEBUFFER, null)
            }

            _disposeResource() {
                if (this._frameBuffer) {
                    var gl = Laya.LayaGL.instance;
                    gl.deleteTexture(this._glTexture), gl.deleteFramebuffer(this._frameBuffer), gl.deleteRenderbuffer(this._depthStencilBuffer), this._glTexture = null, this._frameBuffer = null, this._depthStencilBuffer = null, this._setGPUMemory(0)
                }
            }
        }

        RenderTexture._pool = [];

        class Picker {
            constructor() {
            }

            static calculateCursorRay(point, viewPort, projectionMatrix, viewMatrix, world, out) {
                var x = point.x, y = point.y, nearSource = Picker._tempVector30, nerSourceE = nearSource;
                nerSourceE.x = x, nerSourceE.y = y, nerSourceE.z = viewPort.minDepth;
                var farSource = Picker._tempVector31, farSourceE = farSource;
                farSourceE.x = x, farSourceE.y = y, farSourceE.z = viewPort.maxDepth;
                var nearPoint = out.origin, farPoint = Picker._tempVector32;
                viewPort.unprojectFromWVP(nearSource, projectionMatrix, viewMatrix, world, nearPoint), viewPort.unprojectFromWVP(farSource, projectionMatrix, viewMatrix, world, farPoint);
                var outDire = out.direction;
                outDire.x = farPoint.x - nearPoint.x, outDire.y = farPoint.y - nearPoint.y, outDire.z = farPoint.z - nearPoint.z, Vector3.normalize(out.direction, out.direction)
            }

            static rayIntersectsTriangle(ray, vertex1, vertex2, vertex3) {
                var edge1 = Picker._tempVector30, edge2 = Picker._tempVector31;
                Vector3.subtract(vertex2, vertex1, edge1), Vector3.subtract(vertex3, vertex1, edge2);
                var determinant, directionCrossEdge2 = Picker._tempVector32;
                if (Vector3.cross(ray.direction, edge2, directionCrossEdge2), (determinant = Vector3.dot(edge1, directionCrossEdge2)) > -Number.MIN_VALUE && determinant < Number.MIN_VALUE) return Number.NaN;
                var triangleU, inverseDeterminant = 1 / determinant, distanceVector = Picker._tempVector33;
                if (Vector3.subtract(ray.origin, vertex1, distanceVector), triangleU = Vector3.dot(distanceVector, directionCrossEdge2), (triangleU *= inverseDeterminant) < 0 || triangleU > 1) return Number.NaN;
                var triangleV, rayDistance, distanceCrossEdge1 = Picker._tempVector34;
                return Vector3.cross(distanceVector, edge1, distanceCrossEdge1), triangleV = Vector3.dot(ray.direction, distanceCrossEdge1), (triangleV *= inverseDeterminant) < 0 || triangleU + triangleV > 1 ? Number.NaN : (rayDistance = Vector3.dot(edge2, distanceCrossEdge1), (rayDistance *= inverseDeterminant) < 0 ? Number.NaN : rayDistance)
            }
        }

        Picker._tempVector30 = new Vector3, Picker._tempVector31 = new Vector3, Picker._tempVector32 = new Vector3, Picker._tempVector33 = new Vector3, Picker._tempVector34 = new Vector3;

        class SkyMesh {
            constructor() {
            }

            _render(state) {
            }
        }

        class SkyBox extends SkyMesh {
            static __init__() {
                SkyBox.instance = new SkyBox
            }

            constructor() {
                super();
                var gl = Laya.LayaGL.instance,
                    vertices = new Float32Array([-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1]),
                    indices = new Uint8Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 0, 3, 7, 7, 4, 0, 1, 5, 6, 6, 2, 1, 3, 2, 6, 6, 7, 3, 0, 4, 5, 5, 1, 0]),
                    verDec = VertexMesh.getVertexDeclaration("POSITION");
                this._vertexBuffer = new VertexBuffer3D(8 * verDec.vertexStride, gl.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = verDec, this._indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_UBYTE, 36, gl.STATIC_DRAW, !1), this._vertexBuffer.setData(vertices.buffer), this._indexBuffer.setData(indices);
                var bufferState = new BufferState;
                bufferState.bind(), bufferState.applyVertexBuffer(this._vertexBuffer), bufferState.applyIndexBuffer(this._indexBuffer), bufferState.unBind(), this._bufferState = bufferState
            }

            _render(state) {
                var gl = Laya.LayaGL.instance;
                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_BYTE, 0), Laya.Stat.trianglesFaces += 12, Laya.Stat.renderBatches++
            }
        }

        class SkyRenderer {
            constructor() {
                this._mesh = SkyBox.instance
            }

            get material() {
                return this._material
            }

            set material(value) {
                this._material !== value && (this._material && this._material._removeReference(), value && value._addReference(), this._material = value)
            }

            get mesh() {
                return this._mesh
            }

            set mesh(value) {
                this._mesh !== value && (this._mesh = value)
            }

            _isAvailable() {
                return !(!this._material || !this._mesh)
            }

            _render(state) {
                if (this._material && this._mesh) {
                    var gl = Laya.LayaGL.instance, scene = state.scene, camera = state.camera,
                        noteValue = ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                    Laya.ILaya.Render.supportWebGLPlusRendering && ShaderData.setRuntimeValueMode(!1), Laya.WebGLContext.setCullFace(gl, !1), Laya.WebGLContext.setDepthFunc(gl, gl.LEQUAL), Laya.WebGLContext.setDepthMask(gl, !1);
                    var shader = state.shader = this._material._shader.getSubShaderAt(0)._passes[0].withCompile(0, 0, this._material._shaderValues._defineDatas.value),
                        switchShader = shader.bind(), switchShaderLoop = Laya.Stat.loopCount !== shader._uploadMark,
                        uploadScene = shader._uploadScene !== scene || switchShaderLoop;
                    (uploadScene || switchShader) && (shader.uploadUniforms(shader._sceneUniformParamsMap, scene._shaderValues, uploadScene), shader._uploadScene = scene);
                    var renderTar = camera._renderTexture || camera._offScreenRenderTexture,
                        uploadCamera = shader._uploadCamera !== camera || switchShaderLoop;
                    if (uploadCamera || switchShader) {
                        var viewMatrix = SkyRenderer._tempMatrix0, projectionMatrix = camera.projectionMatrix;
                        camera.transform.worldMatrix.cloneTo(viewMatrix), viewMatrix.transpose(), camera.orthographic && (projectionMatrix = SkyRenderer._tempMatrix1, Matrix4x4.createPerspective(camera.fieldOfView, camera.aspectRatio, camera.nearPlane, camera.farPlane, projectionMatrix)), camera._applyViewProject(state, viewMatrix, projectionMatrix, !!renderTar), shader.uploadUniforms(shader._cameraUniformParamsMap, camera._shaderValues, uploadCamera), shader._uploadCamera = camera
                    }
                    var uploadMaterial = shader._uploadMaterial !== this._material || switchShaderLoop;
                    (uploadMaterial || switchShader) && (shader.uploadUniforms(shader._materialUniformParamsMap, this._material._shaderValues, uploadMaterial), shader._uploadMaterial = this._material), this._mesh._bufferState.bind(), this._mesh._render(state), Laya.ILaya.Render.supportWebGLPlusRendering && ShaderData.setRuntimeValueMode(noteValue), Laya.WebGLContext.setDepthFunc(gl, gl.LESS), Laya.WebGLContext.setDepthMask(gl, !0), camera._applyViewProject(state, camera.viewMatrix, camera.projectionMatrix, !!renderTar)
                }
            }

            destroy() {
                this._material && (this._material._removeReference(), this._material = null)
            }
        }

        SkyRenderer._tempMatrix0 = new Matrix4x4, SkyRenderer._tempMatrix1 = new Matrix4x4;

        class BaseCamera extends Sprite3D {
            constructor(nearPlane = .3, farPlane = 1e3) {
                super(), this._skyRenderer = new SkyRenderer, this._forward = new Vector3, this._up = new Vector3, this.clearColor = new Vector4(100 / 255, 149 / 255, 237 / 255, 1), this._shaderValues = new ShaderData(null), this._fieldOfView = 60, this._useUserProjectionMatrix = !1, this._orthographic = !1, this._orthographicVerticalSize = 10, this.renderingOrder = 0, this._nearPlane = nearPlane, this._farPlane = farPlane, this.cullingMask = 2147483647, this.clearFlag = BaseCamera.CLEARFLAG_SOLIDCOLOR, this.useOcclusionCulling = !0
            }

            get skyRenderer() {
                return this._skyRenderer
            }

            get fieldOfView() {
                return this._fieldOfView
            }

            set fieldOfView(value) {
                this._fieldOfView = value, this._calculateProjectionMatrix()
            }

            get nearPlane() {
                return this._nearPlane
            }

            set nearPlane(value) {
                this._nearPlane = value, this._calculateProjectionMatrix()
            }

            get farPlane() {
                return this._farPlane
            }

            set farPlane(vaule) {
                this._farPlane = vaule, this._calculateProjectionMatrix()
            }

            get orthographic() {
                return this._orthographic
            }

            set orthographic(vaule) {
                this._orthographic = vaule, this._calculateProjectionMatrix()
            }

            get orthographicVerticalSize() {
                return this._orthographicVerticalSize
            }

            set orthographicVerticalSize(vaule) {
                this._orthographicVerticalSize = vaule, this._calculateProjectionMatrix()
            }

            get renderingOrder() {
                return this._renderingOrder
            }

            set renderingOrder(value) {
                this._renderingOrder = value, this._sortCamerasByRenderingOrder()
            }

            _sortCamerasByRenderingOrder() {
                if (this.displayedInStage) for (var cameraPool = this.scene._cameraPool, n = cameraPool.length - 1, i = 0; i < n; i++) if (cameraPool[i].renderingOrder > cameraPool[n].renderingOrder) {
                    var tempCamera = cameraPool[i];
                    cameraPool[i] = cameraPool[n], cameraPool[n] = tempCamera
                }
            }

            _calculateProjectionMatrix() {
            }

            _onScreenSizeChanged() {
                this._calculateProjectionMatrix()
            }

            _prepareCameraToRender() {
                var cameraSV = this._shaderValues;
                this.transform.getForward(this._forward), this.transform.getUp(this._up), cameraSV.setVector3(BaseCamera.CAMERAPOS, this.transform.position), cameraSV.setVector3(BaseCamera.CAMERADIRECTION, this._forward), cameraSV.setVector3(BaseCamera.CAMERAUP, this._up)
            }

            render(shader = null, replacementTag = null) {
            }

            addLayer(layer) {
                this.cullingMask |= Math.pow(2, layer)
            }

            removeLayer(layer) {
                this.cullingMask &= ~Math.pow(2, layer)
            }

            addAllLayers() {
                this.cullingMask = 2147483647
            }

            removeAllLayers() {
                this.cullingMask = 0
            }

            resetProjectionMatrix() {
                this._useUserProjectionMatrix = !1, this._calculateProjectionMatrix()
            }

            _onActive() {
                this._scene._addCamera(this), super._onActive()
            }

            _onInActive() {
                this._scene._removeCamera(this), super._onInActive()
            }

            _parse(data, spriteMap) {
                super._parse(data, spriteMap);
                var clearFlagData = data.clearFlag;
                void 0 !== clearFlagData && (this.clearFlag = clearFlagData), this.orthographic = data.orthographic, void 0 !== data.orthographicVerticalSize && (this.orthographicVerticalSize = data.orthographicVerticalSize), void 0 !== data.fieldOfView && (this.fieldOfView = data.fieldOfView), this.nearPlane = data.nearPlane, this.farPlane = data.farPlane;
                var color = data.clearColor;
                this.clearColor = new Vector4(color[0], color[1], color[2], color[3]);
                var skyboxMaterial = data.skyboxMaterial;
                skyboxMaterial && (this._skyRenderer.material = Laya.Loader.getRes(skyboxMaterial.path))
            }

            destroy(destroyChild = !0) {
                this._skyRenderer.destroy(), this._skyRenderer = null, Laya.Laya.stage.off(Laya.Event.RESIZE, this, this._onScreenSizeChanged), super.destroy(destroyChild)
            }

            _create() {
                return new BaseCamera
            }
        }

        BaseCamera._tempMatrix4x40 = new Matrix4x4, BaseCamera.CAMERAPOS = Shader3D.propertyNameToID("u_CameraPos"), BaseCamera.VIEWMATRIX = Shader3D.propertyNameToID("u_View"), BaseCamera.PROJECTMATRIX = Shader3D.propertyNameToID("u_Projection"), BaseCamera.VIEWPROJECTMATRIX = Shader3D.propertyNameToID("u_ViewProjection"), BaseCamera.CAMERADIRECTION = Shader3D.propertyNameToID("u_CameraDirection"), BaseCamera.CAMERAUP = Shader3D.propertyNameToID("u_CameraUp"), BaseCamera.RENDERINGTYPE_DEFERREDLIGHTING = "DEFERREDLIGHTING", BaseCamera.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING", BaseCamera.CLEARFLAG_SOLIDCOLOR = 0, BaseCamera.CLEARFLAG_SKY = 1, BaseCamera.CLEARFLAG_DEPTHONLY = 2, BaseCamera.CLEARFLAG_NONE = 3, BaseCamera._invertYScaleMatrix = new Matrix4x4(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), BaseCamera._invertYProjectionMatrix = new Matrix4x4, BaseCamera._invertYProjectionViewMatrix = new Matrix4x4;

        class RenderContext3D {
            constructor() {
            }
        }

        RenderContext3D._instance = new RenderContext3D;

        class ScreenQuad extends Laya.Resource {
            constructor() {
                super(), this._bufferState = new BufferState, this._bufferStateInvertUV = new BufferState;
                var gl = Laya.LayaGL.instance;
                this._vertexBuffer = new VertexBuffer3D(64, gl.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = ScreenQuad._vertexDeclaration, this._vertexBuffer.setData(ScreenQuad._vertices.buffer), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.unBind(), this._vertexBufferInvertUV = new VertexBuffer3D(64, gl.STATIC_DRAW, !1), this._vertexBufferInvertUV.vertexDeclaration = ScreenQuad._vertexDeclaration, this._vertexBufferInvertUV.setData(ScreenQuad._verticesInvertUV.buffer), this._bufferStateInvertUV.bind(), this._bufferStateInvertUV.applyVertexBuffer(this._vertexBufferInvertUV), this._bufferStateInvertUV.unBind(), this._setGPUMemory(this._vertexBuffer._byteLength + this._vertexBufferInvertUV._byteLength)
            }

            static __init__() {
                ScreenQuad._vertexDeclaration = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, ScreenQuad.SCREENQUAD_POSITION_UV)]), ScreenQuad.instance = new ScreenQuad, ScreenQuad.instance.lock = !0
            }

            render() {
                var gl = Laya.LayaGL.instance;
                this._bufferState.bind(), gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4), Laya.Stat.renderBatches++
            }

            renderInvertUV() {
                var gl = Laya.LayaGL.instance;
                this._bufferStateInvertUV.bind(), gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4), Laya.Stat.renderBatches++
            }

            destroy() {
                super.destroy(), this._bufferState.destroy(), this._vertexBuffer.destroy(), this._bufferStateInvertUV.destroy(), this._vertexBufferInvertUV.destroy(), this._setGPUMemory(0)
            }
        }

        ScreenQuad.SCREENQUAD_POSITION_UV = 0, ScreenQuad._vertices = new Float32Array([1, 1, 1, 0, 1, -1, 1, 1, -1, 1, 0, 0, -1, -1, 0, 1]), ScreenQuad._verticesInvertUV = new Float32Array([1, 1, 1, 1, 1, -1, 1, 0, -1, 1, 0, 1, -1, -1, 0, 0]);

        class ScreenTriangle extends Laya.Resource {
            constructor() {
                super(), this._bufferState = new BufferState, this._bufferStateInvertUV = new BufferState;
                var gl = Laya.LayaGL.instance;
                this._vertexBuffer = new VertexBuffer3D(48, gl.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = ScreenTriangle._vertexDeclaration, this._vertexBuffer.setData(ScreenTriangle._vertices.buffer), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.unBind(), this._vertexBufferInvertUV = new VertexBuffer3D(48, gl.STATIC_DRAW, !1), this._vertexBufferInvertUV.vertexDeclaration = ScreenTriangle._vertexDeclaration, this._vertexBufferInvertUV.setData(ScreenTriangle._verticesInvertUV.buffer), this._bufferStateInvertUV.bind(), this._bufferStateInvertUV.applyVertexBuffer(this._vertexBufferInvertUV), this._bufferStateInvertUV.unBind(), this._setGPUMemory(this._vertexBuffer._byteLength + this._vertexBufferInvertUV._byteLength)
            }

            static __init__() {
                ScreenTriangle._vertexDeclaration = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, ScreenTriangle.SCREENTRIANGLE_POSITION_UV)]), ScreenTriangle.instance = new ScreenTriangle, ScreenTriangle.instance.lock = !0
            }

            render() {
                var gl = Laya.LayaGL.instance;
                this._bufferState.bind(), gl.drawArrays(gl.TRIANGLES, 0, 3), Laya.Stat.renderBatches++
            }

            renderInvertUV() {
                var gl = Laya.LayaGL.instance;
                this._bufferStateInvertUV.bind(), gl.drawArrays(gl.TRIANGLES, 0, 3), Laya.Stat.renderBatches++
            }

            destroy() {
                super.destroy(), this._bufferState.destroy(), this._vertexBuffer.destroy(), this._bufferStateInvertUV.destroy(), this._vertexBufferInvertUV.destroy(), this._setGPUMemory(0)
            }
        }

        ScreenTriangle.SCREENTRIANGLE_POSITION_UV = 0, ScreenTriangle._vertices = new Float32Array([-1, -1, 0, 1, -1, 3, 0, -1, 3, -1, 2, 1]), ScreenTriangle._verticesInvertUV = new Float32Array([-1, -1, 0, 0, -1, 3, 0, 2, 3, -1, 2, 0]);

        class Command {
            constructor() {
                this._commandBuffer = null
            }

            static __init__() {
                Command._screenShaderData = new ShaderData, Command._screenShader = Shader3D.find("BlitScreen")
            }

            run() {
            }

            recover() {
                this._commandBuffer = null
            }
        }

        Command.SCREENTEXTURE_NAME = "u_MainTex", Command.MAINTEXTURE_TEXELSIZE_NAME = "u_MainTex_TexelSize", Command.SCREENTEXTURE_ID = Shader3D.propertyNameToID(Command.SCREENTEXTURE_NAME), Command.MAINTEXTURE_TEXELSIZE_ID = Shader3D.propertyNameToID(Command.MAINTEXTURE_TEXELSIZE_NAME);

        class BlitScreenQuadCMD extends Command {
            constructor() {
                super(...arguments), this._source = null, this._dest = null, this._shader = null, this._shaderData = null, this._subShader = 0, this._sourceTexelSize = new Vector4, this._screenType = 0
            }

            static create(source, dest, shader = null, shaderData = null, subShader = 0, screenType = BlitScreenQuadCMD._SCREENTYPE_QUAD) {
                var cmd;
                return (cmd = BlitScreenQuadCMD._pool.length > 0 ? BlitScreenQuadCMD._pool.pop() : new BlitScreenQuadCMD)._source = source, cmd._dest = dest, cmd._shader = shader, cmd._shaderData = shaderData, cmd._subShader = subShader, cmd._screenType = screenType, cmd
            }

            run() {
                var shader = this._shader || Command._screenShader,
                    shaderData = this._shaderData || Command._screenShaderData, dest = this._dest;
                Laya.LayaGL.instance.viewport(0, 0, dest ? dest.width : RenderContext3D.clientWidth, dest ? dest.height : RenderContext3D.clientHeight), shaderData.setTexture(Command.SCREENTEXTURE_ID, this._source), this._sourceTexelSize.setValue(1 / this._source.width, 1 / this._source.height, this._source.width, this._source.height), shaderData.setVector(Command.MAINTEXTURE_TEXELSIZE_ID, this._sourceTexelSize), dest && dest._start();
                for (var passes = shader.getSubShaderAt(this._subShader)._passes, i = 0, n = passes.length; i < n; i++) {
                    var shaderPass = passes[i].withCompile(0, 0, shaderData._defineDatas.value);
                    switch (shaderPass.bind(), shaderPass.uploadUniforms(shaderPass._materialUniformParamsMap, shaderData, !0), shaderPass.uploadRenderStateBlendDepth(shaderData), shaderPass.uploadRenderStateFrontFace(shaderData, !1, null), this._screenType) {
                        case BlitScreenQuadCMD._SCREENTYPE_QUAD:
                            dest ? ScreenQuad.instance.renderInvertUV() : ScreenQuad.instance.render();
                            break;
                        case BlitScreenQuadCMD._SCREENTYPE_TRIANGLE:
                            dest ? ScreenTriangle.instance.renderInvertUV() : ScreenTriangle.instance.render()
                    }
                }
                dest && dest._end()
            }

            recover() {
                BlitScreenQuadCMD._pool.push(this), this._dest = null, this._shader = null, this._shaderData = null, super.recover()
            }
        }

        BlitScreenQuadCMD._SCREENTYPE_QUAD = 0, BlitScreenQuadCMD._SCREENTYPE_TRIANGLE = 1, BlitScreenQuadCMD._pool = [];

        class SetRenderTargetCMD extends Command {
            constructor() {
                super(...arguments), this._renderTexture = null
            }

            static create(renderTexture) {
                var cmd;
                return (cmd = SetRenderTargetCMD._pool.length > 0 ? SetRenderTargetCMD._pool.pop() : new SetRenderTargetCMD)._renderTexture = renderTexture, cmd
            }

            run() {
                this._renderTexture._start()
            }

            recover() {
                SetRenderTargetCMD._pool.push(this), this._renderTexture = null
            }
        }

        SetRenderTargetCMD._pool = [];

        class SetShaderDataTextureCMD extends Command {
            constructor() {
                super(...arguments), this._shaderData = null, this._nameID = 0, this._texture = null
            }

            static create(shaderData, nameID, texture) {
                var cmd;
                return (cmd = SetShaderDataTextureCMD._pool.length > 0 ? SetShaderDataTextureCMD._pool.pop() : new SetShaderDataTextureCMD)._shaderData = shaderData, cmd._nameID = nameID, cmd._texture = texture, cmd
            }

            run() {
                this._shaderData.setTexture(this._nameID, this._texture)
            }

            recover() {
                SetShaderDataTextureCMD._pool.push(this), this._shaderData = null, this._nameID = 0, this._texture = null
            }
        }

        SetShaderDataTextureCMD._pool = [];

        class CommandBuffer {
            constructor() {
                this._camera = null, this._commands = []
            }

            _apply() {
                for (var i = 0, n = this._commands.length; i < n; i++) this._commands[i].run()
            }

            setShaderDataTexture(shaderData, nameID, source) {
                this._commands.push(SetShaderDataTextureCMD.create(shaderData, nameID, source))
            }

            blitScreenQuad(source, dest, shader = null, shaderData = null, subShader = 0) {
                this._commands.push(BlitScreenQuadCMD.create(source, dest, shader, shaderData, subShader, BlitScreenQuadCMD._SCREENTYPE_QUAD))
            }

            blitScreenTriangle(source, dest, shader = null, shaderData = null, subShader = 0) {
                this._commands.push(BlitScreenQuadCMD.create(source, dest, shader, shaderData, subShader, BlitScreenQuadCMD._SCREENTYPE_TRIANGLE))
            }

            setRenderTarget(renderTexture) {
                this._commands.push(SetRenderTargetCMD.create(renderTexture))
            }

            clear() {
                for (var i = 0, n = this._commands.length; i < n; i++) this._commands[i].recover();
                this._commands.length = 0
            }
        }

        class Scene3DShaderDeclaration {
        }

        class Camera extends BaseCamera {
            constructor(aspectRatio = 0, nearPlane = .3, farPlane = 1e3) {
                super(nearPlane, farPlane), this._updateViewMatrix = !0, this._offScreenRenderTexture = null, this._postProcess = null, this._enableHDR = !1, this._renderTexture = null, this._postProcessCommandBuffers = [], this.enableRender = !0, this._viewMatrix = new Matrix4x4, this._projectionMatrix = new Matrix4x4, this._projectionViewMatrix = new Matrix4x4, this._viewport = new Viewport(0, 0, 0, 0), this._normalizedViewport = new Viewport(0, 0, 1, 1), this._aspectRatio = aspectRatio, this._boundFrustum = new BoundFrustum(Matrix4x4.DEFAULT), Laya.Render.supportWebGLPlusCulling && (this._boundFrustumBuffer = new Float32Array(24)), this._calculateProjectionMatrix(), Laya.Laya.stage.on(Laya.Event.RESIZE, this, this._onScreenSizeChanged), this.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onTransformChanged)
            }

            get aspectRatio() {
                if (0 === this._aspectRatio) {
                    var vp = this.viewport;
                    return vp.width / vp.height
                }
                return this._aspectRatio
            }

            set aspectRatio(value) {
                if (value < 0) throw new Error("Camera: the aspect ratio has to be a positive real number.");
                this._aspectRatio = value, this._calculateProjectionMatrix()
            }

            get viewport() {
                return this._offScreenRenderTexture ? this._calculationViewport(this._normalizedViewport, this._offScreenRenderTexture.width, this._offScreenRenderTexture.height) : this._calculationViewport(this._normalizedViewport, RenderContext3D.clientWidth, RenderContext3D.clientHeight), this._viewport
            }

            set viewport(value) {
                var width, height;
                this._offScreenRenderTexture ? (width = this._offScreenRenderTexture.width, height = this._offScreenRenderTexture.height) : (width = RenderContext3D.clientWidth, height = RenderContext3D.clientHeight), this._normalizedViewport.x = value.x / width, this._normalizedViewport.y = value.y / height, this._normalizedViewport.width = value.width / width, this._normalizedViewport.height = value.height / height, this._calculationViewport(this._normalizedViewport, width, height), this._calculateProjectionMatrix()
            }

            get normalizedViewport() {
                return this._normalizedViewport
            }

            set normalizedViewport(value) {
                var width, height;
                this._offScreenRenderTexture ? (width = this._offScreenRenderTexture.width, height = this._offScreenRenderTexture.height) : (width = RenderContext3D.clientWidth, height = RenderContext3D.clientHeight), this._normalizedViewport !== value && value.cloneTo(this._normalizedViewport), this._calculationViewport(value, width, height), this._calculateProjectionMatrix()
            }

            get viewMatrix() {
                if (this._updateViewMatrix) {
                    var scale = this.transform.getWorldLossyScale(), scaleX = scale.x, scaleY = scale.y,
                        scaleZ = scale.z, viewMatE = this._viewMatrix.elements;
                    this.transform.worldMatrix.cloneTo(this._viewMatrix), viewMatE[0] /= scaleX, viewMatE[1] /= scaleX, viewMatE[2] /= scaleX, viewMatE[4] /= scaleY, viewMatE[5] /= scaleY, viewMatE[6] /= scaleY, viewMatE[8] /= scaleZ, viewMatE[9] /= scaleZ, viewMatE[10] /= scaleZ, this._viewMatrix.invert(this._viewMatrix), this._updateViewMatrix = !1
                }
                return this._viewMatrix
            }

            get projectionMatrix() {
                return this._projectionMatrix
            }

            set projectionMatrix(value) {
                this._projectionMatrix = value, this._useUserProjectionMatrix = !0
            }

            get projectionViewMatrix() {
                return Matrix4x4.multiply(this.projectionMatrix, this.viewMatrix, this._projectionViewMatrix), this._projectionViewMatrix
            }

            get boundFrustum() {
                if (this._boundFrustum.matrix = this.projectionViewMatrix, Laya.Render.supportWebGLPlusCulling) {
                    var near = this._boundFrustum.near, far = this._boundFrustum.far, left = this._boundFrustum.left,
                        right = this._boundFrustum.right, top = this._boundFrustum.top,
                        bottom = this._boundFrustum.bottom, nearNE = near.normal, farNE = far.normal,
                        leftNE = left.normal, rightNE = right.normal, topNE = top.normal, bottomNE = bottom.normal,
                        buffer = this._boundFrustumBuffer;
                    buffer[0] = nearNE.x, buffer[1] = nearNE.y, buffer[2] = nearNE.z, buffer[3] = near.distance, buffer[4] = farNE.x, buffer[5] = farNE.y, buffer[6] = farNE.z, buffer[7] = far.distance, buffer[8] = leftNE.x, buffer[9] = leftNE.y, buffer[10] = leftNE.z, buffer[11] = left.distance, buffer[12] = rightNE.x, buffer[13] = rightNE.y, buffer[14] = rightNE.z, buffer[15] = right.distance, buffer[16] = topNE.x, buffer[17] = topNE.y, buffer[18] = topNE.z, buffer[19] = top.distance, buffer[20] = bottomNE.x, buffer[21] = bottomNE.y, buffer[22] = bottomNE.z, buffer[23] = bottom.distance
                }
                return this._boundFrustum
            }

            get renderTarget() {
                return this._offScreenRenderTexture
            }

            set renderTarget(value) {
                this._offScreenRenderTexture !== value && (this._offScreenRenderTexture = value, this._calculateProjectionMatrix())
            }

            get postProcess() {
                return this._postProcess
            }

            set postProcess(value) {
                this._postProcess = value;
                var postProcessCommandBuffer = new CommandBuffer;
                this.addCommandBuffer(Camera.CAMERAEVENT_POSTPROCESS, postProcessCommandBuffer), value._init(this, postProcessCommandBuffer)
            }

            get enableHDR() {
                return this._enableHDR
            }

            set enableHDR(value) {
                this._enableHDR = value
            }

            _isLayerVisible(layer) {
                return 0 != (Math.pow(2, layer) & this.cullingMask)
            }

            _onTransformChanged(flag) {
                (flag &= Transform3D.TRANSFORM_WORLDMATRIX) && (this._updateViewMatrix = !0)
            }

            _calculationViewport(normalizedViewport, width, height) {
                var lx = normalizedViewport.x * width, ly = normalizedViewport.y * height,
                    rx = lx + Math.max(normalizedViewport.width * width, 0),
                    ry = ly + Math.max(normalizedViewport.height * height, 0), ceilLeftX = Math.ceil(lx),
                    ceilLeftY = Math.ceil(ly), floorRightX = Math.floor(rx), floorRightY = Math.floor(ry),
                    pixelLeftX = ceilLeftX - lx >= .5 ? Math.floor(lx) : ceilLeftX,
                    pixelLeftY = ceilLeftY - ly >= .5 ? Math.floor(ly) : ceilLeftY,
                    pixelRightX = rx - floorRightX >= .5 ? Math.ceil(rx) : floorRightX,
                    pixelRightY = ry - floorRightY >= .5 ? Math.ceil(ry) : floorRightY;
                this._viewport.x = pixelLeftX, this._viewport.y = pixelLeftY, this._viewport.width = pixelRightX - pixelLeftX, this._viewport.height = pixelRightY - pixelLeftY
            }

            _parse(data, spriteMap) {
                super._parse(data, spriteMap);
                var viewport = data.viewport;
                this.normalizedViewport = new Viewport(viewport[0], viewport[1], viewport[2], viewport[3]);
                var enableHDR = data.enableHDR;
                void 0 !== enableHDR && (this.enableHDR = enableHDR)
            }

            _calculateProjectionMatrix() {
                if (!this._useUserProjectionMatrix) if (this._orthographic) {
                    var halfWidth = this.orthographicVerticalSize * this.aspectRatio * .5,
                        halfHeight = .5 * this.orthographicVerticalSize;
                    Matrix4x4.createOrthoOffCenter(-halfWidth, halfWidth, -halfHeight, halfHeight, this.nearPlane, this.farPlane, this._projectionMatrix)
                } else Matrix4x4.createPerspective(3.1416 * this.fieldOfView / 180, this.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix)
            }

            _getCanvasHeight() {
                return this._offScreenRenderTexture ? this._offScreenRenderTexture.height : RenderContext3D.clientHeight
            }

            _applyPostProcessCommandBuffers() {
                for (var i = 0, n = this._postProcessCommandBuffers.length; i < n; i++) this._postProcessCommandBuffers[i]._apply()
            }

            _getRenderTextureFormat() {
                return this._enableHDR ? Laya.BaseTexture.RENDERTEXTURE_FORMAT_RGBA_HALF_FLOAT : Laya.BaseTexture.FORMAT_R8G8B8
            }

            render(shader = null, replacementTag = null) {
                if (this._scene) {
                    var createRenderTexture = !(!this._postProcess && !this._enableHDR);
                    createRenderTexture && (this._renderTexture = RenderTexture.createFromPool(RenderContext3D.clientWidth, RenderContext3D.clientHeight, this._getRenderTextureFormat(), Laya.BaseTexture.FORMAT_DEPTH_16, Laya.BaseTexture.FILTERMODE_BILINEAR));
                    var gl = Laya.LayaGL.instance, context = RenderContext3D._instance,
                        scene = context.scene = this._scene;
                    if (scene.parallelSplitShadowMaps[0]) {
                        ShaderData.setRuntimeValueMode(!1);
                        var parallelSplitShadowMap = scene.parallelSplitShadowMaps[0];
                        parallelSplitShadowMap._calcAllLightCameraInfo(this), scene._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_CAST_SHADOW);
                        for (var i = 0, n = parallelSplitShadowMap.shadowMapCount; i < n; i++) {
                            var smCamera = parallelSplitShadowMap.cameras[i];
                            context.camera = smCamera, FrustumCulling.renderObjectCulling(smCamera, scene, context, scene._castShadowRenders, shader, replacementTag);
                            var shadowMap = parallelSplitShadowMap.cameras[i + 1].renderTarget;
                            shadowMap._start(), context.camera = smCamera, context.viewport = smCamera.viewport, smCamera._prepareCameraToRender(), smCamera._applyViewProject(context, smCamera.viewMatrix, smCamera.projectionMatrix, !1), scene._clear(gl, context), scene._opaqueQueue._render(context, !1), shadowMap._end()
                        }
                        scene._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_CAST_SHADOW), ShaderData.setRuntimeValueMode(!0)
                    }
                    context.camera = this, scene._preRenderScript();
                    var renderTar = this._renderTexture || this._offScreenRenderTexture;
                    if (renderTar && renderTar._start(), context.viewport = this.viewport, this._prepareCameraToRender(), this._applyViewProject(context, this.viewMatrix, this._projectionMatrix, !!renderTar), scene._preCulling(context, this, shader, replacementTag), scene._clear(gl, context), scene._renderScene(context), scene._postRenderScript(), renderTar && renderTar._end(), createRenderTexture) {
                        if (this._postProcess) this._postProcess._render(), this._applyPostProcessCommandBuffers(); else if (this._enableHDR) {
                            var blit = BlitScreenQuadCMD.create(this._renderTexture, this._offScreenRenderTexture ? this._offScreenRenderTexture : null);
                            blit.run(), blit.recover()
                        }
                        RenderTexture.recoverToPool(this._renderTexture)
                    }
                }
            }

            _applyViewProject(context, viewMat, proMat, inverseY) {
                var projectView, shaderData = this._shaderValues;
                inverseY ? (Matrix4x4.multiply(BaseCamera._invertYScaleMatrix, proMat, BaseCamera._invertYProjectionMatrix), Matrix4x4.multiply(BaseCamera._invertYProjectionMatrix, viewMat, BaseCamera._invertYProjectionViewMatrix), proMat = BaseCamera._invertYProjectionMatrix, projectView = BaseCamera._invertYProjectionViewMatrix) : (Matrix4x4.multiply(proMat, viewMat, this._projectionViewMatrix), projectView = this._projectionViewMatrix), context.viewMatrix = viewMat, context.projectionMatrix = proMat, context.projectionViewMatrix = projectView, shaderData.setMatrix4x4(BaseCamera.VIEWMATRIX, viewMat), shaderData.setMatrix4x4(BaseCamera.PROJECTMATRIX, proMat), shaderData.setMatrix4x4(BaseCamera.VIEWPROJECTMATRIX, projectView)
            }

            viewportPointToRay(point, out) {
                Picker.calculateCursorRay(point, this.viewport, this._projectionMatrix, this.viewMatrix, null, out)
            }

            normalizedViewportPointToRay(point, out) {
                var finalPoint = Camera._tempVector20, vp = this.viewport;
                finalPoint.x = point.x * vp.width, finalPoint.y = point.y * vp.height, Picker.calculateCursorRay(finalPoint, this.viewport, this._projectionMatrix, this.viewMatrix, null, out)
            }

            worldToViewportPoint(position, out) {
                Matrix4x4.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix), this.viewport.project(position, this._projectionViewMatrix, out), out.x = out.x / Laya.Laya.stage.clientScaleX, out.y = out.y / Laya.Laya.stage.clientScaleY
            }

            worldToNormalizedViewportPoint(position, out) {
                Matrix4x4.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix), this.normalizedViewport.project(position, this._projectionViewMatrix, out), out.x = out.x / Laya.Laya.stage.clientScaleX, out.y = out.y / Laya.Laya.stage.clientScaleY
            }

            convertScreenCoordToOrthographicCoord(source, out) {
                if (this._orthographic) {
                    var clientWidth = RenderContext3D.clientWidth, clientHeight = RenderContext3D.clientHeight,
                        ratioX = this.orthographicVerticalSize * this.aspectRatio / clientWidth,
                        ratioY = this.orthographicVerticalSize / clientHeight;
                    return out.x = (-clientWidth / 2 + source.x) * ratioX, out.y = (clientHeight / 2 - source.y) * ratioY, out.z = (this.nearPlane - this.farPlane) * (source.z + 1) / 2 - this.nearPlane, Vector3.transformCoordinate(out, this.transform.worldMatrix, out), !0
                }
                return !1
            }

            destroy(destroyChild = !0) {
                this._offScreenRenderTexture = null, this.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onTransformChanged), super.destroy(destroyChild)
            }

            addCommandBuffer(event, commandBuffer) {
                switch (event) {
                    case Camera.CAMERAEVENT_POSTPROCESS:
                        this._postProcessCommandBuffers.push(commandBuffer), commandBuffer._camera = this;
                        break;
                    default:
                        throw"Camera:unknown event."
                }
            }

            removeCommandBuffer(event, commandBuffer) {
                switch (event) {
                    case Camera.CAMERAEVENT_POSTPROCESS:
                        var index = this._postProcessCommandBuffers.indexOf(commandBuffer);
                        -1 !== index && this._postProcessCommandBuffers.splice(index, 1);
                        break;
                    default:
                        throw"Camera:unknown event."
                }
            }

            removeCommandBuffers(event) {
                switch (event) {
                    case Camera.CAMERAEVENT_POSTPROCESS:
                        this._postProcessCommandBuffers.length = 0;
                        break;
                    default:
                        throw"Camera:unknown event."
                }
            }

            _create() {
                return new Camera
            }
        }

        Camera.CAMERAEVENT_POSTPROCESS = 0, Camera._tempVector20 = new Vector2, Camera._updateMark = 0;

        class RenderElement {
            constructor() {
                this.renderSubShader = null, this.renderType = RenderElement.RENDERTYPE_NORMAL
            }

            getInvertFront() {
                return this._transform._isFrontFaceInvert
            }

            setTransform(transform) {
                this._transform = transform
            }

            setGeometry(geometry) {
                this._geometry = geometry
            }

            addToOpaqueRenderQueue(context, queue) {
                queue.elements.add(this)
            }

            addToTransparentRenderQueue(context, queue) {
                queue.elements.add(this), queue.lastTransparentBatched = !1, queue.lastTransparentRenderElement = this
            }

            _update(scene, context, customShader, replacementTag) {
                if (this.material) {
                    var subShader = this.material._shader.getSubShaderAt(0);
                    if (this.renderSubShader = null, customShader) if (replacementTag) {
                        var oriTag = subShader.getFlag(replacementTag);
                        if (!oriTag) return;
                        for (var customSubShaders = customShader._subShaders, k = 0, p = customSubShaders.length; k < p; k++) {
                            var customSubShader = customSubShaders[k];
                            if (oriTag === customSubShader.getFlag(replacementTag)) {
                                this.renderSubShader = customSubShader;
                                break
                            }
                        }
                        if (!this.renderSubShader) return
                    } else this.renderSubShader = customShader.getSubShaderAt(0); else this.renderSubShader = subShader;
                    var renderQueue = scene._getRenderQueue(this.material.renderQueue);
                    renderQueue.isTransparent ? this.addToTransparentRenderQueue(context, renderQueue) : this.addToOpaqueRenderQueue(context, renderQueue)
                }
            }

            _render(context, isTarget) {
                var lastStateMaterial, lastStateShaderInstance, lastStateRender, updateMark = Camera._updateMark,
                    scene = context.scene, camera = context.camera, transform = this._transform,
                    geometry = this._geometry;
                context.renderElement = this;
                var updateRender = updateMark !== this.render._updateMark || this.renderType !== this.render._updateRenderType;
                if (updateRender && (this.render._renderUpdate(context, transform), this.render._renderUpdateWithCamera(context, transform), this.render._updateMark = updateMark, this.render._updateRenderType = this.renderType), geometry._prepareRender(context)) for (var passes = this.renderSubShader._passes, j = 0, m = passes.length; j < m; j++) {
                    var shaderPass = context.shader = passes[j].withCompile(scene._shaderValues._defineDatas.value & ~this.material._disablePublicDefineDatas.value, this.render._shaderValues._defineDatas.value, this.material._shaderValues._defineDatas.value),
                        switchShader = shaderPass.bind(), switchUpdateMark = updateMark !== shaderPass._uploadMark,
                        uploadScene = shaderPass._uploadScene !== scene || switchUpdateMark;
                    (uploadScene || switchShader) && (shaderPass.uploadUniforms(shaderPass._sceneUniformParamsMap, scene._shaderValues, uploadScene), shaderPass._uploadScene = scene);
                    var uploadSprite3D = shaderPass._uploadRender !== this.render || shaderPass._uploadRenderType !== this.renderType || switchUpdateMark;
                    (uploadSprite3D || switchShader) && (shaderPass.uploadUniforms(shaderPass._spriteUniformParamsMap, this.render._shaderValues, uploadSprite3D), shaderPass._uploadRender = this.render, shaderPass._uploadRenderType = this.renderType);
                    var uploadCamera = shaderPass._uploadCamera !== camera || switchUpdateMark;
                    (uploadCamera || switchShader) && (shaderPass.uploadUniforms(shaderPass._cameraUniformParamsMap, camera._shaderValues, uploadCamera), shaderPass._uploadCamera = camera);
                    var uploadMaterial = shaderPass._uploadMaterial !== this.material || switchUpdateMark;
                    (uploadMaterial || switchShader) && (shaderPass.uploadUniforms(shaderPass._materialUniformParamsMap, this.material._shaderValues, uploadMaterial), shaderPass._uploadMaterial = this.material);
                    var matValues = this.material._shaderValues;
                    lastStateMaterial !== this.material || lastStateShaderInstance !== shaderPass ? (shaderPass.uploadRenderStateBlendDepth(matValues), shaderPass.uploadRenderStateFrontFace(matValues, isTarget, this.getInvertFront()), lastStateMaterial = this.material, lastStateShaderInstance = shaderPass, lastStateRender = this.render) : lastStateRender !== this.render && (shaderPass.uploadRenderStateFrontFace(matValues, isTarget, this.getInvertFront()), lastStateRender = this.render), geometry._render(context), shaderPass._uploadMark = updateMark
                }
                updateRender && this.renderType !== RenderElement.RENDERTYPE_NORMAL && this.render._revertBatchRenderUpdate(context), Camera._updateMark++
            }

            destroy() {
                this._transform = null, this._geometry = null, this.material = null, this.render = null
            }
        }

        RenderElement.RENDERTYPE_NORMAL = 0, RenderElement.RENDERTYPE_STATICBATCH = 1, RenderElement.RENDERTYPE_INSTANCEBATCH = 2, RenderElement.RENDERTYPE_VERTEXBATCH = 3;

        class SubMeshRenderElement extends RenderElement {
            constructor() {
                super(), this._dynamicWorldPositionNormalNeedUpdate = !0
            }

            _onWorldMatrixChanged() {
                this._dynamicWorldPositionNormalNeedUpdate = !0
            }

            _computeWorldPositionsAndNormals(positionOffset, normalOffset, multiSubMesh, vertexCount) {
                if (this._dynamicWorldPositionNormalNeedUpdate) {
                    for (var subMesh = this._geometry, vertexBuffer = subMesh._vertexBuffer, vertexFloatCount = vertexBuffer.vertexDeclaration.vertexStride / 4, oriVertexes = vertexBuffer.getFloat32Data(), worldMat = this._transform.worldMatrix, rotation = this._transform.rotation, indices = subMesh._indices, i = 0; i < vertexCount; i++) {
                        var oriOffset = (multiSubMesh ? indices[i] : i) * vertexFloatCount, bakeOffset = 3 * i;
                        Utils3D.transformVector3ArrayToVector3ArrayCoordinate(oriVertexes, oriOffset + positionOffset, worldMat, this._dynamicWorldPositions, bakeOffset), -1 !== normalOffset && Utils3D.transformVector3ArrayByQuat(oriVertexes, oriOffset + normalOffset, rotation, this._dynamicWorldNormals, bakeOffset)
                    }
                    this._dynamicWorldPositionNormalNeedUpdate = !1
                }
            }

            setTransform(transform) {
                this._transform !== transform && (this._transform && this._transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged), transform && transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged), this._dynamicWorldPositionNormalNeedUpdate = !0, this._transform = transform)
            }

            setGeometry(geometry) {
                if (this._geometry !== geometry) {
                    var subMesh = geometry, mesh = subMesh._mesh;
                    if (mesh) {
                        var multiSubMesh = mesh._subMeshes.length > 1,
                            dynBatVerCount = multiSubMesh ? subMesh._indexCount : mesh._vertexCount;
                        if (dynBatVerCount <= ILaya3D.SubMeshDynamicBatch.maxAllowVertexCount) {
                            var length = 3 * dynBatVerCount;
                            this._dynamicVertexBatch = !0, this._dynamicWorldPositions = new Float32Array(length), this._dynamicWorldNormals = new Float32Array(length), this._dynamicVertexCount = dynBatVerCount, this._dynamicMultiSubMesh = multiSubMesh
                        } else this._dynamicVertexBatch = !1
                    }
                    this._geometry = geometry
                }
            }

            addToOpaqueRenderQueue(context, queue) {
                var subMeshStaticBatch = this.staticBatch, queueElements = queue.elements,
                    elements = queueElements.elements;
                if (subMeshStaticBatch) {
                    var staManager = ILaya3D.MeshRenderStaticBatchManager.instance,
                        staBatchMarks = staManager.getBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, subMeshStaticBatch._batchID);
                    if (staManager._updateCountMark === staBatchMarks.updateMark) {
                        var staBatchIndex = staBatchMarks.indexInList;
                        if (staBatchMarks.batched) elements[staBatchIndex].staticBatchElementList.add(this); else {
                            var staOriElement = elements[staBatchIndex], staOriRender = staOriElement.render,
                                staBatchElement = staManager._getBatchRenderElementFromPool();
                            staBatchElement.renderType = RenderElement.RENDERTYPE_STATICBATCH, staBatchElement.setGeometry(subMeshStaticBatch), staBatchElement.material = staOriElement.material;
                            var staRootOwner = subMeshStaticBatch.batchOwner,
                                staBatchTransform = staRootOwner ? staRootOwner._transform : null;
                            staBatchElement.setTransform(staBatchTransform), staBatchElement.render = staOriRender, staBatchElement.renderSubShader = staOriElement.renderSubShader;
                            var staBatchList = staBatchElement.staticBatchElementList;
                            staBatchList.length = 0, staBatchList.add(staOriElement), staBatchList.add(this), elements[staBatchIndex] = staBatchElement, staBatchMarks.batched = !0
                        }
                    } else staBatchMarks.updateMark = staManager._updateCountMark, staBatchMarks.indexInList = queueElements.length, staBatchMarks.batched = !1, queueElements.add(this)
                } else if (this.renderSubShader._owner._enableInstancing && Laya.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                    var subMesh = this._geometry, insManager = ILaya3D.MeshRenderDynamicBatchManager.instance,
                        insBatchMarks = insManager.getInstanceBatchOpaquaMark(this.render.receiveShadow, this.material.id, subMesh._id, this._transform._isFrontFaceInvert);
                    if (insManager._updateCountMark === insBatchMarks.updateMark) {
                        var insBatchIndex = insBatchMarks.indexInList;
                        if (insBatchMarks.batched) {
                            var instanceBatchElementList = elements[insBatchIndex].instanceBatchElementList;
                            instanceBatchElementList.length === SubMeshInstanceBatch.instance.maxInstanceCount ? (insBatchMarks.updateMark = insManager._updateCountMark, insBatchMarks.indexInList = queueElements.length, insBatchMarks.batched = !1, queueElements.add(this)) : instanceBatchElementList.add(this)
                        } else {
                            var insOriElement = elements[insBatchIndex], insOriRender = insOriElement.render,
                                insBatchElement = insManager._getBatchRenderElementFromPool();
                            insBatchElement.renderType = RenderElement.RENDERTYPE_INSTANCEBATCH, insBatchElement.setGeometry(SubMeshInstanceBatch.instance), insBatchElement.material = insOriElement.material, insBatchElement.setTransform(null), insBatchElement.render = insOriRender, insBatchElement.instanceSubMesh = subMesh, insBatchElement.renderSubShader = insOriElement.renderSubShader;
                            var insBatchList = insBatchElement.instanceBatchElementList;
                            insBatchList.length = 0, insBatchList.add(insOriElement), insBatchList.add(this), elements[insBatchIndex] = insBatchElement, insBatchMarks.batched = !0
                        }
                    } else insBatchMarks.updateMark = insManager._updateCountMark, insBatchMarks.indexInList = queueElements.length, insBatchMarks.batched = !1, queueElements.add(this)
                } else if (this._dynamicVertexBatch) {
                    var verDec = this._geometry._vertexBuffer.vertexDeclaration,
                        dynManager = ILaya3D.MeshRenderDynamicBatchManager.instance,
                        dynBatchMarks = dynManager.getVertexBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, verDec.id);
                    if (dynManager._updateCountMark === dynBatchMarks.updateMark) {
                        var dynBatchIndex = dynBatchMarks.indexInList;
                        if (dynBatchMarks.batched) elements[dynBatchIndex].vertexBatchElementList.add(this); else {
                            var dynOriElement = elements[dynBatchIndex], dynOriRender = dynOriElement.render,
                                dynBatchElement = dynManager._getBatchRenderElementFromPool();
                            dynBatchElement.renderType = RenderElement.RENDERTYPE_VERTEXBATCH, dynBatchElement.setGeometry(ILaya3D.SubMeshDynamicBatch.instance), dynBatchElement.material = dynOriElement.material, dynBatchElement.setTransform(null), dynBatchElement.render = dynOriRender, dynBatchElement.vertexBatchVertexDeclaration = verDec, dynBatchElement.renderSubShader = dynOriElement.renderSubShader;
                            var dynBatchList = dynBatchElement.vertexBatchElementList;
                            dynBatchList.length = 0, dynBatchList.add(dynOriElement), dynBatchList.add(this), elements[dynBatchIndex] = dynBatchElement, dynBatchMarks.batched = !0
                        }
                    } else dynBatchMarks.updateMark = dynManager._updateCountMark, dynBatchMarks.indexInList = queueElements.length, dynBatchMarks.batched = !1, queueElements.add(this)
                } else queueElements.add(this)
            }

            addToTransparentRenderQueue(context, queue) {
                var subMeshStaticBatch = this.staticBatch, queueElements = queue.elements,
                    elements = queueElements.elements;
                if (subMeshStaticBatch) {
                    var staManager = ILaya3D.MeshRenderStaticBatchManager.instance,
                        staLastElement = queue.lastTransparentRenderElement;
                    if (staLastElement) {
                        var staLastRender = staLastElement.render;
                        if (staLastElement._geometry._getType() !== this._geometry._getType() || staLastElement.staticBatch !== subMeshStaticBatch || staLastElement.material !== this.material || staLastRender.receiveShadow !== this.render.receiveShadow || staLastRender.lightmapIndex !== this.render.lightmapIndex) queueElements.add(this), queue.lastTransparentBatched = !1; else {
                            if (queue.lastTransparentBatched) elements[queueElements.length - 1].staticBatchElementList.add(this); else {
                                var staBatchElement = staManager._getBatchRenderElementFromPool();
                                staBatchElement.renderType = RenderElement.RENDERTYPE_STATICBATCH, staBatchElement.setGeometry(subMeshStaticBatch), staBatchElement.material = staLastElement.material;
                                var staRootOwner = subMeshStaticBatch.batchOwner,
                                    staBatchTransform = staRootOwner ? staRootOwner._transform : null;
                                staBatchElement.setTransform(staBatchTransform), staBatchElement.render = this.render, staBatchElement.renderSubShader = staLastElement.renderSubShader;
                                var staBatchList = staBatchElement.staticBatchElementList;
                                staBatchList.length = 0, staBatchList.add(staLastElement), staBatchList.add(this), elements[queueElements.length - 1] = staBatchElement
                            }
                            queue.lastTransparentBatched = !0
                        }
                    } else queueElements.add(this), queue.lastTransparentBatched = !1
                } else if (this.renderSubShader._owner._enableInstancing && Laya.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                    var subMesh = this._geometry, insManager = ILaya3D.MeshRenderDynamicBatchManager.instance,
                        insLastElement = queue.lastTransparentRenderElement;
                    if (insLastElement) {
                        var insLastRender = insLastElement.render;
                        if (insLastElement._geometry._getType() !== this._geometry._getType() || insLastElement._geometry !== subMesh || insLastElement.material !== this.material || insLastRender.receiveShadow !== this.render.receiveShadow) queueElements.add(this), queue.lastTransparentBatched = !1; else if (queue.lastTransparentBatched) {
                            var instanceBatchElementList = elements[queueElements.length - 1].instanceBatchElementList;
                            instanceBatchElementList.length === SubMeshInstanceBatch.instance.maxInstanceCount ? (queueElements.add(this), queue.lastTransparentBatched = !1) : (instanceBatchElementList.add(this), queue.lastTransparentBatched = !0)
                        } else {
                            var insBatchElement = insManager._getBatchRenderElementFromPool();
                            insBatchElement.renderType = RenderElement.RENDERTYPE_INSTANCEBATCH, insBatchElement.setGeometry(SubMeshInstanceBatch.instance), insBatchElement.material = insLastElement.material, insBatchElement.setTransform(null), insBatchElement.render = this.render, insBatchElement.instanceSubMesh = subMesh, insBatchElement.renderSubShader = insLastElement.renderSubShader;
                            var insBatchList = insBatchElement.instanceBatchElementList;
                            insBatchList.length = 0, insBatchList.add(insLastElement), insBatchList.add(this), elements[queueElements.length - 1] = insBatchElement, queue.lastTransparentBatched = !0
                        }
                    } else queueElements.add(this), queue.lastTransparentBatched = !1
                } else if (this._dynamicVertexBatch) {
                    var verDec = this._geometry._vertexBuffer.vertexDeclaration,
                        dynManager = ILaya3D.MeshRenderDynamicBatchManager.instance,
                        dynLastElement = queue.lastTransparentRenderElement;
                    if (dynLastElement) {
                        var dynLastRender = dynLastElement.render;
                        if (dynLastElement._geometry._getType() !== this._geometry._getType() || dynLastElement._geometry._vertexBuffer._vertexDeclaration !== verDec || dynLastElement.material !== this.material || dynLastRender.receiveShadow !== this.render.receiveShadow || dynLastRender.lightmapIndex !== this.render.lightmapIndex) queueElements.add(this), queue.lastTransparentBatched = !1; else {
                            if (queue.lastTransparentBatched) elements[queueElements.length - 1].vertexBatchElementList.add(this); else {
                                var dynBatchElement = dynManager._getBatchRenderElementFromPool();
                                dynBatchElement.renderType = RenderElement.RENDERTYPE_VERTEXBATCH, dynBatchElement.setGeometry(ILaya3D.SubMeshDynamicBatch.instance), dynBatchElement.material = dynLastElement.material, dynBatchElement.setTransform(null), dynBatchElement.render = this.render, dynBatchElement.vertexBatchVertexDeclaration = verDec, dynBatchElement.renderSubShader = dynLastElement.renderSubShader;
                                var dynBatchList = dynBatchElement.vertexBatchElementList;
                                dynBatchList.length = 0, dynBatchList.add(dynLastElement), dynBatchList.add(this), elements[queueElements.length - 1] = dynBatchElement
                            }
                            queue.lastTransparentBatched = !0
                        }
                    } else queueElements.add(this), queue.lastTransparentBatched = !1
                } else queueElements.add(this);
                queue.lastTransparentRenderElement = this
            }

            getInvertFront() {
                switch (this.renderType) {
                    case RenderElement.RENDERTYPE_NORMAL:
                        return this._transform._isFrontFaceInvert;
                    case RenderElement.RENDERTYPE_STATICBATCH:
                    case RenderElement.RENDERTYPE_VERTEXBATCH:
                        return !1;
                    case RenderElement.RENDERTYPE_INSTANCEBATCH:
                        return this.instanceBatchElementList.elements[0]._transform._isFrontFaceInvert;
                    default:
                        throw"SubMeshRenderElement: unknown renderType"
                }
            }

            destroy() {
                super.destroy(), this._dynamicWorldPositions = null, this._dynamicWorldNormals = null, this.staticBatch = null, this.staticBatchElementList = null, this.vertexBatchElementList = null, this.vertexBatchVertexDeclaration = null
            }
        }

        class SingletonList {
            constructor() {
                this.elements = [], this.length = 0
            }

            _add(element) {
                this.length === this.elements.length ? this.elements.push(element) : this.elements[this.length] = element
            }

            add(element) {
                this.length === this.elements.length ? this.elements.push(element) : this.elements[this.length] = element, this.length++
            }
        }

        class MeshRenderDynamicBatchManager extends DynamicBatchManager {
            constructor() {
                super(), this._instanceBatchOpaqueMarks = [], this._vertexBatchOpaqueMarks = [], this._cacheBufferStates = [], this._updateCountMark = 0
            }

            getInstanceBatchOpaquaMark(receiveShadow, materialID, subMeshID, invertFace) {
                var instanceReceiveShadowMarks = this._instanceBatchOpaqueMarks[receiveShadow ? 0 : 1] || (this._instanceBatchOpaqueMarks[receiveShadow ? 0 : 1] = []),
                    instanceMaterialMarks = instanceReceiveShadowMarks[materialID] || (instanceReceiveShadowMarks[materialID] = []),
                    instancSubMeshMarks = instanceMaterialMarks[subMeshID] || (instanceMaterialMarks[subMeshID] = []);
                return instancSubMeshMarks[invertFace ? 1 : 0] || (instancSubMeshMarks[invertFace ? 1 : 0] = new BatchMark)
            }

            getVertexBatchOpaquaMark(lightMapIndex, receiveShadow, materialID, verDecID) {
                var dynLightMapMarks = this._vertexBatchOpaqueMarks[lightMapIndex] || (this._vertexBatchOpaqueMarks[lightMapIndex] = []),
                    dynReceiveShadowMarks = dynLightMapMarks[receiveShadow ? 0 : 1] || (dynLightMapMarks[receiveShadow ? 0 : 1] = []),
                    dynMaterialMarks = dynReceiveShadowMarks[materialID] || (dynReceiveShadowMarks[materialID] = []);
                return dynMaterialMarks[verDecID] || (dynMaterialMarks[verDecID] = new BatchMark)
            }

            _getBufferState(vertexDeclaration) {
                var bufferState = this._cacheBufferStates[vertexDeclaration.id];
                if (!bufferState) {
                    var instance = SubMeshDynamicBatch.instance;
                    (bufferState = new BufferState).bind();
                    var vertexBuffer = instance._vertexBuffer;
                    vertexBuffer.vertexDeclaration = vertexDeclaration, bufferState.applyVertexBuffer(vertexBuffer), bufferState.applyIndexBuffer(instance._indexBuffer), bufferState.unBind(), this._cacheBufferStates[vertexDeclaration.id] = bufferState
                }
                return bufferState
            }

            _getBatchRenderElementFromPool() {
                var renderElement = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
                return renderElement || (renderElement = new SubMeshRenderElement, this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = renderElement, renderElement.vertexBatchElementList = new SingletonList, renderElement.instanceBatchElementList = new SingletonList), renderElement
            }

            _clear() {
                super._clear(), this._updateCountMark++
            }
        }

        MeshRenderDynamicBatchManager.instance = new MeshRenderDynamicBatchManager;

        class SubMeshStaticBatch extends GeometryElement {
            constructor(batchOwner, number, vertexDeclaration) {
                super(), this._bufferState = new BufferState, this._batchID = SubMeshStaticBatch._batchIDCounter++, this._batchElements = [], this._currentBatchVertexCount = 0, this._currentBatchIndexCount = 0, this._vertexDeclaration = vertexDeclaration, this.batchOwner = batchOwner, this.number = number
            }

            _getStaticBatchBakedVertexs(batchVertices, batchOffset, batchOwnerTransform, transform, render, mesh) {
                var worldMat, vertexBuffer = mesh._vertexBuffer, vertexDeclaration = vertexBuffer.vertexDeclaration,
                    positionOffset = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_POSITION0)._offset / 4,
                    normalElement = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_NORMAL0),
                    normalOffset = normalElement ? normalElement._offset / 4 : -1,
                    colorElement = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_COLOR0),
                    colorOffset = colorElement ? colorElement._offset / 4 : -1,
                    uv0Element = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TEXTURECOORDINATE0),
                    uv0Offset = uv0Element ? uv0Element._offset / 4 : -1,
                    uv1Element = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TEXTURECOORDINATE1),
                    uv1Offset = uv1Element ? uv1Element._offset / 4 : -1,
                    tangentElement = vertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TANGENT0),
                    sTangentOffset = tangentElement ? tangentElement._offset / 4 : -1,
                    oriVertexFloatCount = vertexDeclaration.vertexStride / 4,
                    oriVertexes = vertexBuffer.getFloat32Data();
                batchOwnerTransform ? (batchOwnerTransform.worldMatrix.invert(SubMeshStaticBatch._tempMatrix4x40), worldMat = SubMeshStaticBatch._tempMatrix4x41, Matrix4x4.multiply(SubMeshStaticBatch._tempMatrix4x40, transform.worldMatrix, worldMat)) : worldMat = transform.worldMatrix;
                var rotation = SubMeshStaticBatch._tempQuaternion0;
                worldMat.decomposeTransRotScale(SubMeshStaticBatch._tempVector30, rotation, SubMeshStaticBatch._tempVector31);
                for (var lightmapScaleOffset = render.lightmapScaleOffset, vertexCount = mesh.vertexCount, i = 0; i < vertexCount; i++) {
                    var j, m, oriOffset = i * oriVertexFloatCount, bakeOffset = 18 * (i + batchOffset);
                    Utils3D.transformVector3ArrayToVector3ArrayCoordinate(oriVertexes, oriOffset + positionOffset, worldMat, batchVertices, bakeOffset + 0), -1 !== normalOffset && Utils3D.transformVector3ArrayByQuat(oriVertexes, oriOffset + normalOffset, rotation, batchVertices, bakeOffset + 3);
                    var bakOff = bakeOffset + 6;
                    if (-1 !== colorOffset) {
                        var oriOff = oriOffset + colorOffset;
                        for (j = 0, m = 4; j < m; j++) batchVertices[bakOff + j] = oriVertexes[oriOff + j]
                    } else for (j = 0, m = 4; j < m; j++) batchVertices[bakOff + j] = 1;
                    if (-1 !== uv0Offset) {
                        var absUv0Offset = oriOffset + uv0Offset;
                        batchVertices[bakeOffset + 10] = oriVertexes[absUv0Offset], batchVertices[bakeOffset + 11] = oriVertexes[absUv0Offset + 1]
                    }
                    if (lightmapScaleOffset && (-1 !== uv1Offset ? Utils3D.transformLightingMapTexcoordArray(oriVertexes, oriOffset + uv1Offset, lightmapScaleOffset, batchVertices, bakeOffset + 12) : Utils3D.transformLightingMapTexcoordArray(oriVertexes, oriOffset + uv0Offset, lightmapScaleOffset, batchVertices, bakeOffset + 12)), -1 !== sTangentOffset) {
                        var absSTanegntOffset = oriOffset + sTangentOffset;
                        batchVertices[bakeOffset + 14] = oriVertexes[absSTanegntOffset], batchVertices[bakeOffset + 15] = oriVertexes[absSTanegntOffset + 1], batchVertices[bakeOffset + 16] = oriVertexes[absSTanegntOffset + 2], batchVertices[bakeOffset + 17] = oriVertexes[absSTanegntOffset + 3]
                    }
                }
                return vertexCount
            }

            addTest(sprite) {
                var subMeshVertexCount = sprite.meshFilter.sharedMesh.vertexCount;
                return !(this._currentBatchVertexCount + subMeshVertexCount > SubMeshStaticBatch.maxBatchVertexCount)
            }

            add(sprite) {
                var oldStaticBatch = sprite._render._staticBatch;
                oldStaticBatch && oldStaticBatch.remove(sprite);
                var mesh = sprite.meshFilter.sharedMesh, subMeshVertexCount = mesh.vertexCount;
                this._batchElements.push(sprite);
                var render = sprite._render;
                render._isPartOfStaticBatch = !0, render._staticBatch = this;
                for (var renderElements = render._renderElements, i = 0, n = renderElements.length; i < n; i++) renderElements[i].staticBatch = this;
                this._currentBatchIndexCount += mesh._indexBuffer.indexCount, this._currentBatchVertexCount += subMeshVertexCount
            }

            remove(sprite) {
                var mesh = sprite.meshFilter.sharedMesh, index = this._batchElements.indexOf(sprite);
                if (-1 !== index) {
                    this._batchElements.splice(index, 1);
                    sprite._render;
                    for (var renderElements = sprite._render._renderElements, i = 0, n = renderElements.length; i < n; i++) renderElements[i].staticBatch = null;
                    var meshVertexCount = mesh.vertexCount;
                    this._currentBatchIndexCount = this._currentBatchIndexCount - mesh._indexBuffer.indexCount, this._currentBatchVertexCount = this._currentBatchVertexCount - meshVertexCount, sprite._render._isPartOfStaticBatch = !1
                }
            }

            finishInit() {
                this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer.destroy(), Laya.Resource._addGPUMemory(-(this._vertexBuffer._byteLength + this._indexBuffer._byteLength)));
                var gl = Laya.LayaGL.instance, batchVertexCount = 0, batchIndexCount = 0, rootOwner = this.batchOwner,
                    floatStride = this._vertexDeclaration.vertexStride / 4,
                    vertexDatas = new Float32Array(floatStride * this._currentBatchVertexCount),
                    indexDatas = new Uint16Array(this._currentBatchIndexCount);
                this._vertexBuffer = new VertexBuffer3D(this._vertexDeclaration.vertexStride * this._currentBatchVertexCount, gl.STATIC_DRAW), this._vertexBuffer.vertexDeclaration = this._vertexDeclaration, this._indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, this._currentBatchIndexCount, gl.STATIC_DRAW);
                for (var i = 0, n = this._batchElements.length; i < n; i++) {
                    for (var k, sprite = this._batchElements[i], mesh = sprite.meshFilter.sharedMesh, meshVerCount = this._getStaticBatchBakedVertexs(vertexDatas, batchVertexCount, rootOwner ? rootOwner._transform : null, sprite._transform, sprite._render, mesh), indices = mesh._indexBuffer.getData(), indexOffset = batchVertexCount, indexEnd = batchIndexCount + indices.length, elements = sprite._render._renderElements, j = 0, m = mesh.subMeshCount; j < m; j++) {
                        var subMesh = mesh._subMeshes[j], start = batchIndexCount + subMesh._indexStart,
                            element = elements[j];
                        element.staticBatchIndexStart = start, element.staticBatchIndexEnd = start + subMesh._indexCount
                    }
                    if (indexDatas.set(indices, batchIndexCount), rootOwner ? sprite._transform._isFrontFaceInvert !== rootOwner.transform._isFrontFaceInvert : sprite._transform._isFrontFaceInvert) for (k = batchIndexCount; k < indexEnd; k += 3) {
                        indexDatas[k] = indexOffset + indexDatas[k];
                        var index1 = indexDatas[k + 1], index2 = indexDatas[k + 2];
                        indexDatas[k + 1] = indexOffset + index2, indexDatas[k + 2] = indexOffset + index1
                    } else for (k = batchIndexCount; k < indexEnd; k += 3) indexDatas[k] = indexOffset + indexDatas[k], indexDatas[k + 1] = indexOffset + indexDatas[k + 1], indexDatas[k + 2] = indexOffset + indexDatas[k + 2];
                    batchIndexCount += indices.length, batchVertexCount += meshVerCount
                }
                this._vertexBuffer.setData(vertexDatas.buffer), this._indexBuffer.setData(indexDatas);
                var memorySize = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                Laya.Resource._addGPUMemory(memorySize), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind()
            }

            _render(state) {
                this._bufferState.bind();
                for (var gl = Laya.LayaGL.instance, staticBatchElementList = state.renderElement.staticBatchElementList, batchElementList = staticBatchElementList.elements, from = 0, end = 0, count = staticBatchElementList.length, i = 1; i < count; i++) {
                    if (batchElementList[i - 1].staticBatchIndexEnd !== batchElementList[i].staticBatchIndexStart) {
                        var start = batchElementList[from].staticBatchIndexStart,
                            indexCount = batchElementList[end].staticBatchIndexEnd - start;
                        gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 2 * start), from = ++end, Laya.Stat.trianglesFaces += indexCount / 3
                    } else end++
                }
                start = batchElementList[from].staticBatchIndexStart, indexCount = batchElementList[end].staticBatchIndexEnd - start, gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 2 * start), Laya.Stat.renderBatches++, Laya.Stat.savedRenderBatches += count - 1, Laya.Stat.trianglesFaces += indexCount / 3
            }

            dispose() {
                var memorySize = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                Laya.Resource._addGPUMemory(-memorySize), this._batchElements = null, this.batchOwner = null, this._vertexDeclaration = null, this._bufferState.destroy(), this._vertexBuffer.destroy(), this._indexBuffer.destroy(), this._vertexBuffer = null, this._indexBuffer = null, this._bufferState = null
            }
        }

        SubMeshStaticBatch._tempVector30 = new Vector3, SubMeshStaticBatch._tempVector31 = new Vector3, SubMeshStaticBatch._tempQuaternion0 = new Quaternion, SubMeshStaticBatch._tempMatrix4x40 = new Matrix4x4, SubMeshStaticBatch._tempMatrix4x41 = new Matrix4x4, SubMeshStaticBatch.maxBatchVertexCount = 65535, SubMeshStaticBatch._batchIDCounter = 0;

        class MeshRenderStaticBatchManager extends StaticBatchManager {
            constructor() {
                super(), this._opaqueBatchMarks = [], this._updateCountMark = 0
            }

            static __init__() {
                MeshRenderStaticBatchManager._verDec = VertexMesh.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT")
            }

            _compare(left, right) {
                var lRender = left._render, rRender = right._render, leftGeo = left.meshFilter.sharedMesh,
                    rightGeo = right.meshFilter.sharedMesh, lightOffset = lRender.lightmapIndex - rRender.lightmapIndex;
                if (0 === lightOffset) {
                    var receiveShadowOffset = (lRender.receiveShadow ? 1 : 0) - (rRender.receiveShadow ? 1 : 0);
                    if (0 === receiveShadowOffset) {
                        var materialOffset = lRender.sharedMaterial.id - rRender.sharedMaterial.id;
                        if (0 === materialOffset) {
                            var verDec = leftGeo._vertexBuffer.vertexDeclaration.id - rightGeo._vertexBuffer.vertexDeclaration.id;
                            return 0 === verDec ? rightGeo._indexBuffer.indexCount - leftGeo._indexBuffer.indexCount : verDec
                        }
                        return materialOffset
                    }
                    return receiveShadowOffset
                }
                return lightOffset
            }

            _getBatchRenderElementFromPool() {
                var renderElement = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
                return renderElement || (renderElement = new SubMeshRenderElement, this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = renderElement, renderElement.staticBatchElementList = new SingletonList), renderElement
            }

            _getStaticBatch(rootOwner, number) {
                var key = rootOwner ? rootOwner.id : 0, batchOwner = this._staticBatches[key];
                return batchOwner || (batchOwner = this._staticBatches[key] = []), batchOwner[number] || (batchOwner[number] = new SubMeshStaticBatch(rootOwner, number, MeshRenderStaticBatchManager._verDec))
            }

            _initStaticBatchs(rootOwner) {
                this._quickSort(this._initBatchSprites, 0, this._initBatchSprites.length - 1);
                for (var curStaticBatch, lastCanMerage = !1, batchNumber = 0, i = 0, n = this._initBatchSprites.length; i < n; i++) {
                    var sprite = this._initBatchSprites[i];
                    if (lastCanMerage) curStaticBatch.addTest(sprite) ? curStaticBatch.add(sprite) : (lastCanMerage = !1, batchNumber++); else i !== n - 1 && ((curStaticBatch = this._getStaticBatch(rootOwner, batchNumber)).add(sprite), lastCanMerage = !0)
                }
                for (var key in this._staticBatches) {
                    var batches = this._staticBatches[key];
                    for (i = 0, n = batches.length; i < n; i++) batches[i].finishInit()
                }
                this._initBatchSprites.length = 0
            }

            _destroyRenderSprite(sprite) {
                var staticBatch = sprite._render._staticBatch;
                if (staticBatch.remove(sprite), 0 === staticBatch._batchElements.length) {
                    var owner = staticBatch.batchOwner, ownerID = owner ? owner.id : 0,
                        batches = this._staticBatches[ownerID];
                    batches[staticBatch.number] = null, staticBatch.dispose();
                    for (var empty = !0, i = 0; i < batches.length; i++) batches[i] && (empty = !1);
                    empty && delete this._staticBatches[ownerID]
                }
            }

            _clear() {
                super._clear(), this._updateCountMark++
            }

            _garbageCollection() {
                for (var key in this._staticBatches) for (var batches = this._staticBatches[key], i = 0, n = batches.length; i < n; i++) {
                    var staticBatch = batches[i];
                    0 === staticBatch._batchElements.length && (staticBatch.dispose(), batches.splice(i, 1), i--, 0 === --n && delete this._staticBatches[key])
                }
            }

            getBatchOpaquaMark(lightMapIndex, receiveShadow, materialID, staticBatchID) {
                var receiveShadowIndex = receiveShadow ? 1 : 0,
                    staLightMapMarks = this._opaqueBatchMarks[lightMapIndex] || (this._opaqueBatchMarks[lightMapIndex] = []),
                    staReceiveShadowMarks = staLightMapMarks[receiveShadowIndex] || (staLightMapMarks[receiveShadowIndex] = []),
                    staMaterialMarks = staReceiveShadowMarks[materialID] || (staReceiveShadowMarks[materialID] = []);
                return staMaterialMarks[staticBatchID] || (staMaterialMarks[staticBatchID] = new BatchMark)
            }
        }

        MeshRenderStaticBatchManager.instance = new MeshRenderStaticBatchManager;

        class Physics3D {
        }

        Physics3D._physics3D = null, Physics3D._enbalePhysics = !1;

        class Physics3DUtils {
            constructor() {
            }

            static setColliderCollision(collider1, collider2, collsion) {
            }

            static getIColliderCollision(collider1, collider2) {
                return !1
            }
        }

        Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER = 1, Physics3DUtils.COLLISIONFILTERGROUP_STATICFILTER = 2, Physics3DUtils.COLLISIONFILTERGROUP_KINEMATICFILTER = 4, Physics3DUtils.COLLISIONFILTERGROUP_DEBRISFILTER = 8, Physics3DUtils.COLLISIONFILTERGROUP_SENSORTRIGGER = 16, Physics3DUtils.COLLISIONFILTERGROUP_CHARACTERFILTER = 32, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 64, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 128, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 256, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 512, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 1024, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 2048, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 4096, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 8192, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 16384, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 32768, Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER = -1, Physics3DUtils.gravity = new Vector3(0, -9.81, 0);

        class ColliderShape {
            constructor() {
                this._scale = new Vector3(1, 1, 1), this._centerMatrix = new Matrix4x4, this._attatched = !1, this._indexInCompound = -1, this._compoundParent = null, this._attatchedCollisionObject = null, this._referenceCount = 0, this._localOffset = new Vector3(0, 0, 0), this._localRotation = new Quaternion(0, 0, 0, 1), this.needsCustomCollisionCallback = !1
            }

            static __init__() {
                ColliderShape._nativeScale = new Physics3D._physics3D.btVector3(1, 1, 1), ColliderShape._nativeVector30 = new Physics3D._physics3D.btVector3(0, 0, 0), ColliderShape._nativQuaternion0 = new Physics3D._physics3D.btQuaternion(0, 0, 0, 1), ColliderShape._nativeTransform0 = new Physics3D._physics3D.btTransform
            }

            static _createAffineTransformation(trans, rot, outE) {
                var x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2,
                    xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2,
                    wz = w * z2;
                outE[0] = 1 - (yy + zz), outE[1] = xy + wz, outE[2] = xz - wy, outE[3] = 0, outE[4] = xy - wz, outE[5] = 1 - (xx + zz), outE[6] = yz + wx, outE[7] = 0, outE[8] = xz + wy, outE[9] = yz - wx, outE[10] = 1 - (xx + yy), outE[11] = 0, outE[12] = trans.x, outE[13] = trans.y, outE[14] = trans.z, outE[15] = 1
            }

            get type() {
                return this._type
            }

            get localOffset() {
                return this._localOffset
            }

            set localOffset(value) {
                this._localOffset = value, this._compoundParent && this._compoundParent._updateChildTransform(this)
            }

            get localRotation() {
                return this._localRotation
            }

            set localRotation(value) {
                this._localRotation = value, this._compoundParent && this._compoundParent._updateChildTransform(this)
            }

            _setScale(value) {
                this._compoundParent ? this.updateLocalTransformations() : (ColliderShape._nativeScale.setValue(value.x, value.y, value.z), this._nativeShape.setLocalScaling(ColliderShape._nativeScale))
            }

            _addReference() {
                this._referenceCount++
            }

            _removeReference() {
                this._referenceCount--
            }

            updateLocalTransformations() {
                if (this._compoundParent) {
                    var offset = ColliderShape._tempVector30;
                    Vector3.multiply(this.localOffset, this._scale, offset), ColliderShape._createAffineTransformation(offset, this.localRotation, this._centerMatrix.elements)
                } else ColliderShape._createAffineTransformation(this.localOffset, this.localRotation, this._centerMatrix.elements)
            }

            cloneTo(destObject) {
                var destColliderShape = destObject;
                this._localOffset.cloneTo(destColliderShape.localOffset), this._localRotation.cloneTo(destColliderShape.localRotation), destColliderShape.localOffset = destColliderShape.localOffset, destColliderShape.localRotation = destColliderShape.localRotation
            }

            clone() {
                return null
            }

            destroy() {
                this._nativeShape && (Physics3D._physics3D.destroy(this._nativeShape), this._nativeShape = null)
            }
        }

        ColliderShape.SHAPEORIENTATION_UPX = 0, ColliderShape.SHAPEORIENTATION_UPY = 1, ColliderShape.SHAPEORIENTATION_UPZ = 2, ColliderShape.SHAPETYPES_BOX = 0, ColliderShape.SHAPETYPES_SPHERE = 1, ColliderShape.SHAPETYPES_CYLINDER = 2, ColliderShape.SHAPETYPES_CAPSULE = 3, ColliderShape.SHAPETYPES_CONVEXHULL = 4, ColliderShape.SHAPETYPES_COMPOUND = 5, ColliderShape.SHAPETYPES_STATICPLANE = 6, ColliderShape.SHAPETYPES_CONE = 7, ColliderShape._tempVector30 = new Vector3;

        class BoxColliderShape extends ColliderShape {
            static __init__() {
                BoxColliderShape._nativeSize = new Physics3D._physics3D.btVector3(0, 0, 0)
            }

            get sizeX() {
                return this._sizeX
            }

            get sizeY() {
                return this._sizeY
            }

            get sizeZ() {
                return this._sizeZ
            }

            constructor(sizeX = 1, sizeY = 1, sizeZ = 1) {
                super(), this._sizeX = sizeX, this._sizeY = sizeY, this._sizeZ = sizeZ, this._type = ColliderShape.SHAPETYPES_BOX, BoxColliderShape._nativeSize.setValue(sizeX / 2, sizeY / 2, sizeZ / 2), this._nativeShape = new Physics3D._physics3D.btBoxShape(BoxColliderShape._nativeSize)
            }

            clone() {
                var dest = new BoxColliderShape(this._sizeX, this._sizeY, this._sizeZ);
                return this.cloneTo(dest), dest
            }
        }

        class CapsuleColliderShape extends ColliderShape {
            constructor(radius = .5, length = 1.25, orientation = ColliderShape.SHAPEORIENTATION_UPY) {
                switch (super(), this._radius = radius, this._length = length, this._orientation = orientation, this._type = ColliderShape.SHAPETYPES_CAPSULE, orientation) {
                    case ColliderShape.SHAPEORIENTATION_UPX:
                        this._nativeShape = new Physics3D._physics3D.btCapsuleShapeX(radius, length - 2 * radius);
                        break;
                    case ColliderShape.SHAPEORIENTATION_UPY:
                        this._nativeShape = new Physics3D._physics3D.btCapsuleShape(radius, length - 2 * radius);
                        break;
                    case ColliderShape.SHAPEORIENTATION_UPZ:
                        this._nativeShape = new Physics3D._physics3D.btCapsuleShapeZ(radius, length - 2 * radius);
                        break;
                    default:
                        throw"CapsuleColliderShape:unknown orientation."
                }
            }

            get radius() {
                return this._radius
            }

            get length() {
                return this._length
            }

            get orientation() {
                return this._orientation
            }

            _setScale(value) {
                var fixScale = CapsuleColliderShape._tempVector30;
                switch (this.orientation) {
                    case ColliderShape.SHAPEORIENTATION_UPX:
                        fixScale.x = value.x, fixScale.y = fixScale.z = Math.max(value.y, value.z);
                        break;
                    case ColliderShape.SHAPEORIENTATION_UPY:
                        fixScale.y = value.y, fixScale.x = fixScale.z = Math.max(value.x, value.z);
                        break;
                    case ColliderShape.SHAPEORIENTATION_UPZ:
                        fixScale.z = value.z, fixScale.x = fixScale.y = Math.max(value.x, value.y);
                        break;
                    default:
                        throw"CapsuleColliderShape:unknown orientation."
                }
                super._setScale(fixScale)
            }

            clone() {
                var dest = new CapsuleColliderShape(this._radius, this._length, this._orientation);
                return this.cloneTo(dest), dest
            }
        }

        CapsuleColliderShape._tempVector30 = new Vector3;

        class CompoundColliderShape extends ColliderShape {
            constructor() {
                super(), this._childColliderShapes = [], this._type = ColliderShape.SHAPETYPES_COMPOUND, this._nativeShape = new Physics3D._physics3D.btCompoundShape
            }

            static __init__() {
                CompoundColliderShape._nativeVector3One = new Physics3D._physics3D.btVector3(1, 1, 1), CompoundColliderShape._nativeTransform = new Physics3D._physics3D.btTransform, CompoundColliderShape._nativeOffset = new Physics3D._physics3D.btVector3(0, 0, 0), CompoundColliderShape._nativRotation = new Physics3D._physics3D.btQuaternion(0, 0, 0, 1)
            }

            _clearChildShape(shape) {
                shape._attatched = !1, shape._compoundParent = null, shape._indexInCompound = -1
            }

            _addReference() {
            }

            _removeReference() {
            }

            _updateChildTransform(shape) {
                var offset = shape.localOffset, rotation = shape.localRotation,
                    nativeOffset = ColliderShape._nativeVector30, nativeQuaternion = ColliderShape._nativQuaternion0,
                    nativeTransform = ColliderShape._nativeTransform0;
                nativeOffset.setValue(-offset.x, offset.y, offset.z), nativeQuaternion.setValue(-rotation.x, rotation.y, rotation.z, -rotation.w), nativeTransform.setOrigin(nativeOffset), nativeTransform.setRotation(nativeQuaternion), this._nativeShape.updateChildTransform(shape._indexInCompound, nativeTransform, !0)
            }

            addChildShape(shape) {
                if (shape._attatched) throw"CompoundColliderShape: this shape has attatched to other entity.";
                shape._attatched = !0, shape._compoundParent = this, shape._indexInCompound = this._childColliderShapes.length, this._childColliderShapes.push(shape);
                var offset = shape.localOffset, rotation = shape.localRotation;
                CompoundColliderShape._nativeOffset.setValue(-offset.x, offset.y, offset.z), CompoundColliderShape._nativRotation.setValue(-rotation.x, rotation.y, rotation.z, -rotation.w), CompoundColliderShape._nativeTransform.setOrigin(CompoundColliderShape._nativeOffset), CompoundColliderShape._nativeTransform.setRotation(CompoundColliderShape._nativRotation);
                var nativeScale = this._nativeShape.getLocalScaling();
                this._nativeShape.setLocalScaling(CompoundColliderShape._nativeVector3One), this._nativeShape.addChildShape(CompoundColliderShape._nativeTransform, shape._nativeShape), this._nativeShape.setLocalScaling(nativeScale), this._attatchedCollisionObject && (this._attatchedCollisionObject.colliderShape = this)
            }

            removeChildShape(shape) {
                if (shape._compoundParent === this) {
                    var index = shape._indexInCompound;
                    this._clearChildShape(shape);
                    var endShape = this._childColliderShapes[this._childColliderShapes.length - 1];
                    endShape._indexInCompound = index, this._childColliderShapes[index] = endShape, this._childColliderShapes.pop(), this._nativeShape.removeChildShapeByIndex(index)
                }
            }

            clearChildShape() {
                for (var i = 0, n = this._childColliderShapes.length; i < n; i++) this._clearChildShape(this._childColliderShapes[i]), this._nativeShape.removeChildShapeByIndex(0);
                this._childColliderShapes.length = 0
            }

            getChildShapeCount() {
                return this._childColliderShapes.length
            }

            cloneTo(destObject) {
                var destCompoundColliderShape = destObject;
                destCompoundColliderShape.clearChildShape();
                for (var i = 0, n = this._childColliderShapes.length; i < n; i++) destCompoundColliderShape.addChildShape(this._childColliderShapes[i].clone())
            }

            clone() {
                var dest = new CompoundColliderShape;
                return this.cloneTo(dest), dest
            }

            destroy() {
                super.destroy();
                for (var i = 0, n = this._childColliderShapes.length; i < n; i++) {
                    var childShape = this._childColliderShapes[i];
                    0 === childShape._referenceCount && childShape.destroy()
                }
            }
        }

        class ConeColliderShape extends ColliderShape {
            constructor(radius = .5, height = 1, orientation = ColliderShape.SHAPEORIENTATION_UPY) {
                switch (super(), this._radius = 1, this._height = .5, this._radius = radius, this._height = height, this._orientation = orientation, this._type = ColliderShape.SHAPETYPES_CYLINDER, orientation) {
                    case ColliderShape.SHAPEORIENTATION_UPX:
                        this._nativeShape = new Physics3D._physics3D.btConeShapeX(radius, height);
                        break;
                    case ColliderShape.SHAPEORIENTATION_UPY:
                        this._nativeShape = new Physics3D._physics3D.btConeShape(radius, height);
                        break;
                    case ColliderShape.SHAPEORIENTATION_UPZ:
                        this._nativeShape = new Physics3D._physics3D.btConeShapeZ(radius, height);
                        break;
                    default:
                        throw"ConeColliderShape:unknown orientation."
                }
            }

            get radius() {
                return this._radius
            }

            get height() {
                return this._height
            }

            get orientation() {
                return this._orientation
            }

            clone() {
                var dest = new ConeColliderShape(this._radius, this._height, this._orientation);
                return this.cloneTo(dest), dest
            }
        }

        class CylinderColliderShape extends ColliderShape {
            constructor(radius = .5, height = 1, orientation = ColliderShape.SHAPEORIENTATION_UPY) {
                switch (super(), this._radius = 1, this._height = .5, this._radius = radius, this._height = height, this._orientation = orientation, this._type = ColliderShape.SHAPETYPES_CYLINDER, orientation) {
                    case ColliderShape.SHAPEORIENTATION_UPX:
                        CylinderColliderShape._nativeSize.setValue(height / 2, radius, radius), this._nativeShape = new Physics3D._physics3D.btCylinderShapeX(CylinderColliderShape._nativeSize);
                        break;
                    case ColliderShape.SHAPEORIENTATION_UPY:
                        CylinderColliderShape._nativeSize.setValue(radius, height / 2, radius), this._nativeShape = new Physics3D._physics3D.btCylinderShape(CylinderColliderShape._nativeSize);
                        break;
                    case ColliderShape.SHAPEORIENTATION_UPZ:
                        CylinderColliderShape._nativeSize.setValue(radius, radius, height / 2), this._nativeShape = new Physics3D._physics3D.btCylinderShapeZ(CylinderColliderShape._nativeSize);
                        break;
                    default:
                        throw"CapsuleColliderShape:unknown orientation."
                }
            }

            static __init__() {
                CylinderColliderShape._nativeSize = new Physics3D._physics3D.btVector3(0, 0, 0)
            }

            get radius() {
                return this._radius
            }

            get height() {
                return this._height
            }

            get orientation() {
                return this._orientation
            }

            clone() {
                var dest = new CylinderColliderShape(this._radius, this._height, this._orientation);
                return this.cloneTo(dest), dest
            }
        }

        class MeshColliderShape extends ColliderShape {
            constructor() {
                super(), this._mesh = null, this._convex = !1
            }

            get mesh() {
                return this._mesh
            }

            set mesh(value) {
                if (this._mesh !== value) {
                    var physics3D = Physics3D._physics3D;
                    this._mesh && physics3D.destroy(this._nativeShape), value && (this._nativeShape = new Physics3D._physics3D.btGImpactMeshShape(value._getPhysicMesh()), this._nativeShape.updateBound()), this._mesh = value
                }
            }

            get convex() {
                return this._convex
            }

            set convex(value) {
                this._convex = value
            }

            _setScale(value) {
                this._compoundParent ? this.updateLocalTransformations() : (ColliderShape._nativeScale.setValue(value.x, value.y, value.z), this._nativeShape.setLocalScaling(ColliderShape._nativeScale), this._nativeShape.updateBound())
            }

            cloneTo(destObject) {
                var destMeshCollider = destObject;
                destMeshCollider.convex = this._convex, destMeshCollider.mesh = this._mesh, super.cloneTo(destObject)
            }

            clone() {
                var dest = new MeshColliderShape;
                return this.cloneTo(dest), dest
            }

            destroy() {
                this._nativeShape && (Physics3D._physics3D.destroy(this._nativeShape), this._nativeShape = null)
            }
        }

        class SphereColliderShape extends ColliderShape {
            get radius() {
                return this._radius
            }

            constructor(radius = .5) {
                super(), this._radius = radius, this._type = ColliderShape.SHAPETYPES_SPHERE, this._nativeShape = new Physics3D._physics3D.btSphereShape(radius)
            }

            clone() {
                var dest = new SphereColliderShape(this._radius);
                return this.cloneTo(dest), dest
            }
        }

        class PhysicsComponent extends Laya.Component {
            constructor(collisionGroup, canCollideWith) {
                super(), this._restitution = 0, this._friction = .5, this._rollingFriction = 0, this._ccdMotionThreshold = 0, this._ccdSweptSphereRadius = 0, this._collisionGroup = Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER, this._canCollideWith = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, this._colliderShape = null, this._transformFlag = 2147483647, this._enableProcessCollisions = !0, this._inPhysicUpdateListIndex = -1, this.canScaleShape = !0, this._collisionGroup = collisionGroup, this._canCollideWith = canCollideWith, PhysicsComponent._physicObjectsMap[this.id] = this
            }

            static __init__() {
                PhysicsComponent._nativeVector30 = new Physics3D._physics3D.btVector3(0, 0, 0), PhysicsComponent._nativeQuaternion0 = new Physics3D._physics3D.btQuaternion(0, 0, 0, 1)
            }

            static _createAffineTransformationArray(tranX, tranY, tranZ, rotX, rotY, rotZ, rotW, scale, outE) {
                var x2 = rotX + rotX, y2 = rotY + rotY, z2 = rotZ + rotZ, xx = rotX * x2, xy = rotX * y2,
                    xz = rotX * z2, yy = rotY * y2, yz = rotY * z2, zz = rotZ * z2, wx = rotW * x2, wy = rotW * y2,
                    wz = rotW * z2, sx = scale[0], sy = scale[1], sz = scale[2];
                outE[0] = (1 - (yy + zz)) * sx, outE[1] = (xy + wz) * sx, outE[2] = (xz - wy) * sx, outE[3] = 0, outE[4] = (xy - wz) * sy, outE[5] = (1 - (xx + zz)) * sy, outE[6] = (yz + wx) * sy, outE[7] = 0, outE[8] = (xz + wy) * sz, outE[9] = (yz - wx) * sz, outE[10] = (1 - (xx + yy)) * sz, outE[11] = 0, outE[12] = tranX, outE[13] = tranY, outE[14] = tranZ, outE[15] = 1
            }

            static _creatShape(shapeData) {
                var colliderShape;
                switch (shapeData.type) {
                    case"BoxColliderShape":
                        var sizeData = shapeData.size;
                        colliderShape = sizeData ? new BoxColliderShape(sizeData[0], sizeData[1], sizeData[2]) : new BoxColliderShape;
                        break;
                    case"SphereColliderShape":
                        colliderShape = new SphereColliderShape(shapeData.radius);
                        break;
                    case"CapsuleColliderShape":
                        colliderShape = new CapsuleColliderShape(shapeData.radius, shapeData.height, shapeData.orientation);
                        break;
                    case"MeshColliderShape":
                        var meshCollider = new MeshColliderShape;
                        shapeData.mesh && (meshCollider.mesh = Laya.Loader.getRes(shapeData.mesh)), colliderShape = meshCollider;
                        break;
                    case"ConeColliderShape":
                        colliderShape = new ConeColliderShape(shapeData.radius, shapeData.height, shapeData.orientation);
                        break;
                    case"CylinderColliderShape":
                        colliderShape = new CylinderColliderShape(shapeData.radius, shapeData.height, shapeData.orientation);
                        break;
                    default:
                        throw"unknown shape type."
                }
                if (shapeData.center) {
                    var localOffset = colliderShape.localOffset;
                    localOffset.fromArray(shapeData.center), colliderShape.localOffset = localOffset
                }
                return colliderShape
            }

            static physicVector3TransformQuat(source, qx, qy, qz, qw, out) {
                var x = source.x, y = source.y, z = source.z, ix = qw * x + qy * z - qz * y,
                    iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
                out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz, out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx
            }

            static physicQuaternionMultiply(lx, ly, lz, lw, right, out) {
                var rx = right.x, ry = right.y, rz = right.z, rw = right.w, a = ly * rz - lz * ry,
                    b = lz * rx - lx * rz, c = lx * ry - ly * rx, d = lx * rx + ly * ry + lz * rz;
                out.x = lx * rw + rx * lw + a, out.y = ly * rw + ry * lw + b, out.z = lz * rw + rz * lw + c, out.w = lw * rw - d
            }

            get restitution() {
                return this._restitution
            }

            set restitution(value) {
                this._restitution = value, this._nativeColliderObject && this._nativeColliderObject.setRestitution(value)
            }

            get friction() {
                return this._friction
            }

            set friction(value) {
                this._friction = value, this._nativeColliderObject && this._nativeColliderObject.setFriction(value)
            }

            get rollingFriction() {
                return this._nativeColliderObject.getRollingFriction()
            }

            set rollingFriction(value) {
                this._rollingFriction = value, this._nativeColliderObject && this._nativeColliderObject.setRollingFriction(value)
            }

            get ccdMotionThreshold() {
                return this._ccdMotionThreshold
            }

            set ccdMotionThreshold(value) {
                this._ccdMotionThreshold = value, this._nativeColliderObject && this._nativeColliderObject.setCcdMotionThreshold(value)
            }

            get ccdSweptSphereRadius() {
                return this._ccdSweptSphereRadius
            }

            set ccdSweptSphereRadius(value) {
                this._ccdSweptSphereRadius = value, this._nativeColliderObject && this._nativeColliderObject.setCcdSweptSphereRadius(value)
            }

            get isActive() {
                return !!this._nativeColliderObject && this._nativeColliderObject.isActive()
            }

            get enabled() {
                return super.enabled
            }

            set enabled(value) {
                this._enabled != value && (this._simulation && this._colliderShape && (value ? (this._derivePhysicsTransformation(!0), this._addToSimulation()) : this._removeFromSimulation()), super.enabled = value)
            }

            get colliderShape() {
                return this._colliderShape
            }

            set colliderShape(value) {
                var lastColliderShape = this._colliderShape;
                if (lastColliderShape && (lastColliderShape._attatched = !1, lastColliderShape._attatchedCollisionObject = null), this._colliderShape = value, value) {
                    if (value._attatched) throw"PhysicsComponent: this shape has attatched to other entity.";
                    if (value._attatched = !0, value._attatchedCollisionObject = this, this._nativeColliderObject) {
                        this._nativeColliderObject.setCollisionShape(value._nativeShape);
                        var canInSimulation = this._simulation && this._enabled;
                        canInSimulation && lastColliderShape && this._removeFromSimulation(), this._onShapeChange(value), canInSimulation && (this._derivePhysicsTransformation(!0), this._addToSimulation())
                    }
                } else this._simulation && this._enabled && lastColliderShape && this._removeFromSimulation()
            }

            get simulation() {
                return this._simulation
            }

            get collisionGroup() {
                return this._collisionGroup
            }

            set collisionGroup(value) {
                this._collisionGroup !== value && (this._collisionGroup = value, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(), this._addToSimulation()))
            }

            get canCollideWith() {
                return this._canCollideWith
            }

            set canCollideWith(value) {
                this._canCollideWith !== value && (this._canCollideWith = value, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(), this._addToSimulation()))
            }

            _isValid() {
                return this._simulation && this._colliderShape && this._enabled
            }

            _parse(data) {
                null != data.collisionGroup && (this.collisionGroup = data.collisionGroup), null != data.canCollideWith && (this.canCollideWith = data.canCollideWith), null != data.ccdMotionThreshold && (this.ccdMotionThreshold = data.ccdMotionThreshold), null != data.ccdSweptSphereRadius && (this.ccdSweptSphereRadius = data.ccdSweptSphereRadius)
            }

            _parseShape(shapesData) {
                var shapeCount = shapesData.length;
                if (1 === shapeCount) {
                    var shape = PhysicsComponent._creatShape(shapesData[0]);
                    this.colliderShape = shape
                } else {
                    for (var compoundShape = new CompoundColliderShape, i = 0; i < shapeCount; i++) shape = PhysicsComponent._creatShape(shapesData[i]), compoundShape.addChildShape(shape);
                    this.colliderShape = compoundShape
                }
            }

            _onScaleChange(scale) {
                this._colliderShape._setScale(scale)
            }

            _setTransformFlag(type, value) {
                value ? this._transformFlag |= type : this._transformFlag &= ~type
            }

            _getTransformFlag(type) {
                return 0 != (this._transformFlag & type)
            }

            _addToSimulation() {
            }

            _removeFromSimulation() {
            }

            _derivePhysicsTransformation(force) {
                this._innerDerivePhysicsTransformation(this._nativeColliderObject.getWorldTransform(), force)
            }

            _innerDerivePhysicsTransformation(physicTransformOut, force) {
                var transform = this.owner._transform, rotation = transform.rotation;
                if (force || this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                    var shapeOffset = this._colliderShape.localOffset, position = transform.position,
                        nativePosition = PhysicsComponent._nativeVector30;
                    if (0 !== shapeOffset.x || 0 !== shapeOffset.y || 0 !== shapeOffset.z) {
                        var physicPosition = PhysicsComponent._tempVector30;
                        PhysicsComponent.physicVector3TransformQuat(shapeOffset, rotation.x, rotation.y, rotation.z, rotation.w, physicPosition), Vector3.add(position, physicPosition, physicPosition), nativePosition.setValue(-physicPosition.x, physicPosition.y, physicPosition.z)
                    } else nativePosition.setValue(-position.x, position.y, position.z);
                    physicTransformOut.setOrigin(nativePosition), this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, !1)
                }
                if (force || this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION)) {
                    var shapeRotation = this._colliderShape.localRotation,
                        nativeRotation = PhysicsComponent._nativeQuaternion0;
                    if (0 !== shapeRotation.x || 0 !== shapeRotation.y || 0 !== shapeRotation.z || 1 !== shapeRotation.w) {
                        var physicRotation = PhysicsComponent._tempQuaternion0;
                        PhysicsComponent.physicQuaternionMultiply(rotation.x, rotation.y, rotation.z, rotation.w, shapeRotation, physicRotation), nativeRotation.setValue(-physicRotation.x, physicRotation.y, physicRotation.z, -physicRotation.w)
                    } else nativeRotation.setValue(-rotation.x, rotation.y, rotation.z, -rotation.w);
                    physicTransformOut.setRotation(nativeRotation), this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, !1)
                }
                (force || this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) && (this._onScaleChange(transform.getWorldLossyScale()), this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, !1))
            }

            _updateTransformComponent(physicsTransform) {
                var localOffset = this._colliderShape.localOffset, localRotation = this._colliderShape.localRotation,
                    transform = this.owner._transform, position = transform.position, rotation = transform.rotation,
                    nativePosition = physicsTransform.getOrigin(), nativeRotation = physicsTransform.getRotation(),
                    nativeRotX = -nativeRotation.x(), nativeRotY = nativeRotation.y(), nativeRotZ = nativeRotation.z(),
                    nativeRotW = -nativeRotation.w();
                if (0 !== localOffset.x || 0 !== localOffset.y || 0 !== localOffset.z) {
                    var rotShapePosition = PhysicsComponent._tempVector30;
                    PhysicsComponent.physicVector3TransformQuat(localOffset, nativeRotX, nativeRotY, nativeRotZ, nativeRotW, rotShapePosition), position.x = -nativePosition.x() - rotShapePosition.x, position.y = nativePosition.y() - rotShapePosition.y, position.z = nativePosition.z() - rotShapePosition.z
                } else position.x = -nativePosition.x(), position.y = nativePosition.y(), position.z = nativePosition.z();
                if (transform.position = position, 0 !== localRotation.x || 0 !== localRotation.y || 0 !== localRotation.z || 1 !== localRotation.w) {
                    var invertShapeRotaion = PhysicsComponent._tempQuaternion0;
                    localRotation.invert(invertShapeRotaion), PhysicsComponent.physicQuaternionMultiply(nativeRotX, nativeRotY, nativeRotZ, nativeRotW, invertShapeRotaion, rotation)
                } else rotation.x = nativeRotX, rotation.y = nativeRotY, rotation.z = nativeRotZ, rotation.w = nativeRotW;
                transform.rotation = rotation
            }

            _onEnable() {
                this._simulation = this.owner._scene.physicsSimulation, this._nativeColliderObject.setContactProcessingThreshold(1e30), this._colliderShape && this._enabled && (this._derivePhysicsTransformation(!0), this._addToSimulation())
            }

            _onDisable() {
                this._colliderShape && this._enabled && (this._removeFromSimulation(), -1 !== this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.remove(this)), this._simulation = null
            }

            _onShapeChange(colShape) {
                var btColObj = this._nativeColliderObject, flags = btColObj.getCollisionFlags();
                colShape.needsCustomCollisionCallback ? 0 == (flags & PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) && btColObj.setCollisionFlags(flags | PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) : (flags & PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) > 0 && btColObj.setCollisionFlags(flags ^ PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK)
            }

            _onAdded() {
                this.enabled = this._enabled, this.restitution = this._restitution, this.friction = this._friction, this.rollingFriction = this._rollingFriction, this.ccdMotionThreshold = this._ccdMotionThreshold, this.ccdSweptSphereRadius = this._ccdSweptSphereRadius, this.owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onTransformChanged)
            }

            _onDestroy() {
                var physics3D = Physics3D._physics3D;
                delete PhysicsComponent._physicObjectsMap[this.id], physics3D.destroy(this._nativeColliderObject), this._colliderShape.destroy(), super._onDestroy(), this._nativeColliderObject = null, this._colliderShape = null, this._simulation = null, this.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onTransformChanged)
            }

            _onTransformChanged(flag) {
                PhysicsComponent._addUpdateList && (flag &= Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE) && (this._transformFlag |= flag, this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this))
            }

            _cloneTo(dest) {
                var destPhysicsComponent = dest;
                destPhysicsComponent.restitution = this._restitution, destPhysicsComponent.friction = this._friction, destPhysicsComponent.rollingFriction = this._rollingFriction, destPhysicsComponent.ccdMotionThreshold = this._ccdMotionThreshold, destPhysicsComponent.ccdSweptSphereRadius = this._ccdSweptSphereRadius, destPhysicsComponent.collisionGroup = this._collisionGroup, destPhysicsComponent.canCollideWith = this._canCollideWith, destPhysicsComponent.canScaleShape = this.canScaleShape, this._colliderShape && (destPhysicsComponent.colliderShape = this._colliderShape.clone())
            }
        }

        PhysicsComponent.ACTIVATIONSTATE_ACTIVE_TAG = 1, PhysicsComponent.ACTIVATIONSTATE_ISLAND_SLEEPING = 2, PhysicsComponent.ACTIVATIONSTATE_WANTS_DEACTIVATION = 3, PhysicsComponent.ACTIVATIONSTATE_DISABLE_DEACTIVATION = 4, PhysicsComponent.ACTIVATIONSTATE_DISABLE_SIMULATION = 5, PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT = 1, PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT = 2, PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE = 4, PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK = 8, PhysicsComponent.COLLISIONFLAGS_CHARACTER_OBJECT = 16, PhysicsComponent.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT = 32, PhysicsComponent.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING = 64, PhysicsComponent._tempVector30 = new Vector3, PhysicsComponent._tempQuaternion0 = new Quaternion, PhysicsComponent._tempQuaternion1 = new Quaternion, PhysicsComponent._tempMatrix4x40 = new Matrix4x4, PhysicsComponent._physicObjectsMap = {}, PhysicsComponent._addUpdateList = !0;

        class PhysicsUpdateList extends SingletonList {
            constructor() {
                super()
            }

            add(element) {
                if (-1 !== element._inPhysicUpdateListIndex) throw"PhysicsUpdateList:element has  in  PhysicsUpdateList.";
                this._add(element), element._inPhysicUpdateListIndex = this.length++
            }

            remove(element) {
                var index = element._inPhysicUpdateListIndex;
                if (this.length--, index !== this.length) {
                    var end = this.elements[this.length];
                    this.elements[index] = end, end._inPhysicUpdateListIndex = index
                }
                element._inPhysicUpdateListIndex = -1
            }
        }

        class ContactPoint {
            constructor() {
                this._idCounter = 0, this.colliderA = null, this.colliderB = null, this.distance = 0, this.normal = new Vector3, this.positionOnA = new Vector3, this.positionOnB = new Vector3, this._id = ++this._idCounter
            }
        }

        class HitResult {
            constructor() {
                this.succeeded = !1, this.collider = null, this.point = new Vector3, this.normal = new Vector3, this.hitFraction = 0
            }
        }

        class Collision {
            constructor() {
                this._lastUpdateFrame = -2147483648, this._updateFrame = -2147483648, this._isTrigger = !1, this.contacts = []
            }

            _setUpdateFrame(farme) {
                this._lastUpdateFrame = this._updateFrame, this._updateFrame = farme
            }
        }

        class CollisionTool {
            constructor() {
                this._hitResultsPoolIndex = 0, this._hitResultsPool = [], this._contactPonintsPoolIndex = 0, this._contactPointsPool = [], this._collisionsPool = [], this._collisions = {}
            }

            getHitResult() {
                var hitResult = this._hitResultsPool[this._hitResultsPoolIndex++];
                return hitResult || (hitResult = new HitResult, this._hitResultsPool.push(hitResult)), hitResult
            }

            recoverAllHitResultsPool() {
                this._hitResultsPoolIndex = 0
            }

            getContactPoints() {
                var contactPoint = this._contactPointsPool[this._contactPonintsPoolIndex++];
                return contactPoint || (contactPoint = new ContactPoint, this._contactPointsPool.push(contactPoint)), contactPoint
            }

            recoverAllContactPointsPool() {
                this._contactPonintsPoolIndex = 0
            }

            getCollision(physicComponentA, physicComponentB) {
                var collision, idA = physicComponentA.id, idB = physicComponentB.id,
                    subCollisionFirst = this._collisions[idA];
                return subCollisionFirst && (collision = subCollisionFirst[idB]), collision || (subCollisionFirst || (subCollisionFirst = {}, this._collisions[idA] = subCollisionFirst), (collision = 0 === this._collisionsPool.length ? new Collision : this._collisionsPool.pop())._colliderA = physicComponentA, collision._colliderB = physicComponentB, subCollisionFirst[idB] = collision), collision
            }

            recoverCollision(collision) {
                var idA = collision._colliderA.id, idB = collision._colliderB.id;
                this._collisions[idA][idB] = null, this._collisionsPool.push(collision)
            }

            garbageCollection() {
                for (var subCollisionsKey in this._hitResultsPoolIndex = 0, this._hitResultsPool.length = 0, this._contactPonintsPoolIndex = 0, this._contactPointsPool.length = 0, this._collisionsPool.length = 0, this._collisionsPool) {
                    var subCollisions = this._collisionsPool[subCollisionsKey], wholeDelete = !0;
                    for (var collisionKey in subCollisions) subCollisions[collisionKey] ? wholeDelete = !1 : delete subCollisions[collisionKey];
                    wholeDelete && delete this._collisionsPool[subCollisionsKey]
                }
            }
        }

        class PhysicsSimulation {
            constructor(configuration, flags = 0) {
                this._gravity = new Vector3(0, -10, 0), this._nativeVector3Zero = new Physics3D._physics3D.btVector3(0, 0, 0), this._nativeDefaultQuaternion = new Physics3D._physics3D.btQuaternion(0, 0, 0, -1), this._collisionsUtils = new CollisionTool, this._previousFrameCollisions = [], this._currentFrameCollisions = [], this._physicsUpdateList = new PhysicsUpdateList, this._characters = [], this._updatedRigidbodies = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60, this.maxSubSteps = configuration.maxSubSteps, this.fixedTimeStep = configuration.fixedTimeStep;
                var physics3D = Physics3D._physics3D;
                this._nativeCollisionConfiguration = new physics3D.btDefaultCollisionConfiguration, this._nativeDispatcher = new physics3D.btCollisionDispatcher(this._nativeCollisionConfiguration), this._nativeBroadphase = new physics3D.btDbvtBroadphase, this._nativeBroadphase.getOverlappingPairCache().setInternalGhostPairCallback(new physics3D.btGhostPairCallback);
                var conFlags = configuration.flags;
                if (conFlags & PhysicsSimulation.PHYSICSENGINEFLAGS_COLLISIONSONLY) this._nativeCollisionWorld = new physics3D.btCollisionWorld(this._nativeDispatcher, this._nativeBroadphase, this._nativeCollisionConfiguration); else {
                    if (conFlags & PhysicsSimulation.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT) throw"PhysicsSimulation:SoftBody processing is not yet available";
                    var solver = new physics3D.btSequentialImpulseConstraintSolver;
                    this._nativeDiscreteDynamicsWorld = new physics3D.btDiscreteDynamicsWorld(this._nativeDispatcher, this._nativeBroadphase, solver, this._nativeCollisionConfiguration), this._nativeCollisionWorld = this._nativeDiscreteDynamicsWorld
                }
                this._nativeDiscreteDynamicsWorld && (this._nativeSolverInfo = this._nativeDiscreteDynamicsWorld.getSolverInfo(), this._nativeDispatchInfo = this._nativeDiscreteDynamicsWorld.getDispatchInfo()), this._nativeClosestRayResultCallback = new physics3D.ClosestRayResultCallback(this._nativeVector3Zero, this._nativeVector3Zero), this._nativeAllHitsRayResultCallback = new physics3D.AllHitsRayResultCallback(this._nativeVector3Zero, this._nativeVector3Zero), this._nativeClosestConvexResultCallback = new physics3D.ClosestConvexResultCallback(this._nativeVector3Zero, this._nativeVector3Zero), this._nativeAllConvexResultCallback = new physics3D.AllConvexResultCallback(this._nativeVector3Zero, this._nativeVector3Zero), physics3D._btGImpactCollisionAlgorithm_RegisterAlgorithm(this._nativeDispatcher.a)
            }

            static __init__() {
                PhysicsSimulation._nativeTempVector30 = new Physics3D._physics3D.btVector3(0, 0, 0), PhysicsSimulation._nativeTempVector31 = new Physics3D._physics3D.btVector3(0, 0, 0), PhysicsSimulation._nativeTempQuaternion0 = new Physics3D._physics3D.btQuaternion(0, 0, 0, 1), PhysicsSimulation._nativeTempQuaternion1 = new Physics3D._physics3D.btQuaternion(0, 0, 0, 1), PhysicsSimulation._nativeTempTransform0 = new Physics3D._physics3D.btTransform, PhysicsSimulation._nativeTempTransform1 = new Physics3D._physics3D.btTransform
            }

            static createConstraint() {
            }

            get continuousCollisionDetection() {
                return this._nativeDispatchInfo.get_m_useContinuous()
            }

            set continuousCollisionDetection(value) {
                this._nativeDispatchInfo.set_m_useContinuous(value)
            }

            get gravity() {
                if (!this._nativeDiscreteDynamicsWorld) throw"Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                return this._gravity
            }

            set gravity(value) {
                if (!this._nativeDiscreteDynamicsWorld) throw"Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._gravity = value;
                var nativeGravity = PhysicsSimulation._nativeTempVector30;
                nativeGravity.setValue(-value.x, value.y, value.z), this._nativeDiscreteDynamicsWorld.setGravity(nativeGravity)
            }

            get speculativeContactRestitution() {
                if (!this._nativeDiscreteDynamicsWorld) throw"Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
                return this._nativeDiscreteDynamicsWorld.getApplySpeculativeContactRestitution()
            }

            set speculativeContactRestitution(value) {
                if (!this._nativeDiscreteDynamicsWorld) throw"Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._nativeDiscreteDynamicsWorld.setApplySpeculativeContactRestitution(value)
            }

            _simulate(deltaTime) {
                this._updatedRigidbodies = 0, this._nativeDiscreteDynamicsWorld ? this._nativeDiscreteDynamicsWorld.stepSimulation(deltaTime, this.maxSubSteps, this.fixedTimeStep) : this._nativeCollisionWorld.PerformDiscreteCollisionDetection()
            }

            _destroy() {
                var physics3D = Physics3D._physics3D;
                this._nativeDiscreteDynamicsWorld ? (physics3D.destroy(this._nativeDiscreteDynamicsWorld), this._nativeDiscreteDynamicsWorld = null) : (physics3D.destroy(this._nativeCollisionWorld), this._nativeCollisionWorld = null), physics3D.destroy(this._nativeBroadphase), this._nativeBroadphase = null, physics3D.destroy(this._nativeDispatcher), this._nativeDispatcher = null, physics3D.destroy(this._nativeCollisionConfiguration), this._nativeCollisionConfiguration = null
            }

            _addPhysicsCollider(component, group, mask) {
                this._nativeCollisionWorld.addCollisionObject(component._nativeColliderObject, group, mask)
            }

            _removePhysicsCollider(component) {
                this._nativeCollisionWorld.removeCollisionObject(component._nativeColliderObject)
            }

            _addRigidBody(rigidBody, group, mask) {
                if (!this._nativeDiscreteDynamicsWorld) throw"Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._nativeCollisionWorld.addRigidBody(rigidBody._nativeColliderObject, group, mask)
            }

            _removeRigidBody(rigidBody) {
                if (!this._nativeDiscreteDynamicsWorld) throw"Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._nativeCollisionWorld.removeRigidBody(rigidBody._nativeColliderObject)
            }

            _addCharacter(character, group, mask) {
                if (!this._nativeDiscreteDynamicsWorld) throw"Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._nativeCollisionWorld.addCollisionObject(character._nativeColliderObject, group, mask), this._nativeCollisionWorld.addAction(character._nativeKinematicCharacter)
            }

            _removeCharacter(character) {
                if (!this._nativeDiscreteDynamicsWorld) throw"Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._nativeCollisionWorld.removeCollisionObject(character._nativeColliderObject), this._nativeCollisionWorld.removeAction(character._nativeKinematicCharacter)
            }

            raycastFromTo(from, to, out = null, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
                var rayResultCall = this._nativeClosestRayResultCallback,
                    rayFrom = PhysicsSimulation._nativeTempVector30, rayTo = PhysicsSimulation._nativeTempVector31;
                if (rayFrom.setValue(-from.x, from.y, from.z), rayTo.setValue(-to.x, to.y, to.z), rayResultCall.set_m_rayFromWorld(rayFrom), rayResultCall.set_m_rayToWorld(rayTo), rayResultCall.set_m_collisionFilterGroup(collisonGroup), rayResultCall.set_m_collisionFilterMask(collisionMask), rayResultCall.set_m_collisionObject(null), rayResultCall.set_m_closestHitFraction(1), this._nativeCollisionWorld.rayTest(rayFrom, rayTo, rayResultCall), rayResultCall.hasHit()) {
                    if (out) {
                        out.succeeded = !0, out.collider = PhysicsComponent._physicObjectsMap[rayResultCall.get_m_collisionObject().getUserIndex()], out.hitFraction = rayResultCall.get_m_closestHitFraction();
                        var nativePoint = rayResultCall.get_m_hitPointWorld(), point = out.point;
                        point.x = -nativePoint.x(), point.y = nativePoint.y(), point.z = nativePoint.z();
                        var nativeNormal = rayResultCall.get_m_hitNormalWorld(), normal = out.normal;
                        normal.x = -nativeNormal.x(), normal.y = nativeNormal.y(), normal.z = nativeNormal.z()
                    }
                    return !0
                }
                return out && (out.succeeded = !1), !1
            }

            raycastAllFromTo(from, to, out, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
                var rayResultCall = this._nativeAllHitsRayResultCallback,
                    rayFrom = PhysicsSimulation._nativeTempVector30, rayTo = PhysicsSimulation._nativeTempVector31;
                out.length = 0, rayFrom.setValue(-from.x, from.y, from.z), rayTo.setValue(-to.x, to.y, to.z), rayResultCall.set_m_rayFromWorld(rayFrom), rayResultCall.set_m_rayToWorld(rayTo), rayResultCall.set_m_collisionFilterGroup(collisonGroup), rayResultCall.set_m_collisionFilterMask(collisionMask);
                var collisionObjects = rayResultCall.get_m_collisionObjects(),
                    nativePoints = rayResultCall.get_m_hitPointWorld(),
                    nativeNormals = rayResultCall.get_m_hitNormalWorld(),
                    nativeFractions = rayResultCall.get_m_hitFractions();
                collisionObjects.clear(), nativePoints.clear(), nativeNormals.clear(), nativeFractions.clear(), this._nativeCollisionWorld.rayTest(rayFrom, rayTo, rayResultCall);
                var count = collisionObjects.size();
                if (count > 0) {
                    this._collisionsUtils.recoverAllHitResultsPool();
                    for (var i = 0; i < count; i++) {
                        var hitResult = this._collisionsUtils.getHitResult();
                        out.push(hitResult), hitResult.succeeded = !0, hitResult.collider = PhysicsComponent._physicObjectsMap[collisionObjects.at(i).getUserIndex()], hitResult.hitFraction = nativeFractions.at(i);
                        var nativePoint = nativePoints.at(i), pointE = hitResult.point;
                        pointE.x = -nativePoint.x(), pointE.y = nativePoint.y(), pointE.z = nativePoint.z();
                        var nativeNormal = nativeNormals.at(i), normalE = hitResult.normal;
                        normalE.x = -nativeNormal.x(), normalE.y = nativeNormal.y(), normalE.z = nativeNormal.z()
                    }
                    return !0
                }
                return !1
            }

            rayCast(ray, outHitResult = null, distance = 2147483647, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
                var from = ray.origin, to = PhysicsSimulation._tempVector30;
                return Vector3.normalize(ray.direction, to), Vector3.scale(to, distance, to), Vector3.add(from, to, to), this.raycastFromTo(from, to, outHitResult, collisonGroup, collisionMask)
            }

            rayCastAll(ray, out, distance = 2147483647, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
                var from = ray.origin, to = PhysicsSimulation._tempVector30;
                return Vector3.normalize(ray.direction, to), Vector3.scale(to, distance, to), Vector3.add(from, to, to), this.raycastAllFromTo(from, to, out, collisonGroup, collisionMask)
            }

            shapeCast(shape, fromPosition, toPosition, out = null, fromRotation = null, toRotation = null, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, allowedCcdPenetration = 0) {
                var convexResultCall = this._nativeClosestConvexResultCallback,
                    convexPosFrom = PhysicsSimulation._nativeTempVector30,
                    convexPosTo = PhysicsSimulation._nativeTempVector31,
                    convexRotFrom = PhysicsSimulation._nativeTempQuaternion0,
                    convexRotTo = PhysicsSimulation._nativeTempQuaternion1,
                    convexTransform = PhysicsSimulation._nativeTempTransform0,
                    convexTransTo = PhysicsSimulation._nativeTempTransform1, sweepShape = shape._nativeShape;
                if (convexPosFrom.setValue(-fromPosition.x, fromPosition.y, fromPosition.z), convexPosTo.setValue(-toPosition.x, toPosition.y, toPosition.z), convexResultCall.set_m_collisionFilterGroup(collisonGroup), convexResultCall.set_m_collisionFilterMask(collisionMask), convexTransform.setOrigin(convexPosFrom), convexTransTo.setOrigin(convexPosTo), fromRotation ? (convexRotFrom.setValue(-fromRotation.x, fromRotation.y, fromRotation.z, -fromRotation.w), convexTransform.setRotation(convexRotFrom)) : convexTransform.setRotation(this._nativeDefaultQuaternion), toRotation ? (convexRotTo.setValue(-toRotation.x, toRotation.y, toRotation.z, -toRotation.w), convexTransTo.setRotation(convexRotTo)) : convexTransTo.setRotation(this._nativeDefaultQuaternion), convexResultCall.set_m_hitCollisionObject(null), convexResultCall.set_m_closestHitFraction(1), this._nativeCollisionWorld.convexSweepTest(sweepShape, convexTransform, convexTransTo, convexResultCall, allowedCcdPenetration), convexResultCall.hasHit()) {
                    if (out) {
                        out.succeeded = !0, out.collider = PhysicsComponent._physicObjectsMap[convexResultCall.get_m_hitCollisionObject().getUserIndex()], out.hitFraction = convexResultCall.get_m_closestHitFraction();
                        var nativePoint = convexResultCall.get_m_hitPointWorld(),
                            nativeNormal = convexResultCall.get_m_hitNormalWorld(), point = out.point,
                            normal = out.normal;
                        point.x = -nativePoint.x(), point.y = nativePoint.y(), point.z = nativePoint.z(), normal.x = -nativeNormal.x(), normal.y = nativeNormal.y(), normal.z = nativeNormal.z()
                    }
                    return !0
                }
                return out && (out.succeeded = !1), !1
            }

            shapeCastAll(shape, fromPosition, toPosition, out, fromRotation = null, toRotation = null, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, allowedCcdPenetration = 0) {
                var convexResultCall = this._nativeAllConvexResultCallback,
                    convexPosFrom = PhysicsSimulation._nativeTempVector30,
                    convexPosTo = PhysicsSimulation._nativeTempVector31,
                    convexRotFrom = PhysicsSimulation._nativeTempQuaternion0,
                    convexRotTo = PhysicsSimulation._nativeTempQuaternion1,
                    convexTransform = PhysicsSimulation._nativeTempTransform0,
                    convexTransTo = PhysicsSimulation._nativeTempTransform1, sweepShape = shape._nativeShape;
                out.length = 0, convexPosFrom.setValue(-fromPosition.x, fromPosition.y, fromPosition.z), convexPosTo.setValue(-toPosition.x, toPosition.y, toPosition.z), convexResultCall.set_m_collisionFilterGroup(collisonGroup), convexResultCall.set_m_collisionFilterMask(collisionMask), convexTransform.setOrigin(convexPosFrom), convexTransTo.setOrigin(convexPosTo), fromRotation ? (convexRotFrom.setValue(-fromRotation.x, fromRotation.y, fromRotation.z, -fromRotation.w), convexTransform.setRotation(convexRotFrom)) : convexTransform.setRotation(this._nativeDefaultQuaternion), toRotation ? (convexRotTo.setValue(-toRotation.x, toRotation.y, toRotation.z, -toRotation.w), convexTransTo.setRotation(convexRotTo)) : convexTransTo.setRotation(this._nativeDefaultQuaternion);
                var collisionObjects = convexResultCall.get_m_collisionObjects();
                collisionObjects.clear(), this._nativeCollisionWorld.convexSweepTest(sweepShape, convexTransform, convexTransTo, convexResultCall, allowedCcdPenetration);
                var count = collisionObjects.size();
                if (count > 0) {
                    for (var nativePoints = convexResultCall.get_m_hitPointWorld(), nativeNormals = convexResultCall.get_m_hitNormalWorld(), nativeFractions = convexResultCall.get_m_hitFractions(), i = 0; i < count; i++) {
                        var hitResult = this._collisionsUtils.getHitResult();
                        out.push(hitResult), hitResult.succeeded = !0, hitResult.collider = PhysicsComponent._physicObjectsMap[collisionObjects.at(i).getUserIndex()], hitResult.hitFraction = nativeFractions.at(i);
                        var nativePoint = nativePoints.at(i), point = hitResult.point;
                        point.x = -nativePoint.x(), point.y = nativePoint.y(), point.z = nativePoint.z();
                        var nativeNormal = nativeNormals.at(i), normal = hitResult.normal;
                        normal.x = -nativeNormal.x(), normal.y = nativeNormal.y(), normal.z = nativeNormal.z()
                    }
                    return !0
                }
                return !1
            }

            addConstraint(constraint, disableCollisionsBetweenLinkedBodies = !1) {
                if (!this._nativeDiscreteDynamicsWorld) throw"Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._nativeDiscreteDynamicsWorld.addConstraint(constraint._nativeConstraint, disableCollisionsBetweenLinkedBodies), constraint._simulation = this
            }

            removeConstraint(constraint) {
                if (!this._nativeDiscreteDynamicsWorld) throw"Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._nativeDiscreteDynamicsWorld.removeConstraint(constraint._nativeConstraint)
            }

            _updatePhysicsTransformFromRender() {
                for (var elements = this._physicsUpdateList.elements, i = 0, n = this._physicsUpdateList.length; i < n; i++) {
                    var physicCollider = elements[i];
                    physicCollider._derivePhysicsTransformation(!1), physicCollider._inPhysicUpdateListIndex = -1
                }
                this._physicsUpdateList.length = 0
            }

            _updateCharacters() {
                for (var i = 0, n = this._characters.length; i < n; i++) {
                    var character = this._characters[i];
                    character._updateTransformComponent(character._nativeColliderObject.getWorldTransform())
                }
            }

            _updateCollisions() {
                this._collisionsUtils.recoverAllContactPointsPool();
                var previous = this._currentFrameCollisions;
                this._currentFrameCollisions = this._previousFrameCollisions, this._currentFrameCollisions.length = 0, this._previousFrameCollisions = previous;
                for (var loopCount = Laya.Stat.loopCount, numManifolds = this._nativeDispatcher.getNumManifolds(), i = 0; i < numManifolds; i++) {
                    var isFirstCollision, contactManifold = this._nativeDispatcher.getManifoldByIndexInternal(i),
                        componentA = PhysicsComponent._physicObjectsMap[contactManifold.getBody0().getUserIndex()],
                        componentB = PhysicsComponent._physicObjectsMap[contactManifold.getBody1().getUserIndex()],
                        collision = null, contacts = null;
                    if ((componentA.isTrigger || componentB.isTrigger) && (componentA.owner._needProcessTriggers || componentB.owner._needProcessTriggers)) for (var numContacts = contactManifold.getNumContacts(), j = 0; j < numContacts; j++) {
                        var pt = contactManifold.getContactPoint(j), distance = pt.getDistance();
                        if (distance <= 0) {
                            contacts = (collision = this._collisionsUtils.getCollision(componentA, componentB)).contacts, (isFirstCollision = collision._updateFrame !== loopCount) && (collision._isTrigger = !0, contacts.length = 0);
                            break
                        }
                    } else if ((componentA.owner._needProcessCollisions || componentB.owner._needProcessCollisions) && (componentA._enableProcessCollisions || componentB._enableProcessCollisions)) for (numContacts = contactManifold.getNumContacts(), j = 0; j < numContacts; j++) if ((distance = (pt = contactManifold.getContactPoint(j)).getDistance()) <= 0) {
                        var contactPoint = this._collisionsUtils.getContactPoints();
                        contactPoint.colliderA = componentA, contactPoint.colliderB = componentB, contactPoint.distance = distance;
                        var nativeNormal = pt.get_m_normalWorldOnB(), normal = contactPoint.normal;
                        normal.x = -nativeNormal.x(), normal.y = nativeNormal.y(), normal.z = nativeNormal.z();
                        var nativePostionA = pt.get_m_positionWorldOnA(), positionOnA = contactPoint.positionOnA;
                        positionOnA.x = -nativePostionA.x(), positionOnA.y = nativePostionA.y(), positionOnA.z = nativePostionA.z();
                        var nativePostionB = pt.get_m_positionWorldOnB(), positionOnB = contactPoint.positionOnB;
                        positionOnB.x = -nativePostionB.x(), positionOnB.y = nativePostionB.y(), positionOnB.z = nativePostionB.z(), collision || (contacts = (collision = this._collisionsUtils.getCollision(componentA, componentB)).contacts, (isFirstCollision = collision._updateFrame !== loopCount) && (collision._isTrigger = !1, contacts.length = 0)), contacts.push(contactPoint)
                    }
                    collision && isFirstCollision && (this._currentFrameCollisions.push(collision), collision._setUpdateFrame(loopCount))
                }
            }

            _eventScripts() {
                for (var loopCount = Laya.Stat.loopCount, i = 0, n = this._currentFrameCollisions.length; i < n; i++) {
                    var curFrameCol = this._currentFrameCollisions[i], colliderA = curFrameCol._colliderA,
                        colliderB = curFrameCol._colliderB;
                    if (!colliderA.destroyed && !colliderB.destroyed) if (loopCount - curFrameCol._lastUpdateFrame == 1) {
                        var ownerA = colliderA.owner, scriptsA = ownerA._scripts;
                        if (scriptsA) if (curFrameCol._isTrigger) {
                            if (ownerA._needProcessTriggers) for (var j = 0, m = scriptsA.length; j < m; j++) scriptsA[j].onTriggerStay(colliderB)
                        } else if (ownerA._needProcessCollisions) for (j = 0, m = scriptsA.length; j < m; j++) curFrameCol.other = colliderB, scriptsA[j].onCollisionStay(curFrameCol);
                        var ownerB = colliderB.owner, scriptsB = ownerB._scripts;
                        if (scriptsB) if (curFrameCol._isTrigger) {
                            if (ownerB._needProcessTriggers) for (j = 0, m = scriptsB.length; j < m; j++) scriptsB[j].onTriggerStay(colliderA)
                        } else if (ownerB._needProcessCollisions) for (j = 0, m = scriptsB.length; j < m; j++) curFrameCol.other = colliderA, scriptsB[j].onCollisionStay(curFrameCol)
                    } else {
                        if (scriptsA = (ownerA = colliderA.owner)._scripts) if (curFrameCol._isTrigger) {
                            if (ownerA._needProcessTriggers) for (j = 0, m = scriptsA.length; j < m; j++) scriptsA[j].onTriggerEnter(colliderB)
                        } else if (ownerA._needProcessCollisions) for (j = 0, m = scriptsA.length; j < m; j++) curFrameCol.other = colliderB, scriptsA[j].onCollisionEnter(curFrameCol);
                        if (scriptsB = (ownerB = colliderB.owner)._scripts) if (curFrameCol._isTrigger) {
                            if (ownerB._needProcessTriggers) for (j = 0, m = scriptsB.length; j < m; j++) scriptsB[j].onTriggerEnter(colliderA)
                        } else if (ownerB._needProcessCollisions) for (j = 0, m = scriptsB.length; j < m; j++) curFrameCol.other = colliderA, scriptsB[j].onCollisionEnter(curFrameCol)
                    }
                }
                for (i = 0, n = this._previousFrameCollisions.length; i < n; i++) {
                    var preFrameCol = this._previousFrameCollisions[i], preColliderA = preFrameCol._colliderA,
                        preColliderB = preFrameCol._colliderB;
                    if (!preColliderA.destroyed && !preColliderB.destroyed && loopCount - preFrameCol._updateFrame == 1) {
                        if (this._collisionsUtils.recoverCollision(preFrameCol), scriptsA = (ownerA = preColliderA.owner)._scripts) if (preFrameCol._isTrigger) {
                            if (ownerA._needProcessTriggers) for (j = 0, m = scriptsA.length; j < m; j++) scriptsA[j].onTriggerExit(preColliderB)
                        } else if (ownerA._needProcessCollisions) for (j = 0, m = scriptsA.length; j < m; j++) preFrameCol.other = preColliderB, scriptsA[j].onCollisionExit(preFrameCol);
                        if (scriptsB = (ownerB = preColliderB.owner)._scripts) if (preFrameCol._isTrigger) {
                            if (ownerB._needProcessTriggers) for (j = 0, m = scriptsB.length; j < m; j++) scriptsB[j].onTriggerExit(preColliderA)
                        } else if (ownerB._needProcessCollisions) for (j = 0, m = scriptsB.length; j < m; j++) preFrameCol.other = preColliderA, scriptsB[j].onCollisionExit(preFrameCol)
                    }
                }
            }

            clearForces() {
                if (!this._nativeDiscreteDynamicsWorld) throw"Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._nativeDiscreteDynamicsWorld.clearForces()
            }
        }

        PhysicsSimulation.PHYSICSENGINEFLAGS_NONE = 0, PhysicsSimulation.PHYSICSENGINEFLAGS_COLLISIONSONLY = 1, PhysicsSimulation.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT = 2, PhysicsSimulation.PHYSICSENGINEFLAGS_MULTITHREADED = 4, PhysicsSimulation.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE = 8, PhysicsSimulation.SOLVERMODE_RANDMIZE_ORDER = 1, PhysicsSimulation.SOLVERMODE_FRICTION_SEPARATE = 2, PhysicsSimulation.SOLVERMODE_USE_WARMSTARTING = 4, PhysicsSimulation.SOLVERMODE_USE_2_FRICTION_DIRECTIONS = 16, PhysicsSimulation.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING = 32, PhysicsSimulation.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64, PhysicsSimulation.SOLVERMODE_CACHE_FRIENDLY = 128, PhysicsSimulation.SOLVERMODE_SIMD = 256, PhysicsSimulation.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512, PhysicsSimulation.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024, PhysicsSimulation._tempVector30 = new Vector3, PhysicsSimulation.disableSimulation = !1;

        class BoundBox {
            constructor(min, max) {
                this.min = min, this.max = max
            }

            _rotateExtents(extents, rotation, out) {
                var extentsX = extents.x, extentsY = extents.y, extentsZ = extents.z, matElements = rotation.elements;
                out.x = Math.abs(matElements[0] * extentsX) + Math.abs(matElements[4] * extentsY) + Math.abs(matElements[8] * extentsZ), out.y = Math.abs(matElements[1] * extentsX) + Math.abs(matElements[5] * extentsY) + Math.abs(matElements[9] * extentsZ), out.z = Math.abs(matElements[2] * extentsX) + Math.abs(matElements[6] * extentsY) + Math.abs(matElements[10] * extentsZ)
            }

            getCorners(corners) {
                corners.length = 8;
                var minX = this.min.x, minY = this.min.y, minZ = this.min.z, maxX = this.max.x, maxY = this.max.y,
                    maxZ = this.max.z;
                corners[0] = new Vector3(minX, maxY, maxZ), corners[1] = new Vector3(maxX, maxY, maxZ), corners[2] = new Vector3(maxX, minY, maxZ), corners[3] = new Vector3(minX, minY, maxZ), corners[4] = new Vector3(minX, maxY, minZ), corners[5] = new Vector3(maxX, maxY, minZ), corners[6] = new Vector3(maxX, minY, minZ), corners[7] = new Vector3(minX, minY, minZ)
            }

            getCenter(out) {
                Vector3.add(this.min, this.max, out), Vector3.scale(out, .5, out)
            }

            getExtent(out) {
                Vector3.subtract(this.max, this.min, out), Vector3.scale(out, .5, out)
            }

            setCenterAndExtent(center, extent) {
                Vector3.subtract(center, extent, this.min), Vector3.add(center, extent, this.max)
            }

            tranform(matrix, out) {
                var center = BoundBox._tempVector30, extent = BoundBox._tempVector31;
                this.getCenter(center), this.getExtent(extent), Vector3.transformCoordinate(center, matrix, center), this._rotateExtents(extent, matrix, extent), out.setCenterAndExtent(center, extent)
            }

            toDefault() {
                this.min.toDefault(), this.max.toDefault()
            }

            static createfromPoints(points, out) {
                if (null == points) throw new Error("points");
                var min = out.min, max = out.max;
                min.x = Number.MAX_VALUE, min.y = Number.MAX_VALUE, min.z = Number.MAX_VALUE, max.x = -Number.MAX_VALUE, max.y = -Number.MAX_VALUE, max.z = -Number.MAX_VALUE;
                for (var i = 0, n = points.length; i < n; ++i) Vector3.min(min, points[i], min), Vector3.max(max, points[i], max)
            }

            static merge(box1, box2, out) {
                Vector3.min(box1.min, box2.min, out.min), Vector3.max(box1.max, box2.max, out.max)
            }

            cloneTo(destObject) {
                var dest = destObject;
                this.min.cloneTo(dest.min), this.max.cloneTo(dest.max)
            }

            clone() {
                var dest = new BoundBox(new Vector3, new Vector3);
                return this.cloneTo(dest), dest
            }
        }

        BoundBox._tempVector30 = new Vector3, BoundBox._tempVector31 = new Vector3;

        class BoundSphere {
            constructor(center, radius) {
                this.center = center, this.radius = radius
            }

            toDefault() {
                this.center.toDefault(), this.radius = 0
            }

            static createFromSubPoints(points, start, count, out) {
                if (null == points) throw new Error("points");
                if (start < 0 || start >= points.length) throw new Error("start" + start + "Must be in the range [0, " + (points.length - 1) + "]");
                if (count < 0 || start + count > points.length) throw new Error("count" + count + "Must be in the range <= " + points.length + "}");
                var upperEnd = start + count, center = BoundSphere._tempVector3;
                center.x = 0, center.y = 0, center.z = 0;
                for (var i = start; i < upperEnd; ++i) Vector3.add(points[i], center, center);
                var outCenter = out.center;
                Vector3.scale(center, 1 / count, outCenter);
                var radius = 0;
                for (i = start; i < upperEnd; ++i) {
                    var distance = Vector3.distanceSquared(outCenter, points[i]);
                    distance > radius && (radius = distance)
                }
                out.radius = Math.sqrt(radius)
            }

            static createfromPoints(points, out) {
                if (null == points) throw new Error("points");
                BoundSphere.createFromSubPoints(points, 0, points.length, out)
            }

            intersectsRayDistance(ray) {
                return CollisionUtils.intersectsRayAndSphereRD(ray, this)
            }

            intersectsRayPoint(ray, outPoint) {
                return CollisionUtils.intersectsRayAndSphereRP(ray, this, outPoint)
            }

            cloneTo(destObject) {
                var dest = destObject;
                this.center.cloneTo(dest.center), dest.radius = this.radius
            }

            clone() {
                var dest = new BoundSphere(new Vector3, 0);
                return this.cloneTo(dest), dest
            }
        }

        BoundSphere._tempVector3 = new Vector3;

        class ParallelSplitShadowMap {
            constructor() {
                var i;
                for (this._spiltDistance = [], this._currentPSSM = -1, this._shadowMapCount = 3, this._maxDistance = 200, this._ratioOfDistance = 1 / this._shadowMapCount, this._globalParallelLightDir = new Vector3(0, -1, 0), this._statesDirty = !0, this._shadowMapTextureSize = 1024, this._scene = null, this._boundingSphere = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1), this._boundingBox = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1), this._frustumPos = new Array(4 * (ParallelSplitShadowMap.MAX_PSSM_COUNT + 1)), this._uniformDistance = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1), this._logDistance = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1), this._dimension = new Array(ParallelSplitShadowMap.MAX_PSSM_COUNT + 1), this._PCFType = 0, this._tempLookAt3 = new Vector3, this._tempLookAt4 = new Vector4, this._tempValue = new Vector4, this._tempPos = new Vector3, this._tempLightUp = new Vector3, this._tempMin = new Vector4, this._tempMax = new Vector4, this._tempMatrix44 = new Matrix4x4, this._splitFrustumCulling = new BoundFrustum(Matrix4x4.DEFAULT), this._tempScaleMatrix44 = new Matrix4x4, this._shadowPCFOffset = new Vector2(1 / 1024, 1 / 1024), this._shaderValueDistance = new Vector4, this._shaderValueLightVP = null, this.cameras = [], this._shaderValueVPs = [], i = 0; i < this._spiltDistance.length; i++) this._spiltDistance[i] = 0;
                for (i = 0; i < this._dimension.length; i++) this._dimension[i] = new Vector2;
                for (i = 0; i < this._frustumPos.length; i++) this._frustumPos[i] = new Vector3;
                for (i = 0; i < this._boundingBox.length; i++) this._boundingBox[i] = new BoundBox(new Vector3, new Vector3);
                for (i = 0; i < this._boundingSphere.length; i++) this._boundingSphere[i] = new BoundSphere(new Vector3, 0);
                Matrix4x4.createScaling(new Vector3(.5, .5, 1), this._tempScaleMatrix44), this._tempScaleMatrix44.elements[12] = .5, this._tempScaleMatrix44.elements[13] = .5
            }

            setInfo(scene, maxDistance, globalParallelDir, shadowMapTextureSize, numberOfPSSM, PCFType) {
                numberOfPSSM > ParallelSplitShadowMap.MAX_PSSM_COUNT && (this._shadowMapCount = ParallelSplitShadowMap.MAX_PSSM_COUNT), this._scene = scene, this._maxDistance = maxDistance, this.shadowMapCount = numberOfPSSM, this._globalParallelLightDir = globalParallelDir, this._ratioOfDistance = 1 / this._shadowMapCount;
                for (var i = 0; i < this._spiltDistance.length; i++) this._spiltDistance[i] = 0;
                this._shadowMapTextureSize = shadowMapTextureSize, this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize, this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize, this.setPCFType(PCFType), this._statesDirty = !0
            }

            setPCFType(PCFtype) {
                this._PCFType = PCFtype;
                var defineData = this._scene._shaderValues;
                switch (this._PCFType) {
                    case 0:
                        defineData.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF_NO), defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF1), defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF2), defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF3);
                        break;
                    case 1:
                        defineData.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF1), defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF_NO), defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF2), defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF3);
                        break;
                    case 2:
                        defineData.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF2), defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF_NO), defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF1), defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF3);
                        break;
                    case 3:
                        defineData.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF3), defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF_NO), defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF1), defineData.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF2)
                }
            }

            getPCFType() {
                return this._PCFType
            }

            setFarDistance(value) {
                this._maxDistance != value && (this._maxDistance = value, this._statesDirty = !0)
            }

            getFarDistance() {
                return this._maxDistance
            }

            set shadowMapCount(value) {
                if (value = (value = value > 0 ? value : 1) <= ParallelSplitShadowMap.MAX_PSSM_COUNT ? value : ParallelSplitShadowMap.MAX_PSSM_COUNT, this._shadowMapCount != value) {
                    this._shadowMapCount = value, this._ratioOfDistance = 1 / this._shadowMapCount, this._statesDirty = !0, this._shaderValueLightVP = new Float32Array(16 * value), this._shaderValueVPs.length = value;
                    for (var i = 0; i < value; i++) this._shaderValueVPs[i] = new Float32Array(this._shaderValueLightVP.buffer, 64 * i)
                }
            }

            get shadowMapCount() {
                return this._shadowMapCount
            }

            _beginSampler(index, sceneCamera) {
                if (index < 0 || index > this._shadowMapCount) throw new Error("ParallelSplitShadowMap: beginSample invalid index");
                this._currentPSSM = index, this._update(sceneCamera)
            }

            endSampler(sceneCamera) {
                this._currentPSSM = -1
            }

            _calcAllLightCameraInfo(sceneCamera) {
                if (1 === this._shadowMapCount) this._beginSampler(0, sceneCamera), this.endSampler(sceneCamera); else for (var i = 0, n = this._shadowMapCount + 1; i < n; i++) this._beginSampler(i, sceneCamera), this.endSampler(sceneCamera)
            }

            _recalculate(nearPlane, fieldOfView, aspectRatio) {
                this._calcSplitDistance(nearPlane), this._calcBoundingBox(fieldOfView, aspectRatio), this._rebuildRenderInfo()
            }

            _update(sceneCamera) {
                var nearPlane = sceneCamera.nearPlane, fieldOfView = sceneCamera.fieldOfView,
                    aspectRatio = sceneCamera.aspectRatio;
                (this._statesDirty || this.lastNearPlane !== nearPlane || this.lastFieldOfView !== fieldOfView || this.lastAspectRatio !== aspectRatio) && (this._recalculate(nearPlane, fieldOfView, aspectRatio), this._uploadShaderValue(), this._statesDirty = !1, this.lastNearPlane = nearPlane, this.lastFieldOfView = fieldOfView, this.lastAspectRatio = aspectRatio), this._calcLightViewProject(sceneCamera)
            }

            _uploadShaderValue() {
                var sceneSV = this._scene._shaderValues;
                switch (this._shadowMapCount) {
                    case 1:
                        sceneSV.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM1), sceneSV.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM2), sceneSV.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM3);
                        break;
                    case 2:
                        sceneSV.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM2), sceneSV.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM1), sceneSV.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM3);
                        break;
                    case 3:
                        sceneSV.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM3), sceneSV.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM1), sceneSV.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM2)
                }
                switch (sceneSV.setVector(ILaya3D.Scene3D.SHADOWDISTANCE, this._shaderValueDistance), sceneSV.setBuffer(ILaya3D.Scene3D.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP), sceneSV.setVector2(ILaya3D.Scene3D.SHADOWMAPPCFOFFSET, this._shadowPCFOffset), this._shadowMapCount) {
                    case 3:
                        sceneSV.setTexture(ILaya3D.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget), sceneSV.setTexture(ILaya3D.Scene3D.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget), sceneSV.setTexture(ILaya3D.Scene3D.SHADOWMAPTEXTURE3, this.cameras[3].renderTarget);
                        break;
                    case 2:
                        sceneSV.setTexture(ILaya3D.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget), sceneSV.setTexture(ILaya3D.Scene3D.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget);
                        break;
                    case 1:
                        sceneSV.setTexture(ILaya3D.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget)
                }
            }

            _calcSplitDistance(nearPlane) {
                var i, far = this._maxDistance, invNumberOfPSSM = 1 / this._shadowMapCount;
                for (i = 0; i <= this._shadowMapCount; i++) this._uniformDistance[i] = nearPlane + (far - nearPlane) * i * invNumberOfPSSM;
                var farDivNear = far / nearPlane;
                for (i = 0; i <= this._shadowMapCount; i++) {
                    var n = Math.pow(farDivNear, i * invNumberOfPSSM);
                    this._logDistance[i] = nearPlane * n
                }
                for (i = 0; i <= this._shadowMapCount; i++) this._spiltDistance[i] = this._uniformDistance[i] * this._ratioOfDistance + this._logDistance[i] * (1 - this._ratioOfDistance);
                this._shaderValueDistance.x = null != this._spiltDistance[1] && this._spiltDistance[1], this._shaderValueDistance.y = null != this._spiltDistance[2] && this._spiltDistance[2], this._shaderValueDistance.z = null != this._spiltDistance[3] && this._spiltDistance[3], this._shaderValueDistance.w = null != this._spiltDistance[4] && this._spiltDistance[4]
            }

            _calcBoundingBox(fieldOfView, aspectRatio) {
                var height, width, distance, i, d, min, max, center, fov = 3.1415926 * fieldOfView / 180,
                    halfTanValue = Math.tan(fov / 2);
                for (i = 0; i <= this._shadowMapCount; i++) {
                    width = (height = (distance = this._spiltDistance[i]) * halfTanValue) * aspectRatio;
                    var temp = this._frustumPos[4 * i + 0];
                    temp.x = -width, temp.y = -height, temp.z = -distance, (temp = this._frustumPos[4 * i + 1]).x = width, temp.y = -height, temp.z = -distance, (temp = this._frustumPos[4 * i + 2]).x = -width, temp.y = height, temp.z = -distance, (temp = this._frustumPos[4 * i + 3]).x = width, temp.y = height, temp.z = -distance, (temp = this._dimension[i]).x = width, temp.y = height
                }
                for (i = 1; i <= this._shadowMapCount; i++) d = this._dimension[i], (min = this._boundingBox[i].min).x = -d.x, min.y = -d.y, min.z = -this._spiltDistance[i], (max = this._boundingBox[i].max).x = d.x, max.y = d.y, max.z = -this._spiltDistance[i - 1], (center = this._boundingSphere[i].center).x = .5 * (min.x + max.x), center.y = .5 * (min.y + max.y), center.z = .5 * (min.z + max.z), this._boundingSphere[i].radius = .5 * Math.sqrt(Math.pow(max.x - min.x, 2) + Math.pow(max.y - min.y, 2) + Math.pow(max.z - min.z, 2));
                min = this._boundingBox[0].min, d = this._dimension[this._shadowMapCount], min.x = -d.x, min.y = -d.y, min.z = -this._spiltDistance[this._shadowMapCount], (max = this._boundingBox[0].max).x = d.x, max.y = d.y, max.z = -this._spiltDistance[0], (center = this._boundingSphere[0].center).x = .5 * (min.x + max.x), center.y = .5 * (min.y + max.y), center.z = .5 * (min.z + max.z), this._boundingSphere[0].radius = .5 * Math.sqrt(Math.pow(max.x - min.x, 2) + Math.pow(max.y - min.y, 2) + Math.pow(max.z - min.z, 2))
            }

            calcSplitFrustum(sceneCamera) {
                this._currentPSSM > 0 ? Matrix4x4.createPerspective(3.1416 * sceneCamera.fieldOfView / 180, sceneCamera.aspectRatio, this._spiltDistance[this._currentPSSM - 1], this._spiltDistance[this._currentPSSM], this._tempMatrix44) : Matrix4x4.createPerspective(3.1416 * sceneCamera.fieldOfView / 180, sceneCamera.aspectRatio, this._spiltDistance[0], this._spiltDistance[this._shadowMapCount], this._tempMatrix44), Matrix4x4.multiply(this._tempMatrix44, sceneCamera.viewMatrix, this._tempMatrix44), this._splitFrustumCulling.matrix = this._tempMatrix44
            }

            _rebuildRenderInfo() {
                var i, nNum = this._shadowMapCount + 1;
                for (this.cameras.length = nNum, i = 0; i < nNum; i++) {
                    if (!this.cameras[i]) {
                        var camera = new Camera;
                        camera.name = "lightCamera" + i, camera.clearColor = new Vector4(1, 1, 1, 1), this.cameras[i] = camera
                    }
                    var shadowMap = this.cameras[i].renderTarget;
                    null != shadowMap && shadowMap.width == this._shadowMapTextureSize && shadowMap.height == this._shadowMapTextureSize || (shadowMap && shadowMap.destroy(), (shadowMap = new RenderTexture(this._shadowMapTextureSize, this._shadowMapTextureSize, Laya.BaseTexture.FORMAT_R8G8B8A8, Laya.BaseTexture.FORMAT_DEPTH_16)).filterMode = Laya.BaseTexture.FILTERMODE_POINT, this.cameras[i].renderTarget = shadowMap)
                }
            }

            _calcLightViewProject(sceneCamera) {
                var boundSphere = this._boundingSphere[this._currentPSSM],
                    cameraMatViewInv = sceneCamera.transform.worldMatrix;
                boundSphere.radius;
                boundSphere.center.cloneTo(this._tempLookAt3), Vector3.transformV3ToV4(this._tempLookAt3, cameraMatViewInv, this._tempLookAt4);
                var lookAt3Element = this._tempLookAt3, lookAt4Element = this._tempLookAt4;
                lookAt3Element.x = lookAt4Element.x, lookAt3Element.y = lookAt4Element.y, lookAt3Element.z = lookAt4Element.z;
                var lightUpElement = this._tempLightUp;
                sceneCamera.transform.worldMatrix.getForward(ParallelSplitShadowMap._tempVector30);
                var sceneCameraDir = ParallelSplitShadowMap._tempVector30;
                lightUpElement.x = sceneCameraDir.x, lightUpElement.y = 1, lightUpElement.z = sceneCameraDir.z, Vector3.normalize(this._tempLightUp, this._tempLightUp), Vector3.scale(this._globalParallelLightDir, 4 * boundSphere.radius, this._tempPos), Vector3.subtract(this._tempLookAt3, this._tempPos, this._tempPos);
                var curLightCamera = this.cameras[this._currentPSSM];
                curLightCamera.transform.position = this._tempPos, curLightCamera.transform.lookAt(this._tempLookAt3, this._tempLightUp, !1);
                var tempMax = this._tempMax, tempMin = this._tempMin;
                tempMax.x = tempMax.y = tempMax.z = -1e5, tempMax.w = 1, tempMin.x = tempMin.y = tempMin.z = 1e5, tempMin.w = 1, Matrix4x4.multiply(curLightCamera.viewMatrix, cameraMatViewInv, this._tempMatrix44);
                var tempValueElement = this._tempValue, corners = [];
                corners.length = 8, this._boundingBox[this._currentPSSM].getCorners(corners);
                for (var i = 0; i < 8; i++) {
                    var frustumPosElements = corners[i];
                    tempValueElement.x = frustumPosElements.x, tempValueElement.y = frustumPosElements.y, tempValueElement.z = frustumPosElements.z, tempValueElement.w = 1, Vector4.transformByM4x4(this._tempValue, this._tempMatrix44, this._tempValue), tempMin.x = tempValueElement.x < tempMin.x ? tempValueElement.x : tempMin.x, tempMin.y = tempValueElement.y < tempMin.y ? tempValueElement.y : tempMin.y, tempMin.z = tempValueElement.z < tempMin.z ? tempValueElement.z : tempMin.z, tempMax.x = tempValueElement.x > tempMax.x ? tempValueElement.x : tempMax.x, tempMax.y = tempValueElement.y > tempMax.y ? tempValueElement.y : tempMax.y, tempMax.z = tempValueElement.z > tempMax.z ? tempValueElement.z : tempMax.z
                }
                Vector4.add(this._tempMax, this._tempMin, this._tempValue), tempValueElement.x *= .5, tempValueElement.y *= .5, tempValueElement.z *= .5, tempValueElement.w = 1, Vector4.transformByM4x4(this._tempValue, curLightCamera.transform.worldMatrix, this._tempValue);
                var distance = Math.abs(-this._tempMax.z),
                    farPlane = distance > this._maxDistance ? distance : this._maxDistance;
                Vector3.scale(this._globalParallelLightDir, farPlane, this._tempPos);
                var tempPosElement = this._tempPos;
                tempPosElement.x = tempValueElement.x - tempPosElement.x, tempPosElement.y = tempValueElement.y - tempPosElement.y, tempPosElement.z = tempValueElement.z - tempPosElement.z, curLightCamera.transform.position = this._tempPos, curLightCamera.transform.lookAt(this._tempLookAt3, this._tempLightUp, !1), Matrix4x4.createOrthoOffCenter(tempMin.x, tempMax.x, tempMin.y, tempMax.y, 1, farPlane + .5 * (tempMax.z - tempMin.z), curLightCamera.projectionMatrix);
                var projectView = curLightCamera.projectionViewMatrix;
                ParallelSplitShadowMap.multiplyMatrixOutFloat32Array(this._tempScaleMatrix44, projectView, this._shaderValueVPs[this._currentPSSM]), this._scene._shaderValues.setBuffer(ILaya3D.Scene3D.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP)
            }

            static multiplyMatrixOutFloat32Array(left, right, out) {
                var i, a, b, ai0, ai1, ai2, ai3;
                for (a = left.elements, b = right.elements, i = 0; i < 4; i++) ai0 = a[i], ai1 = a[i + 4], ai2 = a[i + 8], ai3 = a[i + 12], out[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3], out[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7], out[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11], out[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15]
            }

            setShadowMapTextureSize(size) {
                size !== this._shadowMapTextureSize && (this._shadowMapTextureSize = size, this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize, this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize, this._statesDirty = !0)
            }

            disposeAllRenderTarget() {
                for (var i = 0, n = this._shadowMapCount + 1; i < n; i++) this.cameras[i].renderTarget && (this.cameras[i].renderTarget.destroy(), this.cameras[i].renderTarget = null)
            }
        }

        ParallelSplitShadowMap.MAX_PSSM_COUNT = 3, ParallelSplitShadowMap._tempVector30 = new Vector3;

        class LightSprite extends Sprite3D {
            constructor() {
                super(), this._intensity = 1, this._intensityColor = new Vector3, this.color = new Vector3(1, 1, 1), this._shadow = !1, this._shadowFarPlane = 8, this._shadowMapSize = 512, this._shadowMapCount = 1, this._shadowMapPCFType = 0, this._lightmapBakedType = LightSprite.LIGHTMAPBAKEDTYPE_REALTIME
            }

            get intensity() {
                return this._intensity
            }

            set intensity(value) {
                this._intensity = value
            }

            get shadow() {
                return this._shadow
            }

            set shadow(value) {
                throw new Error("LightSprite: must override it.")
            }

            get shadowDistance() {
                return this._shadowFarPlane
            }

            set shadowDistance(value) {
                this._shadowFarPlane = value, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setFarDistance(value)
            }

            get shadowResolution() {
                return this._shadowMapSize
            }

            set shadowResolution(value) {
                this._shadowMapSize = value, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setShadowMapTextureSize(value)
            }

            get shadowPSSMCount() {
                return this._shadowMapCount
            }

            set shadowPSSMCount(value) {
                this._shadowMapCount = value, this._parallelSplitShadowMap && (this._parallelSplitShadowMap.shadowMapCount = value)
            }

            get shadowPCFType() {
                return this._shadowMapPCFType
            }

            set shadowPCFType(value) {
                this._shadowMapPCFType = value, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setPCFType(value)
            }

            get lightmapBakedType() {
                return this._lightmapBakedType
            }

            set lightmapBakedType(value) {
                this._lightmapBakedType !== value && (this._lightmapBakedType = value, this.activeInHierarchy && (value !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED ? this._scene._addLight(this) : this._scene._removeLight(this)))
            }

            _parse(data, spriteMap) {
                super._parse(data, spriteMap);
                var colorData = data.color;
                this.color.fromArray(colorData), this.intensity = data.intensity, this.lightmapBakedType = data.lightmapBakedType
            }

            _onActive() {
                super._onActive(), this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._scene._addLight(this)
            }

            _onInActive() {
                super._onInActive(), this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._scene._removeLight(this)
            }

            _prepareToScene() {
                return !1
            }

            _create() {
                return new LightSprite
            }

            get diffuseColor() {
                return console.log("LightSprite: discard property,please use color property instead."), this.color
            }

            set diffuseColor(value) {
                console.log("LightSprite: discard property,please use color property instead."), this.color = value
            }
        }

        LightSprite.LIGHTMAPBAKEDTYPE_REALTIME = 0, LightSprite.LIGHTMAPBAKEDTYPE_MIXED = 1, LightSprite.LIGHTMAPBAKEDTYPE_BAKED = 2;

        class DirectionLight extends LightSprite {
            set shadow(value) {
                this._shadow !== value && (this._shadow = value, this.scene && this._initShadow())
            }

            constructor() {
                super(), this._direction = new Vector3
            }

            _initShadow() {
                if (this._shadow) this._parallelSplitShadowMap = new ParallelSplitShadowMap, this.scene.parallelSplitShadowMaps.push(this._parallelSplitShadowMap), this.transform.worldMatrix.getForward(this._direction), Vector3.normalize(this._direction, this._direction), this._parallelSplitShadowMap.setInfo(this.scene, this._shadowFarPlane, this._direction, this._shadowMapSize, this._shadowMapCount, this._shadowMapPCFType); else {
                    var defineDatas = this._scene._shaderValues,
                        parallelSplitShadowMaps = this.scene.parallelSplitShadowMaps;
                    parallelSplitShadowMaps.splice(parallelSplitShadowMaps.indexOf(this._parallelSplitShadowMap), 1), this._parallelSplitShadowMap.disposeAllRenderTarget(), this._parallelSplitShadowMap = null, defineDatas.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM1), defineDatas.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM2), defineDatas.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM3)
                }
            }

            _onActive() {
                super._onActive(), this._shadow && this._initShadow(), this._lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._scene._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT)
            }

            _onInActive() {
                super._onInActive(), this._lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._scene._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT)
            }

            _prepareToScene() {
                var scene = this._scene;
                if (scene.enableLight && this.activeInHierarchy) {
                    var shaderValue = scene._shaderValues;
                    return Vector3.scale(this.color, this._intensity, this._intensityColor), shaderValue.setVector3(ILaya3D.Scene3D.LIGHTDIRCOLOR, this._intensityColor), this.transform.worldMatrix.getForward(this._direction), Vector3.normalize(this._direction, this._direction), shaderValue.setVector3(ILaya3D.Scene3D.LIGHTDIRECTION, this._direction), !0
                }
                return !1
            }
        }

        class PointLight extends LightSprite {
            constructor() {
                super(), this._lightMatrix = new Matrix4x4, this._range = 6
            }

            get range() {
                return this._range
            }

            set range(value) {
                this._range = value
            }

            _onActive() {
                super._onActive(), this._lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._scene._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT)
            }

            _onInActive() {
                super._onInActive(), this._lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._scene._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT)
            }

            _prepareToScene() {
                var scene = this._scene;
                if (scene.enableLight && this.activeInHierarchy) {
                    var shaderValue = scene._shaderValues;
                    Vector3.scale(this.color, this._intensity, this._intensityColor), shaderValue.setVector3(ILaya3D.Scene3D.POINTLIGHTCOLOR, this._intensityColor), shaderValue.setVector3(ILaya3D.Scene3D.POINTLIGHTPOS, this.transform.position), shaderValue.setNumber(ILaya3D.Scene3D.POINTLIGHTRANGE, this.range);
                    var lightMatrix = this._lightMatrix, lightMatrixE = lightMatrix.elements;
                    lightMatrix.identity(), lightMatrixE[0] = lightMatrixE[5] = lightMatrixE[10] = 1 / this._range;
                    var toLightMatrix = PointLight._tempMatrix0;
                    return this.transform.worldMatrix.invert(toLightMatrix), Matrix4x4.multiply(lightMatrix, toLightMatrix, lightMatrix), shaderValue.setMatrix4x4(ILaya3D.Scene3D.POINTLIGHTMATRIX, lightMatrix), !0
                }
                return !1
            }

            _parse(data, spriteMap) {
                super._parse(data, spriteMap), this.range = data.range
            }
        }

        PointLight._tempMatrix0 = new Matrix4x4;

        class SpotLight extends LightSprite {
            constructor() {
                super(), this._spotAngle = 30, this._range = 10, this._direction = new Vector3
            }

            get spotAngle() {
                return this._spotAngle
            }

            set spotAngle(value) {
                this._spotAngle = Math.max(Math.min(value, 180), 0)
            }

            get range() {
                return this._range
            }

            set range(value) {
                this._range = value
            }

            _onActive() {
                super._onActive(), this._lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this.scene._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT)
            }

            _onInActive() {
                super._onInActive(), this._lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this.scene._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT)
            }

            _prepareToScene() {
                var scene = this._scene;
                if (scene.enableLight && this.activeInHierarchy) {
                    var shaderValue = scene._shaderValues;
                    return Vector3.scale(this.color, this._intensity, this._intensityColor), shaderValue.setVector3(ILaya3D.Scene3D.SPOTLIGHTCOLOR, this._intensityColor), shaderValue.setVector3(ILaya3D.Scene3D.SPOTLIGHTPOS, this.transform.position), this.transform.worldMatrix.getForward(this._direction), Vector3.normalize(this._direction, this._direction), shaderValue.setVector3(ILaya3D.Scene3D.SPOTLIGHTDIRECTION, this._direction), shaderValue.setNumber(ILaya3D.Scene3D.SPOTLIGHTRANGE, this.range), shaderValue.setNumber(ILaya3D.Scene3D.SPOTLIGHTSPOTANGLE, this.spotAngle * Math.PI / 180), !0
                }
                return !1
            }

            _parse(data, spriteMap) {
                super._parse(data, spriteMap), this.range = data.range, this.spotAngle = data.spotAngle
            }
        }

        SpotLight._tempMatrix0 = new Matrix4x4, SpotLight._tempMatrix1 = new Matrix4x4;

        class MeshSprite3DShaderDeclaration {
        }

        class MeshFilter {
            get sharedMesh() {
                return this._sharedMesh
            }

            set sharedMesh(value) {
                if (this._sharedMesh !== value) {
                    var defineDatas = this._owner._render._shaderValues, lastValue = this._sharedMesh;
                    lastValue && (lastValue._removeReference(), defineDatas.removeDefine(this._getMeshDefine(lastValue))), value && (value._addReference(), defineDatas.addDefine(this._getMeshDefine(value))), this._owner._render._onMeshChange(value), this._sharedMesh = value
                }
            }

            constructor(owner) {
                this._owner = owner
            }

            _getMeshDefine(mesh) {
                for (var define, i = 0, n = mesh._subMeshes.length; i < n; i++) for (var vertexElements = mesh.getSubMesh(i)._vertexBuffer._vertexDeclaration._vertexElements, j = 0, m = vertexElements.length; j < m; j++) {
                    switch (vertexElements[j]._elementUsage) {
                        case VertexMesh.MESH_COLOR0:
                            define |= MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR;
                            break;
                        case VertexMesh.MESH_TEXTURECOORDINATE0:
                            define |= MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0;
                            break;
                        case VertexMesh.MESH_TEXTURECOORDINATE1:
                            define |= MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1
                    }
                }
                return define
            }

            destroy() {
                this._owner = null, this._sharedMesh && (this._sharedMesh._removeReference(), this._sharedMesh = null)
            }
        }

        class BaseMaterial extends Laya.Resource {
            constructor() {
                super(), this._shaderValues = null, this._disablePublicDefineDatas = new DefineDatas, this._shaderValues = new ShaderData(this), this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE, this._alphaTest = !1
            }

            static load(url, complete) {
                Laya.Laya.loader.create(url, complete, null, BaseMaterial.MATERIAL)
            }

            static __initDefine__() {
                BaseMaterial.shaderDefines = new ShaderDefines, BaseMaterial.SHADERDEFINE_ALPHATEST = BaseMaterial.shaderDefines.registerDefine("ALPHATEST")
            }

            static _parse(data, propertyParams = null, constructParams = null) {
                var material, jsonData = data, props = jsonData.props, classType = props.type,
                    clas = Laya.ClassUtils.getRegClass(classType);
                if (!clas) throw"_getSprite3DHierarchyInnerUrls 错误: " + data.type + " 不是类";
                switch (material = new clas, jsonData.version) {
                    case"LAYAMATERIAL:01":
                    case"LAYAMATERIAL:02":
                        var i, n;
                        for (var key in props) switch (key) {
                            case"vectors":
                                var vectors = props[key];
                                for (i = 0, n = vectors.length; i < n; i++) {
                                    var vector = vectors[i], vectorValue = vector.value;
                                    switch (vectorValue.length) {
                                        case 2:
                                            material[vector.name] = new Vector2(vectorValue[0], vectorValue[1]);
                                            break;
                                        case 3:
                                            material[vector.name] = new Vector3(vectorValue[0], vectorValue[1], vectorValue[2]);
                                            break;
                                        case 4:
                                            material[vector.name] = new Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                            break;
                                        default:
                                            throw new Error("BaseMaterial:unkonwn color length.")
                                    }
                                }
                                break;
                            case"textures":
                                var textures = props[key];
                                for (i = 0, n = textures.length; i < n; i++) {
                                    var texture = textures[i], path = texture.path;
                                    path && (material[texture.name] = Laya.Loader.getRes(path))
                                }
                                break;
                            case"defines":
                                var defineNames = props[key];
                                for (i = 0, n = defineNames.length; i < n; i++) {
                                    var define = material._shader.getSubShaderAt(0).getMaterialDefineByName(defineNames[i]);
                                    material._shaderValues.addDefine(define)
                                }
                                break;
                            case"renderStates":
                                var renderStateData = props[key][0], mat = material;
                                mat.blend = renderStateData.blend, mat.cull = renderStateData.cull, mat.depthTest = renderStateData.depthTest, mat.depthWrite = renderStateData.depthWrite, mat.blendSrc = renderStateData.srcBlend, mat.blendDst = renderStateData.dstBlend;
                                break;
                            case"cull":
                                material.cull = props[key];
                                break;
                            case"blend":
                                material.blend = props[key];
                                break;
                            case"depthWrite":
                                material.depthWrite = props[key];
                                break;
                            case"srcBlend":
                                material.blendSrc = props[key];
                                break;
                            case"dstBlend":
                                material.blendDst = props[key];
                                break;
                            default:
                                material[key] = props[key]
                        }
                        break;
                    default:
                        throw new Error("BaseMaterial:unkonwn version.")
                }
                return material
            }

            get alphaTestValue() {
                return this._shaderValues.getNumber(BaseMaterial.ALPHATESTVALUE)
            }

            set alphaTestValue(value) {
                this._shaderValues.setNumber(BaseMaterial.ALPHATESTVALUE, value)
            }

            get alphaTest() {
                return this._alphaTest
            }

            set alphaTest(value) {
                this._alphaTest = value, value ? this._shaderValues.addDefine(BaseMaterial.SHADERDEFINE_ALPHATEST) : this._shaderValues.removeDefine(BaseMaterial.SHADERDEFINE_ALPHATEST)
            }

            _removeTetxureReference() {
                var data = this._shaderValues.getData();
                for (var k in data) {
                    var value = data[k];
                    value && value instanceof Laya.BaseTexture && value._removeReference()
                }
            }

            _addReference(count = 1) {
                super._addReference(count);
                var data = this._shaderValues.getData();
                for (var k in data) {
                    var value = data[k];
                    value && value instanceof Laya.BaseTexture && value._addReference()
                }
            }

            _removeReference(count = 1) {
                super._removeReference(count), this._removeTetxureReference()
            }

            _disposeResource() {
                this._referenceCount > 0 && this._removeTetxureReference(), this._shaderValues = null
            }

            setShaderName(name) {
                if (this._shader = Shader3D.find(name), !this._shader) throw new Error("BaseMaterial: unknown shader name.")
            }

            cloneTo(destObject) {
                var destBaseMaterial = destObject;
                destBaseMaterial.name = this.name, destBaseMaterial.renderQueue = this.renderQueue, this._disablePublicDefineDatas.cloneTo(destBaseMaterial._disablePublicDefineDatas), this._shaderValues.cloneTo(destBaseMaterial._shaderValues)
            }

            clone() {
                var dest = new BaseMaterial;
                return this.cloneTo(dest), dest
            }

            get _defineDatas() {
                return this._shaderValues._defineDatas
            }
        }

        BaseMaterial.MATERIAL = "MATERIAL", BaseMaterial.RENDERQUEUE_OPAQUE = 2e3, BaseMaterial.RENDERQUEUE_ALPHATEST = 2450, BaseMaterial.RENDERQUEUE_TRANSPARENT = 3e3, BaseMaterial.ALPHATESTVALUE = Shader3D.propertyNameToID("u_AlphaTestValue"), BaseMaterial.shaderDefines = null;

        class RenderState {
            constructor() {
                this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_DISABLE, this.srcBlend = RenderState.BLENDPARAM_ONE, this.dstBlend = RenderState.BLENDPARAM_ZERO, this.srcBlendRGB = RenderState.BLENDPARAM_ONE, this.dstBlendRGB = RenderState.BLENDPARAM_ZERO, this.srcBlendAlpha = RenderState.BLENDPARAM_ONE, this.dstBlendAlpha = RenderState.BLENDPARAM_ZERO, this.blendConstColor = new Vector4(1, 1, 1, 1), this.blendEquation = RenderState.BLENDEQUATION_ADD, this.blendEquationRGB = RenderState.BLENDEQUATION_ADD, this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD, this.depthTest = RenderState.DEPTHTEST_LEQUAL, this.depthWrite = !0
            }

            cloneTo(dest) {
                var destState = dest;
                destState.cull = this.cull, destState.blend = this.blend, destState.srcBlend = this.srcBlend, destState.dstBlend = this.dstBlend, destState.srcBlendRGB = this.srcBlendRGB, destState.dstBlendRGB = this.dstBlendRGB, destState.srcBlendAlpha = this.srcBlendAlpha, destState.dstBlendAlpha = this.dstBlendAlpha, this.blendConstColor.cloneTo(destState.blendConstColor), destState.blendEquation = this.blendEquation, destState.blendEquationRGB = this.blendEquationRGB, destState.blendEquationAlpha = this.blendEquationAlpha, destState.depthTest = this.depthTest, destState.depthWrite = this.depthWrite
            }

            clone() {
                var dest = new RenderState;
                return this.cloneTo(dest), dest
            }
        }

        RenderState.CULL_NONE = 0, RenderState.CULL_FRONT = 1, RenderState.CULL_BACK = 2, RenderState.BLEND_DISABLE = 0, RenderState.BLEND_ENABLE_ALL = 1, RenderState.BLEND_ENABLE_SEPERATE = 2, RenderState.BLENDPARAM_ZERO = 0, RenderState.BLENDPARAM_ONE = 1, RenderState.BLENDPARAM_SRC_COLOR = 768, RenderState.BLENDPARAM_ONE_MINUS_SRC_COLOR = 769, RenderState.BLENDPARAM_DST_COLOR = 774, RenderState.BLENDPARAM_ONE_MINUS_DST_COLOR = 775, RenderState.BLENDPARAM_SRC_ALPHA = 770, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA = 771, RenderState.BLENDPARAM_DST_ALPHA = 772, RenderState.BLENDPARAM_ONE_MINUS_DST_ALPHA = 773, RenderState.BLENDPARAM_SRC_ALPHA_SATURATE = 776, RenderState.BLENDEQUATION_ADD = 0, RenderState.BLENDEQUATION_SUBTRACT = 1, RenderState.BLENDEQUATION_REVERSE_SUBTRACT = 2, RenderState.DEPTHTEST_OFF = 0, RenderState.DEPTHTEST_NEVER = 512, RenderState.DEPTHTEST_LESS = 513, RenderState.DEPTHTEST_EQUAL = 514, RenderState.DEPTHTEST_LEQUAL = 515, RenderState.DEPTHTEST_GREATER = 516, RenderState.DEPTHTEST_NOTEQUAL = 517, RenderState.DEPTHTEST_GEQUAL = 518, RenderState.DEPTHTEST_ALWAYS = 519;

        class BlinnPhongMaterial extends BaseMaterial {
            constructor() {
                super(), this._enableVertexColor = !1, this.setShaderName("BLINNPHONG"), this._albedoIntensity = 1, this._albedoColor = new Vector4(1, 1, 1, 1);
                var sv = this._shaderValues;
                sv.setVector(BlinnPhongMaterial.ALBEDOCOLOR, new Vector4(1, 1, 1, 1)), sv.setVector(BlinnPhongMaterial.MATERIALSPECULAR, new Vector4(1, 1, 1, 1)), sv.setNumber(BlinnPhongMaterial.SHININESS, .078125), sv.setNumber(BaseMaterial.ALPHATESTVALUE, .5), sv.setVector(BlinnPhongMaterial.TILINGOFFSET, new Vector4(1, 1, 0, 0)), this._enableLighting = !0, this.renderMode = BlinnPhongMaterial.RENDERMODE_OPAQUE
            }

            static __initDefine__() {
                BlinnPhongMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines), BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP = BlinnPhongMaterial.shaderDefines.registerDefine("DIFFUSEMAP"), BlinnPhongMaterial.SHADERDEFINE_NORMALMAP = BlinnPhongMaterial.shaderDefines.registerDefine("NORMALMAP"), BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP = BlinnPhongMaterial.shaderDefines.registerDefine("SPECULARMAP"), BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET = BlinnPhongMaterial.shaderDefines.registerDefine("TILINGOFFSET"), BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = BlinnPhongMaterial.shaderDefines.registerDefine("ENABLEVERTEXCOLOR")
            }

            get _ColorR() {
                return this._albedoColor.x
            }

            set _ColorR(value) {
                this._albedoColor.x = value, this.albedoColor = this._albedoColor
            }

            get _ColorG() {
                return this._albedoColor.y
            }

            set _ColorG(value) {
                this._albedoColor.y = value, this.albedoColor = this._albedoColor
            }

            get _ColorB() {
                return this._albedoColor.z
            }

            set _ColorB(value) {
                this._albedoColor.z = value, this.albedoColor = this._albedoColor
            }

            get _ColorA() {
                return this._albedoColor.w
            }

            set _ColorA(value) {
                this._albedoColor.w = value, this.albedoColor = this._albedoColor
            }

            get _SpecColorR() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x
            }

            set _SpecColorR(value) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x = value
            }

            get _SpecColorG() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y
            }

            set _SpecColorG(value) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y = value
            }

            get _SpecColorB() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z
            }

            set _SpecColorB(value) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z = value
            }

            get _SpecColorA() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w
            }

            set _SpecColorA(value) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w = value
            }

            get _AlbedoIntensity() {
                return this._albedoIntensity
            }

            set _AlbedoIntensity(value) {
                if (this._albedoIntensity !== value) {
                    var finalAlbedo = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
                    Vector4.scale(this._albedoColor, value, finalAlbedo), this._albedoIntensity = value, this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, finalAlbedo)
                }
            }

            get _Shininess() {
                return this._shaderValues.getNumber(BlinnPhongMaterial.SHININESS)
            }

            set _Shininess(value) {
                value = Math.max(0, Math.min(1, value)), this._shaderValues.setNumber(BlinnPhongMaterial.SHININESS, value)
            }

            get _MainTex_STX() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).x
            }

            set _MainTex_STX(x) {
                var tilOff = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                tilOff.x = x, this.tilingOffset = tilOff
            }

            get _MainTex_STY() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).y
            }

            set _MainTex_STY(y) {
                var tilOff = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                tilOff.y = y, this.tilingOffset = tilOff
            }

            get _MainTex_STZ() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).z
            }

            set _MainTex_STZ(z) {
                var tilOff = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                tilOff.z = z, this.tilingOffset = tilOff
            }

            get _MainTex_STW() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).w
            }

            set _MainTex_STW(w) {
                var tilOff = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                tilOff.w = w, this.tilingOffset = tilOff
            }

            get _Cutoff() {
                return this.alphaTestValue
            }

            set _Cutoff(value) {
                this.alphaTestValue = value
            }

            set renderMode(value) {
                switch (value) {
                    case BlinnPhongMaterial.RENDERMODE_OPAQUE:
                        this.alphaTest = !1, this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE, this.depthWrite = !0, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_DISABLE, this.depthTest = RenderState.DEPTHTEST_LESS;
                        break;
                    case BlinnPhongMaterial.RENDERMODE_CUTOUT:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_DISABLE, this.depthTest = RenderState.DEPTHTEST_LESS;
                        break;
                    case BlinnPhongMaterial.RENDERMODE_TRANSPARENT:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA, this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = RenderState.DEPTHTEST_LESS;
                        break;
                    default:
                        throw new Error("Material:renderMode value error.")
                }
            }

            get enableVertexColor() {
                return this._enableVertexColor
            }

            set enableVertexColor(value) {
                this._enableVertexColor = value, value ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR)
            }

            get tilingOffsetX() {
                return this._MainTex_STX
            }

            set tilingOffsetX(x) {
                this._MainTex_STX = x
            }

            get tilingOffsetY() {
                return this._MainTex_STY
            }

            set tilingOffsetY(y) {
                this._MainTex_STY = y
            }

            get tilingOffsetZ() {
                return this._MainTex_STZ
            }

            set tilingOffsetZ(z) {
                this._MainTex_STZ = z
            }

            get tilingOffsetW() {
                return this._MainTex_STW
            }

            set tilingOffsetW(w) {
                this._MainTex_STW = w
            }

            get tilingOffset() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET)
            }

            set tilingOffset(value) {
                value && (1 != value.x || 1 != value.y || 0 != value.z || 0 != value.w) ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET), this._shaderValues.setVector(BlinnPhongMaterial.TILINGOFFSET, value)
            }

            get albedoColorR() {
                return this._ColorR
            }

            set albedoColorR(value) {
                this._ColorR = value
            }

            get albedoColorG() {
                return this._ColorG
            }

            set albedoColorG(value) {
                this._ColorG = value
            }

            get albedoColorB() {
                return this._ColorB
            }

            set albedoColorB(value) {
                this._ColorB = value
            }

            get albedoColorA() {
                return this._ColorA
            }

            set albedoColorA(value) {
                this._ColorA = value
            }

            get albedoColor() {
                return this._albedoColor
            }

            set albedoColor(value) {
                var finalAlbedo = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
                Vector4.scale(value, this._albedoIntensity, finalAlbedo), this._albedoColor = value, this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, finalAlbedo)
            }

            get albedoIntensity() {
                return this._albedoIntensity
            }

            set albedoIntensity(value) {
                this._AlbedoIntensity = value
            }

            get specularColorR() {
                return this._SpecColorR
            }

            set specularColorR(value) {
                this._SpecColorR = value
            }

            get specularColorG() {
                return this._SpecColorG
            }

            set specularColorG(value) {
                this._SpecColorG = value
            }

            get specularColorB() {
                return this._SpecColorB
            }

            set specularColorB(value) {
                this._SpecColorB = value
            }

            get specularColorA() {
                return this._SpecColorA
            }

            set specularColorA(value) {
                this._SpecColorA = value
            }

            get specularColor() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR)
            }

            set specularColor(value) {
                this._shaderValues.setVector(BlinnPhongMaterial.MATERIALSPECULAR, value)
            }

            get shininess() {
                return this._Shininess
            }

            set shininess(value) {
                this._Shininess = value
            }

            get albedoTexture() {
                return this._shaderValues.getTexture(BlinnPhongMaterial.ALBEDOTEXTURE)
            }

            set albedoTexture(value) {
                value ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP), this._shaderValues.setTexture(BlinnPhongMaterial.ALBEDOTEXTURE, value)
            }

            get normalTexture() {
                return this._shaderValues.getTexture(BlinnPhongMaterial.NORMALTEXTURE)
            }

            set normalTexture(value) {
                value ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP), this._shaderValues.setTexture(BlinnPhongMaterial.NORMALTEXTURE, value)
            }

            get specularTexture() {
                return this._shaderValues.getTexture(BlinnPhongMaterial.SPECULARTEXTURE)
            }

            set specularTexture(value) {
                value ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP), this._shaderValues.setTexture(BlinnPhongMaterial.SPECULARTEXTURE, value)
            }

            get enableLighting() {
                return this._enableLighting
            }

            set enableLighting(value) {
                this._enableLighting !== value && (value ? this._disablePublicDefineDatas.remove(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT) : this._disablePublicDefineDatas.add(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT), this._enableLighting = value)
            }

            set depthWrite(value) {
                this._shaderValues.setBool(BlinnPhongMaterial.DEPTH_WRITE, value)
            }

            get depthWrite() {
                return this._shaderValues.getBool(BlinnPhongMaterial.DEPTH_WRITE)
            }

            set cull(value) {
                this._shaderValues.setInt(BlinnPhongMaterial.CULL, value)
            }

            get cull() {
                return this._shaderValues.getInt(BlinnPhongMaterial.CULL)
            }

            set blend(value) {
                this._shaderValues.setInt(BlinnPhongMaterial.BLEND, value)
            }

            get blend() {
                return this._shaderValues.getInt(BlinnPhongMaterial.BLEND)
            }

            set blendSrc(value) {
                this._shaderValues.setInt(BlinnPhongMaterial.BLEND_SRC, value)
            }

            get blendSrc() {
                return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_SRC)
            }

            set blendDst(value) {
                this._shaderValues.setInt(BlinnPhongMaterial.BLEND_DST, value)
            }

            get blendDst() {
                return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_DST)
            }

            set depthTest(value) {
                this._shaderValues.setInt(BlinnPhongMaterial.DEPTH_TEST, value)
            }

            get depthTest() {
                return this._shaderValues.getInt(BlinnPhongMaterial.DEPTH_TEST)
            }

            clone() {
                var dest = new BlinnPhongMaterial;
                return this.cloneTo(dest), dest
            }

            cloneTo(destObject) {
                super.cloneTo(destObject);
                var destMaterial = destObject;
                destMaterial._enableLighting = this._enableLighting, destMaterial._albedoIntensity = this._albedoIntensity, destMaterial._enableVertexColor = this._enableVertexColor, this._albedoColor.cloneTo(destMaterial._albedoColor)
            }
        }

        BlinnPhongMaterial.RENDERMODE_OPAQUE = 0, BlinnPhongMaterial.RENDERMODE_CUTOUT = 1, BlinnPhongMaterial.RENDERMODE_TRANSPARENT = 2, BlinnPhongMaterial.ALBEDOTEXTURE = Shader3D.propertyNameToID("u_DiffuseTexture"), BlinnPhongMaterial.NORMALTEXTURE = Shader3D.propertyNameToID("u_NormalTexture"), BlinnPhongMaterial.SPECULARTEXTURE = Shader3D.propertyNameToID("u_SpecularTexture"), BlinnPhongMaterial.ALBEDOCOLOR = Shader3D.propertyNameToID("u_DiffuseColor"), BlinnPhongMaterial.MATERIALSPECULAR = Shader3D.propertyNameToID("u_MaterialSpecular"), BlinnPhongMaterial.SHININESS = Shader3D.propertyNameToID("u_Shininess"), BlinnPhongMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset"), BlinnPhongMaterial.CULL = Shader3D.propertyNameToID("s_Cull"), BlinnPhongMaterial.BLEND = Shader3D.propertyNameToID("s_Blend"), BlinnPhongMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc"), BlinnPhongMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst"), BlinnPhongMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest"), BlinnPhongMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite"), BlinnPhongMaterial.shaderDefines = null;

        class Bounds {
            constructor(min, max) {
                this._updateFlag = 0, this._center = new Vector3, this._extent = new Vector3, this._boundBox = new BoundBox(new Vector3, new Vector3), min.cloneTo(this._boundBox.min), max.cloneTo(this._boundBox.max), this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0)
            }

            setMin(value) {
                var min = this._boundBox.min;
                value !== min && value.cloneTo(min), this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0), this._setUpdateFlag(Bounds._UPDATE_MIN, !1)
            }

            getMin() {
                var min = this._boundBox.min;
                return this._getUpdateFlag(Bounds._UPDATE_MIN) && (this._getMin(this.getCenter(), this.getExtent(), min), this._setUpdateFlag(Bounds._UPDATE_MIN, !1)), min
            }

            setMax(value) {
                var max = this._boundBox.max;
                value !== max && value.cloneTo(max), this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0), this._setUpdateFlag(Bounds._UPDATE_MAX, !1)
            }

            getMax() {
                var max = this._boundBox.max;
                return this._getUpdateFlag(Bounds._UPDATE_MAX) && (this._getMax(this.getCenter(), this.getExtent(), max), this._setUpdateFlag(Bounds._UPDATE_MAX, !1)), max
            }

            setCenter(value) {
                value !== this._center && value.cloneTo(this._center), this._setUpdateFlag(Bounds._UPDATE_MIN | Bounds._UPDATE_MAX, !0), this._setUpdateFlag(Bounds._UPDATE_CENTER, !1)
            }

            getCenter() {
                return this._getUpdateFlag(Bounds._UPDATE_CENTER) && (this._getCenter(this.getMin(), this.getMax(), this._center), this._setUpdateFlag(Bounds._UPDATE_CENTER, !1)), this._center
            }

            setExtent(value) {
                value !== this._extent && value.cloneTo(this._extent), this._setUpdateFlag(Bounds._UPDATE_MIN | Bounds._UPDATE_MAX, !0), this._setUpdateFlag(Bounds._UPDATE_EXTENT, !1)
            }

            getExtent() {
                return this._getUpdateFlag(Bounds._UPDATE_EXTENT) && (this._getExtent(this.getMin(), this.getMax(), this._extent), this._setUpdateFlag(Bounds._UPDATE_EXTENT, !1)), this._extent
            }

            _getUpdateFlag(type) {
                return 0 != (this._updateFlag & type)
            }

            _setUpdateFlag(type, value) {
                value ? this._updateFlag |= type : this._updateFlag &= ~type
            }

            _getCenter(min, max, out) {
                Vector3.add(min, max, out), Vector3.scale(out, .5, out)
            }

            _getExtent(min, max, out) {
                Vector3.subtract(max, min, out), Vector3.scale(out, .5, out)
            }

            _getMin(center, extent, out) {
                Vector3.subtract(center, extent, out)
            }

            _getMax(center, extent, out) {
                Vector3.add(center, extent, out)
            }

            _rotateExtents(extents, rotation, out) {
                var extentsX = extents.x, extentsY = extents.y, extentsZ = extents.z, matE = rotation.elements;
                out.x = Math.abs(matE[0] * extentsX) + Math.abs(matE[4] * extentsY) + Math.abs(matE[8] * extentsZ), out.y = Math.abs(matE[1] * extentsX) + Math.abs(matE[5] * extentsY) + Math.abs(matE[9] * extentsZ), out.z = Math.abs(matE[2] * extentsX) + Math.abs(matE[6] * extentsY) + Math.abs(matE[10] * extentsZ)
            }

            _tranform(matrix, out) {
                var outCen = out._center, outExt = out._extent;
                Vector3.transformCoordinate(this.getCenter(), matrix, outCen), this._rotateExtents(this.getExtent(), matrix, outExt), out._boundBox.setCenterAndExtent(outCen, outExt), out._updateFlag = 0
            }

            _getBoundBox() {
                if (this._updateFlag & Bounds._UPDATE_MIN) {
                    var min = this._boundBox.min;
                    this._getMin(this.getCenter(), this.getExtent(), min), this._setUpdateFlag(Bounds._UPDATE_MIN, !1)
                }
                if (this._updateFlag & Bounds._UPDATE_MAX) {
                    var max = this._boundBox.max;
                    this._getMax(this.getCenter(), this.getExtent(), max), this._setUpdateFlag(Bounds._UPDATE_MAX, !1)
                }
                return this._boundBox
            }

            cloneTo(destObject) {
                var destBounds = destObject;
                this.getMin().cloneTo(destBounds._boundBox.min), this.getMax().cloneTo(destBounds._boundBox.max), this.getCenter().cloneTo(destBounds._center), this.getExtent().cloneTo(destBounds._extent), destBounds._updateFlag = 0
            }

            clone() {
                var dest = new Bounds(new Vector3, new Vector3);
                return this.cloneTo(dest), dest
            }
        }

        Bounds._UPDATE_MIN = 1, Bounds._UPDATE_MAX = 2, Bounds._UPDATE_CENTER = 4, Bounds._UPDATE_EXTENT = 8;

        class BaseRender extends Laya.EventDispatcher {
            constructor(owner) {
                if (super(), this._indexInList = -1, this._indexInCastShadowList = -1, this._boundsChange = !0, this._supportOctree = !0, this._sharedMaterials = [], this._visible = !0, this._indexInOctreeMotionList = -1, this._updateMark = -1, this._updateRenderType = -1, this._isPartOfStaticBatch = !1, this._staticBatch = null, this._id = ++BaseRender._uniqueIDCounter, this._indexInCastShadowList = -1, this._bounds = new Bounds(Vector3._ZERO, Vector3._ZERO), Laya.Render.supportWebGLPlusCulling) {
                    var length = FrustumCulling._cullingBufferLength;
                    this._cullingBufferIndex = length;
                    var cullingBuffer = FrustumCulling._cullingBuffer, resizeLength = length + 7;
                    if (resizeLength >= cullingBuffer.length) {
                        var temp = cullingBuffer;
                        (cullingBuffer = FrustumCulling._cullingBuffer = new Float32Array(cullingBuffer.length + 4096)).set(temp, 0)
                    }
                    cullingBuffer[length] = 2, FrustumCulling._cullingBufferLength = resizeLength
                }
                this._renderElements = [], this._owner = owner, this._enable = !0, this._materialsInstance = [], this._shaderValues = new ShaderData(null), this.lightmapIndex = -1, this._castShadow = !1, this.receiveShadow = !1, this.sortingFudge = 0, owner && this._owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange)
            }

            get id() {
                return this._id
            }

            get lightmapIndex() {
                return this._lightmapIndex
            }

            set lightmapIndex(value) {
                this._lightmapIndex !== value && (this._lightmapIndex = value, this._applyLightMapParams())
            }

            get lightmapScaleOffset() {
                return this._lightmapScaleOffset
            }

            set lightmapScaleOffset(value) {
                this._lightmapScaleOffset = value, this._shaderValues.setVector(RenderableSprite3D.LIGHTMAPSCALEOFFSET, value), this._shaderValues.addDefine(RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV)
            }

            get enable() {
                return this._enable
            }

            set enable(value) {
                this._enable = !!value
            }

            get material() {
                var material = this._sharedMaterials[0];
                if (material && !this._materialsInstance[0]) {
                    var insMat = this._getInstanceMaterial(material, 0), renderElement = this._renderElements[0];
                    renderElement && (renderElement.material = insMat)
                }
                return this._sharedMaterials[0]
            }

            set material(value) {
                this.sharedMaterial = value
            }

            get materials() {
                for (var i = 0, n = this._sharedMaterials.length; i < n; i++) if (!this._materialsInstance[i]) {
                    var insMat = this._getInstanceMaterial(this._sharedMaterials[i], i),
                        renderElement = this._renderElements[i];
                    renderElement && (renderElement.material = insMat)
                }
                return this._sharedMaterials.slice()
            }

            set materials(value) {
                this.sharedMaterials = value
            }

            get sharedMaterial() {
                return this._sharedMaterials[0]
            }

            set sharedMaterial(value) {
                var lastValue = this._sharedMaterials[0];
                if (lastValue !== value) {
                    this._sharedMaterials[0] = value, this._materialsInstance[0] = !1, this._changeMaterialReference(lastValue, value);
                    var renderElement = this._renderElements[0];
                    renderElement && (renderElement.material = value)
                }
            }

            get sharedMaterials() {
                return this._sharedMaterials.slice()
            }

            set sharedMaterials(value) {
                for (var materialsInstance = this._materialsInstance, sharedMats = this._sharedMaterials, i = 0, n = sharedMats.length; i < n; i++) {
                    var lastMat = sharedMats[i];
                    lastMat && lastMat._removeReference()
                }
                if (!value) throw new Error("BaseRender: shadredMaterials value can't be null.");
                var count = value.length;
                for (materialsInstance.length = count, sharedMats.length = count, i = 0; i < count; i++) {
                    lastMat = sharedMats[i];
                    var mat = value[i];
                    if (lastMat !== mat) {
                        materialsInstance[i] = !1;
                        var renderElement = this._renderElements[i];
                        renderElement && (renderElement.material = mat)
                    }
                    mat && mat._addReference(), sharedMats[i] = mat
                }
            }

            get bounds() {
                return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1), this._bounds
            }

            set receiveShadow(value) {
                this._receiveShadow !== value && (this._receiveShadow = value, value ? this._shaderValues.addDefine(RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW) : this._shaderValues.removeDefine(RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW))
            }

            get receiveShadow() {
                return this._receiveShadow
            }

            get castShadow() {
                return this._castShadow
            }

            set castShadow(value) {
                this._castShadow !== value && (this._owner.activeInHierarchy && (value ? this._scene._addShadowCastRenderObject(this) : this._scene._removeShadowCastRenderObject(this)), this._castShadow = value)
            }

            get isPartOfStaticBatch() {
                return this._isPartOfStaticBatch
            }

            _getOctreeNode() {
                return this._octreeNode
            }

            _setOctreeNode(value) {
                this._octreeNode = value
            }

            _getIndexInMotionList() {
                return this._indexInOctreeMotionList
            }

            _setIndexInMotionList(value) {
                this._indexInOctreeMotionList = value
            }

            _changeMaterialReference(lastValue, value) {
                lastValue && lastValue._removeReference(), value._addReference()
            }

            _getInstanceMaterial(material, index) {
                var insMat = material.clone();
                return insMat.name = insMat.name + "(Instance)", this._materialsInstance[index] = !0, this._changeMaterialReference(this._sharedMaterials[index], insMat), this._sharedMaterials[index] = insMat, insMat
            }

            _applyLightMapParams() {
                if (this._scene && this._lightmapIndex >= 0) {
                    var lightMaps = this._scene.getlightmaps();
                    this._lightmapIndex < lightMaps.length ? (this._shaderValues.addDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP), this._shaderValues.setTexture(RenderableSprite3D.LIGHTMAP, lightMaps[this._lightmapIndex])) : this._shaderValues.removeDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP)
                } else this._shaderValues.removeDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP)
            }

            _onWorldMatNeedChange(flag) {
                this._boundsChange = !0, this._octreeNode && (flag &= Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this)
            }

            _calculateBoundingBox() {
                throw"BaseRender: must override it."
            }

            _getIndexInList() {
                return this._indexInList
            }

            _setIndexInList(index) {
                this._indexInList = index
            }

            _setBelongScene(scene) {
                this._scene !== scene && (this._scene = scene, this._applyLightMapParams())
            }

            _needRender(boundFrustum, context) {
                return !0
            }

            _renderUpdate(context, transform) {
            }

            _renderUpdateWithCamera(context, transform) {
            }

            _revertBatchRenderUpdate(context) {
            }

            _destroy() {
                -1 !== this._indexInOctreeMotionList && this._octreeNode._octree.removeMotionObject(this), this.offAll();
                var i = 0, n = 0;
                for (i = 0, n = this._renderElements.length; i < n; i++) this._renderElements[i].destroy();
                for (i = 0, n = this._sharedMaterials.length; i < n; i++) this._sharedMaterials[i].destroyed || this._sharedMaterials[i]._removeReference();
                this._renderElements = null, this._owner = null, this._sharedMaterials = null, this._bounds = null, this._lightmapScaleOffset = null
            }
        }

        BaseRender._tempBoundBoxCorners = [new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3], BaseRender._uniqueIDCounter = 0;

        class MeshRenderer extends BaseRender {
            constructor(owner) {
                super(owner), this._projectionViewWorldMatrix = new Matrix4x4
            }

            _createRenderElement() {
                return new SubMeshRenderElement
            }

            _onMeshChange(mesh) {
                if (mesh) {
                    var count = mesh.subMeshCount;
                    this._renderElements.length = count;
                    for (var i = 0; i < count; i++) {
                        var renderElement = this._renderElements[i];
                        if (!renderElement) {
                            var material = this.sharedMaterials[i];
                            (renderElement = this._renderElements[i] = this._createRenderElement()).setTransform(this._owner._transform), renderElement.render = this, renderElement.material = material || BlinnPhongMaterial.defaultMaterial
                        }
                        renderElement.setGeometry(mesh.getSubMesh(i))
                    }
                } else this._renderElements.length = 0;
                this._boundsChange = !0
            }

            _calculateBoundingBox() {
                var sharedMesh = this._owner.meshFilter.sharedMesh;
                if (sharedMesh) {
                    var worldMat = this._owner.transform.worldMatrix;
                    sharedMesh.bounds._tranform(worldMat, this._bounds)
                }
                if (Laya.Render.supportWebGLPlusCulling) {
                    var min = this._bounds.getMin(), max = this._bounds.getMax(),
                        buffer = FrustumCulling._cullingBuffer;
                    buffer[this._cullingBufferIndex + 1] = min.x, buffer[this._cullingBufferIndex + 2] = min.y, buffer[this._cullingBufferIndex + 3] = min.z, buffer[this._cullingBufferIndex + 4] = max.x, buffer[this._cullingBufferIndex + 5] = max.y, buffer[this._cullingBufferIndex + 6] = max.z
                }
            }

            _needRender(boundFrustum, context) {
                return !boundFrustum || boundFrustum.intersects(this.bounds._getBoundBox())
            }

            _renderUpdate(context, transform) {
                var element = context.renderElement;
                switch (element.renderType) {
                    case RenderElement.RENDERTYPE_NORMAL:
                        this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, transform.worldMatrix);
                        break;
                    case RenderElement.RENDERTYPE_STATICBATCH:
                        this._oriDefineValue = this._shaderValues._defineDatas.value, transform ? this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, transform.worldMatrix) : this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, Matrix4x4.DEFAULT), this._shaderValues.addDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1), this._shaderValues.removeDefine(RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV);
                        break;
                    case RenderElement.RENDERTYPE_VERTEXBATCH:
                        this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, Matrix4x4.DEFAULT);
                        break;
                    case RenderElement.RENDERTYPE_INSTANCEBATCH:
                        for (var worldMatrixData = SubMeshInstanceBatch.instance.instanceWorldMatrixData, insBatches = element.instanceBatchElementList, elements = insBatches.elements, count = insBatches.length, i = 0; i < count; i++) worldMatrixData.set(elements[i]._transform.worldMatrix.elements, 16 * i);
                        SubMeshInstanceBatch.instance.instanceWorldMatrixBuffer.setData(worldMatrixData.buffer, 0, 0, 16 * count * 4), this._shaderValues.addDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_GPU_INSTANCE)
                }
            }

            _renderUpdateWithCamera(context, transform) {
                var projectionView = context.projectionViewMatrix, element = context.renderElement;
                switch (element.renderType) {
                    case RenderElement.RENDERTYPE_NORMAL:
                    case RenderElement.RENDERTYPE_STATICBATCH:
                    case RenderElement.RENDERTYPE_VERTEXBATCH:
                        transform ? (Matrix4x4.multiply(projectionView, transform.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, projectionView);
                        break;
                    case RenderElement.RENDERTYPE_INSTANCEBATCH:
                        for (var mvpMatrixData = SubMeshInstanceBatch.instance.instanceMVPMatrixData, insBatches = element.instanceBatchElementList, elements = insBatches.elements, count = insBatches.length, i = 0; i < count; i++) {
                            var worldMat = elements[i]._transform.worldMatrix;
                            Utils3D.mulMatrixByArray(projectionView.elements, 0, worldMat.elements, 0, mvpMatrixData, 16 * i)
                        }
                        SubMeshInstanceBatch.instance.instanceMVPMatrixBuffer.setData(mvpMatrixData.buffer, 0, 0, 16 * count * 4)
                }
            }

            _revertBatchRenderUpdate(context) {
                switch (context.renderElement.renderType) {
                    case RenderElement.RENDERTYPE_STATICBATCH:
                        this._shaderValues._defineDatas.value = this._oriDefineValue;
                        break;
                    case RenderElement.RENDERTYPE_INSTANCEBATCH:
                        this._shaderValues.removeDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_GPU_INSTANCE)
                }
            }

            _destroy() {
                this._isPartOfStaticBatch && MeshRenderStaticBatchManager.instance._destroyRenderSprite(this._owner), super._destroy()
            }
        }

        class MeshSprite3D extends RenderableSprite3D {
            static __init__() {
                MeshSprite3D.shaderDefines = new ShaderDefines(RenderableSprite3D.shaderDefines), MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0 = MeshSprite3D.shaderDefines.registerDefine("UV"), MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR = MeshSprite3D.shaderDefines.registerDefine("COLOR"), MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1 = MeshSprite3D.shaderDefines.registerDefine("UV1"), MeshSprite3DShaderDeclaration.SHADERDEFINE_GPU_INSTANCE = MeshSprite3D.shaderDefines.registerDefine("GPU_INSTANCE"), StaticBatchManager._registerManager(MeshRenderStaticBatchManager.instance), DynamicBatchManager._registerManager(MeshRenderDynamicBatchManager.instance)
            }

            get meshFilter() {
                return this._meshFilter
            }

            get meshRenderer() {
                return this._render
            }

            constructor(mesh = null, name = null) {
                super(name), this._meshFilter = new MeshFilter(this), this._render = new MeshRenderer(this), mesh && (this._meshFilter.sharedMesh = mesh)
            }

            _parse(data, spriteMap) {
                super._parse(data, spriteMap);
                var render = this.meshRenderer, lightmapIndex = data.lightmapIndex;
                null != lightmapIndex && (render.lightmapIndex = lightmapIndex);
                var lightmapScaleOffsetArray = data.lightmapScaleOffset;
                lightmapScaleOffsetArray && (render.lightmapScaleOffset = new Vector4(lightmapScaleOffsetArray[0], lightmapScaleOffsetArray[1], lightmapScaleOffsetArray[2], lightmapScaleOffsetArray[3])), null != data.meshPath && (this.meshFilter.sharedMesh = Laya.Loader.getRes(data.meshPath)), null != data.enableRender && (this.meshRenderer.enable = data.enableRender);
                var materials = data.materials;
                if (materials) {
                    var sharedMaterials = render.sharedMaterials, materialCount = materials.length;
                    sharedMaterials.length = materialCount;
                    for (var i = 0; i < materialCount; i++) sharedMaterials[i] = Laya.Loader.getRes(materials[i].path);
                    render.sharedMaterials = sharedMaterials
                }
            }

            _addToInitStaticBatchManager() {
                this.meshFilter.sharedMesh && MeshRenderStaticBatchManager.instance._addBatchSprite(this)
            }

            _cloneTo(destObject, rootSprite, dstSprite) {
                var meshSprite3D = destObject;
                meshSprite3D._meshFilter.sharedMesh = this._meshFilter.sharedMesh;
                var meshRender = this._render, destMeshRender = meshSprite3D._render;
                destMeshRender.enable = meshRender.enable, destMeshRender.sharedMaterials = meshRender.sharedMaterials, destMeshRender.castShadow = meshRender.castShadow;
                var lightmapScaleOffset = meshRender.lightmapScaleOffset;
                lightmapScaleOffset && (destMeshRender.lightmapScaleOffset = lightmapScaleOffset.clone()), destMeshRender.lightmapIndex = meshRender.lightmapIndex, destMeshRender.receiveShadow = meshRender.receiveShadow, destMeshRender.sortingFudge = meshRender.sortingFudge, super._cloneTo(destObject, rootSprite, dstSprite)
            }

            destroy(destroyChild = !0) {
                this.destroyed || (super.destroy(destroyChild), this._meshFilter.destroy())
            }

            _create() {
                return new MeshSprite3D
            }
        }

        class GradientMode {
        }

        GradientMode.Blend = 0, GradientMode.Fixed = 1;

        class Gradient {
            constructor(maxColorRGBKeyCount, maxColorAlphaKeyCount) {
                this._mode = 0, this._maxColorRGBKeysCount = 0, this._maxColorAlphaKeysCount = 0, this._colorRGBKeysCount = 0, this._colorAlphaKeysCount = 0, this._alphaElements = null, this._rgbElements = null, this._maxColorRGBKeysCount = maxColorRGBKeyCount, this._maxColorAlphaKeysCount = maxColorAlphaKeyCount, this._rgbElements = new Float32Array(4 * maxColorRGBKeyCount), this._alphaElements = new Float32Array(2 * maxColorAlphaKeyCount)
            }

            get mode() {
                return this._mode
            }

            set mode(value) {
                this._mode = value
            }

            get colorRGBKeysCount() {
                return this._colorRGBKeysCount
            }

            get colorAlphaKeysCount() {
                return this._colorAlphaKeysCount
            }

            get maxColorRGBKeysCount() {
                return this._maxColorRGBKeysCount
            }

            get maxColorAlphaKeysCount() {
                return this._maxColorAlphaKeysCount
            }

            addColorRGB(key, value) {
                if (this._colorRGBKeysCount < this._maxColorRGBKeysCount) {
                    var offset = 4 * this._colorRGBKeysCount;
                    this._rgbElements[offset] = key, this._rgbElements[offset + 1] = value.r, this._rgbElements[offset + 2] = value.g, this._rgbElements[offset + 3] = value.b, this._colorRGBKeysCount++
                } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorRGBKeysCount)
            }

            addColorAlpha(key, value) {
                if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount) {
                    var offset = 2 * this._colorAlphaKeysCount;
                    this._alphaElements[offset] = key, this._alphaElements[offset + 1] = value, this._colorAlphaKeysCount++
                } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorAlphaKeysCount)
            }

            updateColorRGB(index, key, value) {
                if (index < this._colorRGBKeysCount) {
                    var offset = 4 * index;
                    this._rgbElements[offset] = key, this._rgbElements[offset + 1] = value.r, this._rgbElements[offset + 2] = value.g, this._rgbElements[offset + 3] = value.b
                } else console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount)
            }

            updateColorAlpha(index, key, value) {
                if (index < this._colorAlphaKeysCount) {
                    var offset = 2 * index;
                    this._alphaElements[offset] = key, this._alphaElements[offset + 1] = value
                } else console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount)
            }

            evaluateColorRGB(lerpFactor, out, startSearchIndex = 0, reverseSearch = !1) {
                lerpFactor = Math.min(Math.max(lerpFactor, 0), 1);
                var rgbElements = this._rgbElements, curIndex = startSearchIndex;
                if (reverseSearch) for (var i = curIndex; i >= 0; i--) {
                    var offset = 4 * i;
                    if (lerpFactor === (left = rgbElements[offset])) return out.r = rgbElements[offset + 1], out.g = rgbElements[offset + 2], out.b = rgbElements[offset + 3], curIndex;
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor > left) {
                                if (lerpFactor > (right = rgbElements[offset + 4])) throw"Gradient:wrong startSearchIndex.";
                                var diff = right - left, y1 = right - lerpFactor, y2 = lerpFactor - left;
                                return out.r = (y1 * rgbElements[offset + 1] + y2 * rgbElements[offset + 5]) / diff, out.g = (y1 * rgbElements[offset + 2] + y2 * rgbElements[offset + 6]) / diff, out.b = (y1 * rgbElements[offset + 3] + y2 * rgbElements[offset + 7]) / diff, curIndex
                            }
                            curIndex--;
                            continue;
                        case GradientMode.Fixed:
                            if (lerpFactor > left) {
                                if (lerpFactor > rgbElements[offset + 4]) throw"Gradient:wrong startSearchIndex.";
                                return out.r = rgbElements[offset + 5], out.g = rgbElements[offset + 6], out.b = rgbElements[offset + 7], curIndex
                            }
                            curIndex--;
                            continue;
                        default:
                            throw"Gradient:unknown mode."
                    }
                } else {
                    i = 0;
                    for (var n = this._rgbElements.length; i < n; i++) {
                        var right;
                        if (lerpFactor === (right = rgbElements[offset = 4 * i])) return out.r = rgbElements[offset + 1], out.g = rgbElements[offset + 2], out.b = rgbElements[offset + 3], curIndex;
                        switch (this._mode) {
                            case GradientMode.Blend:
                                if (lerpFactor < right) {
                                    var left;
                                    if (lerpFactor < (left = rgbElements[offset - 4])) throw"Gradient:wrong startSearchIndex.";
                                    diff = right - left, y1 = right - lerpFactor, y2 = lerpFactor - left;
                                    return out.r = (y1 * rgbElements[offset - 3] + y2 * rgbElements[offset + 1]) / diff, out.g = (y1 * rgbElements[offset - 2] + y2 * rgbElements[offset + 2]) / diff, out.b = (y1 * rgbElements[offset - 1] + y2 * rgbElements[offset + 3]) / diff, curIndex
                                }
                                curIndex++;
                                continue;
                            case GradientMode.Fixed:
                                if (lerpFactor < right) {
                                    if (lerpFactor < rgbElements[offset - 4]) throw"Gradient:wrong startSearchIndex.";
                                    return out.r = rgbElements[offset + 1], out.g = rgbElements[offset + 2], out.b = rgbElements[offset + 3], curIndex
                                }
                                curIndex++;
                                continue;
                            default:
                                throw"Gradient:unknown mode."
                        }
                    }
                }
                return curIndex
            }

            evaluateColorAlpha(lerpFactor, outColor, startSearchIndex = 0, reverseSearch = !1) {
                lerpFactor = Math.min(Math.max(lerpFactor, 0), 1);
                var alphaElements = this._alphaElements, curIndex = startSearchIndex;
                if (reverseSearch) for (var i = curIndex; i >= 0; i--) {
                    if (lerpFactor === (left = alphaElements[offset = 2 * i])) return outColor.a = alphaElements[offset + 1], curIndex;
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor > left) {
                                if (lerpFactor > (right = alphaElements[offset + 2])) throw"Gradient:wrong startSearchIndex.";
                                var diff = right - left, x1 = right - lerpFactor, x2 = lerpFactor - left;
                                return outColor.a = (x1 * alphaElements[offset + 1] + x2 * alphaElements[offset + 3]) / diff, curIndex
                            }
                            curIndex--;
                            continue;
                        case GradientMode.Fixed:
                            if (lerpFactor > left) {
                                if (lerpFactor > alphaElements[offset + 2]) throw"Gradient:wrong startSearchIndex.";
                                return outColor.a = alphaElements[offset + 3], curIndex
                            }
                            curIndex--;
                            continue;
                        default:
                            throw"Gradient:unknown mode."
                    }
                } else {
                    i = curIndex;
                    for (var n = this._alphaElements.length; i < n; i++) {
                        var offset, right;
                        if (lerpFactor === (right = alphaElements[offset = 2 * i])) return outColor.a = alphaElements[offset + 1], curIndex;
                        switch (this._mode) {
                            case GradientMode.Blend:
                                if (lerpFactor < right) {
                                    var left;
                                    if (lerpFactor < (left = alphaElements[offset - 2])) throw"Gradient:wrong startSearchIndex.";
                                    diff = right - left, x1 = right - lerpFactor, x2 = lerpFactor - left;
                                    return outColor.a = (x1 * alphaElements[offset - 1] + x2 * alphaElements[offset + 1]) / diff, curIndex
                                }
                                curIndex++;
                                continue;
                            case GradientMode.Fixed:
                                if (lerpFactor < right) {
                                    if (lerpFactor < alphaElements[offset - 2]) throw"Gradient:wrong startSearchIndex.";
                                    return outColor.a = alphaElements[offset + 1], curIndex
                                }
                                curIndex++;
                                continue;
                            default:
                                throw"Gradient:unknown mode."
                        }
                    }
                }
                return curIndex
            }

            cloneTo(destObject) {
                var i, n, destGradientDataColor = destObject;
                destGradientDataColor._colorAlphaKeysCount = this._colorAlphaKeysCount;
                var destAlphaElements = destGradientDataColor._alphaElements;
                for (i = 0, n = this._alphaElements.length; i < n; i++) destAlphaElements[i] = this._alphaElements[i];
                destGradientDataColor._colorRGBKeysCount = this._colorRGBKeysCount;
                var destRGBElements = destGradientDataColor._rgbElements;
                for (i = 0, n = this._rgbElements.length; i < n; i++) destRGBElements[i] = this._rgbElements[i]
            }

            clone() {
                var destGradientDataColor = new Gradient(this._maxColorRGBKeysCount, this._maxColorAlphaKeysCount);
                return this.cloneTo(destGradientDataColor), destGradientDataColor
            }
        }

        class ShurikenParticleMaterial extends BaseMaterial {
            constructor() {
                super(), this.setShaderName("PARTICLESHURIKEN"), this._color = new Vector4(1, 1, 1, 1), this.renderMode = ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED
            }

            static __initDefine__() {
                ShurikenParticleMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines), ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP = ShurikenParticleMaterial.shaderDefines.registerDefine("DIFFUSEMAP"), ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR = ShurikenParticleMaterial.shaderDefines.registerDefine("TINTCOLOR"), ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG = ShurikenParticleMaterial.shaderDefines.registerDefine("ADDTIVEFOG"), ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET = ShurikenParticleMaterial.shaderDefines.registerDefine("TILINGOFFSET")
            }

            get _TintColorR() {
                return this._color.x
            }

            set _TintColorR(value) {
                this._color.x = value, this.color = this._color
            }

            get _TintColorG() {
                return this._color.y
            }

            set _TintColorG(value) {
                this._color.y = value, this.color = this._color
            }

            get _TintColorB() {
                return this._color.z
            }

            set _TintColorB(value) {
                this._color.z = value, this.color = this._color
            }

            get _TintColorA() {
                return this._color.w
            }

            set _TintColorA(value) {
                this._color.w = value, this.color = this._color
            }

            get _MainTex_STX() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).x
            }

            set _MainTex_STX(x) {
                var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                tilOff.x = x, this.tilingOffset = tilOff
            }

            get _MainTex_STY() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).y
            }

            set _MainTex_STY(y) {
                var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                tilOff.y = y, this.tilingOffset = tilOff
            }

            get _MainTex_STZ() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).z
            }

            set _MainTex_STZ(z) {
                var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                tilOff.z = z, this.tilingOffset = tilOff
            }

            get _MainTex_STW() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).w
            }

            set _MainTex_STW(w) {
                var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                tilOff.w = w, this.tilingOffset = tilOff
            }

            set renderMode(value) {
                switch (value) {
                    case ShurikenParticleMaterial.RENDERMODE_ADDTIVE:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1, this.cull = RenderState.CULL_NONE, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA, this.blendDst = RenderState.BLENDPARAM_ONE, this.alphaTest = !1, this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                        break;
                    case ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1, this.cull = RenderState.CULL_NONE, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA, this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.alphaTest = !1, this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                        break;
                    default:
                        throw new Error("ShurikenParticleMaterial : renderMode value error.")
                }
            }

            get colorR() {
                return this._TintColorR
            }

            set colorR(value) {
                this._TintColorR = value
            }

            get colorG() {
                return this._TintColorG
            }

            set colorG(value) {
                this._TintColorG = value
            }

            get colorB() {
                return this._TintColorB
            }

            set colorB(value) {
                this._TintColorB = value
            }

            get colorA() {
                return this._TintColorA
            }

            set colorA(value) {
                this._TintColorA = value
            }

            get color() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TINTCOLOR)
            }

            set color(value) {
                value ? this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR) : this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR), this._shaderValues.setVector(ShurikenParticleMaterial.TINTCOLOR, value)
            }

            get tilingOffsetX() {
                return this._MainTex_STX
            }

            set tilingOffsetX(x) {
                this._MainTex_STX = x
            }

            get tilingOffsetY() {
                return this._MainTex_STY
            }

            set tilingOffsetY(y) {
                this._MainTex_STY = y
            }

            get tilingOffsetZ() {
                return this._MainTex_STZ
            }

            set tilingOffsetZ(z) {
                this._MainTex_STZ = z
            }

            get tilingOffsetW() {
                return this._MainTex_STW
            }

            set tilingOffsetW(w) {
                this._MainTex_STW = w
            }

            get tilingOffset() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET)
            }

            set tilingOffset(value) {
                value && (1 != value.x || 1 != value.y || 0 != value.z || 0 != value.w) ? this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET), this._shaderValues.setVector(ShurikenParticleMaterial.TILINGOFFSET, value)
            }

            get texture() {
                return this._shaderValues.getTexture(ShurikenParticleMaterial.DIFFUSETEXTURE)
            }

            set texture(value) {
                value ? this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP), this._shaderValues.setTexture(ShurikenParticleMaterial.DIFFUSETEXTURE, value)
            }

            set depthWrite(value) {
                this._shaderValues.setBool(ShurikenParticleMaterial.DEPTH_WRITE, value)
            }

            get depthWrite() {
                return this._shaderValues.getBool(ShurikenParticleMaterial.DEPTH_WRITE)
            }

            set cull(value) {
                this._shaderValues.setInt(ShurikenParticleMaterial.CULL, value)
            }

            get cull() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.CULL)
            }

            set blend(value) {
                this._shaderValues.setInt(ShurikenParticleMaterial.BLEND, value)
            }

            get blend() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND)
            }

            set blendSrc(value) {
                this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_SRC, value)
            }

            get blendSrc() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_SRC)
            }

            set blendDst(value) {
                this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_DST, value)
            }

            get blendDst() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_DST)
            }

            set depthTest(value) {
                this._shaderValues.setInt(ShurikenParticleMaterial.DEPTH_TEST, value)
            }

            get depthTest() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.DEPTH_TEST)
            }

            clone() {
                var dest = new ShurikenParticleMaterial;
                return this.cloneTo(dest), dest
            }
        }

        ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED = 0, ShurikenParticleMaterial.RENDERMODE_ADDTIVE = 1, ShurikenParticleMaterial.DIFFUSETEXTURE = Shader3D.propertyNameToID("u_texture"), ShurikenParticleMaterial.TINTCOLOR = Shader3D.propertyNameToID("u_Tintcolor"), ShurikenParticleMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset"), ShurikenParticleMaterial.CULL = Shader3D.propertyNameToID("s_Cull"), ShurikenParticleMaterial.BLEND = Shader3D.propertyNameToID("s_Blend"), ShurikenParticleMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc"), ShurikenParticleMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst"), ShurikenParticleMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest"), ShurikenParticleMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite"), ShurikenParticleMaterial.shaderDefines = null;

        class ShuriKenParticle3DShaderDeclaration {
        }

        ShuriKenParticle3DShaderDeclaration.WORLDPOSITION = Shader3D.propertyNameToID("u_WorldPosition"), ShuriKenParticle3DShaderDeclaration.WORLDROTATION = Shader3D.propertyNameToID("u_WorldRotation"), ShuriKenParticle3DShaderDeclaration.POSITIONSCALE = Shader3D.propertyNameToID("u_PositionScale"), ShuriKenParticle3DShaderDeclaration.SIZESCALE = Shader3D.propertyNameToID("u_SizeScale"), ShuriKenParticle3DShaderDeclaration.SCALINGMODE = Shader3D.propertyNameToID("u_ScalingMode"), ShuriKenParticle3DShaderDeclaration.GRAVITY = Shader3D.propertyNameToID("u_Gravity"), ShuriKenParticle3DShaderDeclaration.THREEDSTARTROTATION = Shader3D.propertyNameToID("u_ThreeDStartRotation"), ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDLENGTHSCALE = Shader3D.propertyNameToID("u_StretchedBillboardLengthScale"), ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDSPEEDSCALE = Shader3D.propertyNameToID("u_StretchedBillboardSpeedScale"), ShuriKenParticle3DShaderDeclaration.SIMULATIONSPACE = Shader3D.propertyNameToID("u_SimulationSpace"), ShuriKenParticle3DShaderDeclaration.CURRENTTIME = Shader3D.propertyNameToID("u_CurrentTime"), ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST = Shader3D.propertyNameToID("u_VOLVelocityConst"), ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX = Shader3D.propertyNameToID("u_VOLVelocityGradientX"), ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY = Shader3D.propertyNameToID("u_VOLVelocityGradientY"), ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ = Shader3D.propertyNameToID("u_VOLVelocityGradientZ"), ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONSTMAX = Shader3D.propertyNameToID("u_VOLVelocityConstMax"), ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTXMAX = Shader3D.propertyNameToID("u_VOLVelocityGradientMaxX"), ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTYMAX = Shader3D.propertyNameToID("u_VOLVelocityGradientMaxY"), ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZMAX = Shader3D.propertyNameToID("u_VOLVelocityGradientMaxZ"), ShuriKenParticle3DShaderDeclaration.VOLSPACETYPE = Shader3D.propertyNameToID("u_VOLSpaceType"), ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS = Shader3D.propertyNameToID("u_ColorOverLifeGradientAlphas"), ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS = Shader3D.propertyNameToID("u_ColorOverLifeGradientColors"), ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTALPHAS = Shader3D.propertyNameToID("u_MaxColorOverLifeGradientAlphas"), ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTCOLORS = Shader3D.propertyNameToID("u_MaxColorOverLifeGradientColors"), ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENT = Shader3D.propertyNameToID("u_SOLSizeGradient"), ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTX = Shader3D.propertyNameToID("u_SOLSizeGradientX"), ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTY = Shader3D.propertyNameToID("u_SOLSizeGradientY"), ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZ = Shader3D.propertyNameToID("u_SOLSizeGradientZ"), ShuriKenParticle3DShaderDeclaration.SOLSizeGradientMax = Shader3D.propertyNameToID("u_SOLSizeGradientMax"), ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTXMAX = Shader3D.propertyNameToID("u_SOLSizeGradientMaxX"), ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTYMAX = Shader3D.propertyNameToID("u_SOLSizeGradientMaxY"), ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZMAX = Shader3D.propertyNameToID("u_SOLSizeGradientMaxZ"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONST = Shader3D.propertyNameToID("u_ROLAngularVelocityConst"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTSEPRARATE = Shader3D.propertyNameToID("u_ROLAngularVelocityConstSeprarate"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENT = Shader3D.propertyNameToID("u_ROLAngularVelocityGradient"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTX = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientX"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTY = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientY"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZ = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientZ"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAX = Shader3D.propertyNameToID("u_ROLAngularVelocityConstMax"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAXSEPRARATE = Shader3D.propertyNameToID("u_ROLAngularVelocityConstMaxSeprarate"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTMAX = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMax"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTXMAX = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxX"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTYMAX = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxY"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZMAX = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxZ"), ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTWMAX = Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxW"), ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONCYCLES = Shader3D.propertyNameToID("u_TSACycles"), ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONSUBUVLENGTH = Shader3D.propertyNameToID("u_TSASubUVLength"), ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTUVS = Shader3D.propertyNameToID("u_TSAGradientUVs"), ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTMAXUVS = Shader3D.propertyNameToID("u_TSAMaxGradientUVs");

        class ShurikenParticleRenderer extends BaseRender {
            constructor(owner) {
                super(owner), this._finalGravity = new Vector3, this._tempRotationMatrix = new Matrix4x4, this._renderMode = 0, this._mesh = null, this.stretchedBillboardCameraSpeedScale = 0, this.stretchedBillboardSpeedScale = 0, this.stretchedBillboardLengthScale = 0, this._defaultBoundBox = new BoundBox(new Vector3, new Vector3), this._renderMode = -1, this.stretchedBillboardCameraSpeedScale = 0, this.stretchedBillboardSpeedScale = 0, this.stretchedBillboardLengthScale = 1, this._supportOctree = !1
            }

            get renderMode() {
                return this._renderMode
            }

            get mesh() {
                return this._mesh
            }

            set mesh(value) {
                this._mesh !== value && (this._mesh && this._mesh._removeReference(), this._mesh = value, value && value._addReference(), this._owner.particleSystem._initBufferDatas())
            }

            set renderMode(value) {
                if (this._renderMode !== value) {
                    var defineDatas = this._shaderValues;
                    switch (this._renderMode) {
                        case 0:
                            defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_BILLBOARD);
                            break;
                        case 1:
                            defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                            break;
                        case 2:
                            defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                            break;
                        case 3:
                            defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                            break;
                        case 4:
                            defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_MESH)
                    }
                    switch (this._renderMode = value, value) {
                        case 0:
                            defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_BILLBOARD);
                            break;
                        case 1:
                            defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                            break;
                        case 2:
                            defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                            break;
                        case 3:
                            defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                            break;
                        case 4:
                            defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_MESH);
                            break;
                        default:
                            throw new Error("ShurikenParticleRender: unknown renderMode Value.")
                    }
                    this._owner.particleSystem._initBufferDatas()
                }
            }

            _calculateBoundingBox() {
                if ((min = this._bounds.getMin()).x = -Number.MAX_VALUE, min.y = -Number.MAX_VALUE, min.z = -Number.MAX_VALUE, this._bounds.setMin(min), (max = this._bounds.getMax()).x = Number.MAX_VALUE, max.y = Number.MAX_VALUE, max.z = Number.MAX_VALUE, this._bounds.setMax(max), Laya.Render.supportWebGLPlusCulling) {
                    var min = this._bounds.getMin(), max = this._bounds.getMax(),
                        buffer = FrustumCulling._cullingBuffer;
                    buffer[this._cullingBufferIndex + 1] = min.x, buffer[this._cullingBufferIndex + 2] = min.y, buffer[this._cullingBufferIndex + 3] = min.z, buffer[this._cullingBufferIndex + 4] = max.x, buffer[this._cullingBufferIndex + 5] = max.y, buffer[this._cullingBufferIndex + 6] = max.z
                }
            }

            _needRender(boundFrustum, context) {
                return !boundFrustum || !!boundFrustum.intersects(this.bounds._getBoundBox()) && !!this._owner.particleSystem.isAlive
            }

            _renderUpdate(context, transfrom) {
                var particleSystem = this._owner.particleSystem, sv = this._shaderValues,
                    transform = this._owner.transform;
                switch (particleSystem.simulationSpace) {
                    case 0:
                        break;
                    case 1:
                        sv.setVector3(ShuriKenParticle3DShaderDeclaration.WORLDPOSITION, transform.position), sv.setQuaternion(ShuriKenParticle3DShaderDeclaration.WORLDROTATION, transform.rotation);
                        break;
                    default:
                        throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.")
                }
                switch (particleSystem.scaleMode) {
                    case 0:
                        var scale = transform.getWorldLossyScale();
                        sv.setVector3(ShuriKenParticle3DShaderDeclaration.POSITIONSCALE, scale), sv.setVector3(ShuriKenParticle3DShaderDeclaration.SIZESCALE, scale);
                        break;
                    case 1:
                        var localScale = transform.localScale;
                        sv.setVector3(ShuriKenParticle3DShaderDeclaration.POSITIONSCALE, localScale), sv.setVector3(ShuriKenParticle3DShaderDeclaration.SIZESCALE, localScale);
                        break;
                    case 2:
                        sv.setVector3(ShuriKenParticle3DShaderDeclaration.POSITIONSCALE, transform.getWorldLossyScale()), sv.setVector3(ShuriKenParticle3DShaderDeclaration.SIZESCALE, Vector3._ONE)
                }
                Vector3.scale(Physics3DUtils.gravity, particleSystem.gravityModifier, this._finalGravity), sv.setVector3(ShuriKenParticle3DShaderDeclaration.GRAVITY, this._finalGravity), sv.setInt(ShuriKenParticle3DShaderDeclaration.SIMULATIONSPACE, particleSystem.simulationSpace), sv.setBool(ShuriKenParticle3DShaderDeclaration.THREEDSTARTROTATION, particleSystem.threeDStartRotation), sv.setInt(ShuriKenParticle3DShaderDeclaration.SCALINGMODE, particleSystem.scaleMode), sv.setNumber(ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDLENGTHSCALE, this.stretchedBillboardLengthScale), sv.setNumber(ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDSPEEDSCALE, this.stretchedBillboardSpeedScale), sv.setNumber(ShuriKenParticle3DShaderDeclaration.CURRENTTIME, particleSystem._currentTime)
            }

            get bounds() {
                return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1), this._bounds
            }

            _destroy() {
                super._destroy(), this._mesh && (this._mesh._removeReference(), this._mesh = null)
            }
        }

        class ShurikenParticleData {
            constructor() {
            }

            static _getStartLifetimeFromGradient(startLifeTimeGradient, emissionTime) {
                for (var i = 1, n = startLifeTimeGradient.gradientCount; i < n; i++) {
                    var key = startLifeTimeGradient.getKeyByIndex(i);
                    if (key >= emissionTime) {
                        var lastKey = startLifeTimeGradient.getKeyByIndex(i - 1),
                            age = (emissionTime - lastKey) / (key - lastKey);
                        return Laya.MathUtil.lerp(startLifeTimeGradient.getValueByIndex(i - 1), startLifeTimeGradient.getValueByIndex(i), age)
                    }
                }
                throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.")
            }

            static _randomInvertRoationArray(rotatonE, outE, randomizeRotationDirection, rand, randomSeeds) {
                var randDic;
                rand ? (rand.seed = randomSeeds[6], randDic = rand.getFloat(), randomSeeds[6] = rand.seed) : randDic = Math.random(), randDic < randomizeRotationDirection ? (outE.x = -rotatonE.x, outE.y = -rotatonE.y, outE.z = -rotatonE.z) : (outE.x = rotatonE.x, outE.y = rotatonE.y, outE.z = rotatonE.z)
            }

            static _randomInvertRoation(rotaton, randomizeRotationDirection, rand, randomSeeds) {
                var randDic;
                return rand ? (rand.seed = randomSeeds[6], randDic = rand.getFloat(), randomSeeds[6] = rand.seed) : randDic = Math.random(), randDic < randomizeRotationDirection && (rotaton = -rotaton), rotaton
            }

            static create(particleSystem, particleRender, transform) {
                var autoRandomSeed = particleSystem.autoRandomSeed, rand = particleSystem._rand,
                    randomSeeds = particleSystem._randomSeeds;
                switch (particleSystem.startColorType) {
                    case 0:
                        var constantStartColor = particleSystem.startColorConstant;
                        ShurikenParticleData.startColor.x = constantStartColor.x, ShurikenParticleData.startColor.y = constantStartColor.y, ShurikenParticleData.startColor.z = constantStartColor.z, ShurikenParticleData.startColor.w = constantStartColor.w;
                        break;
                    case 2:
                        autoRandomSeed ? Vector4.lerp(particleSystem.startColorConstantMin, particleSystem.startColorConstantMax, Math.random(), ShurikenParticleData.startColor) : (rand.seed = randomSeeds[3], Vector4.lerp(particleSystem.startColorConstantMin, particleSystem.startColorConstantMax, rand.getFloat(), ShurikenParticleData.startColor), randomSeeds[3] = rand.seed)
                }
                var colorOverLifetime = particleSystem.colorOverLifetime;
                if (colorOverLifetime && colorOverLifetime.enbale) {
                    var color = colorOverLifetime.color;
                    switch (color.type) {
                        case 0:
                            ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * color.constant.x, ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * color.constant.y, ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * color.constant.z, ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * color.constant.w;
                            break;
                        case 2:
                            var colorRandom;
                            autoRandomSeed ? colorRandom = Math.random() : (rand.seed = randomSeeds[10], colorRandom = rand.getFloat(), randomSeeds[10] = rand.seed);
                            var minConstantColor = color.constantMin, maxConstantColor = color.constantMax;
                            ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * Laya.MathUtil.lerp(minConstantColor.x, maxConstantColor.x, colorRandom), ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * Laya.MathUtil.lerp(minConstantColor.y, maxConstantColor.y, colorRandom), ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * Laya.MathUtil.lerp(minConstantColor.z, maxConstantColor.z, colorRandom), ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * Laya.MathUtil.lerp(minConstantColor.w, maxConstantColor.w, colorRandom)
                    }
                }
                var particleSize = ShurikenParticleData.startSize;
                switch (particleSystem.startSizeType) {
                    case 0:
                        if (particleSystem.threeDStartSize) {
                            var startSizeConstantSeparate = particleSystem.startSizeConstantSeparate;
                            particleSize[0] = startSizeConstantSeparate.x, particleSize[1] = startSizeConstantSeparate.y, particleSize[2] = startSizeConstantSeparate.z
                        } else particleSize[0] = particleSize[1] = particleSize[2] = particleSystem.startSizeConstant;
                        break;
                    case 2:
                        if (particleSystem.threeDStartSize) {
                            var startSizeConstantMinSeparate = particleSystem.startSizeConstantMinSeparate,
                                startSizeConstantMaxSeparate = particleSystem.startSizeConstantMaxSeparate;
                            autoRandomSeed ? (particleSize[0] = Laya.MathUtil.lerp(startSizeConstantMinSeparate.x, startSizeConstantMaxSeparate.x, Math.random()), particleSize[1] = Laya.MathUtil.lerp(startSizeConstantMinSeparate.y, startSizeConstantMaxSeparate.y, Math.random()), particleSize[2] = Laya.MathUtil.lerp(startSizeConstantMinSeparate.z, startSizeConstantMaxSeparate.z, Math.random())) : (rand.seed = randomSeeds[4], particleSize[0] = Laya.MathUtil.lerp(startSizeConstantMinSeparate.x, startSizeConstantMaxSeparate.x, rand.getFloat()), particleSize[1] = Laya.MathUtil.lerp(startSizeConstantMinSeparate.y, startSizeConstantMaxSeparate.y, rand.getFloat()), particleSize[2] = Laya.MathUtil.lerp(startSizeConstantMinSeparate.z, startSizeConstantMaxSeparate.z, rand.getFloat()), randomSeeds[4] = rand.seed)
                        } else autoRandomSeed ? particleSize[0] = particleSize[1] = particleSize[2] = Laya.MathUtil.lerp(particleSystem.startSizeConstantMin, particleSystem.startSizeConstantMax, Math.random()) : (rand.seed = randomSeeds[4], particleSize[0] = particleSize[1] = particleSize[2] = Laya.MathUtil.lerp(particleSystem.startSizeConstantMin, particleSystem.startSizeConstantMax, rand.getFloat()), randomSeeds[4] = rand.seed)
                }
                var sizeOverLifetime = particleSystem.sizeOverLifetime;
                if (sizeOverLifetime && sizeOverLifetime.enbale && 1 === sizeOverLifetime.size.type) {
                    var randomSize, size = sizeOverLifetime.size;
                    if (size.separateAxes) autoRandomSeed ? (particleSize[0] = particleSize[0] * Laya.MathUtil.lerp(size.constantMinSeparate.x, size.constantMaxSeparate.x, Math.random()), particleSize[1] = particleSize[1] * Laya.MathUtil.lerp(size.constantMinSeparate.y, size.constantMaxSeparate.y, Math.random()), particleSize[2] = particleSize[2] * Laya.MathUtil.lerp(size.constantMinSeparate.z, size.constantMaxSeparate.z, Math.random())) : (rand.seed = randomSeeds[11], particleSize[0] = particleSize[0] * Laya.MathUtil.lerp(size.constantMinSeparate.x, size.constantMaxSeparate.x, rand.getFloat()), particleSize[1] = particleSize[1] * Laya.MathUtil.lerp(size.constantMinSeparate.y, size.constantMaxSeparate.y, rand.getFloat()), particleSize[2] = particleSize[2] * Laya.MathUtil.lerp(size.constantMinSeparate.z, size.constantMaxSeparate.z, rand.getFloat()), randomSeeds[11] = rand.seed); else autoRandomSeed ? randomSize = Laya.MathUtil.lerp(size.constantMin, size.constantMax, Math.random()) : (rand.seed = randomSeeds[11], randomSize = Laya.MathUtil.lerp(size.constantMin, size.constantMax, rand.getFloat()), randomSeeds[11] = rand.seed), particleSize[0] = particleSize[0] * randomSize, particleSize[1] = particleSize[1] * randomSize, particleSize[2] = particleSize[2] * randomSize
                }
                var renderMode = particleRender.renderMode;
                if (1 !== renderMode) switch (particleSystem.startRotationType) {
                    case 0:
                        if (particleSystem.threeDStartRotation) {
                            var startRotationConstantSeparate = particleSystem.startRotationConstantSeparate,
                                randomRotationE = ShurikenParticleData._tempVector30;
                            ShurikenParticleData._randomInvertRoationArray(startRotationConstantSeparate, randomRotationE, particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds), ShurikenParticleData.startRotation[0] = randomRotationE.x, ShurikenParticleData.startRotation[1] = randomRotationE.y, ShurikenParticleData.startRotation[2] = 4 !== renderMode ? -randomRotationE.z : randomRotationE.z
                        } else ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(particleSystem.startRotationConstant, particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds), ShurikenParticleData.startRotation[1] = 0, ShurikenParticleData.startRotation[2] = 0;
                        break;
                    case 2:
                        if (particleSystem.threeDStartRotation) {
                            var startRotationConstantMinSeparate = particleSystem.startRotationConstantMinSeparate,
                                startRotationConstantMaxSeparate = particleSystem.startRotationConstantMaxSeparate,
                                lerpRoationE = ShurikenParticleData._tempVector30;
                            autoRandomSeed ? (lerpRoationE.x = Laya.MathUtil.lerp(startRotationConstantMinSeparate.x, startRotationConstantMaxSeparate.x, Math.random()), lerpRoationE.y = Laya.MathUtil.lerp(startRotationConstantMinSeparate.y, startRotationConstantMaxSeparate.y, Math.random()), lerpRoationE.z = Laya.MathUtil.lerp(startRotationConstantMinSeparate.z, startRotationConstantMaxSeparate.z, Math.random())) : (rand.seed = randomSeeds[5], lerpRoationE.x = Laya.MathUtil.lerp(startRotationConstantMinSeparate.x, startRotationConstantMaxSeparate.x, rand.getFloat()), lerpRoationE.y = Laya.MathUtil.lerp(startRotationConstantMinSeparate.y, startRotationConstantMaxSeparate.y, rand.getFloat()), lerpRoationE.z = Laya.MathUtil.lerp(startRotationConstantMinSeparate.z, startRotationConstantMaxSeparate.z, rand.getFloat()), randomSeeds[5] = rand.seed), ShurikenParticleData._randomInvertRoationArray(lerpRoationE, lerpRoationE, particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds), ShurikenParticleData.startRotation[0] = lerpRoationE.x, ShurikenParticleData.startRotation[1] = lerpRoationE.y, ShurikenParticleData.startRotation[2] = 4 !== renderMode ? -lerpRoationE.z : lerpRoationE.z
                        } else autoRandomSeed ? ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(Laya.MathUtil.lerp(particleSystem.startRotationConstantMin, particleSystem.startRotationConstantMax, Math.random()), particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds) : (rand.seed = randomSeeds[5], ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(Laya.MathUtil.lerp(particleSystem.startRotationConstantMin, particleSystem.startRotationConstantMax, rand.getFloat()), particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds), randomSeeds[5] = rand.seed)
                }
                switch (particleSystem.startLifetimeType) {
                    case 0:
                        ShurikenParticleData.startLifeTime = particleSystem.startLifetimeConstant;
                        break;
                    case 1:
                        ShurikenParticleData.startLifeTime = ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradient, particleSystem.emissionTime);
                        break;
                    case 2:
                        autoRandomSeed ? ShurikenParticleData.startLifeTime = Laya.MathUtil.lerp(particleSystem.startLifetimeConstantMin, particleSystem.startLifetimeConstantMax, Math.random()) : (rand.seed = randomSeeds[7], ShurikenParticleData.startLifeTime = Laya.MathUtil.lerp(particleSystem.startLifetimeConstantMin, particleSystem.startLifetimeConstantMax, rand.getFloat()), randomSeeds[7] = rand.seed);
                        break;
                    case 3:
                        var emissionTime = particleSystem.emissionTime;
                        autoRandomSeed ? ShurikenParticleData.startLifeTime = Laya.MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin, emissionTime), ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax, emissionTime), Math.random()) : (rand.seed = randomSeeds[7], ShurikenParticleData.startLifeTime = Laya.MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin, emissionTime), ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax, emissionTime), rand.getFloat()), randomSeeds[7] = rand.seed)
                }
                switch (particleSystem.startSpeedType) {
                    case 0:
                        ShurikenParticleData.startSpeed = particleSystem.startSpeedConstant;
                        break;
                    case 2:
                        autoRandomSeed ? ShurikenParticleData.startSpeed = Laya.MathUtil.lerp(particleSystem.startSpeedConstantMin, particleSystem.startSpeedConstantMax, Math.random()) : (rand.seed = randomSeeds[8], ShurikenParticleData.startSpeed = Laya.MathUtil.lerp(particleSystem.startSpeedConstantMin, particleSystem.startSpeedConstantMax, rand.getFloat()), randomSeeds[8] = rand.seed)
                }
                var textureSheetAnimation = particleSystem.textureSheetAnimation;
                if (textureSheetAnimation && textureSheetAnimation.enable) {
                    var startFrameCount, title = textureSheetAnimation.tiles, titleX = title.x, titleY = title.y,
                        subU = 1 / titleX, subV = 1 / titleY, startFrame = textureSheetAnimation.startFrame;
                    switch (startFrame.type) {
                        case 0:
                            startFrameCount = startFrame.constant;
                            break;
                        case 1:
                            autoRandomSeed ? startFrameCount = Laya.MathUtil.lerp(startFrame.constantMin, startFrame.constantMax, Math.random()) : (rand.seed = randomSeeds[14], startFrameCount = Laya.MathUtil.lerp(startFrame.constantMin, startFrame.constantMax, rand.getFloat()), randomSeeds[14] = rand.seed)
                    }
                    var frame = textureSheetAnimation.frame;
                    switch (frame.type) {
                        case 0:
                            startFrameCount += frame.constant;
                            break;
                        case 2:
                            autoRandomSeed ? startFrameCount += Laya.MathUtil.lerp(frame.constantMin, frame.constantMax, Math.random()) : (rand.seed = randomSeeds[15], startFrameCount += Laya.MathUtil.lerp(frame.constantMin, frame.constantMax, rand.getFloat()), randomSeeds[15] = rand.seed)
                    }
                    var startRow = 0;
                    switch (textureSheetAnimation.type) {
                        case 0:
                            startRow = Math.floor(startFrameCount / titleX);
                            break;
                        case 1:
                            textureSheetAnimation.randomRow ? autoRandomSeed ? startRow = Math.floor(Math.random() * titleY) : (rand.seed = randomSeeds[13], startRow = Math.floor(rand.getFloat() * titleY), randomSeeds[13] = rand.seed) : startRow = textureSheetAnimation.rowIndex
                    }
                    var startCol = Math.floor(startFrameCount % titleX);
                    ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo, ShurikenParticleData.startUVInfo[0] = subU, ShurikenParticleData.startUVInfo[1] = subV, ShurikenParticleData.startUVInfo[2] = startCol * subU, ShurikenParticleData.startUVInfo[3] = startRow * subV
                } else ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo, ShurikenParticleData.startUVInfo[0] = 1, ShurikenParticleData.startUVInfo[1] = 1, ShurikenParticleData.startUVInfo[2] = 0, ShurikenParticleData.startUVInfo[3] = 0;
                switch (particleSystem.simulationSpace) {
                    case 0:
                        var position = transform.position;
                        ShurikenParticleData.simulationWorldPostion[0] = position.x, ShurikenParticleData.simulationWorldPostion[1] = position.y, ShurikenParticleData.simulationWorldPostion[2] = position.z;
                        var rotation = transform.rotation;
                        ShurikenParticleData.simulationWorldRotation[0] = rotation.x, ShurikenParticleData.simulationWorldRotation[1] = rotation.y, ShurikenParticleData.simulationWorldRotation[2] = rotation.z, ShurikenParticleData.simulationWorldRotation[3] = rotation.w;
                        break;
                    case 1:
                        break;
                    default:
                        throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.")
                }
            }
        }

        ShurikenParticleData._tempVector30 = new Vector3, ShurikenParticleData._tempQuaternion = new Quaternion, ShurikenParticleData.startColor = new Vector4, ShurikenParticleData.startSize = new Float32Array(3), ShurikenParticleData.startRotation = new Float32Array(3), ShurikenParticleData.startUVInfo = new Float32Array(4), ShurikenParticleData.simulationWorldPostion = new Float32Array(3), ShurikenParticleData.simulationWorldRotation = new Float32Array(4);

        class Emission {
            set emissionRate(value) {
                if (value < 0) throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
                this._emissionRate = value
            }

            get emissionRate() {
                return this._emissionRate
            }

            get destroyed() {
                return this._destroyed
            }

            constructor() {
                this._destroyed = !1, this.emissionRate = 10, this._bursts = []
            }

            destroy() {
                this._bursts = null, this._destroyed = !0
            }

            getBurstsCount() {
                return this._bursts.length
            }

            getBurstByIndex(index) {
                return this._bursts[index]
            }

            addBurst(burst) {
                var burstsCount = this._bursts.length;
                if (burstsCount > 0) for (var i = 0; i < burstsCount; i++) this._bursts[i].time > burst.time && this._bursts.splice(i, 0, burst);
                this._bursts.push(burst)
            }

            removeBurst(burst) {
                var index = this._bursts.indexOf(burst);
                -1 !== index && this._bursts.splice(index, 1)
            }

            removeBurstByIndex(index) {
                this._bursts.splice(index, 1)
            }

            clearBurst() {
                this._bursts.length = 0
            }

            cloneTo(destObject) {
                var destEmission = destObject, destBursts = destEmission._bursts;
                destBursts.length = this._bursts.length;
                for (var i = 0, n = this._bursts.length; i < n; i++) {
                    var destBurst = destBursts[i];
                    destBurst ? this._bursts[i].cloneTo(destBurst) : destBursts[i] = this._bursts[i].clone()
                }
                destEmission._emissionRate = this._emissionRate, destEmission.enbale = this.enbale
            }

            clone() {
                var destEmission = new Emission;
                return this.cloneTo(destEmission), destEmission
            }
        }

        class GradientDataNumber {
            constructor() {
                this._currentLength = 0, this._elements = new Float32Array(8)
            }

            get gradientCount() {
                return this._currentLength / 2
            }

            add(key, value) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== key && (key = 1, console.log("GradientDataNumber warning:the forth key is  be force set to 1.")), this._elements[this._currentLength++] = key, this._elements[this._currentLength++] = value) : console.log("GradientDataNumber warning:data count must lessEqual than 4")
            }

            getKeyByIndex(index) {
                return this._elements[2 * index]
            }

            getValueByIndex(index) {
                return this._elements[2 * index + 1]
            }

            getAverageValue() {
                for (var i = 0, n = this._currentLength - 2; i < n; i += 2) {
                    this._elements[i + 1];
                    this._elements[i + 3], this._elements[i + 2] - this._elements[i]
                }
                return 0
            }

            cloneTo(destObject) {
                var destGradientDataNumber = destObject;
                destGradientDataNumber._currentLength = this._currentLength;
                for (var destElements = destGradientDataNumber._elements, i = 0, n = this._elements.length; i < n; i++) destElements[i] = this._elements[i]
            }

            clone() {
                var destGradientDataNumber = new GradientDataNumber;
                return this.cloneTo(destGradientDataNumber), destGradientDataNumber
            }
        }

        class VertexShuriKenParticle {
            constructor() {
            }
        }

        VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0 = 0, VertexShuriKenParticle.PARTICLE_POSITION0 = 1, VertexShuriKenParticle.PARTICLE_COLOR0 = 2, VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0 = 3, VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME = 4, VertexShuriKenParticle.PARTICLE_DIRECTIONTIME = 5, VertexShuriKenParticle.PARTICLE_STARTCOLOR0 = 6, VertexShuriKenParticle.PARTICLE_ENDCOLOR0 = 7, VertexShuriKenParticle.PARTICLE_STARTSIZE = 8, VertexShuriKenParticle.PARTICLE_STARTROTATION = 9, VertexShuriKenParticle.PARTICLE_STARTSPEED = 10, VertexShuriKenParticle.PARTICLE_RANDOM0 = 11, VertexShuriKenParticle.PARTICLE_RANDOM1 = 12, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION = 13, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION = 14;

        class VertexShurikenParticleBillboard extends VertexShuriKenParticle {
            static get vertexDeclaration() {
                return VertexShurikenParticleBillboard._vertexDeclaration
            }

            static __init__() {
                VertexShurikenParticleBillboard._vertexDeclaration = new VertexDeclaration(152, [new VertexElement(0, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0), new VertexElement(16, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new VertexElement(32, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_DIRECTIONTIME), new VertexElement(48, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_STARTCOLOR0), new VertexElement(64, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTSIZE), new VertexElement(76, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTROTATION), new VertexElement(88, VertexElementFormat.Single, VertexShuriKenParticle.PARTICLE_STARTSPEED), new VertexElement(92, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM0), new VertexElement(108, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM1), new VertexElement(124, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION), new VertexElement(136, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION)])
            }

            get cornerTextureCoordinate() {
                return this._cornerTextureCoordinate
            }

            get positionStartLifeTime() {
                return this._positionStartLifeTime
            }

            get velocity() {
                return this._velocity
            }

            get startColor() {
                return this._startColor
            }

            get startSize() {
                return this._startSize
            }

            get startRotation0() {
                return this._startRotation0
            }

            get startRotation1() {
                return this._startRotation1
            }

            get startRotation2() {
                return this._startRotation2
            }

            get startLifeTime() {
                return this._startLifeTime
            }

            get time() {
                return this._time
            }

            get startSpeed() {
                return this._startSpeed
            }

            get random0() {
                return this._randoms0
            }

            get random1() {
                return this._randoms1
            }

            get simulationWorldPostion() {
                return this._simulationWorldPostion
            }

            constructor(cornerTextureCoordinate, positionStartLifeTime, velocity, startColor, startSize, startRotation0, startRotation1, startRotation2, ageAddScale, time, startSpeed, randoms0, randoms1, simulationWorldPostion) {
                super(), this._cornerTextureCoordinate = cornerTextureCoordinate, this._positionStartLifeTime = positionStartLifeTime, this._velocity = velocity, this._startColor = startColor, this._startSize = startSize, this._startRotation0 = startRotation0, this._startRotation1 = startRotation1, this._startRotation2 = startRotation2, this._startLifeTime = ageAddScale, this._time = time, this._startSpeed = startSpeed, this._randoms0 = this.random0, this._randoms1 = this.random1, this._simulationWorldPostion = simulationWorldPostion
            }
        }

        class VertexShurikenParticleMesh extends VertexShuriKenParticle {
            static __init__() {
                VertexShurikenParticleMesh._vertexDeclaration = new VertexDeclaration(172, [new VertexElement(0, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_POSITION0), new VertexElement(12, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_COLOR0), new VertexElement(28, VertexElementFormat.Vector2, VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0), new VertexElement(36, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new VertexElement(52, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_DIRECTIONTIME), new VertexElement(68, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_STARTCOLOR0), new VertexElement(84, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTSIZE), new VertexElement(96, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTROTATION), new VertexElement(108, VertexElementFormat.Single, VertexShuriKenParticle.PARTICLE_STARTSPEED), new VertexElement(112, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM0), new VertexElement(128, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM1), new VertexElement(144, VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION), new VertexElement(156, VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION)])
            }

            static get vertexDeclaration() {
                return VertexShurikenParticleMesh._vertexDeclaration
            }

            get cornerTextureCoordinate() {
                return this._cornerTextureCoordinate
            }

            get position() {
                return this._positionStartLifeTime
            }

            get velocity() {
                return this._velocity
            }

            get startColor() {
                return this._startColor
            }

            get startSize() {
                return this._startSize
            }

            get startRotation0() {
                return this._startRotation0
            }

            get startRotation1() {
                return this._startRotation1
            }

            get startRotation2() {
                return this._startRotation2
            }

            get startLifeTime() {
                return this._startLifeTime
            }

            get time() {
                return this._time
            }

            get startSpeed() {
                return this._startSpeed
            }

            get random0() {
                return this._randoms0
            }

            get random1() {
                return this._randoms1
            }

            get simulationWorldPostion() {
                return this._simulationWorldPostion
            }

            constructor(cornerTextureCoordinate, positionStartLifeTime, velocity, startColor, startSize, startRotation0, startRotation1, startRotation2, ageAddScale, time, startSpeed, randoms0, randoms1, simulationWorldPostion) {
                super(), this._cornerTextureCoordinate = cornerTextureCoordinate, this._positionStartLifeTime = positionStartLifeTime, this._velocity = velocity, this._startColor = startColor, this._startSize = startSize, this._startRotation0 = startRotation0, this._startRotation1 = startRotation1, this._startRotation2 = startRotation2, this._startLifeTime = ageAddScale, this._time = time, this._startSpeed = startSpeed, this._randoms0 = this.random0, this._randoms1 = this.random1, this._simulationWorldPostion = simulationWorldPostion
            }
        }

        class Rand {
            constructor(seed) {
                this._temp = new Uint32Array(1), this.seeds = new Uint32Array(4), this.seeds[0] = seed, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1, this.seeds[3] = 1812433253 * this.seeds[2] + 1
            }

            static getFloatFromInt(v) {
                return 1 / 8388607 * (8388607 & v)
            }

            static getByteFromInt(v) {
                return (8388607 & v) >>> 15
            }

            get seed() {
                return this.seeds[0]
            }

            set seed(seed) {
                this.seeds[0] = seed, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1, this.seeds[3] = 1812433253 * this.seeds[2] + 1
            }

            getUint() {
                return this._temp[0] = this.seeds[0] ^ this.seeds[0] << 11, this.seeds[0] = this.seeds[1], this.seeds[1] = this.seeds[2], this.seeds[2] = this.seeds[3], this.seeds[3] = this.seeds[3] ^ this.seeds[3] >>> 19 ^ this._temp[0] ^ this._temp[0] >>> 8, this.seeds[3]
            }

            getFloat() {
                return this.getUint(), (8388607 & this.seeds[3]) * (1 / 8388607)
            }

            getSignedFloat() {
                return 2 * this.getFloat() - 1
            }
        }

        class ShurikenParticleSystem extends GeometryElement {
            constructor(owner) {
                super(), this._tempRotationMatrix = new Matrix4x4, this._boundingSphere = null, this._boundingBox = null, this._boundingBoxCorners = null, this._owner = null, this._ownerRender = null, this._vertices = null, this._floatCountPerVertex = 0, this._startLifeTimeIndex = 0, this._timeIndex = 0, this._simulateUpdate = !1, this._firstActiveElement = 0, this._firstNewElement = 0, this._firstFreeElement = 0, this._firstRetiredElement = 0, this._drawCounter = 0, this._bufferMaxParticles = 0, this._emission = null, this._shape = null, this._isEmitting = !1, this._isPlaying = !1, this._isPaused = !1, this._playStartDelay = 0, this._frameRateTime = 0, this._emissionTime = 0, this._totalDelayTime = 0, this._burstsIndex = 0, this._velocityOverLifetime = null, this._colorOverLifetime = null, this._sizeOverLifetime = null, this._rotationOverLifetime = null, this._textureSheetAnimation = null, this._startLifetimeType = 0, this._startLifetimeConstant = 0, this._startLifeTimeGradient = null, this._startLifetimeConstantMin = 0, this._startLifetimeConstantMax = 0, this._startLifeTimeGradientMin = null, this._startLifeTimeGradientMax = null, this._maxStartLifetime = 0, this._uvLength = new Vector2, this._vertexStride = 0, this._indexStride = 0, this._vertexBuffer = null, this._indexBuffer = null, this._bufferState = new BufferState, this._currentTime = 0, this._startUpdateLoopCount = 0, this._rand = null, this._randomSeeds = null, this.duration = 0, this.looping = !1, this.prewarm = !1, this.startDelayType = 0, this.startDelay = 0, this.startDelayMin = 0, this.startDelayMax = 0, this.startSpeedType = 0, this.startSpeedConstant = 0, this.startSpeedConstantMin = 0, this.startSpeedConstantMax = 0, this.threeDStartSize = !1, this.startSizeType = 0, this.startSizeConstant = 0, this.startSizeConstantSeparate = null, this.startSizeConstantMin = 0, this.startSizeConstantMax = 0, this.startSizeConstantMinSeparate = null, this.startSizeConstantMaxSeparate = null, this.threeDStartRotation = !1, this.startRotationType = 0, this.startRotationConstant = 0, this.startRotationConstantSeparate = null, this.startRotationConstantMin = 0, this.startRotationConstantMax = 0, this.startRotationConstantMinSeparate = null, this.startRotationConstantMaxSeparate = null, this.randomizeRotationDirection = 0, this.startColorType = 0, this.startColorConstant = null, this.startColorConstantMin = null, this.startColorConstantMax = null, this.gravityModifier = 0, this.simulationSpace = 0, this.scaleMode = 0, this.playOnAwake = !1, this.randomSeed = null, this.autoRandomSeed = !1, this.isPerformanceMode = !1, this._firstActiveElement = 0, this._firstNewElement = 0, this._firstFreeElement = 0, this._firstRetiredElement = 0, this._owner = owner, this._ownerRender = owner.particleRenderer, this._boundingBoxCorners = [], this._boundingSphere = new BoundSphere(new Vector3, Number.MAX_VALUE), this._boundingBox = new BoundBox(new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)), this._currentTime = 0, this._isEmitting = !1,this._isPlaying = !1,this._isPaused = !1,this._burstsIndex = 0,this._frameRateTime = 0,this._emissionTime = 0,this._totalDelayTime = 0,this._simulateUpdate = !1,this._bufferMaxParticles = 1,this.duration = 5,this.looping = !0,this.prewarm = !1,this.startDelayType = 0,this.startDelay = 0,this.startDelayMin = 0,this.startDelayMax = 0,this._startLifetimeType = 0,this._startLifetimeConstant = 5,this._startLifeTimeGradient = new GradientDataNumber,this._startLifetimeConstantMin = 0,this._startLifetimeConstantMax = 5,this._startLifeTimeGradientMin = new GradientDataNumber,this._startLifeTimeGradientMax = new GradientDataNumber,this._maxStartLifetime = 5,this.startSpeedType = 0,this.startSpeedConstant = 5,this.startSpeedConstantMin = 0,this.startSpeedConstantMax = 5,this.threeDStartSize = !1,this.startSizeType = 0,this.startSizeConstant = 1,this.startSizeConstantSeparate = new Vector3(1, 1, 1),this.startSizeConstantMin = 0,this.startSizeConstantMax = 1,this.startSizeConstantMinSeparate = new Vector3(0, 0, 0),this.startSizeConstantMaxSeparate = new Vector3(1, 1, 1),this.threeDStartRotation = !1,this.startRotationType = 0,this.startRotationConstant = 0,this.startRotationConstantSeparate = new Vector3(0, 0, 0),this.startRotationConstantMin = 0,this.startRotationConstantMax = 0,this.startRotationConstantMinSeparate = new Vector3(0, 0, 0),this.startRotationConstantMaxSeparate = new Vector3(0, 0, 0),this.randomizeRotationDirection = 0,this.startColorType = 0,this.startColorConstant = new Vector4(1, 1, 1, 1),this.startColorConstantMin = new Vector4(1, 1, 1, 1),this.startColorConstantMax = new Vector4(1, 1, 1, 1),this.gravityModifier = 0,this.simulationSpace = 1,this.scaleMode = 0,this.playOnAwake = !0,this._rand = new Rand(0),this.autoRandomSeed = !0,this.randomSeed = new Uint32Array(1),this._randomSeeds = new Uint32Array(ShurikenParticleSystem._RANDOMOFFSET.length),this.isPerformanceMode = !0,this._emission = new Emission,this._emission.enbale = !0
            }

            get maxParticles() {
                return this._bufferMaxParticles - 1
            }

            set maxParticles(value) {
                var newMaxParticles = value + 1;
                newMaxParticles !== this._bufferMaxParticles && (this._bufferMaxParticles = newMaxParticles, this._initBufferDatas())
            }

            get emission() {
                return this._emission
            }

            get aliveParticleCount() {
                return this._firstNewElement >= this._firstRetiredElement ? this._firstNewElement - this._firstRetiredElement : this._bufferMaxParticles - this._firstRetiredElement + this._firstNewElement
            }

            get emissionTime() {
                return this._emissionTime > this.duration ? this.duration : this._emissionTime
            }

            get shape() {
                return this._shape
            }

            set shape(value) {
                this._shape !== value && (value && value.enable ? this._owner._render._shaderValues.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SHAPE) : this._owner._render._shaderValues.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SHAPE), this._shape = value)
            }

            get isAlive() {
                return !!(this._isPlaying || this.aliveParticleCount > 0)
            }

            get isEmitting() {
                return this._isEmitting
            }

            get isPlaying() {
                return this._isPlaying
            }

            get isPaused() {
                return this._isPaused
            }

            get startLifetimeType() {
                return this._startLifetimeType
            }

            set startLifetimeType(value) {
                var i, n;
                switch (this.startLifetimeType) {
                    case 0:
                        this._maxStartLifetime = this.startLifetimeConstant;
                        break;
                    case 1:
                        this._maxStartLifetime = -Number.MAX_VALUE;
                        var startLifeTimeGradient = startLifeTimeGradient;
                        for (i = 0, n = startLifeTimeGradient.gradientCount; i < n; i++) this._maxStartLifetime = Math.max(this._maxStartLifetime, startLifeTimeGradient.getValueByIndex(i));
                        break;
                    case 2:
                        this._maxStartLifetime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                        break;
                    case 3:
                        this._maxStartLifetime = -Number.MAX_VALUE;
                        var startLifeTimeGradientMin = startLifeTimeGradientMin;
                        for (i = 0, n = startLifeTimeGradientMin.gradientCount; i < n; i++) this._maxStartLifetime = Math.max(this._maxStartLifetime, startLifeTimeGradientMin.getValueByIndex(i));
                        var startLifeTimeGradientMax = startLifeTimeGradientMax;
                        for (i = 0, n = startLifeTimeGradientMax.gradientCount; i < n; i++) this._maxStartLifetime = Math.max(this._maxStartLifetime, startLifeTimeGradientMax.getValueByIndex(i))
                }
                this._startLifetimeType = value
            }

            get startLifetimeConstant() {
                return this._startLifetimeConstant
            }

            set startLifetimeConstant(value) {
                0 === this._startLifetimeType && (this._maxStartLifetime = value), this._startLifetimeConstant = value
            }

            get startLifeTimeGradient() {
                return this._startLifeTimeGradient
            }

            set startLifeTimeGradient(value) {
                if (1 === this._startLifetimeType) {
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    for (var i = 0, n = value.gradientCount; i < n; i++) this._maxStartLifetime = Math.max(this._maxStartLifetime, value.getValueByIndex(i))
                }
                this._startLifeTimeGradient = value
            }

            get startLifetimeConstantMin() {
                return this._startLifetimeConstantMin
            }

            set startLifetimeConstantMin(value) {
                2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(value, this._startLifetimeConstantMax)), this._startLifetimeConstantMin = value
            }

            get startLifetimeConstantMax() {
                return this._startLifetimeConstantMax
            }

            set startLifetimeConstantMax(value) {
                2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(this._startLifetimeConstantMin, value)), this._startLifetimeConstantMax = value
            }

            get startLifeTimeGradientMin() {
                return this._startLifeTimeGradientMin
            }

            set startLifeTimeGradientMin(value) {
                if (3 === this._startLifetimeType) {
                    var i, n;
                    for (this._maxStartLifetime = -Number.MAX_VALUE, i = 0, n = value.gradientCount; i < n; i++) this._maxStartLifetime = Math.max(this._maxStartLifetime, value.getValueByIndex(i));
                    for (i = 0, n = this._startLifeTimeGradientMax.gradientCount; i < n; i++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMax.getValueByIndex(i))
                }
                this._startLifeTimeGradientMin = value
            }

            get startLifeTimeGradientMax() {
                return this._startLifeTimeGradientMax
            }

            set startLifeTimeGradientMax(value) {
                if (3 === this._startLifetimeType) {
                    var i, n;
                    for (this._maxStartLifetime = -Number.MAX_VALUE, i = 0, n = this._startLifeTimeGradientMin.gradientCount; i < n; i++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMin.getValueByIndex(i));
                    for (i = 0, n = value.gradientCount; i < n; i++) this._maxStartLifetime = Math.max(this._maxStartLifetime, value.getValueByIndex(i))
                }
                this._startLifeTimeGradientMax = value
            }

            get velocityOverLifetime() {
                return this._velocityOverLifetime
            }

            set velocityOverLifetime(value) {
                var shaDat = this._owner._render._shaderValues;
                if (value) {
                    var velocity = value.velocity, velocityType = velocity.type;
                    if (value.enbale) switch (velocityType) {
                        case 0:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                            break;
                        case 1:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                            break;
                        case 2:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                            break;
                        case 3:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE)
                    } else shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                    switch (velocityType) {
                        case 0:
                            shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST, velocity.constant);
                            break;
                        case 1:
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX, velocity.gradientX._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY, velocity.gradientY._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ, velocity.gradientZ._elements);
                            break;
                        case 2:
                            shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST, velocity.constantMin), shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONSTMAX, velocity.constantMax);
                            break;
                        case 3:
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX, velocity.gradientXMin._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTXMAX, velocity.gradientXMax._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY, velocity.gradientYMin._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTYMAX, velocity.gradientYMax._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ, velocity.gradientZMin._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZMAX, velocity.gradientZMax._elements)
                    }
                    shaDat.setInt(ShuriKenParticle3DShaderDeclaration.VOLSPACETYPE, value.space)
                } else shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE), shaDat.setVector(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ, null), shaDat.setVector(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST, null), shaDat.setVector(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONSTMAX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTXMAX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTYMAX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZMAX, null), shaDat.setInt(ShuriKenParticle3DShaderDeclaration.VOLSPACETYPE, void 0);
                this._velocityOverLifetime = value
            }

            get colorOverLifetime() {
                return this._colorOverLifetime
            }

            set colorOverLifetime(value) {
                var shaDat = this._owner._render._shaderValues;
                if (value) {
                    var color = value.color;
                    if (value.enbale) switch (color.type) {
                        case 1:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME);
                            break;
                        case 3:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME)
                    } else shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                    switch (color.type) {
                        case 1:
                            var gradientColor = color.gradient;
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, gradientColor._alphaElements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, gradientColor._rgbElements);
                            break;
                        case 3:
                            var minGradientColor = color.gradientMin, maxGradientColor = color.gradientMax;
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, minGradientColor._alphaElements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, minGradientColor._rgbElements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTALPHAS, maxGradientColor._alphaElements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTCOLORS, maxGradientColor._rgbElements)
                    }
                } else shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, gradientColor._alphaElements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, gradientColor._rgbElements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, minGradientColor._alphaElements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, minGradientColor._rgbElements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTALPHAS, maxGradientColor._alphaElements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTCOLORS, maxGradientColor._rgbElements);
                this._colorOverLifetime = value
            }

            get sizeOverLifetime() {
                return this._sizeOverLifetime
            }

            set sizeOverLifetime(value) {
                var shaDat = this._owner._render._shaderValues;
                if (value) {
                    var size = value.size, sizeSeparate = size.separateAxes, sizeType = size.type;
                    if (value.enbale) switch (sizeType) {
                        case 0:
                            sizeSeparate ? shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE) : shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                            break;
                        case 2:
                            sizeSeparate ? shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE) : shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES)
                    } else shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVE), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                    switch (sizeType) {
                        case 0:
                            sizeSeparate ? (shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTX, size.gradientX._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTY, size.gradientY._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZ, size.gradientZ._elements)) : shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENT, size.gradient._elements);
                            break;
                        case 2:
                            sizeSeparate ? (shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTX, size.gradientXMin._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTXMAX, size.gradientXMax._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTY, size.gradientYMin._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTYMAX, size.gradientYMax._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZ, size.gradientZMin._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZMAX, size.gradientZMax._elements)) : (shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENT, size.gradientMin._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientMax, size.gradientMax._elements))
                    }
                } else shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVE), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTXMAX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTY, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTYMAX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZ, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZMAX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENT, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientMax, null);
                this._sizeOverLifetime = value
            }

            get rotationOverLifetime() {
                return this._rotationOverLifetime
            }

            set rotationOverLifetime(value) {
                var shaDat = this._owner._render._shaderValues;
                if (value) {
                    var rotation = value.angularVelocity;
                    if (!rotation) return;
                    var rotationSeparate = rotation.separateAxes, rotationType = rotation.type;
                    if (value.enbale) switch (rotationSeparate ? shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE) : shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME), rotationType) {
                        case 0:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                            break;
                        case 1:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                            break;
                        case 2:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                            break;
                        case 3:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES)
                    } else shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                    switch (rotationType) {
                        case 0:
                            rotationSeparate ? shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTSEPRARATE, rotation.constantSeparate) : shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONST, rotation.constant);
                            break;
                        case 1:
                            rotationSeparate ? (shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTX, rotation.gradientX._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTY, rotation.gradientY._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZ, rotation.gradientZ._elements)) : shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENT, rotation.gradient._elements);
                            break;
                        case 2:
                            rotationSeparate ? (shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTSEPRARATE, rotation.constantMinSeparate), shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAXSEPRARATE, rotation.constantMaxSeparate)) : (shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONST, rotation.constantMin), shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAX, rotation.constantMax));
                            break;
                        case 3:
                            rotationSeparate ? (shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTX, rotation.gradientXMin._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTXMAX, rotation.gradientXMax._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTY, rotation.gradientYMin._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTYMAX, rotation.gradientYMax._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZ, rotation.gradientZMin._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZMAX, rotation.gradientZMax._elements)) : (shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENT, rotation.gradientMin._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTMAX, rotation.gradientMax._elements))
                    }
                } else shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES), shaDat.setVector(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTSEPRARATE, null), shaDat.setVector(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAXSEPRARATE, null), shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONST, void 0), shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAX, void 0), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTXMAX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTY, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTYMAX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZ, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZMAX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTWMAX, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENT, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTMAX, null);
                this._rotationOverLifetime = value
            }

            get textureSheetAnimation() {
                return this._textureSheetAnimation
            }

            set textureSheetAnimation(value) {
                var shaDat = this._owner._render._shaderValues;
                if (value) {
                    var frameOverTime = value.frame, textureAniType = frameOverTime.type;
                    if (value.enable) switch (textureAniType) {
                        case 1:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                            break;
                        case 3:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE)
                    } else shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                    if (1 === textureAniType || 3 === textureAniType) {
                        shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONCYCLES, value.cycles);
                        var title = value.tiles, _uvLengthE = this._uvLength;
                        _uvLengthE.x = 1 / title.x, _uvLengthE.y = 1 / title.y, shaDat.setVector2(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONSUBUVLENGTH, this._uvLength)
                    }
                    switch (textureAniType) {
                        case 1:
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTUVS, frameOverTime.frameOverTimeData._elements);
                            break;
                        case 3:
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTUVS, frameOverTime.frameOverTimeDataMin._elements), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTMAXUVS, frameOverTime.frameOverTimeDataMax._elements)
                    }
                } else shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE), shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONCYCLES, void 0), shaDat.setVector(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONSUBUVLENGTH, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTUVS, null), shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTMAXUVS, null);
                this._textureSheetAnimation = value
            }

            _getVertexBuffer(index = 0) {
                return 0 === index ? this._vertexBuffer : null
            }

            _getIndexBuffer() {
                return this._indexBuffer
            }

            _generateBoundingSphere() {
                var centerE = this._boundingSphere.center;
                centerE.x = 0, centerE.y = 0, centerE.z = 0, this._boundingSphere.radius = Number.MAX_VALUE
            }

            _generateBoundingBox() {
                var i, n, maxStartLifeTime, minStartSpeed, maxStartSpeed, minPosition, maxPosition, minDirection,
                    maxDirection, particleRender = this._owner.particleRenderer, boundMin = this._boundingBox.min,
                    boundMax = this._boundingBox.max;
                switch (this.startLifetimeType) {
                    case 0:
                        maxStartLifeTime = this.startLifetimeConstant;
                        break;
                    case 1:
                        maxStartLifeTime = -Number.MAX_VALUE;
                        var startLifeTimeGradient = startLifeTimeGradient;
                        for (i = 0, n = startLifeTimeGradient.gradientCount; i < n; i++) maxStartLifeTime = Math.max(maxStartLifeTime, startLifeTimeGradient.getValueByIndex(i));
                        break;
                    case 2:
                        maxStartLifeTime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                        break;
                    case 3:
                        maxStartLifeTime = -Number.MAX_VALUE;
                        var startLifeTimeGradientMin = startLifeTimeGradientMin;
                        for (i = 0, n = startLifeTimeGradientMin.gradientCount; i < n; i++) maxStartLifeTime = Math.max(maxStartLifeTime, startLifeTimeGradientMin.getValueByIndex(i));
                        var startLifeTimeGradientMax = startLifeTimeGradientMax;
                        for (i = 0, n = startLifeTimeGradientMax.gradientCount; i < n; i++) maxStartLifeTime = Math.max(maxStartLifeTime, startLifeTimeGradientMax.getValueByIndex(i))
                }
                switch (this.startSpeedType) {
                    case 0:
                        minStartSpeed = maxStartSpeed = this.startSpeedConstant;
                        break;
                    case 1:
                        break;
                    case 2:
                        minStartSpeed = this.startLifetimeConstantMin, maxStartSpeed = this.startLifetimeConstantMax
                }
                this._shape && this._shape.enable || (minPosition = maxPosition = Vector3._ZERO, minDirection = Vector3._ZERO, maxDirection = Vector3._UnitZ);
                var positionScale, velocityScale,
                    startMinVelocity = new Vector3(minDirection.x * minStartSpeed, minDirection.y * minStartSpeed, minDirection.z * minStartSpeed),
                    startMaxVelocity = new Vector3(maxDirection.x * maxStartSpeed, maxDirection.y * maxStartSpeed, maxDirection.z * maxStartSpeed);
                if (this._velocityOverLifetime && this._velocityOverLifetime.enbale) {
                    var velocity = this._velocityOverLifetime.velocity;
                    switch (velocity.type) {
                        case 0:
                            velocity.constant;
                            break;
                        case 1:
                            new Vector3(velocity.gradientX.getAverageValue(), velocity.gradientY.getAverageValue(), velocity.gradientZ.getAverageValue());
                            break;
                        case 2:
                            velocity.constantMin, velocity.constantMax;
                            break;
                        case 3:
                            new Vector3(velocity.gradientXMin.getAverageValue(), velocity.gradientYMin.getAverageValue(), velocity.gradientZMin.getAverageValue()), new Vector3(velocity.gradientXMax.getAverageValue(), velocity.gradientYMax.getAverageValue(), velocity.gradientZMax.getAverageValue())
                    }
                }
                var minStratPosition, maxStratPosition, maxSize, maxSizeY, transform = this._owner.transform,
                    worldPosition = transform.position, sizeScale = ShurikenParticleSystem._tempVector39,
                    renderMode = particleRender.renderMode;
                switch (this.scaleMode) {
                    case 0:
                        var scale = transform.getWorldLossyScale();
                        positionScale = scale, sizeScale.x = scale.x, sizeScale.y = scale.z, sizeScale.z = scale.y, 1 === renderMode && (velocityScale = scale);
                        break;
                    case 1:
                        var localScale = transform.localScale;
                        positionScale = localScale, sizeScale.x = localScale.x, sizeScale.y = localScale.z, sizeScale.z = localScale.y, 1 === renderMode && (velocityScale = localScale);
                        break;
                    case 2:
                        positionScale = transform.getWorldLossyScale(), sizeScale.x = sizeScale.y = sizeScale.z = 1, 1 === renderMode && (velocityScale = Vector3._ONE)
                }
                switch (this._velocityOverLifetime && this._velocityOverLifetime.enbale || (minStratPosition = new Vector3(startMinVelocity.x * maxStartLifeTime, startMinVelocity.y * maxStartLifeTime, startMinVelocity.z * maxStartLifeTime), maxStratPosition = new Vector3(startMaxVelocity.x * maxStartLifeTime, startMaxVelocity.y * maxStartLifeTime, startMaxVelocity.z * maxStartLifeTime), 2 != this.scaleMode ? (Vector3.add(minPosition, minStratPosition, boundMin), Vector3.multiply(positionScale, boundMin, boundMin), Vector3.add(maxPosition, maxStratPosition, boundMax), Vector3.multiply(positionScale, boundMax, boundMax)) : (Vector3.multiply(positionScale, minPosition, boundMin), Vector3.add(boundMin, minStratPosition, boundMin), Vector3.multiply(positionScale, maxPosition, boundMax), Vector3.add(boundMax, maxStratPosition, boundMax))), this.simulationSpace) {
                    case 0:
                        break;
                    case 1:
                        Vector3.add(boundMin, worldPosition, boundMin), Vector3.add(boundMax, worldPosition, boundMax)
                }
                switch (this.startSizeType) {
                    case 0:
                        if (this.threeDStartSize) {
                            var startSizeConstantSeparate = startSizeConstantSeparate;
                            maxSize = Math.max(startSizeConstantSeparate.x, startSizeConstantSeparate.y), 1 === renderMode && (maxSizeY = startSizeConstantSeparate.y)
                        } else maxSize = this.startSizeConstant, 1 === renderMode && (maxSizeY = this.startSizeConstant);
                        break;
                    case 1:
                        break;
                    case 2:
                        if (this.threeDStartSize) {
                            var startSizeConstantMaxSeparate = startSizeConstantMaxSeparate;
                            maxSize = Math.max(startSizeConstantMaxSeparate.x, startSizeConstantMaxSeparate.y), 1 === renderMode && (maxSizeY = startSizeConstantMaxSeparate.y)
                        } else maxSize = this.startSizeConstantMax, 1 === renderMode && (maxSizeY = this.startSizeConstantMax)
                }
                if (this._sizeOverLifetime && this._sizeOverLifetime.enbale) {
                    this._sizeOverLifetime.size;
                    maxSize *= this._sizeOverLifetime.size.getMaxSizeInGradient()
                }
                var rotSize, nonRotSize, threeDMaxSize = ShurikenParticleSystem._tempVector30;
                switch (renderMode) {
                    case 0:
                        rotSize = maxSize * ShurikenParticleSystem.halfKSqrtOf2, Vector3.scale(sizeScale, maxSize, threeDMaxSize), Vector3.subtract(boundMin, threeDMaxSize, boundMin), Vector3.add(boundMax, threeDMaxSize, boundMax);
                        break;
                    case 1:
                        var maxStretchPosition = ShurikenParticleSystem._tempVector31,
                            maxStretchVelocity = ShurikenParticleSystem._tempVector32,
                            minStretchVelocity = ShurikenParticleSystem._tempVector33,
                            minStretchPosition = ShurikenParticleSystem._tempVector34;
                        this._velocityOverLifetime && this._velocityOverLifetime.enbale || (Vector3.multiply(velocityScale, startMaxVelocity, maxStretchVelocity), Vector3.multiply(velocityScale, startMinVelocity, minStretchVelocity));
                        var sizeStretch = maxSizeY * particleRender.stretchedBillboardLengthScale,
                            maxStretchLength = Vector3.scalarLength(maxStretchVelocity) * particleRender.stretchedBillboardSpeedScale + sizeStretch,
                            minStretchLength = Vector3.scalarLength(minStretchVelocity) * particleRender.stretchedBillboardSpeedScale + sizeStretch,
                            norMaxStretchVelocity = ShurikenParticleSystem._tempVector35,
                            norMinStretchVelocity = ShurikenParticleSystem._tempVector36;
                        Vector3.normalize(maxStretchVelocity, norMaxStretchVelocity), Vector3.scale(norMaxStretchVelocity, maxStretchLength, minStretchPosition), Vector3.subtract(maxStratPosition, minStretchPosition, minStretchPosition), Vector3.normalize(minStretchVelocity, norMinStretchVelocity), Vector3.scale(norMinStretchVelocity, minStretchLength, maxStretchPosition), Vector3.add(minStratPosition, maxStretchPosition, maxStretchPosition), rotSize = maxSize * ShurikenParticleSystem.halfKSqrtOf2, Vector3.scale(sizeScale, rotSize, threeDMaxSize);
                        var halfNorMaxStretchVelocity = ShurikenParticleSystem._tempVector37,
                            halfNorMinStretchVelocity = ShurikenParticleSystem._tempVector38;
                        Vector3.scale(norMaxStretchVelocity, .5, halfNorMaxStretchVelocity), Vector3.scale(norMinStretchVelocity, .5, halfNorMinStretchVelocity), Vector3.multiply(halfNorMaxStretchVelocity, sizeScale, halfNorMaxStretchVelocity), Vector3.multiply(halfNorMinStretchVelocity, sizeScale, halfNorMinStretchVelocity), Vector3.add(boundMin, halfNorMinStretchVelocity, boundMin), Vector3.min(boundMin, minStretchPosition, boundMin), Vector3.subtract(boundMin, threeDMaxSize, boundMin), Vector3.subtract(boundMax, halfNorMaxStretchVelocity, boundMax), Vector3.max(boundMax, maxStretchPosition, boundMax), Vector3.add(boundMax, threeDMaxSize, boundMax);
                        break;
                    case 2:
                        nonRotSize = .5 * (maxSize *= Math.cos(.7853981633974483)), threeDMaxSize.x = sizeScale.x * nonRotSize, threeDMaxSize.y = sizeScale.z * nonRotSize, Vector3.subtract(boundMin, threeDMaxSize, boundMin), Vector3.add(boundMax, threeDMaxSize, boundMax);
                        break;
                    case 3:
                        nonRotSize = .5 * (maxSize *= Math.cos(.7853981633974483)), Vector3.scale(sizeScale, nonRotSize, threeDMaxSize), Vector3.subtract(boundMin, threeDMaxSize, boundMin), Vector3.add(boundMax, threeDMaxSize, boundMax)
                }
                this._boundingBox.getCorners(this._boundingBoxCorners)
            }

            _updateEmission() {
                if (this.isAlive) if (this._simulateUpdate) this._simulateUpdate = !1; else {
                    var elapsedTime = this._startUpdateLoopCount === Laya.Stat.loopCount || this._isPaused ? 0 : this._owner._scene.timer._delta / 1e3;
                    elapsedTime = Math.min(ShurikenParticleSystem._maxElapsedTime, elapsedTime), this._updateParticles(elapsedTime)
                }
            }

            _updateParticles(elapsedTime) {
                (4 !== this._ownerRender.renderMode || this._ownerRender.mesh) && (this._currentTime += elapsedTime, this._retireActiveParticles(), this._freeRetiredParticles(), this._totalDelayTime += elapsedTime, this._totalDelayTime < this._playStartDelay || this._emission.enbale && this._isEmitting && !this._isPaused && this._advanceTime(elapsedTime, this._currentTime))
            }

            _updateParticlesSimulationRestart(time) {
                this._firstActiveElement = 0, this._firstNewElement = 0, this._firstFreeElement = 0, this._firstRetiredElement = 0, this._burstsIndex = 0, this._frameRateTime = time, this._emissionTime = 0, this._totalDelayTime = 0, this._currentTime = time;
                var delayTime = time;
                delayTime < this._playStartDelay ? this._totalDelayTime = delayTime : this._emission.enbale && this._advanceTime(time, time)
            }

            _retireActiveParticles() {
                for (; this._firstActiveElement != this._firstNewElement;) {
                    var index = this._firstActiveElement * this._floatCountPerVertex * this._vertexStride,
                        timeIndex = index + this._timeIndex;
                    if (this._currentTime - this._vertices[timeIndex] + 1e-4 < this._vertices[index + this._startLifeTimeIndex]) break;
                    this._vertices[timeIndex] = this._drawCounter, this._firstActiveElement++, this._firstActiveElement >= this._bufferMaxParticles && (this._firstActiveElement = 0)
                }
            }

            _freeRetiredParticles() {
                for (; this._firstRetiredElement != this._firstActiveElement;) {
                    var age = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * this._vertexStride + this._timeIndex];
                    if (this.isPerformanceMode && age < 3) break;
                    this._firstRetiredElement++, this._firstRetiredElement >= this._bufferMaxParticles && (this._firstRetiredElement = 0)
                }
            }

            _burst(fromTime, toTime) {
                for (var totalEmitCount = 0, bursts = this._emission._bursts, n = bursts.length; this._burstsIndex < n; this._burstsIndex++) {
                    var emitCount, burst = bursts[this._burstsIndex], burstTime = burst.time;
                    if (!(fromTime <= burstTime && burstTime < toTime)) break;
                    this.autoRandomSeed ? emitCount = Laya.MathUtil.lerp(burst.minCount, burst.maxCount, Math.random()) : (this._rand.seed = this._randomSeeds[0], emitCount = Laya.MathUtil.lerp(burst.minCount, burst.maxCount, this._rand.getFloat()), this._randomSeeds[0] = this._rand.seed), totalEmitCount += emitCount
                }
                return totalEmitCount
            }

            _advanceTime(elapsedTime, emitTime) {
                var i, lastEmissionTime = this._emissionTime;
                this._emissionTime += elapsedTime;
                var totalEmitCount = 0;
                if (this._emissionTime > this.duration) {
                    if (!this.looping) {
                        for (totalEmitCount = Math.min(this.maxParticles - this.aliveParticleCount, totalEmitCount), i = 0; i < totalEmitCount; i++) this.emit(emitTime);
                        return this._isPlaying = !1, void this.stop()
                    }
                    totalEmitCount += this._burst(lastEmissionTime, this._emissionTime), this._emissionTime -= this.duration, this._burstsIndex = 0, totalEmitCount += this._burst(0, this._emissionTime)
                } else totalEmitCount += this._burst(lastEmissionTime, this._emissionTime);
                for (totalEmitCount = Math.min(this.maxParticles - this.aliveParticleCount, totalEmitCount), i = 0; i < totalEmitCount; i++) this.emit(emitTime);
                var emissionRate = this.emission.emissionRate;
                if (emissionRate > 0) {
                    var minEmissionTime = 1 / emissionRate;
                    for (this._frameRateTime += minEmissionTime, this._frameRateTime = this._currentTime - (this._currentTime - this._frameRateTime) % this._maxStartLifetime; this._frameRateTime <= emitTime && this.emit(this._frameRateTime);) this._frameRateTime += minEmissionTime;
                    this._frameRateTime = Math.floor(emitTime / minEmissionTime) * minEmissionTime
                }
            }

            _initBufferDatas() {
                this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer.destroy());
                var gl = Laya.LayaGL.instance, render = this._ownerRender, renderMode = render.renderMode;
                if (-1 !== renderMode && this.maxParticles > 0) {
                    var indices, i, j, m, indexOffset, perPartOffset, vertexDeclaration, vbMemorySize = 0,
                        memorySize = 0, mesh = render.mesh;
                    if (4 === renderMode) {
                        if (mesh) {
                            vertexDeclaration = VertexShurikenParticleMesh.vertexDeclaration, this._floatCountPerVertex = vertexDeclaration.vertexStride / 4, this._startLifeTimeIndex = 12, this._timeIndex = 16, this._vertexStride = mesh._vertexBuffer.vertexCount;
                            var totalVertexCount = this._bufferMaxParticles * this._vertexStride,
                                lastVBVertexCount = totalVertexCount % 65535;
                            if (Math.floor(totalVertexCount / 65535) + 1 > 1) throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
                            vbMemorySize = vertexDeclaration.vertexStride * lastVBVertexCount, this._vertexBuffer = new VertexBuffer3D(vbMemorySize, gl.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = vertexDeclaration, this._vertices = new Float32Array(this._floatCountPerVertex * lastVBVertexCount), this._indexStride = mesh._indexBuffer.indexCount;
                            var indexDatas = mesh._indexBuffer.getData(),
                                indexCount = this._bufferMaxParticles * this._indexStride;
                            for (this._indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, indexCount, gl.STATIC_DRAW), indices = new Uint16Array(indexCount), memorySize = vbMemorySize + 2 * indexCount, indexOffset = 0, i = 0; i < this._bufferMaxParticles; i++) {
                                var indexValueOffset = i * this._vertexStride;
                                for (j = 0, m = indexDatas.length; j < m; j++) indices[indexOffset++] = indexValueOffset + indexDatas[j]
                            }
                            this._indexBuffer.setData(indices), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind()
                        }
                    } else {
                        for (vertexDeclaration = VertexShurikenParticleBillboard.vertexDeclaration, this._floatCountPerVertex = vertexDeclaration.vertexStride / 4, this._startLifeTimeIndex = 7, this._timeIndex = 11, this._vertexStride = 4, vbMemorySize = vertexDeclaration.vertexStride * this._bufferMaxParticles * this._vertexStride, this._vertexBuffer = new VertexBuffer3D(vbMemorySize, gl.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = vertexDeclaration, this._vertices = new Float32Array(this._floatCountPerVertex * this._bufferMaxParticles * this._vertexStride), i = 0; i < this._bufferMaxParticles; i++) perPartOffset = i * this._floatCountPerVertex * this._vertexStride, this._vertices[perPartOffset] = -.5, this._vertices[perPartOffset + 1] = -.5, this._vertices[perPartOffset + 2] = 0, this._vertices[perPartOffset + 3] = 1, perPartOffset += this._floatCountPerVertex, this._vertices[perPartOffset] = .5, this._vertices[perPartOffset + 1] = -.5, this._vertices[perPartOffset + 2] = 1, this._vertices[perPartOffset + 3] = 1, perPartOffset += this._floatCountPerVertex, this._vertices[perPartOffset] = .5, this._vertices[perPartOffset + 1] = .5, this._vertices[perPartOffset + 2] = 1, this._vertices[perPartOffset + 3] = 0, perPartOffset += this._floatCountPerVertex, this._vertices[perPartOffset] = -.5, this._vertices[perPartOffset + 1] = .5, this._vertices[perPartOffset + 2] = 0, this._vertices[perPartOffset + 3] = 0;
                        for (this._indexStride = 6, this._indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, 6 * this._bufferMaxParticles, gl.STATIC_DRAW), indices = new Uint16Array(6 * this._bufferMaxParticles), i = 0; i < this._bufferMaxParticles; i++) {
                            indexOffset = 6 * i;
                            var firstVertex = i * this._vertexStride, secondVertex = firstVertex + 2;
                            indices[indexOffset++] = firstVertex, indices[indexOffset++] = secondVertex, indices[indexOffset++] = firstVertex + 1, indices[indexOffset++] = firstVertex, indices[indexOffset++] = firstVertex + 3, indices[indexOffset++] = secondVertex
                        }
                        this._indexBuffer.setData(indices), memorySize = vbMemorySize + 6 * this._bufferMaxParticles * 2, this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind()
                    }
                    Laya.Resource._addMemory(memorySize, memorySize)
                }
            }

            destroy() {
                super.destroy();
                var memorySize = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
                Laya.Resource._addMemory(-memorySize, -memorySize), this._bufferState.destroy(), this._vertexBuffer.destroy(), this._indexBuffer.destroy(), this._emission.destroy(), this._bufferState = null, this._vertexBuffer = null, this._indexBuffer = null, this._owner = null, this._vertices = null, this._indexBuffer = null, this._emission = null, this._shape = null, this.startLifeTimeGradient = null, this.startLifeTimeGradientMin = null, this.startLifeTimeGradientMax = null, this.startSizeConstantSeparate = null, this.startSizeConstantMinSeparate = null, this.startSizeConstantMaxSeparate = null, this.startRotationConstantSeparate = null, this.startRotationConstantMinSeparate = null, this.startRotationConstantMaxSeparate = null, this.startColorConstant = null, this.startColorConstantMin = null, this.startColorConstantMax = null, this._velocityOverLifetime = null, this._colorOverLifetime = null, this._sizeOverLifetime = null, this._rotationOverLifetime = null, this._textureSheetAnimation = null
            }

            emit(time) {
                var position = ShurikenParticleSystem._tempPosition, direction = ShurikenParticleSystem._tempDirection;
                return this._shape && this._shape.enable ? this.autoRandomSeed ? this._shape.generatePositionAndDirection(position, direction) : this._shape.generatePositionAndDirection(position, direction, this._rand, this._randomSeeds) : (position.x = position.y = position.z = 0, direction.x = direction.y = 0, direction.z = 1), this.addParticle(position, direction, time)
            }

            addParticle(position, direction, time) {
                Vector3.normalize(direction, direction);
                var randomVelocityX, randomVelocityY, randomVelocityZ, randomColor, randomSize, randomRotation,
                    randomTextureAnimation, nextFreeParticle = this._firstFreeElement + 1;
                if (nextFreeParticle >= this._bufferMaxParticles && (nextFreeParticle = 0), nextFreeParticle === this._firstRetiredElement) return !1;
                if (ShurikenParticleData.create(this, this._ownerRender, this._owner.transform), this._currentTime - time >= ShurikenParticleData.startLifeTime) return !0;
                var needRandomVelocity = this._velocityOverLifetime && this._velocityOverLifetime.enbale;
                if (needRandomVelocity) {
                    var velocityType = this._velocityOverLifetime.velocity.type;
                    2 === velocityType || 3 === velocityType ? this.autoRandomSeed ? (randomVelocityX = Math.random(), randomVelocityY = Math.random(), randomVelocityZ = Math.random()) : (this._rand.seed = this._randomSeeds[9], randomVelocityX = this._rand.getFloat(), randomVelocityY = this._rand.getFloat(), randomVelocityZ = this._rand.getFloat(), this._randomSeeds[9] = this._rand.seed) : needRandomVelocity = !1
                } else needRandomVelocity = !1;
                var needRandomColor = this._colorOverLifetime && this._colorOverLifetime.enbale;
                needRandomColor ? 3 === this._colorOverLifetime.color.type ? this.autoRandomSeed ? randomColor = Math.random() : (this._rand.seed = this._randomSeeds[10], randomColor = this._rand.getFloat(), this._randomSeeds[10] = this._rand.seed) : needRandomColor = !1 : needRandomColor = !1;
                var needRandomSize = this._sizeOverLifetime && this._sizeOverLifetime.enbale;
                needRandomSize ? 3 === this._sizeOverLifetime.size.type ? this.autoRandomSeed ? randomSize = Math.random() : (this._rand.seed = this._randomSeeds[11], randomSize = this._rand.getFloat(), this._randomSeeds[11] = this._rand.seed) : needRandomSize = !1 : needRandomSize = !1;
                var needRandomRotation = this._rotationOverLifetime && this._rotationOverLifetime.enbale;
                if (needRandomRotation) {
                    var rotationType = this._rotationOverLifetime.angularVelocity.type;
                    2 === rotationType || 3 === rotationType ? this.autoRandomSeed ? randomRotation = Math.random() : (this._rand.seed = this._randomSeeds[12], randomRotation = this._rand.getFloat(), this._randomSeeds[12] = this._rand.seed) : needRandomRotation = !1
                } else needRandomRotation = !1;
                var needRandomTextureAnimation = this._textureSheetAnimation && this._textureSheetAnimation.enable;
                needRandomTextureAnimation ? 3 === this._textureSheetAnimation.frame.type ? this.autoRandomSeed ? randomTextureAnimation = Math.random() : (this._rand.seed = this._randomSeeds[15], randomTextureAnimation = this._rand.getFloat(), this._randomSeeds[15] = this._rand.seed) : needRandomTextureAnimation = !1 : needRandomTextureAnimation = !1;
                var meshVertices, meshVertexStride, meshPosOffset, meshCorOffset, meshUVOffset, meshVertexIndex,
                    startIndex = this._firstFreeElement * this._floatCountPerVertex * this._vertexStride,
                    subU = ShurikenParticleData.startUVInfo[0], subV = ShurikenParticleData.startUVInfo[1],
                    startU = ShurikenParticleData.startUVInfo[2], startV = ShurikenParticleData.startUVInfo[3],
                    render = this._ownerRender;
                if (4 === render.renderMode) {
                    var meshVB = render.mesh._vertexBuffer;
                    meshVertices = meshVB.getFloat32Data();
                    var meshVertexDeclaration = meshVB.vertexDeclaration;
                    meshPosOffset = meshVertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_POSITION0)._offset / 4;
                    var colorElement = meshVertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_COLOR0);
                    meshCorOffset = colorElement ? colorElement._offset / 4 : -1;
                    var uvElement = meshVertexDeclaration.getVertexElementByUsage(VertexMesh.MESH_TEXTURECOORDINATE0);
                    meshUVOffset = uvElement ? uvElement._offset / 4 : -1, meshVertexStride = meshVertexDeclaration.vertexStride / 4, meshVertexIndex = 0
                } else {
                    this._vertices[startIndex + 2] = startU, this._vertices[startIndex + 3] = startV + subV;
                    var secondOffset = startIndex + this._floatCountPerVertex;
                    this._vertices[secondOffset + 2] = startU + subU, this._vertices[secondOffset + 3] = startV + subV;
                    var thirdOffset = secondOffset + this._floatCountPerVertex;
                    this._vertices[thirdOffset + 2] = startU + subU, this._vertices[thirdOffset + 3] = startV;
                    var fourthOffset = thirdOffset + this._floatCountPerVertex;
                    this._vertices[fourthOffset + 2] = startU, this._vertices[fourthOffset + 3] = startV
                }
                for (var i = startIndex, n = startIndex + this._floatCountPerVertex * this._vertexStride; i < n; i += this._floatCountPerVertex) {
                    var offset;
                    if (4 === render.renderMode) {
                        offset = i;
                        var vertexOffset = meshVertexStride * meshVertexIndex++,
                            meshOffset = vertexOffset + meshPosOffset;
                        this._vertices[offset++] = meshVertices[meshOffset++], this._vertices[offset++] = meshVertices[meshOffset++], this._vertices[offset++] = meshVertices[meshOffset], -1 === meshCorOffset ? (this._vertices[offset++] = 1, this._vertices[offset++] = 1, this._vertices[offset++] = 1, this._vertices[offset++] = 1) : (meshOffset = vertexOffset + meshCorOffset, this._vertices[offset++] = meshVertices[meshOffset++], this._vertices[offset++] = meshVertices[meshOffset++], this._vertices[offset++] = meshVertices[meshOffset++], this._vertices[offset++] = meshVertices[meshOffset]), -1 === meshUVOffset ? (this._vertices[offset++] = 0, this._vertices[offset++] = 0) : (meshOffset = vertexOffset + meshUVOffset, this._vertices[offset++] = startU + meshVertices[meshOffset++] * subU, this._vertices[offset++] = startV + meshVertices[meshOffset] * subV)
                    } else offset = i + 4;
                    switch (this._vertices[offset++] = position.x, this._vertices[offset++] = position.y, this._vertices[offset++] = position.z, this._vertices[offset++] = ShurikenParticleData.startLifeTime, this._vertices[offset++] = direction.x, this._vertices[offset++] = direction.y, this._vertices[offset++] = direction.z, this._vertices[offset++] = time, this._vertices[offset++] = ShurikenParticleData.startColor.x, this._vertices[offset++] = ShurikenParticleData.startColor.y, this._vertices[offset++] = ShurikenParticleData.startColor.z, this._vertices[offset++] = ShurikenParticleData.startColor.w, this._vertices[offset++] = ShurikenParticleData.startSize[0], this._vertices[offset++] = ShurikenParticleData.startSize[1], this._vertices[offset++] = ShurikenParticleData.startSize[2], this._vertices[offset++] = ShurikenParticleData.startRotation[0], this._vertices[offset++] = ShurikenParticleData.startRotation[1], this._vertices[offset++] = ShurikenParticleData.startRotation[2], this._vertices[offset++] = ShurikenParticleData.startSpeed, needRandomColor && (this._vertices[offset + 1] = randomColor), needRandomSize && (this._vertices[offset + 2] = randomSize), needRandomRotation && (this._vertices[offset + 3] = randomRotation), needRandomTextureAnimation && (this._vertices[offset + 4] = randomTextureAnimation), needRandomVelocity && (this._vertices[offset + 5] = randomVelocityX, this._vertices[offset + 6] = randomVelocityY, this._vertices[offset + 7] = randomVelocityZ), this.simulationSpace) {
                        case 0:
                            offset += 8, this._vertices[offset++] = ShurikenParticleData.simulationWorldPostion[0], this._vertices[offset++] = ShurikenParticleData.simulationWorldPostion[1], this._vertices[offset++] = ShurikenParticleData.simulationWorldPostion[2], this._vertices[offset++] = ShurikenParticleData.simulationWorldRotation[0], this._vertices[offset++] = ShurikenParticleData.simulationWorldRotation[1], this._vertices[offset++] = ShurikenParticleData.simulationWorldRotation[2], this._vertices[offset++] = ShurikenParticleData.simulationWorldRotation[3];
                            break;
                        case 1:
                            break;
                        default:
                            throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.")
                    }
                }
                return this._firstFreeElement = nextFreeParticle, !0
            }

            addNewParticlesToVertexBuffer() {
                var start, byteStride = this._vertexStride * this._floatCountPerVertex * 4;
                this._firstNewElement < this._firstFreeElement ? (start = this._firstNewElement * byteStride, this._vertexBuffer.setData(this._vertices.buffer, start, start, (this._firstFreeElement - this._firstNewElement) * byteStride)) : (start = this._firstNewElement * byteStride, this._vertexBuffer.setData(this._vertices.buffer, start, start, (this._bufferMaxParticles - this._firstNewElement) * byteStride), this._firstFreeElement > 0 && this._vertexBuffer.setData(this._vertices.buffer, 0, 0, this._firstFreeElement * byteStride)), this._firstNewElement = this._firstFreeElement
            }

            _getType() {
                return ShurikenParticleSystem._type
            }

            _prepareRender(state) {
                return this._updateEmission(), this._firstNewElement != this._firstFreeElement && this.addNewParticlesToVertexBuffer(), this._drawCounter++, this._firstActiveElement != this._firstFreeElement
            }

            _render(state) {
                var indexCount;
                this._bufferState.bind();
                var gl = Laya.LayaGL.instance;
                this._firstActiveElement < this._firstFreeElement ? (indexCount = (this._firstFreeElement - this._firstActiveElement) * this._indexStride, gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride), Laya.Stat.trianglesFaces += indexCount / 3, Laya.Stat.renderBatches++) : (indexCount = (this._bufferMaxParticles - this._firstActiveElement) * this._indexStride, gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride), Laya.Stat.trianglesFaces += indexCount / 3, Laya.Stat.renderBatches++, this._firstFreeElement > 0 && (indexCount = this._firstFreeElement * this._indexStride, gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0), Laya.Stat.trianglesFaces += indexCount / 3, Laya.Stat.renderBatches++))
            }

            play() {
                if (this._burstsIndex = 0, this._isEmitting = !0, this._isPlaying = !0, this._isPaused = !1, this._emissionTime = 0, this._totalDelayTime = 0, !this.autoRandomSeed) for (var i = 0, n = this._randomSeeds.length; i < n; i++) this._randomSeeds[i] = this.randomSeed[0] + ShurikenParticleSystem._RANDOMOFFSET[i];
                switch (this.startDelayType) {
                    case 0:
                        this._playStartDelay = this.startDelay;
                        break;
                    case 1:
                        this.autoRandomSeed ? this._playStartDelay = Laya.MathUtil.lerp(this.startDelayMin, this.startDelayMax, Math.random()) : (this._rand.seed = this._randomSeeds[2], this._playStartDelay = Laya.MathUtil.lerp(this.startDelayMin, this.startDelayMax, this._rand.getFloat()), this._randomSeeds[2] = this._rand.seed);
                        break;
                    default:
                        throw new Error("Utils3D: startDelayType is invalid.")
                }
                this._frameRateTime = this._currentTime + this._playStartDelay, this._startUpdateLoopCount = Laya.Stat.loopCount
            }

            pause() {
                this._isPaused = !0
            }

            simulate(time, restart = !0) {
                this._simulateUpdate = !0, restart ? this._updateParticlesSimulationRestart(time) : (this._isPaused = !1, this._updateParticles(time)), this.pause()
            }

            stop() {
                this._burstsIndex = 0, this._isEmitting = !1, this._emissionTime = 0
            }

            cloneTo(destObject) {
                var dest = destObject;
                dest.duration = this.duration, dest.looping = this.looping, dest.prewarm = this.prewarm, dest.startDelayType = this.startDelayType, dest.startDelay = this.startDelay, dest.startDelayMin = this.startDelayMin, dest.startDelayMax = this.startDelayMax, dest._maxStartLifetime = this._maxStartLifetime, dest.startLifetimeType = this.startLifetimeType, dest.startLifetimeConstant = this.startLifetimeConstant, this.startLifeTimeGradient.cloneTo(dest.startLifeTimeGradient), dest.startLifetimeConstantMin = this.startLifetimeConstantMin, dest.startLifetimeConstantMax = this.startLifetimeConstantMax, this.startLifeTimeGradientMin.cloneTo(dest.startLifeTimeGradientMin), this.startLifeTimeGradientMax.cloneTo(dest.startLifeTimeGradientMax), dest.startSpeedType = this.startSpeedType, dest.startSpeedConstant = this.startSpeedConstant, dest.startSpeedConstantMin = this.startSpeedConstantMin, dest.startSpeedConstantMax = this.startSpeedConstantMax, dest.threeDStartSize = this.threeDStartSize, dest.startSizeType = this.startSizeType, dest.startSizeConstant = this.startSizeConstant, this.startSizeConstantSeparate.cloneTo(dest.startSizeConstantSeparate), dest.startSizeConstantMin = this.startSizeConstantMin, dest.startSizeConstantMax = this.startSizeConstantMax, this.startSizeConstantMinSeparate.cloneTo(dest.startSizeConstantMinSeparate), this.startSizeConstantMaxSeparate.cloneTo(dest.startSizeConstantMaxSeparate), dest.threeDStartRotation = this.threeDStartRotation, dest.startRotationType = this.startRotationType, dest.startRotationConstant = this.startRotationConstant, this.startRotationConstantSeparate.cloneTo(dest.startRotationConstantSeparate), dest.startRotationConstantMin = this.startRotationConstantMin, dest.startRotationConstantMax = this.startRotationConstantMax, this.startRotationConstantMinSeparate.cloneTo(dest.startRotationConstantMinSeparate), this.startRotationConstantMaxSeparate.cloneTo(dest.startRotationConstantMaxSeparate), dest.randomizeRotationDirection = this.randomizeRotationDirection, dest.startColorType = this.startColorType, this.startColorConstant.cloneTo(dest.startColorConstant), this.startColorConstantMin.cloneTo(dest.startColorConstantMin), this.startColorConstantMax.cloneTo(dest.startColorConstantMax), dest.gravityModifier = this.gravityModifier, dest.simulationSpace = this.simulationSpace, dest.scaleMode = this.scaleMode, dest.playOnAwake = this.playOnAwake, dest.autoRandomSeed = this.autoRandomSeed, dest.randomSeed[0] = this.randomSeed[0], dest.maxParticles = this.maxParticles, this._emission && (dest._emission = this._emission.clone()), this.shape && (dest.shape = this.shape.clone()), this.velocityOverLifetime && (dest.velocityOverLifetime = this.velocityOverLifetime.clone()), this.colorOverLifetime && (dest.colorOverLifetime = this.colorOverLifetime.clone()), this.sizeOverLifetime && (dest.sizeOverLifetime = this.sizeOverLifetime.clone()), this.rotationOverLifetime && (dest.rotationOverLifetime = this.rotationOverLifetime.clone()), this.textureSheetAnimation && (dest.textureSheetAnimation = this.textureSheetAnimation.clone()), dest.isPerformanceMode = this.isPerformanceMode, dest._isEmitting = this._isEmitting, dest._isPlaying = this._isPlaying, dest._isPaused = this._isPaused, dest._playStartDelay = this._playStartDelay, dest._frameRateTime = this._frameRateTime, dest._emissionTime = this._emissionTime, dest._totalDelayTime = this._totalDelayTime, dest._burstsIndex = this._burstsIndex
            }

            clone() {
                var dest = new ShurikenParticleSystem(null);
                return this.cloneTo(dest), dest
            }
        }

        ShurikenParticleSystem._RANDOMOFFSET = new Uint32Array([592910910, 3276756734, 322376503, 306581307, 1793934638, 3737431713, 2527743459, 2368504881, 4085612399, 3774601268, 326370691, 1494990940, 1089181156, 3159510623, 2941263940, 2786374529, 271901988, 4233252447]), ShurikenParticleSystem.halfKSqrtOf2 = .71, ShurikenParticleSystem._maxElapsedTime = 1 / 3, ShurikenParticleSystem._tempVector30 = new Vector3, ShurikenParticleSystem._tempVector31 = new Vector3, ShurikenParticleSystem._tempVector32 = new Vector3, ShurikenParticleSystem._tempVector33 = new Vector3, ShurikenParticleSystem._tempVector34 = new Vector3, ShurikenParticleSystem._tempVector35 = new Vector3, ShurikenParticleSystem._tempVector36 = new Vector3, ShurikenParticleSystem._tempVector37 = new Vector3, ShurikenParticleSystem._tempVector38 = new Vector3, ShurikenParticleSystem._tempVector39 = new Vector3, ShurikenParticleSystem._tempPosition = new Vector3, ShurikenParticleSystem._tempDirection = new Vector3, ShurikenParticleSystem._type = GeometryElement._typeCounter++;

        class Burst {
            get time() {
                return this._time
            }

            get minCount() {
                return this._minCount
            }

            get maxCount() {
                return this._maxCount
            }

            constructor(time, minCount, maxCount) {
                this._time = time, this._minCount = minCount, this._maxCount = maxCount
            }

            cloneTo(destObject) {
                var destBurst = destObject;
                destBurst._time = this._time, destBurst._minCount = this._minCount, destBurst._maxCount = this._maxCount
            }

            clone() {
                var destBurst = new Burst(this._time, this._minCount, this._maxCount);
                return this.cloneTo(destBurst), destBurst
            }
        }

        class GradientColor {
            constructor() {
                this._type = 0, this._constant = null, this._constantMin = null, this._constantMax = null, this._gradient = null, this._gradientMin = null, this._gradientMax = null
            }

            static createByConstant(constant) {
                var gradientColor = new GradientColor;
                return gradientColor._type = 0, gradientColor._constant = constant, gradientColor
            }

            static createByGradient(gradient) {
                var gradientColor = new GradientColor;
                return gradientColor._type = 1, gradientColor._gradient = gradient, gradientColor
            }

            static createByRandomTwoConstant(minConstant, maxConstant) {
                var gradientColor = new GradientColor;
                return gradientColor._type = 2, gradientColor._constantMin = minConstant, gradientColor._constantMax = maxConstant, gradientColor
            }

            static createByRandomTwoGradient(minGradient, maxGradient) {
                var gradientColor = new GradientColor;
                return gradientColor._type = 3, gradientColor._gradientMin = minGradient, gradientColor._gradientMax = maxGradient, gradientColor
            }

            get type() {
                return this._type
            }

            get constant() {
                return this._constant
            }

            get constantMin() {
                return this._constantMin
            }

            get constantMax() {
                return this._constantMax
            }

            get gradient() {
                return this._gradient
            }

            get gradientMin() {
                return this._gradientMin
            }

            get gradientMax() {
                return this._gradientMax
            }

            cloneTo(destObject) {
                var destGradientColor = destObject;
                destGradientColor._type = this._type, this._constant.cloneTo(destGradientColor._constant), this._constantMin.cloneTo(destGradientColor._constantMin), this._constantMax.cloneTo(destGradientColor._constantMax), this._gradient.cloneTo(destGradientColor._gradient), this._gradientMin.cloneTo(destGradientColor._gradientMin), this._gradientMax.cloneTo(destGradientColor._gradientMax)
            }

            clone() {
                var destGradientColor = new GradientColor;
                return this.cloneTo(destGradientColor), destGradientColor
            }
        }

        class ColorOverLifetime {
            get color() {
                return this._color
            }

            constructor(color) {
                this._color = color
            }

            cloneTo(destObject) {
                var destColorOverLifetime = destObject;
                this._color.cloneTo(destColorOverLifetime._color), destColorOverLifetime.enbale = this.enbale
            }

            clone() {
                var destColor;
                switch (this._color.type) {
                    case 0:
                        destColor = GradientColor.createByConstant(this._color.constant.clone());
                        break;
                    case 1:
                        destColor = GradientColor.createByGradient(this._color.gradient.clone());
                        break;
                    case 2:
                        destColor = GradientColor.createByRandomTwoConstant(this._color.constantMin.clone(), this._color.constantMax.clone());
                        break;
                    case 3:
                        destColor = GradientColor.createByRandomTwoGradient(this._color.gradientMin.clone(), this._color.gradientMax.clone())
                }
                var destColorOverLifetime = new ColorOverLifetime(destColor);
                return destColorOverLifetime.enbale = this.enbale, destColorOverLifetime
            }
        }

        class FrameOverTime {
            constructor() {
                this._type = 0, this._constant = 0, this._overTime = null, this._constantMin = 0, this._constantMax = 0, this._overTimeMin = null, this._overTimeMax = null
            }

            static createByConstant(constant) {
                var rotationOverLifetime = new FrameOverTime;
                return rotationOverLifetime._type = 0, rotationOverLifetime._constant = constant, rotationOverLifetime
            }

            static createByOverTime(overTime) {
                var rotationOverLifetime = new FrameOverTime;
                return rotationOverLifetime._type = 1, rotationOverLifetime._overTime = overTime, rotationOverLifetime
            }

            static createByRandomTwoConstant(constantMin, constantMax) {
                var rotationOverLifetime = new FrameOverTime;
                return rotationOverLifetime._type = 2, rotationOverLifetime._constantMin = constantMin, rotationOverLifetime._constantMax = constantMax, rotationOverLifetime
            }

            static createByRandomTwoOverTime(gradientFrameMin, gradientFrameMax) {
                var rotationOverLifetime = new FrameOverTime;
                return rotationOverLifetime._type = 3, rotationOverLifetime._overTimeMin = gradientFrameMin, rotationOverLifetime._overTimeMax = gradientFrameMax, rotationOverLifetime
            }

            get type() {
                return this._type
            }

            get constant() {
                return this._constant
            }

            get frameOverTimeData() {
                return this._overTime
            }

            get constantMin() {
                return this._constantMin
            }

            get constantMax() {
                return this._constantMax
            }

            get frameOverTimeDataMin() {
                return this._overTimeMin
            }

            get frameOverTimeDataMax() {
                return this._overTimeMax
            }

            cloneTo(destObject) {
                var destFrameOverTime = destObject;
                destFrameOverTime._type = this._type, destFrameOverTime._constant = this._constant, this._overTime && this._overTime.cloneTo(destFrameOverTime._overTime), destFrameOverTime._constantMin = this._constantMin, destFrameOverTime._constantMax = this._constantMax, this._overTimeMin && this._overTimeMin.cloneTo(destFrameOverTime._overTimeMin), this._overTimeMax && this._overTimeMax.cloneTo(destFrameOverTime._overTimeMax)
            }

            clone() {
                var destFrameOverTime = new FrameOverTime;
                return this.cloneTo(destFrameOverTime), destFrameOverTime
            }
        }

        class GradientAngularVelocity {
            constructor() {
                this._type = 0, this._separateAxes = !1, this._constant = 0, this._constantSeparate = null, this._gradient = null, this._gradientX = null, this._gradientY = null, this._gradientZ = null, this._gradientW = null, this._constantMin = 0, this._constantMax = 0, this._constantMinSeparate = null, this._constantMaxSeparate = null, this._gradientMin = null, this._gradientMax = null, this._gradientXMin = null, this._gradientXMax = null, this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null, this._gradientZMax = null, this._gradientWMin = null, this._gradientWMax = null
            }

            static createByConstant(constant) {
                var gradientAngularVelocity = new GradientAngularVelocity;
                return gradientAngularVelocity._type = 0, gradientAngularVelocity._separateAxes = !1, gradientAngularVelocity._constant = constant, gradientAngularVelocity
            }

            static createByConstantSeparate(separateConstant) {
                var gradientAngularVelocity = new GradientAngularVelocity;
                return gradientAngularVelocity._type = 0, gradientAngularVelocity._separateAxes = !0, gradientAngularVelocity._constantSeparate = separateConstant, gradientAngularVelocity
            }

            static createByGradient(gradient) {
                var gradientAngularVelocity = new GradientAngularVelocity;
                return gradientAngularVelocity._type = 1, gradientAngularVelocity._separateAxes = !1, gradientAngularVelocity._gradient = gradient, gradientAngularVelocity
            }

            static createByGradientSeparate(gradientX, gradientY, gradientZ) {
                var gradientAngularVelocity = new GradientAngularVelocity;
                return gradientAngularVelocity._type = 1, gradientAngularVelocity._separateAxes = !0, gradientAngularVelocity._gradientX = gradientX, gradientAngularVelocity._gradientY = gradientY, gradientAngularVelocity._gradientZ = gradientZ, gradientAngularVelocity
            }

            static createByRandomTwoConstant(constantMin, constantMax) {
                var gradientAngularVelocity = new GradientAngularVelocity;
                return gradientAngularVelocity._type = 2, gradientAngularVelocity._separateAxes = !1, gradientAngularVelocity._constantMin = constantMin, gradientAngularVelocity._constantMax = constantMax, gradientAngularVelocity
            }

            static createByRandomTwoConstantSeparate(separateConstantMin, separateConstantMax) {
                var gradientAngularVelocity = new GradientAngularVelocity;
                return gradientAngularVelocity._type = 2, gradientAngularVelocity._separateAxes = !0, gradientAngularVelocity._constantMinSeparate = separateConstantMin, gradientAngularVelocity._constantMaxSeparate = separateConstantMax, gradientAngularVelocity
            }

            static createByRandomTwoGradient(gradientMin, gradientMax) {
                var gradientAngularVelocity = new GradientAngularVelocity;
                return gradientAngularVelocity._type = 3, gradientAngularVelocity._separateAxes = !1, gradientAngularVelocity._gradientMin = gradientMin, gradientAngularVelocity._gradientMax = gradientMax, gradientAngularVelocity
            }

            static createByRandomTwoGradientSeparate(gradientXMin, gradientXMax, gradientYMin, gradientYMax, gradientZMin, gradientZMax, gradientWMin, gradientWMax) {
                var gradientAngularVelocity = new GradientAngularVelocity;
                return gradientAngularVelocity._type = 3, gradientAngularVelocity._separateAxes = !0, gradientAngularVelocity._gradientXMin = gradientXMin, gradientAngularVelocity._gradientXMax = gradientXMax, gradientAngularVelocity._gradientYMin = gradientYMin, gradientAngularVelocity._gradientYMax = gradientYMax, gradientAngularVelocity._gradientZMin = gradientZMin, gradientAngularVelocity._gradientZMax = gradientZMax, gradientAngularVelocity._gradientWMin = gradientWMin, gradientAngularVelocity._gradientWMax = gradientWMax, gradientAngularVelocity
            }

            get type() {
                return this._type
            }

            get separateAxes() {
                return this._separateAxes
            }

            get constant() {
                return this._constant
            }

            get constantSeparate() {
                return this._constantSeparate
            }

            get gradient() {
                return this._gradient
            }

            get gradientX() {
                return this._gradientX
            }

            get gradientY() {
                return this._gradientY
            }

            get gradientZ() {
                return this._gradientZ
            }

            get gradientW() {
                return this._gradientW
            }

            get constantMin() {
                return this._constantMin
            }

            get constantMax() {
                return this._constantMax
            }

            get constantMinSeparate() {
                return this._constantMinSeparate
            }

            get constantMaxSeparate() {
                return this._constantMaxSeparate
            }

            get gradientMin() {
                return this._gradientMin
            }

            get gradientMax() {
                return this._gradientMax
            }

            get gradientXMin() {
                return this._gradientXMin
            }

            get gradientXMax() {
                return this._gradientXMax
            }

            get gradientYMin() {
                return this._gradientYMin
            }

            get gradientYMax() {
                return this._gradientYMax
            }

            get gradientZMin() {
                return this._gradientZMin
            }

            get gradientZMax() {
                return this._gradientZMax
            }

            get gradientWMin() {
                return this._gradientWMin
            }

            get gradientWMax() {
                return this._gradientWMax
            }

            cloneTo(destObject) {
                var destGradientAngularVelocity = destObject;
                destGradientAngularVelocity._type = this._type, destGradientAngularVelocity._separateAxes = this._separateAxes, destGradientAngularVelocity._constant = this._constant, this._constantSeparate.cloneTo(destGradientAngularVelocity._constantSeparate), this._gradient.cloneTo(destGradientAngularVelocity._gradient), this._gradientX.cloneTo(destGradientAngularVelocity._gradientX), this._gradientY.cloneTo(destGradientAngularVelocity._gradientY), this._gradientZ.cloneTo(destGradientAngularVelocity._gradientZ), destGradientAngularVelocity._constantMin = this._constantMin, destGradientAngularVelocity._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(destGradientAngularVelocity._constantMinSeparate), this._constantMaxSeparate.cloneTo(destGradientAngularVelocity._constantMaxSeparate), this._gradientMin.cloneTo(destGradientAngularVelocity._gradientMin), this._gradientMax.cloneTo(destGradientAngularVelocity._gradientMax), this._gradientXMin.cloneTo(destGradientAngularVelocity._gradientXMin), this._gradientXMax.cloneTo(destGradientAngularVelocity._gradientXMax), this._gradientYMin.cloneTo(destGradientAngularVelocity._gradientYMin), this._gradientYMax.cloneTo(destGradientAngularVelocity._gradientYMax), this._gradientZMin.cloneTo(destGradientAngularVelocity._gradientZMin), this._gradientZMax.cloneTo(destGradientAngularVelocity._gradientZMax)
            }

            clone() {
                var destGradientAngularVelocity = new GradientAngularVelocity;
                return this.cloneTo(destGradientAngularVelocity), destGradientAngularVelocity
            }
        }

        class GradientDataInt {
            constructor() {
                this._currentLength = 0, this._elements = new Float32Array(8)
            }

            get gradientCount() {
                return this._currentLength / 2
            }

            add(key, value) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== key && (key = 1, console.log("Warning:the forth key is  be force set to 1.")), this._elements[this._currentLength++] = key, this._elements[this._currentLength++] = value) : console.log("Warning:data count must lessEqual than 4")
            }

            cloneTo(destObject) {
                var destGradientDataInt = destObject;
                destGradientDataInt._currentLength = this._currentLength;
                for (var destElements = destGradientDataInt._elements, i = 0, n = this._elements.length; i < n; i++) destElements[i] = this._elements[i]
            }

            clone() {
                var destGradientDataInt = new GradientDataInt;
                return this.cloneTo(destGradientDataInt), destGradientDataInt
            }
        }

        class GradientSize {
            constructor() {
                this._type = 0, this._separateAxes = !1, this._gradient = null, this._gradientX = null, this._gradientY = null, this._gradientZ = null, this._constantMin = 0, this._constantMax = 0, this._constantMinSeparate = null, this._constantMaxSeparate = null, this._gradientMin = null, this._gradientMax = null, this._gradientXMin = null, this._gradientXMax = null, this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null, this._gradientZMax = null
            }

            static createByGradient(gradient) {
                var gradientSize = new GradientSize;
                return gradientSize._type = 0, gradientSize._separateAxes = !1, gradientSize._gradient = gradient, gradientSize
            }

            static createByGradientSeparate(gradientX, gradientY, gradientZ) {
                var gradientSize = new GradientSize;
                return gradientSize._type = 0, gradientSize._separateAxes = !0, gradientSize._gradientX = gradientX, gradientSize._gradientY = gradientY, gradientSize._gradientZ = gradientZ, gradientSize
            }

            static createByRandomTwoConstant(constantMin, constantMax) {
                var gradientSize = new GradientSize;
                return gradientSize._type = 1, gradientSize._separateAxes = !1, gradientSize._constantMin = constantMin, gradientSize._constantMax = constantMax, gradientSize
            }

            static createByRandomTwoConstantSeparate(constantMinSeparate, constantMaxSeparate) {
                var gradientSize = new GradientSize;
                return gradientSize._type = 1, gradientSize._separateAxes = !0, gradientSize._constantMinSeparate = constantMinSeparate, gradientSize._constantMaxSeparate = constantMaxSeparate, gradientSize
            }

            static createByRandomTwoGradient(gradientMin, gradientMax) {
                var gradientSize = new GradientSize;
                return gradientSize._type = 2, gradientSize._separateAxes = !1, gradientSize._gradientMin = gradientMin, gradientSize._gradientMax = gradientMax, gradientSize
            }

            static createByRandomTwoGradientSeparate(gradientXMin, gradientXMax, gradientYMin, gradientYMax, gradientZMin, gradientZMax) {
                var gradientSize = new GradientSize;
                return gradientSize._type = 2, gradientSize._separateAxes = !0, gradientSize._gradientXMin = gradientXMin, gradientSize._gradientXMax = gradientXMax, gradientSize._gradientYMin = gradientYMin, gradientSize._gradientYMax = gradientYMax, gradientSize._gradientZMin = gradientZMin, gradientSize._gradientZMax = gradientZMax, gradientSize
            }

            get type() {
                return this._type
            }

            get separateAxes() {
                return this._separateAxes
            }

            get gradient() {
                return this._gradient
            }

            get gradientX() {
                return this._gradientX
            }

            get gradientY() {
                return this._gradientY
            }

            get gradientZ() {
                return this._gradientZ
            }

            get constantMin() {
                return this._constantMin
            }

            get constantMax() {
                return this._constantMax
            }

            get constantMinSeparate() {
                return this._constantMinSeparate
            }

            get constantMaxSeparate() {
                return this._constantMaxSeparate
            }

            get gradientMin() {
                return this._gradientMin
            }

            get gradientMax() {
                return this._gradientMax
            }

            get gradientXMin() {
                return this._gradientXMin
            }

            get gradientXMax() {
                return this._gradientXMax
            }

            get gradientYMin() {
                return this._gradientYMin
            }

            get gradientYMax() {
                return this._gradientYMax
            }

            get gradientZMin() {
                return this._gradientZMin
            }

            get gradientZMax() {
                return this._gradientZMax
            }

            getMaxSizeInGradient() {
                var i, n, maxSize = -Number.MAX_VALUE;
                switch (this._type) {
                    case 0:
                        if (this._separateAxes) {
                            for (i = 0, n = this._gradientX.gradientCount; i < n; i++) maxSize = Math.max(maxSize, this._gradientX.getValueByIndex(i));
                            for (i = 0, n = this._gradientY.gradientCount; i < n; i++) maxSize = Math.max(maxSize, this._gradientY.getValueByIndex(i))
                        } else for (i = 0, n = this._gradient.gradientCount; i < n; i++) maxSize = Math.max(maxSize, this._gradient.getValueByIndex(i));
                        break;
                    case 1:
                        this._separateAxes ? (maxSize = Math.max(this._constantMinSeparate.x, this._constantMaxSeparate.x), maxSize = Math.max(maxSize, this._constantMinSeparate.y), maxSize = Math.max(maxSize, this._constantMaxSeparate.y)) : maxSize = Math.max(this._constantMin, this._constantMax);
                        break;
                    case 2:
                        if (this._separateAxes) {
                            for (i = 0, n = this._gradientXMin.gradientCount; i < n; i++) maxSize = Math.max(maxSize, this._gradientXMin.getValueByIndex(i));
                            for (i = 0, n = this._gradientXMax.gradientCount; i < n; i++) maxSize = Math.max(maxSize, this._gradientXMax.getValueByIndex(i));
                            for (i = 0, n = this._gradientYMin.gradientCount; i < n; i++) maxSize = Math.max(maxSize, this._gradientYMin.getValueByIndex(i));
                            for (i = 0, n = this._gradientZMax.gradientCount; i < n; i++) maxSize = Math.max(maxSize, this._gradientZMax.getValueByIndex(i))
                        } else {
                            for (i = 0, n = this._gradientMin.gradientCount; i < n; i++) maxSize = Math.max(maxSize, this._gradientMin.getValueByIndex(i));
                            for (i = 0, n = this._gradientMax.gradientCount; i < n; i++) maxSize = Math.max(maxSize, this._gradientMax.getValueByIndex(i))
                        }
                }
                return maxSize
            }

            cloneTo(destObject) {
                var destGradientSize = destObject;
                destGradientSize._type = this._type, destGradientSize._separateAxes = this._separateAxes, this._gradient.cloneTo(destGradientSize._gradient), this._gradientX.cloneTo(destGradientSize._gradientX), this._gradientY.cloneTo(destGradientSize._gradientY), this._gradientZ.cloneTo(destGradientSize._gradientZ), destGradientSize._constantMin = this._constantMin, destGradientSize._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(destGradientSize._constantMinSeparate), this._constantMaxSeparate.cloneTo(destGradientSize._constantMaxSeparate), this._gradientMin.cloneTo(destGradientSize._gradientMin), this._gradientMax.cloneTo(destGradientSize._gradientMax), this._gradientXMin.cloneTo(destGradientSize._gradientXMin), this._gradientXMax.cloneTo(destGradientSize._gradientXMax), this._gradientYMin.cloneTo(destGradientSize._gradientYMin), this._gradientYMax.cloneTo(destGradientSize._gradientYMax), this._gradientZMin.cloneTo(destGradientSize._gradientZMin), this._gradientZMax.cloneTo(destGradientSize._gradientZMax)
            }

            clone() {
                var destGradientSize = new GradientSize;
                return this.cloneTo(destGradientSize), destGradientSize
            }
        }

        class GradientVelocity {
            constructor() {
                this._type = 0, this._constant = null, this._gradientX = null, this._gradientY = null, this._gradientZ = null, this._constantMin = null, this._constantMax = null, this._gradientXMin = null, this._gradientXMax = null, this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null, this._gradientZMax = null
            }

            static createByConstant(constant) {
                var gradientVelocity = new GradientVelocity;
                return gradientVelocity._type = 0, gradientVelocity._constant = constant, gradientVelocity
            }

            static createByGradient(gradientX, gradientY, gradientZ) {
                var gradientVelocity = new GradientVelocity;
                return gradientVelocity._type = 1, gradientVelocity._gradientX = gradientX, gradientVelocity._gradientY = gradientY, gradientVelocity._gradientZ = gradientZ, gradientVelocity
            }

            static createByRandomTwoConstant(constantMin, constantMax) {
                var gradientVelocity = new GradientVelocity;
                return gradientVelocity._type = 2, gradientVelocity._constantMin = constantMin, gradientVelocity._constantMax = constantMax, gradientVelocity
            }

            static createByRandomTwoGradient(gradientXMin, gradientXMax, gradientYMin, gradientYMax, gradientZMin, gradientZMax) {
                var gradientVelocity = new GradientVelocity;
                return gradientVelocity._type = 3, gradientVelocity._gradientXMin = gradientXMin, gradientVelocity._gradientXMax = gradientXMax, gradientVelocity._gradientYMin = gradientYMin, gradientVelocity._gradientYMax = gradientYMax, gradientVelocity._gradientZMin = gradientZMin, gradientVelocity._gradientZMax = gradientZMax, gradientVelocity
            }

            get type() {
                return this._type
            }

            get constant() {
                return this._constant
            }

            get gradientX() {
                return this._gradientX
            }

            get gradientY() {
                return this._gradientY
            }

            get gradientZ() {
                return this._gradientZ
            }

            get constantMin() {
                return this._constantMin
            }

            get constantMax() {
                return this._constantMax
            }

            get gradientXMin() {
                return this._gradientXMin
            }

            get gradientXMax() {
                return this._gradientXMax
            }

            get gradientYMin() {
                return this._gradientYMin
            }

            get gradientYMax() {
                return this._gradientYMax
            }

            get gradientZMin() {
                return this._gradientZMin
            }

            get gradientZMax() {
                return this._gradientZMax
            }

            cloneTo(destObject) {
                var destGradientVelocity = destObject;
                destGradientVelocity._type = this._type, this._constant.cloneTo(destGradientVelocity._constant), this._gradientX.cloneTo(destGradientVelocity._gradientX), this._gradientY.cloneTo(destGradientVelocity._gradientY), this._gradientZ.cloneTo(destGradientVelocity._gradientZ), this._constantMin.cloneTo(destGradientVelocity._constantMin), this._constantMax.cloneTo(destGradientVelocity._constantMax), this._gradientXMin.cloneTo(destGradientVelocity._gradientXMin), this._gradientXMax.cloneTo(destGradientVelocity._gradientXMax), this._gradientYMin.cloneTo(destGradientVelocity._gradientYMin), this._gradientYMax.cloneTo(destGradientVelocity._gradientYMax), this._gradientZMin.cloneTo(destGradientVelocity._gradientZMin), this._gradientZMax.cloneTo(destGradientVelocity._gradientZMax)
            }

            clone() {
                var destGradientVelocity = new GradientVelocity;
                return this.cloneTo(destGradientVelocity), destGradientVelocity
            }
        }

        class RotationOverLifetime {
            get angularVelocity() {
                return this._angularVelocity
            }

            constructor(angularVelocity) {
                this._angularVelocity = angularVelocity
            }

            cloneTo(destObject) {
                var destRotationOverLifetime = destObject;
                this._angularVelocity.cloneTo(destRotationOverLifetime._angularVelocity), destRotationOverLifetime.enbale = this.enbale
            }

            clone() {
                var destAngularVelocity;
                switch (this._angularVelocity.type) {
                    case 0:
                        destAngularVelocity = this._angularVelocity.separateAxes ? GradientAngularVelocity.createByConstantSeparate(this._angularVelocity.constantSeparate.clone()) : GradientAngularVelocity.createByConstant(this._angularVelocity.constant);
                        break;
                    case 1:
                        destAngularVelocity = this._angularVelocity.separateAxes ? GradientAngularVelocity.createByGradientSeparate(this._angularVelocity.gradientX.clone(), this._angularVelocity.gradientY.clone(), this._angularVelocity.gradientZ.clone()) : GradientAngularVelocity.createByGradient(this._angularVelocity.gradient.clone());
                        break;
                    case 2:
                        destAngularVelocity = this._angularVelocity.separateAxes ? GradientAngularVelocity.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(), this._angularVelocity.constantMaxSeparate.clone()) : GradientAngularVelocity.createByRandomTwoConstant(this._angularVelocity.constantMin, this._angularVelocity.constantMax);
                        break;
                    case 3:
                        destAngularVelocity = this._angularVelocity.separateAxes ? GradientAngularVelocity.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(), this._angularVelocity.gradientYMin.clone(), this._angularVelocity.gradientZMin.clone(), this._angularVelocity.gradientWMin.clone(), this._angularVelocity.gradientXMax.clone(), this._angularVelocity.gradientYMax.clone(), this._angularVelocity.gradientZMax.clone(), this._angularVelocity.gradientWMax.clone()) : GradientAngularVelocity.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(), this._angularVelocity.gradientMax.clone())
                }
                var destRotationOverLifetime = new RotationOverLifetime(destAngularVelocity);
                return destRotationOverLifetime.enbale = this.enbale, destRotationOverLifetime
            }
        }

        class BaseShape {
            constructor() {
            }

            _getShapeBoundBox(boundBox) {
                throw new Error("BaseShape: must override it.")
            }

            _getSpeedBoundBox(boundBox) {
                throw new Error("BaseShape: must override it.")
            }

            generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
                throw new Error("BaseShape: must override it.")
            }

            _calculateProceduralBounds(boundBox, emitterPosScale, minMaxBounds) {
                this._getShapeBoundBox(boundBox);
                var min = boundBox.min, max = boundBox.max;
                Vector3.multiply(min, emitterPosScale, min), Vector3.multiply(max, emitterPosScale, max);
                var speedBounds = new BoundBox(new Vector3, new Vector3);
                this.randomDirection ? (speedBounds.min = new Vector3(-1, -1, -1), speedBounds.max = new Vector3(1, 1, 1)) : this._getSpeedBoundBox(speedBounds);
                var maxSpeedBound = new BoundBox(new Vector3, new Vector3), maxSpeedMin = maxSpeedBound.min,
                    maxSpeedMax = maxSpeedBound.max;
                Vector3.scale(speedBounds.min, minMaxBounds.y, maxSpeedMin), Vector3.scale(speedBounds.max, minMaxBounds.y, maxSpeedMax), Vector3.add(boundBox.min, maxSpeedMin, maxSpeedMin), Vector3.add(boundBox.max, maxSpeedMax, maxSpeedMax), Vector3.min(boundBox.min, maxSpeedMin, boundBox.min), Vector3.max(boundBox.max, maxSpeedMin, boundBox.max);
                var minSpeedBound = new BoundBox(new Vector3, new Vector3), minSpeedMin = minSpeedBound.min,
                    minSpeedMax = minSpeedBound.max;
                Vector3.scale(speedBounds.min, minMaxBounds.x, minSpeedMin), Vector3.scale(speedBounds.max, minMaxBounds.x, minSpeedMax), Vector3.min(minSpeedBound.min, minSpeedMax, maxSpeedMin), Vector3.max(minSpeedBound.min, minSpeedMax, maxSpeedMax), Vector3.min(boundBox.min, maxSpeedMin, boundBox.min), Vector3.max(boundBox.max, maxSpeedMin, boundBox.max)
            }

            cloneTo(destObject) {
                destObject.enable = this.enable
            }

            clone() {
                var destShape = new BaseShape;
                return this.cloneTo(destShape), destShape
            }
        }

        class ShapeUtils {
            static _randomPointUnitArcCircle(arc, out, rand = null) {
                var angle;
                angle = rand ? rand.getFloat() * arc : Math.random() * arc, out.x = Math.cos(angle), out.y = Math.sin(angle)
            }

            static _randomPointInsideUnitArcCircle(arc, out, rand = null) {
                var range;
                ShapeUtils._randomPointUnitArcCircle(arc, out, rand), range = rand ? Math.pow(rand.getFloat(), .5) : Math.pow(Math.random(), .5), out.x = out.x * range, out.y = out.y * range
            }

            static _randomPointUnitCircle(out, rand = null) {
                var angle;
                angle = rand ? rand.getFloat() * Math.PI * 2 : Math.random() * Math.PI * 2, out.x = Math.cos(angle), out.y = Math.sin(angle)
            }

            static _randomPointInsideUnitCircle(out, rand = null) {
                var range;
                ShapeUtils._randomPointUnitCircle(out), range = rand ? Math.pow(rand.getFloat(), .5) : Math.pow(Math.random(), .5), out.x = out.x * range, out.y = out.y * range
            }

            static _randomPointUnitSphere(out, rand = null) {
                var z, a;
                rand ? (z = out.z = 2 * rand.getFloat() - 1, a = rand.getFloat() * Math.PI * 2) : (z = out.z = 2 * Math.random() - 1, a = Math.random() * Math.PI * 2);
                var r = Math.sqrt(1 - z * z);
                out.x = r * Math.cos(a), out.y = r * Math.sin(a)
            }

            static _randomPointInsideUnitSphere(out, rand = null) {
                var range;
                ShapeUtils._randomPointUnitSphere(out), range = rand ? Math.pow(rand.getFloat(), 1 / 3) : Math.pow(Math.random(), 1 / 3), out.x = out.x * range, out.y = out.y * range, out.z = out.z * range
            }

            static _randomPointInsideHalfUnitBox(out, rand = null) {
                rand ? (out.x = rand.getFloat() - .5, out.y = rand.getFloat() - .5, out.z = rand.getFloat() - .5) : (out.x = Math.random() - .5, out.y = Math.random() - .5, out.z = Math.random() - .5)
            }

            constructor() {
            }
        }

        class BoxShape extends BaseShape {
            constructor() {
                super(), this.x = 1, this.y = 1, this.z = 1, this.randomDirection = !1
            }

            _getShapeBoundBox(boundBox) {
                var min = boundBox.min;
                min.x = .5 * -this.x, min.y = .5 * -this.y, min.z = .5 * -this.z;
                var max = boundBox.max;
                max.x = .5 * this.x, max.y = .5 * this.y, max.z = .5 * this.z
            }

            _getSpeedBoundBox(boundBox) {
                var min = boundBox.min;
                min.x = 0, min.y = 0, min.z = 0;
                var max = boundBox.max;
                max.x = 0, max.y = 1, max.z = 0
            }

            generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
                rand ? (rand.seed = randomSeeds[16], ShapeUtils._randomPointInsideHalfUnitBox(position, rand), randomSeeds[16] = rand.seed) : ShapeUtils._randomPointInsideHalfUnitBox(position), position.x = this.x * position.x, position.y = this.y * position.y, position.z = this.z * position.z, this.randomDirection ? rand ? (rand.seed = randomSeeds[17], ShapeUtils._randomPointUnitSphere(direction, rand), randomSeeds[17] = rand.seed) : ShapeUtils._randomPointUnitSphere(direction) : (direction.x = 0, direction.y = 0, direction.z = 1)
            }

            cloneTo(destObject) {
                super.cloneTo(destObject);
                var destShape = destObject;
                destShape.x = this.x, destShape.y = this.y, destShape.z = this.z, destShape.randomDirection = this.randomDirection
            }

            clone() {
                var destShape = new BoxShape;
                return this.cloneTo(destShape), destShape
            }
        }

        class CircleShape extends BaseShape {
            constructor() {
                super(), this.radius = 1, this.arc = 2 * Math.PI, this.emitFromEdge = !1, this.randomDirection = !1
            }

            _getShapeBoundBox(boundBox) {
                var min = boundBox.min;
                min.x = min.z = -this.radius, min.y = 0;
                var max = boundBox.max;
                max.x = max.z = this.radius, max.y = 0
            }

            _getSpeedBoundBox(boundBox) {
                var min = boundBox.min;
                min.x = min.y = -1, min.z = 0;
                var max = boundBox.max;
                max.x = max.y = 1, max.z = 0
            }

            generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
                var positionPoint = CircleShape._tempPositionPoint;
                rand ? (rand.seed = randomSeeds[16], this.emitFromEdge ? ShapeUtils._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint, rand) : ShapeUtils._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint, rand), randomSeeds[16] = rand.seed) : this.emitFromEdge ? ShapeUtils._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint) : ShapeUtils._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint), position.x = -positionPoint.x, position.y = positionPoint.y, position.z = 0, Vector3.scale(position, this.radius, position), this.randomDirection ? rand ? (rand.seed = randomSeeds[17], ShapeUtils._randomPointUnitSphere(direction, rand), randomSeeds[17] = rand.seed) : ShapeUtils._randomPointUnitSphere(direction) : position.cloneTo(direction)
            }

            cloneTo(destObject) {
                super.cloneTo(destObject);
                var destShape = destObject;
                destShape.radius = this.radius, destShape.arc = this.arc, destShape.emitFromEdge = this.emitFromEdge, destShape.randomDirection = this.randomDirection
            }

            clone() {
                var destShape = new CircleShape;
                return this.cloneTo(destShape), destShape
            }
        }

        CircleShape._tempPositionPoint = new Vector2;

        class ConeShape extends BaseShape {
            constructor() {
                super(), this.angle = 25 / 180 * Math.PI, this.radius = 1, this.length = 5, this.emitType = 0, this.randomDirection = !1
            }

            _getShapeBoundBox(boundBox) {
                const coneRadius2 = this.radius + this.length * Math.sin(this.angle),
                    coneLength = this.length * Math.cos(this.angle);
                var min = boundBox.min;
                min.x = min.y = -coneRadius2, min.z = 0;
                var max = boundBox.max;
                max.x = max.y = coneRadius2, max.z = coneLength
            }

            _getSpeedBoundBox(boundBox) {
                const sinA = Math.sin(this.angle);
                var min = boundBox.min;
                min.x = min.y = -sinA, min.z = 0;
                var max = boundBox.max;
                max.x = max.y = sinA, max.z = 1
            }

            generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
                var positionX, positionY, directionPointE, positionPointE = ConeShape._tempPositionPoint,
                    dirCosA = Math.cos(this.angle), dirSinA = Math.sin(this.angle);
                switch (this.emitType) {
                    case 0:
                        rand ? (rand.seed = randomSeeds[16], ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, rand), randomSeeds[16] = rand.seed) : ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint), positionX = positionPointE.x, positionY = positionPointE.y, position.x = positionX * this.radius, position.y = positionY * this.radius, position.z = 0, this.randomDirection ? (rand ? (rand.seed = randomSeeds[17], ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, rand), randomSeeds[17] = rand.seed) : ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint), directionPointE = ConeShape._tempDirectionPoint, direction.x = directionPointE.x * dirSinA, direction.y = directionPointE.y * dirSinA) : (direction.x = positionX * dirSinA, direction.y = positionY * dirSinA), direction.z = dirCosA;
                        break;
                    case 1:
                        rand ? (rand.seed = randomSeeds[16], ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint, rand), randomSeeds[16] = rand.seed) : ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint), positionX = positionPointE.x, positionY = positionPointE.y, position.x = positionX * this.radius, position.y = positionY * this.radius, position.z = 0, this.randomDirection ? (rand ? (rand.seed = randomSeeds[17], ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, rand), randomSeeds[17] = rand.seed) : ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint), directionPointE = ConeShape._tempDirectionPoint, direction.x = directionPointE.x * dirSinA, direction.y = directionPointE.y * dirSinA) : (direction.x = positionX * dirSinA, direction.y = positionY * dirSinA), direction.z = dirCosA;
                        break;
                    case 2:
                        rand ? (rand.seed = randomSeeds[16], ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, rand)) : ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint), positionX = positionPointE.x, positionY = positionPointE.y, position.x = positionX * this.radius, position.y = positionY * this.radius, position.z = 0, direction.x = positionX * dirSinA, direction.y = positionY * dirSinA, direction.z = dirCosA, Vector3.normalize(direction, direction), rand ? (Vector3.scale(direction, this.length * rand.getFloat(), direction), randomSeeds[16] = rand.seed) : Vector3.scale(direction, this.length * Math.random(), direction), Vector3.add(position, direction, position), this.randomDirection && (rand ? (rand.seed = randomSeeds[17], ShapeUtils._randomPointUnitSphere(direction, rand), randomSeeds[17] = rand.seed) : ShapeUtils._randomPointUnitSphere(direction));
                        break;
                    case 3:
                        rand ? (rand.seed = randomSeeds[16], ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint, rand)) : ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint), positionX = positionPointE.x, positionY = positionPointE.y, position.x = positionX * this.radius, position.y = positionY * this.radius, position.z = 0, direction.x = positionX * dirSinA, direction.y = positionY * dirSinA, direction.z = dirCosA, Vector3.normalize(direction, direction), rand ? (Vector3.scale(direction, this.length * rand.getFloat(), direction), randomSeeds[16] = rand.seed) : Vector3.scale(direction, this.length * Math.random(), direction), Vector3.add(position, direction, position), this.randomDirection && (rand ? (rand.seed = randomSeeds[17], ShapeUtils._randomPointUnitSphere(direction, rand), randomSeeds[17] = rand.seed) : ShapeUtils._randomPointUnitSphere(direction));
                        break;
                    default:
                        throw new Error("ConeShape:emitType is invalid.")
                }
            }

            cloneTo(destObject) {
                super.cloneTo(destObject);
                var destShape = destObject;
                destShape.angle = this.angle, destShape.radius = this.radius, destShape.length = this.length, destShape.emitType = this.emitType, destShape.randomDirection = this.randomDirection
            }

            clone() {
                var destShape = new ConeShape;
                return this.cloneTo(destShape), destShape
            }
        }

        ConeShape._tempPositionPoint = new Vector2, ConeShape._tempDirectionPoint = new Vector2;

        class HemisphereShape extends BaseShape {
            constructor() {
                super(), this.radius = 1, this.emitFromShell = !1, this.randomDirection = !1
            }

            _getShapeBoundBox(boundBox) {
                var min = boundBox.min;
                min.x = min.y = min.z = -this.radius;
                var max = boundBox.max;
                max.x = max.y = this.radius, max.z = 0
            }

            _getSpeedBoundBox(boundBox) {
                var min = boundBox.min;
                min.x = min.y = -1, min.z = 0;
                var max = boundBox.max;
                max.x = max.y = max.z = 1
            }

            generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
                rand ? (rand.seed = randomSeeds[16], this.emitFromShell ? ShapeUtils._randomPointUnitSphere(position, rand) : ShapeUtils._randomPointInsideUnitSphere(position, rand), randomSeeds[16] = rand.seed) : this.emitFromShell ? ShapeUtils._randomPointUnitSphere(position) : ShapeUtils._randomPointInsideUnitSphere(position), Vector3.scale(position, this.radius, position);
                var z = position.z;
                z < 0 && (position.z = -1 * z), this.randomDirection ? rand ? (rand.seed = randomSeeds[17], ShapeUtils._randomPointUnitSphere(direction, rand), randomSeeds[17] = rand.seed) : ShapeUtils._randomPointUnitSphere(direction) : position.cloneTo(direction)
            }

            cloneTo(destObject) {
                super.cloneTo(destObject);
                var destShape = destObject;
                destShape.radius = this.radius, destShape.emitFromShell = this.emitFromShell, destShape.randomDirection = this.randomDirection
            }

            clone() {
                var destShape = new HemisphereShape;
                return this.cloneTo(destShape), destShape
            }
        }

        class SphereShape extends BaseShape {
            constructor() {
                super(), this.radius = 1, this.emitFromShell = !1, this.randomDirection = !1
            }

            _getShapeBoundBox(boundBox) {
                var min = boundBox.min;
                min.x = min.y = min.z = -this.radius;
                var max = boundBox.max;
                max.x = max.y = max.z = this.radius
            }

            _getSpeedBoundBox(boundBox) {
                var min = boundBox.min;
                min.x = min.y = min.z = -1;
                var max = boundBox.max;
                max.x = max.y = max.z = 1
            }

            generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
                rand ? (rand.seed = randomSeeds[16], this.emitFromShell ? ShapeUtils._randomPointUnitSphere(position, rand) : ShapeUtils._randomPointInsideUnitSphere(position, rand), randomSeeds[16] = rand.seed) : this.emitFromShell ? ShapeUtils._randomPointUnitSphere(position) : ShapeUtils._randomPointInsideUnitSphere(position), Vector3.scale(position, this.radius, position), this.randomDirection ? rand ? (rand.seed = randomSeeds[17], ShapeUtils._randomPointUnitSphere(direction, rand), randomSeeds[17] = rand.seed) : ShapeUtils._randomPointUnitSphere(direction) : position.cloneTo(direction)
            }

            cloneTo(destObject) {
                super.cloneTo(destObject);
                var destShape = destObject;
                destShape.radius = this.radius, destShape.emitFromShell = this.emitFromShell, destShape.randomDirection = this.randomDirection
            }

            clone() {
                var destShape = new SphereShape;
                return this.cloneTo(destShape), destShape
            }
        }

        class SizeOverLifetime {
            get size() {
                return this._size
            }

            constructor(size) {
                this._size = size
            }

            cloneTo(destObject) {
                var destSizeOverLifetime = destObject;
                this._size.cloneTo(destSizeOverLifetime._size), destSizeOverLifetime.enbale = this.enbale
            }

            clone() {
                var destSize;
                switch (this._size.type) {
                    case 0:
                        destSize = this._size.separateAxes ? GradientSize.createByGradientSeparate(this._size.gradientX.clone(), this._size.gradientY.clone(), this._size.gradientZ.clone()) : GradientSize.createByGradient(this._size.gradient.clone());
                        break;
                    case 1:
                        destSize = this._size.separateAxes ? GradientSize.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(), this._size.constantMaxSeparate.clone()) : GradientSize.createByRandomTwoConstant(this._size.constantMin, this._size.constantMax);
                        break;
                    case 2:
                        destSize = this._size.separateAxes ? GradientSize.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(), this._size.gradientYMin.clone(), this._size.gradientZMin.clone(), this._size.gradientXMax.clone(), this._size.gradientYMax.clone(), this._size.gradientZMax.clone()) : GradientSize.createByRandomTwoGradient(this._size.gradientMin.clone(), this._size.gradientMax.clone())
                }
                var destSizeOverLifetime = new SizeOverLifetime(destSize);
                return destSizeOverLifetime.enbale = this.enbale, destSizeOverLifetime
            }
        }

        class StartFrame {
            constructor() {
                this._type = 0, this._constant = 0, this._constantMin = 0, this._constantMax = 0
            }

            static createByConstant(constant) {
                var rotationOverLifetime = new StartFrame;
                return rotationOverLifetime._type = 0, rotationOverLifetime._constant = constant, rotationOverLifetime
            }

            static createByRandomTwoConstant(constantMin, constantMax) {
                var rotationOverLifetime = new StartFrame;
                return rotationOverLifetime._type = 1, rotationOverLifetime._constantMin = constantMin, rotationOverLifetime._constantMax = constantMax, rotationOverLifetime
            }

            get type() {
                return this._type
            }

            get constant() {
                return this._constant
            }

            get constantMin() {
                return this._constantMin
            }

            get constantMax() {
                return this._constantMax
            }

            cloneTo(destObject) {
                var destStartFrame = destObject;
                destStartFrame._type = this._type, destStartFrame._constant = this._constant, destStartFrame._constantMin = this._constantMin, destStartFrame._constantMax = this._constantMax
            }

            clone() {
                var destStartFrame = new StartFrame;
                return this.cloneTo(destStartFrame), destStartFrame
            }
        }

        class TextureSheetAnimation {
            constructor(frame, startFrame) {
                this.type = 0, this.randomRow = !1, this.rowIndex = 0, this.cycles = 0, this.enableUVChannels = 0, this.enable = !1, this.tiles = new Vector2(1, 1), this.type = 0, this.randomRow = !0, this.rowIndex = 0, this.cycles = 1, this.enableUVChannels = 1, this._frame = frame, this._startFrame = startFrame
            }

            get frame() {
                return this._frame
            }

            get startFrame() {
                return this._startFrame
            }

            cloneTo(destObject) {
                var destTextureSheetAnimation = destObject;
                this.tiles.cloneTo(destTextureSheetAnimation.tiles), destTextureSheetAnimation.type = this.type, destTextureSheetAnimation.randomRow = this.randomRow, destTextureSheetAnimation.rowIndex = this.rowIndex, destTextureSheetAnimation.cycles = this.cycles, destTextureSheetAnimation.enableUVChannels = this.enableUVChannels, destTextureSheetAnimation.enable = this.enable, this._frame.cloneTo(destTextureSheetAnimation._frame), this._startFrame.cloneTo(destTextureSheetAnimation._startFrame)
            }

            clone() {
                var destFrame, destStartFrame;
                switch (this._frame.type) {
                    case 0:
                        destFrame = FrameOverTime.createByConstant(this._frame.constant);
                        break;
                    case 1:
                        destFrame = FrameOverTime.createByOverTime(this._frame.frameOverTimeData.clone());
                        break;
                    case 2:
                        destFrame = FrameOverTime.createByRandomTwoConstant(this._frame.constantMin, this._frame.constantMax);
                        break;
                    case 3:
                        destFrame = FrameOverTime.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(), this._frame.frameOverTimeDataMax.clone())
                }
                switch (this._startFrame.type) {
                    case 0:
                        destStartFrame = StartFrame.createByConstant(this._startFrame.constant);
                        break;
                    case 1:
                        destStartFrame = StartFrame.createByRandomTwoConstant(this._startFrame.constantMin, this._startFrame.constantMax)
                }
                var destTextureSheetAnimation = new TextureSheetAnimation(destFrame, destStartFrame);
                return this.cloneTo(destTextureSheetAnimation), destTextureSheetAnimation
            }
        }

        class VelocityOverLifetime {
            constructor(velocity) {
                this.enbale = !1, this.space = 0, this._velocity = velocity
            }

            get velocity() {
                return this._velocity
            }

            cloneTo(destObject) {
                var destVelocityOverLifetime = destObject;
                this._velocity.cloneTo(destVelocityOverLifetime._velocity), destVelocityOverLifetime.enbale = this.enbale, destVelocityOverLifetime.space = this.space
            }

            clone() {
                var destVelocity;
                switch (this._velocity.type) {
                    case 0:
                        destVelocity = GradientVelocity.createByConstant(this._velocity.constant.clone());
                        break;
                    case 1:
                        destVelocity = GradientVelocity.createByGradient(this._velocity.gradientX.clone(), this._velocity.gradientY.clone(), this._velocity.gradientZ.clone());
                        break;
                    case 2:
                        destVelocity = GradientVelocity.createByRandomTwoConstant(this._velocity.constantMin.clone(), this._velocity.constantMax.clone());
                        break;
                    case 3:
                        destVelocity = GradientVelocity.createByRandomTwoGradient(this._velocity.gradientXMin.clone(), this._velocity.gradientYMin.clone(), this._velocity.gradientZMin.clone(), this._velocity.gradientXMax.clone(), this._velocity.gradientYMax.clone(), this._velocity.gradientZMax.clone())
                }
                var destVelocityOverLifetime = new VelocityOverLifetime(destVelocity);
                return destVelocityOverLifetime.enbale = this.enbale, destVelocityOverLifetime.space = this.space, destVelocityOverLifetime
            }
        }

        class ShuriKenParticle3D extends RenderableSprite3D {
            static __init__() {
                ShuriKenParticle3D.shaderDefines = new ShaderDefines(RenderableSprite3D.shaderDefines), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_BILLBOARD = ShuriKenParticle3D.shaderDefines.registerDefine("SPHERHBILLBOARD"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = ShuriKenParticle3D.shaderDefines.registerDefine("STRETCHEDBILLBOARD"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = ShuriKenParticle3D.shaderDefines.registerDefine("HORIZONTALBILLBOARD"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = ShuriKenParticle3D.shaderDefines.registerDefine("VERTICALBILLBOARD"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME = ShuriKenParticle3D.shaderDefines.registerDefine("COLOROVERLIFETIME"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = ShuriKenParticle3D.shaderDefines.registerDefine("RANDOMCOLOROVERLIFETIME"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECONSTANT"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECURVE"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCONSTANT"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCURVE"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = ShuriKenParticle3D.shaderDefines.registerDefine("TEXTURESHEETANIMATIONCURVE"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = ShuriKenParticle3D.shaderDefines.registerDefine("TEXTURESHEETANIMATIONRANDOMCURVE"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIME"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMESEPERATE"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECONSTANT"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECURVE"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCONSTANTS"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCURVES"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVE = ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVE"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVESEPERATE"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVES"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVESSEPERATE"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_MESH = ShuriKenParticle3D.shaderDefines.registerDefine("RENDERMODE_MESH"), ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SHAPE = ShuriKenParticle3D.shaderDefines.registerDefine("SHAPE")
            }

            get particleSystem() {
                return this._particleSystem
            }

            get particleRenderer() {
                return this._render
            }

            constructor() {
                super(null), this._render = new ShurikenParticleRenderer(this), this._particleSystem = new ShurikenParticleSystem(this);
                var element = this._render._renderElements[0] = new RenderElement;
                element.setTransform(this._transform), element.render = this._render, element.setGeometry(this._particleSystem), element.material = ShurikenParticleMaterial.defaultMaterial
            }

            static _initStartLife(gradientData) {
                for (var gradient = new GradientDataNumber, startLifetimesData = gradientData.startLifetimes, i = 0, n = startLifetimesData.length; i < n; i++) {
                    var valueData = startLifetimesData[i];
                    gradient.add(valueData.key, valueData.value)
                }
                return gradient
            }

            _initParticleVelocity(gradientData) {
                for (var gradient = new GradientDataNumber, velocitysData = gradientData.velocitys, i = 0, n = velocitysData.length; i < n; i++) {
                    var valueData = velocitysData[i];
                    gradient.add(valueData.key, valueData.value)
                }
                return gradient
            }

            _initParticleColor(gradientColorData) {
                var i, n, gradientColor = new Gradient(4, 4), alphasData = gradientColorData.alphas;
                for (i = 0, n = alphasData.length; i < n; i++) {
                    var alphaData = alphasData[i];
                    3 === i && 1 !== alphaData.key && (alphaData.key = 1, console.log("GradientDataColor warning:the forth key is  be force set to 1.")), gradientColor.addColorAlpha(alphaData.key, alphaData.value)
                }
                var rgbsData = gradientColorData.rgbs;
                for (i = 0, n = rgbsData.length; i < n; i++) {
                    var rgbData = rgbsData[i], rgbValue = rgbData.value;
                    3 === i && 1 !== rgbData.key && (rgbData.key = 1, console.log("GradientDataColor warning:the forth key is  be force set to 1.")), gradientColor.addColorRGB(rgbData.key, new Color(rgbValue[0], rgbValue[1], rgbValue[2], 1))
                }
                return gradientColor
            }

            _initParticleSize(gradientSizeData) {
                for (var gradientSize = new GradientDataNumber, sizesData = gradientSizeData.sizes, i = 0, n = sizesData.length; i < n; i++) {
                    var valueData = sizesData[i];
                    gradientSize.add(valueData.key, valueData.value)
                }
                return gradientSize
            }

            _initParticleRotation(gradientData) {
                for (var gradient = new GradientDataNumber, angularVelocitysData = gradientData.angularVelocitys, i = 0, n = angularVelocitysData.length; i < n; i++) {
                    var valueData = angularVelocitysData[i];
                    gradient.add(valueData.key, valueData.value / 180 * Math.PI)
                }
                return gradient
            }

            _initParticleFrame(overTimeFramesData) {
                for (var overTimeFrame = new GradientDataInt, framesData = overTimeFramesData.frames, i = 0, n = framesData.length; i < n; i++) {
                    var frameData = framesData[i];
                    overTimeFrame.add(frameData.key, frameData.value)
                }
                return overTimeFrame
            }

            _parse(data, spriteMap) {
                super._parse(data, spriteMap);
                const anglelToRad = Math.PI / 180;
                var i, n, material, particleRender = this.particleRenderer, materialData = data.material;
                materialData && (material = Laya.Loader.getRes(materialData.path)), particleRender.sharedMaterial = material;
                var meshPath = data.meshPath;
                meshPath && (particleRender.mesh = Laya.Loader.getRes(meshPath)), particleRender.renderMode = data.renderMode, particleRender.stretchedBillboardCameraSpeedScale = data.stretchedBillboardCameraSpeedScale, particleRender.stretchedBillboardSpeedScale = data.stretchedBillboardSpeedScale, particleRender.stretchedBillboardLengthScale = data.stretchedBillboardLengthScale, particleRender.sortingFudge = data.sortingFudge ? data.sortingFudge : 0;
                var particleSystem = this.particleSystem;
                particleSystem.isPerformanceMode = data.isPerformanceMode, particleSystem.duration = data.duration, particleSystem.looping = data.looping, particleSystem.prewarm = data.prewarm, particleSystem.startDelayType = data.startDelayType, particleSystem.startDelay = data.startDelay, particleSystem.startDelayMin = data.startDelayMin, particleSystem.startDelayMax = data.startDelayMax, particleSystem.startLifetimeType = data.startLifetimeType, particleSystem.startLifetimeConstant = data.startLifetimeConstant, particleSystem.startLifeTimeGradient = ShuriKenParticle3D._initStartLife(data.startLifetimeGradient), particleSystem.startLifetimeConstantMin = data.startLifetimeConstantMin, particleSystem.startLifetimeConstantMax = data.startLifetimeConstantMax, particleSystem.startLifeTimeGradientMin = ShuriKenParticle3D._initStartLife(data.startLifetimeGradientMin), particleSystem.startLifeTimeGradientMax = ShuriKenParticle3D._initStartLife(data.startLifetimeGradientMax), particleSystem.startSpeedType = data.startSpeedType, particleSystem.startSpeedConstant = data.startSpeedConstant, particleSystem.startSpeedConstantMin = data.startSpeedConstantMin, particleSystem.startSpeedConstantMax = data.startSpeedConstantMax, particleSystem.threeDStartSize = data.threeDStartSize, particleSystem.startSizeType = data.startSizeType, particleSystem.startSizeConstant = data.startSizeConstant;
                var startSizeConstantSeparateArray = data.startSizeConstantSeparate,
                    startSizeConstantSeparateElement = particleSystem.startSizeConstantSeparate;
                startSizeConstantSeparateElement.x = startSizeConstantSeparateArray[0], startSizeConstantSeparateElement.y = startSizeConstantSeparateArray[1], startSizeConstantSeparateElement.z = startSizeConstantSeparateArray[2], particleSystem.startSizeConstantMin = data.startSizeConstantMin, particleSystem.startSizeConstantMax = data.startSizeConstantMax;
                var startSizeConstantMinSeparateArray = data.startSizeConstantMinSeparate,
                    startSizeConstantMinSeparateElement = particleSystem.startSizeConstantMinSeparate;
                startSizeConstantMinSeparateElement.x = startSizeConstantMinSeparateArray[0], startSizeConstantMinSeparateElement.y = startSizeConstantMinSeparateArray[1], startSizeConstantMinSeparateElement.z = startSizeConstantMinSeparateArray[2];
                var startSizeConstantMaxSeparateArray = data.startSizeConstantMaxSeparate,
                    startSizeConstantMaxSeparateElement = particleSystem.startSizeConstantMaxSeparate;
                startSizeConstantMaxSeparateElement.x = startSizeConstantMaxSeparateArray[0], startSizeConstantMaxSeparateElement.y = startSizeConstantMaxSeparateArray[1], startSizeConstantMaxSeparateElement.z = startSizeConstantMaxSeparateArray[2], particleSystem.threeDStartRotation = data.threeDStartRotation, particleSystem.startRotationType = data.startRotationType, particleSystem.startRotationConstant = data.startRotationConstant * anglelToRad;
                var startRotationConstantSeparateArray = data.startRotationConstantSeparate,
                    startRotationConstantSeparateElement = particleSystem.startRotationConstantSeparate;
                startRotationConstantSeparateElement.x = startRotationConstantSeparateArray[0] * anglelToRad, startRotationConstantSeparateElement.y = startRotationConstantSeparateArray[1] * anglelToRad, startRotationConstantSeparateElement.z = startRotationConstantSeparateArray[2] * anglelToRad, particleSystem.startRotationConstantMin = data.startRotationConstantMin * anglelToRad, particleSystem.startRotationConstantMax = data.startRotationConstantMax * anglelToRad;
                var startRotationConstantMinSeparateArray = data.startRotationConstantMinSeparate,
                    startRotationConstantMinSeparateElement = particleSystem.startRotationConstantMinSeparate;
                startRotationConstantMinSeparateElement.x = startRotationConstantMinSeparateArray[0] * anglelToRad, startRotationConstantMinSeparateElement.y = startRotationConstantMinSeparateArray[1] * anglelToRad, startRotationConstantMinSeparateElement.z = startRotationConstantMinSeparateArray[2] * anglelToRad;
                var startRotationConstantMaxSeparateArray = data.startRotationConstantMaxSeparate,
                    startRotationConstantMaxSeparateElement = particleSystem.startRotationConstantMaxSeparate;
                startRotationConstantMaxSeparateElement.x = startRotationConstantMaxSeparateArray[0] * anglelToRad, startRotationConstantMaxSeparateElement.y = startRotationConstantMaxSeparateArray[1] * anglelToRad, startRotationConstantMaxSeparateElement.z = startRotationConstantMaxSeparateArray[2] * anglelToRad, particleSystem.randomizeRotationDirection = data.randomizeRotationDirection, particleSystem.startColorType = data.startColorType;
                var startColorConstantArray = data.startColorConstant,
                    startColorConstantElement = particleSystem.startColorConstant;
                startColorConstantElement.x = startColorConstantArray[0], startColorConstantElement.y = startColorConstantArray[1], startColorConstantElement.z = startColorConstantArray[2], startColorConstantElement.w = startColorConstantArray[3];
                var startColorConstantMinArray = data.startColorConstantMin,
                    startColorConstantMinElement = particleSystem.startColorConstantMin;
                startColorConstantMinElement.x = startColorConstantMinArray[0], startColorConstantMinElement.y = startColorConstantMinArray[1], startColorConstantMinElement.z = startColorConstantMinArray[2], startColorConstantMinElement.w = startColorConstantMinArray[3];
                var startColorConstantMaxArray = data.startColorConstantMax,
                    startColorConstantMaxElement = particleSystem.startColorConstantMax;
                startColorConstantMaxElement.x = startColorConstantMaxArray[0], startColorConstantMaxElement.y = startColorConstantMaxArray[1], startColorConstantMaxElement.z = startColorConstantMaxArray[2], startColorConstantMaxElement.w = startColorConstantMaxArray[3], particleSystem.gravityModifier = data.gravityModifier, particleSystem.simulationSpace = data.simulationSpace, particleSystem.scaleMode = data.scaleMode, particleSystem.playOnAwake = data.playOnAwake, particleSystem.maxParticles = data.maxParticles;
                var autoRandomSeed = data.autoRandomSeed;
                null != autoRandomSeed && (particleSystem.autoRandomSeed = autoRandomSeed);
                var randomSeed = data.randomSeed;
                null != randomSeed && (particleSystem.randomSeed[0] = randomSeed);
                var emissionData = data.emission, emission = particleSystem.emission;
                if (emissionData) {
                    emission.emissionRate = emissionData.emissionRate;
                    var burstsData = emissionData.bursts;
                    if (burstsData) for (i = 0, n = burstsData.length; i < n; i++) {
                        var brust = burstsData[i];
                        emission.addBurst(new Burst(brust.time, brust.min, brust.max))
                    }
                    emission.enbale = emissionData.enable
                } else emission.enbale = !1;
                var shapeData = data.shape;
                if (shapeData) {
                    var shape;
                    switch (shapeData.shapeType) {
                        case 0:
                            var sphereShape;
                            shape = sphereShape = new SphereShape, sphereShape.radius = shapeData.sphereRadius, sphereShape.emitFromShell = shapeData.sphereEmitFromShell, sphereShape.randomDirection = shapeData.sphereRandomDirection;
                            break;
                        case 1:
                            var hemiSphereShape;
                            shape = hemiSphereShape = new HemisphereShape, hemiSphereShape.radius = shapeData.hemiSphereRadius, hemiSphereShape.emitFromShell = shapeData.hemiSphereEmitFromShell, hemiSphereShape.randomDirection = shapeData.hemiSphereRandomDirection;
                            break;
                        case 2:
                            var coneShape;
                            shape = coneShape = new ConeShape, coneShape.angle = shapeData.coneAngle * anglelToRad, coneShape.radius = shapeData.coneRadius, coneShape.length = shapeData.coneLength, coneShape.emitType = shapeData.coneEmitType, coneShape.randomDirection = shapeData.coneRandomDirection;
                            break;
                        case 3:
                            var boxShape;
                            shape = boxShape = new BoxShape, boxShape.x = shapeData.boxX, boxShape.y = shapeData.boxY, boxShape.z = shapeData.boxZ, boxShape.randomDirection = shapeData.boxRandomDirection;
                            break;
                        case 7:
                            var circleShape;
                            shape = circleShape = new CircleShape, circleShape.radius = shapeData.circleRadius, circleShape.arc = shapeData.circleArc * anglelToRad, circleShape.emitFromEdge = shapeData.circleEmitFromEdge, circleShape.randomDirection = shapeData.circleRandomDirection;
                            break;
                        default:
                            var tempShape;
                            shape = tempShape = new CircleShape, tempShape.radius = shapeData.circleRadius, tempShape.arc = shapeData.circleArc * anglelToRad, tempShape.emitFromEdge = shapeData.circleEmitFromEdge, tempShape.randomDirection = shapeData.circleRandomDirection
                    }
                    shape.enable = shapeData.enable, particleSystem.shape = shape
                }
                var velocityOverLifetimeData = data.velocityOverLifetime;
                if (velocityOverLifetimeData) {
                    var velocity, velocityData = velocityOverLifetimeData.velocity;
                    switch (velocityData.type) {
                        case 0:
                            var constantData = velocityData.constant;
                            velocity = GradientVelocity.createByConstant(new Vector3(constantData[0], constantData[1], constantData[2]));
                            break;
                        case 1:
                            velocity = GradientVelocity.createByGradient(this._initParticleVelocity(velocityData.gradientX), this._initParticleVelocity(velocityData.gradientY), this._initParticleVelocity(velocityData.gradientZ));
                            break;
                        case 2:
                            var constantMinData = velocityData.constantMin, constantMaxData = velocityData.constantMax;
                            velocity = GradientVelocity.createByRandomTwoConstant(new Vector3(constantMinData[0], constantMinData[1], constantMinData[2]), new Vector3(constantMaxData[0], constantMaxData[1], constantMaxData[2]));
                            break;
                        case 3:
                            velocity = GradientVelocity.createByRandomTwoGradient(this._initParticleVelocity(velocityData.gradientXMin), this._initParticleVelocity(velocityData.gradientXMax), this._initParticleVelocity(velocityData.gradientYMin), this._initParticleVelocity(velocityData.gradientYMax), this._initParticleVelocity(velocityData.gradientZMin), this._initParticleVelocity(velocityData.gradientZMax))
                    }
                    var velocityOverLifetime = new VelocityOverLifetime(velocity);
                    velocityOverLifetime.space = velocityOverLifetimeData.space, velocityOverLifetime.enbale = velocityOverLifetimeData.enable, particleSystem.velocityOverLifetime = velocityOverLifetime
                }
                var colorOverLifetimeData = data.colorOverLifetime;
                if (colorOverLifetimeData) {
                    var color, colorData = colorOverLifetimeData.color;
                    switch (colorData.type) {
                        case 0:
                            var constColorData = colorData.constant;
                            color = GradientColor.createByConstant(new Vector4(constColorData[0], constColorData[1], constColorData[2], constColorData[3]));
                            break;
                        case 1:
                            color = GradientColor.createByGradient(this._initParticleColor(colorData.gradient));
                            break;
                        case 2:
                            var minConstColorData = colorData.constantMin, maxConstColorData = colorData.constantMax;
                            color = GradientColor.createByRandomTwoConstant(new Vector4(minConstColorData[0], minConstColorData[1], minConstColorData[2], minConstColorData[3]), new Vector4(maxConstColorData[0], maxConstColorData[1], maxConstColorData[2], maxConstColorData[3]));
                            break;
                        case 3:
                            color = GradientColor.createByRandomTwoGradient(this._initParticleColor(colorData.gradientMin), this._initParticleColor(colorData.gradientMax))
                    }
                    var colorOverLifetime = new ColorOverLifetime(color);
                    colorOverLifetime.enbale = colorOverLifetimeData.enable, particleSystem.colorOverLifetime = colorOverLifetime
                }
                var sizeOverLifetimeData = data.sizeOverLifetime;
                if (sizeOverLifetimeData) {
                    var size, sizeData = sizeOverLifetimeData.size;
                    switch (sizeData.type) {
                        case 0:
                            size = sizeData.separateAxes ? GradientSize.createByGradientSeparate(this._initParticleSize(sizeData.gradientX), this._initParticleSize(sizeData.gradientY), this._initParticleSize(sizeData.gradientZ)) : GradientSize.createByGradient(this._initParticleSize(sizeData.gradient));
                            break;
                        case 1:
                            if (sizeData.separateAxes) {
                                var constantMinSeparateData = sizeData.constantMinSeparate,
                                    constantMaxSeparateData = sizeData.constantMaxSeparate;
                                size = GradientSize.createByRandomTwoConstantSeparate(new Vector3(constantMinSeparateData[0], constantMinSeparateData[1], constantMinSeparateData[2]), new Vector3(constantMaxSeparateData[0], constantMaxSeparateData[1], constantMaxSeparateData[2]))
                            } else size = GradientSize.createByRandomTwoConstant(sizeData.constantMin, sizeData.constantMax);
                            break;
                        case 2:
                            size = sizeData.separateAxes ? GradientSize.createByRandomTwoGradientSeparate(this._initParticleSize(sizeData.gradientXMin), this._initParticleSize(sizeData.gradientYMin), this._initParticleSize(sizeData.gradientZMin), this._initParticleSize(sizeData.gradientXMax), this._initParticleSize(sizeData.gradientYMax), this._initParticleSize(sizeData.gradientZMax)) : GradientSize.createByRandomTwoGradient(this._initParticleSize(sizeData.gradientMin), this._initParticleSize(sizeData.gradientMax))
                    }
                    var sizeOverLifetime = new SizeOverLifetime(size);
                    sizeOverLifetime.enbale = sizeOverLifetimeData.enable, particleSystem.sizeOverLifetime = sizeOverLifetime
                }
                var rotationOverLifetimeData = data.rotationOverLifetime;
                if (rotationOverLifetimeData) {
                    var angularVelocity, angularVelocityData = rotationOverLifetimeData.angularVelocity;
                    switch (angularVelocityData.type) {
                        case 0:
                            if (angularVelocityData.separateAxes) {
                                var conSep = angularVelocityData.constantSeparate;
                                angularVelocity = GradientAngularVelocity.createByConstantSeparate(new Vector3(conSep[0] * anglelToRad, conSep[1] * anglelToRad, conSep[2] * anglelToRad))
                            } else angularVelocity = GradientAngularVelocity.createByConstant(angularVelocityData.constant * anglelToRad);
                            break;
                        case 1:
                            angularVelocity = angularVelocityData.separateAxes ? GradientAngularVelocity.createByGradientSeparate(this._initParticleRotation(angularVelocityData.gradientX), this._initParticleRotation(angularVelocityData.gradientY), this._initParticleRotation(angularVelocityData.gradientZ)) : GradientAngularVelocity.createByGradient(this._initParticleRotation(angularVelocityData.gradient));
                            break;
                        case 2:
                            if (angularVelocityData.separateAxes) {
                                var minSep = angularVelocityData.constantMinSeparate,
                                    maxSep = angularVelocityData.constantMaxSeparate;
                                angularVelocity = GradientAngularVelocity.createByRandomTwoConstantSeparate(new Vector3(minSep[0] * anglelToRad, minSep[1] * anglelToRad, minSep[2] * anglelToRad), new Vector3(maxSep[0] * anglelToRad, maxSep[1] * anglelToRad, maxSep[2] * anglelToRad))
                            } else angularVelocity = GradientAngularVelocity.createByRandomTwoConstant(angularVelocityData.constantMin * anglelToRad, angularVelocityData.constantMax * anglelToRad);
                            break;
                        case 3:
                            angularVelocityData.separateAxes || (angularVelocity = GradientAngularVelocity.createByRandomTwoGradient(this._initParticleRotation(angularVelocityData.gradientMin), this._initParticleRotation(angularVelocityData.gradientMax)))
                    }
                    var rotationOverLifetime = new RotationOverLifetime(angularVelocity);
                    rotationOverLifetime.enbale = rotationOverLifetimeData.enable, particleSystem.rotationOverLifetime = rotationOverLifetime
                }
                var textureSheetAnimationData = data.textureSheetAnimation;
                if (textureSheetAnimationData) {
                    var frameOverTime, frameData = textureSheetAnimationData.frame;
                    switch (frameData.type) {
                        case 0:
                            frameOverTime = FrameOverTime.createByConstant(frameData.constant);
                            break;
                        case 1:
                            frameOverTime = FrameOverTime.createByOverTime(this._initParticleFrame(frameData.overTime));
                            break;
                        case 2:
                            frameOverTime = FrameOverTime.createByRandomTwoConstant(frameData.constantMin, frameData.constantMax);
                            break;
                        case 3:
                            frameOverTime = FrameOverTime.createByRandomTwoOverTime(this._initParticleFrame(frameData.overTimeMin), this._initParticleFrame(frameData.overTimeMax))
                    }
                    var startFrame, startFrameData = textureSheetAnimationData.startFrame;
                    switch (startFrameData.type) {
                        case 0:
                            startFrame = StartFrame.createByConstant(startFrameData.constant);
                            break;
                        case 1:
                            startFrame = StartFrame.createByRandomTwoConstant(startFrameData.constantMin, startFrameData.constantMax)
                    }
                    var textureSheetAnimation = new TextureSheetAnimation(frameOverTime, startFrame);
                    textureSheetAnimation.enable = textureSheetAnimationData.enable;
                    var tilesData = textureSheetAnimationData.tiles;
                    textureSheetAnimation.tiles = new Vector2(tilesData[0], tilesData[1]), textureSheetAnimation.type = textureSheetAnimationData.type, textureSheetAnimation.randomRow = textureSheetAnimationData.randomRow;
                    var rowIndex = textureSheetAnimationData.rowIndex;
                    void 0 !== rowIndex && (textureSheetAnimation.rowIndex = rowIndex), textureSheetAnimation.cycles = textureSheetAnimationData.cycles, particleSystem.textureSheetAnimation = textureSheetAnimation
                }
            }

            _activeHierarchy(activeChangeComponents) {
                super._activeHierarchy(activeChangeComponents), this.particleSystem.playOnAwake && this.particleSystem.play()
            }

            _inActiveHierarchy(activeChangeComponents) {
                super._inActiveHierarchy(activeChangeComponents), this.particleSystem.isAlive && this.particleSystem.simulate(0, !0)
            }

            _cloneTo(destObject, srcSprite, dstSprite) {
                var destShuriKenParticle3D = destObject, destParticleSystem = destShuriKenParticle3D._particleSystem;
                this._particleSystem.cloneTo(destParticleSystem);
                var destParticleRender = destShuriKenParticle3D._render, particleRender = this._render;
                destParticleRender.sharedMaterials = particleRender.sharedMaterials, destParticleRender.enable = particleRender.enable, destParticleRender.renderMode = particleRender.renderMode, destParticleRender.mesh = particleRender.mesh, destParticleRender.stretchedBillboardCameraSpeedScale = particleRender.stretchedBillboardCameraSpeedScale, destParticleRender.stretchedBillboardSpeedScale = particleRender.stretchedBillboardSpeedScale, destParticleRender.stretchedBillboardLengthScale = particleRender.stretchedBillboardLengthScale, destParticleRender.sortingFudge = particleRender.sortingFudge, super._cloneTo(destObject, srcSprite, dstSprite)
            }

            destroy(destroyChild = !0) {
                this.destroyed || (super.destroy(destroyChild), this._particleSystem.destroy(), this._particleSystem = null)
            }

            _create() {
                return new ShuriKenParticle3D
            }
        }

        class CastShadowList extends SingletonList {
            constructor() {
                super()
            }

            add(element) {
                if (-1 !== element._indexInCastShadowList) throw"CastShadowList:element has  in  CastShadowList.";
                this._add(element), element._indexInCastShadowList = this.length++
            }

            remove(element) {
                var index = element._indexInCastShadowList;
                if (this.length--, index !== this.length) {
                    var end = this.elements[this.length];
                    this.elements[index] = end, end._indexInCastShadowList = index
                }
                element._indexInCastShadowList = -1
            }
        }

        class SimpleSingletonList extends SingletonList {
            constructor() {
                super()
            }

            add(element) {
                if (-1 !== element._getIndexInList()) throw"SimpleSingletonList:" + element + " has  in  SingletonList.";
                this._add(element), element._setIndexInList(this.length++)
            }

            remove(element) {
                var index = element._getIndexInList();
                if (this.length--, index !== this.length) {
                    var end = this.elements[this.length];
                    this.elements[index] = end, end._setIndexInList(index)
                }
                element._setIndexInList(-1)
            }
        }

        class MouseTouch {
            constructor() {
                this._pressedSprite = null, this._pressedLoopCount = -1, this.sprite = null, this.mousePositionX = 0, this.mousePositionY = 0
            }
        }

        class Touch {
            constructor() {
                this._indexInList = -1, this._identifier = -1, this._position = new Vector2
            }

            get identifier() {
                return this._identifier
            }

            get position() {
                return this._position
            }

            _getIndexInList() {
                return this._indexInList
            }

            _setIndexInList(index) {
                this._indexInList = index
            }
        }

        class Input3D {
            constructor() {
                this._eventList = [], this._mouseTouch = new MouseTouch, this._touchPool = [], this._touches = new SimpleSingletonList, this._multiTouchEnabled = !0, this._pushEventList = (e => {
                    e.preventDefault(), this._eventList.push(e)
                }).bind(this)
            }

            __init__(canvas, scene) {
                this._scene = scene, canvas.oncontextmenu = function (e) {
                    return !1
                }
            }

            _onCanvasEvent(canvas) {
                canvas.addEventListener("mousedown", this._pushEventList), canvas.addEventListener("mouseup", this._pushEventList, !0), canvas.addEventListener("mousemove", this._pushEventList, !0), canvas.addEventListener("touchstart", this._pushEventList), canvas.addEventListener("touchend", this._pushEventList, !0), canvas.addEventListener("touchmove", this._pushEventList, !0), canvas.addEventListener("touchcancel", this._pushEventList, !0)
            }

            _offCanvasEvent(canvas) {
                canvas.removeEventListener("mousedown", this._pushEventList), canvas.removeEventListener("mouseup", this._pushEventList, !0), canvas.removeEventListener("mousemove", this._pushEventList, !0), canvas.removeEventListener("touchstart", this._pushEventList), canvas.removeEventListener("touchend", this._pushEventList, !0), canvas.removeEventListener("touchmove", this._pushEventList, !0), canvas.removeEventListener("touchcancel", this._pushEventList, !0), this._eventList.length = 0, this._touches.length = 0
            }

            touchCount() {
                return this._touches.length
            }

            get multiTouchEnabled() {
                return this._multiTouchEnabled
            }

            set multiTouchEnabled(value) {
                this._multiTouchEnabled = value
            }

            _getTouch(touchID) {
                var touch = this._touchPool[touchID];
                return touch || (touch = new Touch, this._touchPool[touchID] = touch, touch._identifier = touchID), touch
            }

            _mouseTouchDown() {
                var touch = this._mouseTouch, sprite = touch.sprite;
                if (touch._pressedSprite = sprite, touch._pressedLoopCount = Laya.Stat.loopCount, sprite) {
                    var scripts = sprite._scripts;
                    if (scripts) for (var i = 0, n = scripts.length; i < n; i++) scripts[i].onMouseDown()
                }
            }

            _mouseTouchUp() {
                var i, n, touch = this._mouseTouch, lastPressedSprite = touch._pressedSprite;
                touch._pressedSprite = null, touch._pressedLoopCount = -1;
                var sprite = touch.sprite;
                if (sprite && sprite === lastPressedSprite) {
                    var scripts = sprite._scripts;
                    if (scripts) for (i = 0, n = scripts.length; i < n; i++) scripts[i].onMouseClick()
                }
                if (lastPressedSprite) {
                    var lastScripts = lastPressedSprite._scripts;
                    if (lastScripts) for (i = 0, n = lastScripts.length; i < n; i++) lastScripts[i].onMouseUp()
                }
            }

            _mouseTouchRayCast(cameras) {
                var touchHitResult = Input3D._tempHitResult0, touchPos = Input3D._tempVector20,
                    touchRay = Input3D._tempRay0;
                touchHitResult.succeeded = !1;
                var x = this._mouseTouch.mousePositionX, y = this._mouseTouch.mousePositionY;
                touchPos.x = x, touchPos.y = y;
                for (var i = cameras.length - 1; i >= 0; i--) {
                    var camera = cameras[i], viewport = camera.viewport;
                    if (touchPos.x >= viewport.x && touchPos.y >= viewport.y && touchPos.x <= viewport.width && touchPos.y <= viewport.height) if (camera.viewportPointToRay(touchPos, touchRay), this._scene._physicsSimulation.rayCast(touchRay, touchHitResult) || camera.clearFlag === BaseCamera.CLEARFLAG_SOLIDCOLOR || camera.clearFlag === BaseCamera.CLEARFLAG_SKY) break
                }
                var touch = this._mouseTouch, lastSprite = touch.sprite;
                if (touchHitResult.succeeded) {
                    var touchSprite = touchHitResult.collider.owner;
                    touch.sprite = touchSprite;
                    var scripts = touchSprite._scripts;
                    if (lastSprite !== touchSprite && scripts) for (var j = 0, m = scripts.length; j < m; j++) scripts[j].onMouseEnter()
                } else touch.sprite = null;
                if (lastSprite && lastSprite !== touchSprite) {
                    var outScripts = lastSprite._scripts;
                    if (outScripts) for (j = 0, m = outScripts.length; j < m; j++) outScripts[j].onMouseOut()
                }
            }

            _changeTouches(changedTouches, flag) {
                for (var offsetX = 0, offsetY = 0, lastCount = this._touches.length, j = 0, m = changedTouches.length; j < m; j++) {
                    var nativeTouch = changedTouches[j], identifier = nativeTouch.identifier;
                    if (this._multiTouchEnabled || 0 === identifier) {
                        var touch = this._getTouch(identifier), pos = touch._position, mousePoint = Input3D._tempPoint;
                        mousePoint.setTo(nativeTouch.pageX, nativeTouch.pageY), Laya.ILaya.stage._canvasTransform.invertTransformPoint(mousePoint);
                        var posX = mousePoint.x, posY = mousePoint.y;
                        switch (flag) {
                            case 0:
                                this._touches.add(touch), offsetX += posX, offsetY += posY;
                                break;
                            case 1:
                                this._touches.remove(touch), offsetX -= posX, offsetY -= posY;
                                break;
                            case 2:
                                offsetX = posX - pos.x, offsetY = posY - pos.y
                        }
                        pos.x = posX, pos.y = posY
                    }
                }
                var touchCount = this._touches.length;
                0 === touchCount ? (this._mouseTouch.mousePositionX = 0, this._mouseTouch.mousePositionY = 0) : (this._mouseTouch.mousePositionX = (this._mouseTouch.mousePositionX * lastCount + offsetX) / touchCount, this._mouseTouch.mousePositionY = (this._mouseTouch.mousePositionY * lastCount + offsetY) / touchCount)
            }

            _update() {
                var i, n, j, m, enablePhysics = Physics3D._enbalePhysics && !PhysicsSimulation.disableSimulation;
                n = this._eventList.length;
                var cameras = this._scene._cameraPool;
                if (n > 0) {
                    var rayCast = !1;
                    for (i = 0; i < n; i++) {
                        var e = this._eventList[i];
                        switch (e.type) {
                            case"mousedown":
                                enablePhysics && this._mouseTouchDown();
                                break;
                            case"mouseup":
                                enablePhysics && this._mouseTouchUp();
                                break;
                            case"mousemove":
                                var mousePoint = Input3D._tempPoint;
                                mousePoint.setTo(e.pageX, e.pageY), Laya.ILaya.stage._canvasTransform.invertTransformPoint(mousePoint), this._mouseTouch.mousePositionX = mousePoint.x, this._mouseTouch.mousePositionY = mousePoint.y, enablePhysics && (rayCast = !0);
                                break;
                            case"touchstart":
                                var lastLength = this._touches.length;
                                this._changeTouches(e.changedTouches, 0), enablePhysics && (rayCast = !0, 0 === lastLength && this._mouseTouchDown());
                                break;
                            case"touchend":
                            case"touchcancel":
                                this._changeTouches(e.changedTouches, 1), enablePhysics && 0 === this._touches.length && this._mouseTouchUp();
                                break;
                            case"touchmove":
                                this._changeTouches(e.changedTouches, 2), enablePhysics && (rayCast = !0);
                                break;
                            default:
                                throw"Input3D:unkonwn event type."
                        }
                    }
                    rayCast && this._mouseTouchRayCast(cameras), this._eventList.length = 0
                }
                if (enablePhysics) {
                    var mouseTouch = this._mouseTouch, pressedSprite = mouseTouch._pressedSprite;
                    if (pressedSprite && Laya.Stat.loopCount > mouseTouch._pressedLoopCount) {
                        var pressedScripts = pressedSprite._scripts;
                        if (pressedScripts) for (j = 0, m = pressedScripts.length; j < m; j++) pressedScripts[j].onMouseDrag()
                    }
                    var touchSprite = mouseTouch.sprite;
                    if (touchSprite) {
                        var scripts = touchSprite._scripts;
                        if (scripts) for (j = 0, m = scripts.length; j < m; j++) scripts[j].onMouseOver()
                    }
                }
            }

            getTouch(index) {
                return index < this._touches.length ? this._touches.elements[index] : null
            }
        }

        Input3D._tempPoint = new Laya.Point, Input3D._tempVector20 = new Vector2, Input3D._tempRay0 = new Ray(new Vector3, new Vector3), Input3D._tempHitResult0 = new HitResult;

        class PhysicsSettings {
            constructor() {
                this.flags = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60
            }
        }

        class VertexPositionTexture0 {
            static get vertexDeclaration() {
                return VertexPositionTexture0._vertexDeclaration
            }

            static __init__() {
                VertexPositionTexture0._vertexDeclaration = new VertexDeclaration(20, [new VertexElement(0, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0), new VertexElement(12, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0)])
            }

            get position() {
                return this._position
            }

            get textureCoordinate0() {
                return this._textureCoordinate0
            }

            get vertexDeclaration() {
                return VertexPositionTexture0._vertexDeclaration
            }

            constructor(position, textureCoordinate0) {
                this._position = position, this._textureCoordinate0 = textureCoordinate0
            }
        }

        class SkyDome extends SkyMesh {
            constructor(stacks = 48, slices = 48) {
                super();
                var gl = Laya.LayaGL.instance;
                this._stacks = stacks, this._slices = slices;
                for (var vertexDeclaration = VertexPositionTexture0.vertexDeclaration, vertexFloatCount = vertexDeclaration.vertexStride / 4, numberVertices = (this._stacks + 1) * (this._slices + 1), numberIndices = 3 * this._stacks * (this._slices + 1) * 2, vertices = new Float32Array(numberVertices * vertexFloatCount), indices = new Uint16Array(numberIndices), stackAngle = Math.PI / this._stacks, sliceAngle = 2 * Math.PI / this._slices, vertexIndex = 0, vertexCount = 0, indexCount = 0, stack = 0; stack < this._stacks + 1; stack++) for (var r = Math.sin(stack * stackAngle), y = Math.cos(stack * stackAngle), slice = 0; slice < this._slices + 1; slice++) {
                    var x = r * Math.sin(slice * sliceAngle), z = r * Math.cos(slice * sliceAngle);
                    vertices[vertexCount + 0] = x * SkyDome._radius, vertices[vertexCount + 1] = y * SkyDome._radius, vertices[vertexCount + 2] = z * SkyDome._radius, vertices[vertexCount + 3] = -slice / this._slices + .75, vertices[vertexCount + 4] = stack / this._stacks, vertexCount += vertexFloatCount, stack != this._stacks - 1 && (indices[indexCount++] = vertexIndex + 1, indices[indexCount++] = vertexIndex, indices[indexCount++] = vertexIndex + (this._slices + 1), indices[indexCount++] = vertexIndex + (this._slices + 1), indices[indexCount++] = vertexIndex, indices[indexCount++] = vertexIndex + this._slices, vertexIndex++)
                }
                this._vertexBuffer = new VertexBuffer3D(4 * vertices.length, gl.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = vertexDeclaration, this._indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, indices.length, gl.STATIC_DRAW, !1), this._vertexBuffer.setData(vertices.buffer), this._indexBuffer.setData(indices);
                var bufferState = new BufferState;
                bufferState.bind(), bufferState.applyVertexBuffer(this._vertexBuffer), bufferState.applyIndexBuffer(this._indexBuffer), bufferState.unBind(), this._bufferState = bufferState
            }

            static __init__() {
                SkyDome.instance = new SkyDome
            }

            get stacks() {
                return this._stacks
            }

            get slices() {
                return this._slices
            }

            _render(state) {
                var gl = Laya.LayaGL.instance, indexCount = this._indexBuffer.indexCount;
                gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0), Laya.Stat.trianglesFaces += indexCount / 3, Laya.Stat.renderBatches++
            }
        }

        SkyDome._radius = 1;

        class PostProcessRenderContext {
            constructor() {
                this.source = null, this.destination = null, this.camera = null, this.compositeShaderData = null, this.command = null, this.deferredReleaseTextures = []
            }
        }

        class PostProcess {
            constructor() {
                this._compositeShader = Shader3D.find("PostProcessComposite"), this._compositeShaderData = new ShaderData, this._context = null, this._effects = [], this._context = new PostProcessRenderContext, this._context.compositeShaderData = this._compositeShaderData
            }

            static __init__() {
                PostProcess.SHADERDEFINE_BLOOM_LOW = PostProcess.shaderDefines.registerDefine("BLOOM_LOW"), PostProcess.SHADERDEFINE_BLOOM = PostProcess.shaderDefines.registerDefine("BLOOM"), PostProcess.SHADERDEFINE_FINALPASS = PostProcess.shaderDefines.registerDefine("FINALPASS")
            }

            _init(camera, command) {
                this._context.camera = camera, this._context.command = command
            }

            _render() {
                var noteValue = ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                Laya.ILaya.Render.supportWebGLPlusRendering && ShaderData.setRuntimeValueMode(!1);
                var camera = this._context.camera,
                    screenTexture = RenderTexture.createFromPool(RenderContext3D.clientWidth, RenderContext3D.clientHeight, camera._getRenderTextureFormat(), Laya.BaseTexture.FORMAT_DEPTHSTENCIL_NONE),
                    cameraTarget = camera._renderTexture;
                this._context.command.clear(), this._context.source = screenTexture, this._context.destination = cameraTarget, this._context.compositeShaderData.clearDefine(), this._context.command.blitScreenTriangle(cameraTarget, screenTexture), this._context.compositeShaderData.setTexture(PostProcess.SHADERVALUE_AUTOEXPOSURETEX, Laya.Texture2D.whiteTexture);
                for (var i = 0, n = this._effects.length; i < n; i++) this._effects[i].render(this._context);
                this._compositeShaderData.addDefine(PostProcess.SHADERDEFINE_FINALPASS);
                var offScreenTexture = camera.renderTarget, dest = offScreenTexture || null;
                this._context.destination = dest, this._context.command.blitScreenTriangle(this._context.source, dest, this._compositeShader, this._compositeShaderData), RenderTexture.recoverToPool(screenTexture);
                var tempRenderTextures = this._context.deferredReleaseTextures;
                for (i = 0, n = tempRenderTextures.length; i < n; i++) RenderTexture.recoverToPool(tempRenderTextures[i]);
                tempRenderTextures.length = 0, Laya.ILaya.Render.supportWebGLPlusRendering && ShaderData.setRuntimeValueMode(noteValue)
            }

            addEffect(effect) {
                this._effects.push(effect)
            }

            removeEffect(effect) {
                var index = this._effects.indexOf(effect);
                -1 !== index && this._effects.splice(index, 1)
            }
        }

        PostProcess.SHADERVALUE_MAINTEX = Shader3D.propertyNameToID("u_MainTex"), PostProcess.SHADERVALUE_BLOOMTEX = Shader3D.propertyNameToID("u_BloomTex"), PostProcess.SHADERVALUE_AUTOEXPOSURETEX = Shader3D.propertyNameToID("u_AutoExposureTex"), PostProcess.SHADERVALUE_BLOOM_DIRTTEX = Shader3D.propertyNameToID("u_Bloom_DirtTex"), PostProcess.SHADERVALUE_BLOOMTEX_TEXELSIZE = Shader3D.propertyNameToID("u_BloomTex_TexelSize"), PostProcess.SHADERVALUE_BLOOM_DIRTTILEOFFSET = Shader3D.propertyNameToID("u_Bloom_DirtTileOffset"), PostProcess.SHADERVALUE_BLOOM_SETTINGS = Shader3D.propertyNameToID("u_Bloom_Settings"), PostProcess.SHADERVALUE_BLOOM_COLOR = Shader3D.propertyNameToID("u_Bloom_Color"), PostProcess.shaderDefines = new ShaderDefines;

        class EffectMaterial extends BaseMaterial {
            constructor() {
                super(), this.setShaderName("Effect"), this._color = new Vector4(1, 1, 1, 1), this._shaderValues.setVector(EffectMaterial.TINTCOLOR, new Vector4(1, 1, 1, 1)), this.renderMode = EffectMaterial.RENDERMODE_ADDTIVE
            }

            static __initDefine__() {
                EffectMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines), EffectMaterial.SHADERDEFINE_MAINTEXTURE = EffectMaterial.shaderDefines.registerDefine("MAINTEXTURE"), EffectMaterial.SHADERDEFINE_TILINGOFFSET = EffectMaterial.shaderDefines.registerDefine("TILINGOFFSET"), EffectMaterial.SHADERDEFINE_ADDTIVEFOG = EffectMaterial.shaderDefines.registerDefine("ADDTIVEFOG")
            }

            get _TintColorR() {
                return this._color.x
            }

            set _TintColorR(value) {
                this._color.x = value, this.color = this._color
            }

            get _TintColorG() {
                return this._color.y
            }

            set _TintColorG(value) {
                this._color.y = value, this.color = this._color
            }

            get _TintColorB() {
                return this._color.z
            }

            set _TintColorB(value) {
                this._color.z = value, this.color = this._color
            }

            get _TintColorA() {
                return this._color.w
            }

            set _TintColorA(value) {
                this._color.w = value, this.color = this._color
            }

            get _MainTex_STX() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).x
            }

            set _MainTex_STX(x) {
                var tilOff = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                tilOff.x = x, this.tilingOffset = tilOff
            }

            get _MainTex_STY() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).y
            }

            set _MainTex_STY(y) {
                var tilOff = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                tilOff.y = y, this.tilingOffset = tilOff
            }

            get _MainTex_STZ() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).z
            }

            set _MainTex_STZ(z) {
                var tilOff = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                tilOff.z = z, this.tilingOffset = tilOff
            }

            get _MainTex_STW() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).w
            }

            set _MainTex_STW(w) {
                var tilOff = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                tilOff.w = w, this.tilingOffset = tilOff
            }

            set renderMode(value) {
                switch (value) {
                    case EffectMaterial.RENDERMODE_ADDTIVE:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, this.cull = RenderState.CULL_NONE, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA, this.blendDst = RenderState.BLENDPARAM_ONE, this.depthTest = RenderState.DEPTHTEST_LESS, this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
                        break;
                    case EffectMaterial.RENDERMODE_ALPHABLENDED:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, this.cull = RenderState.CULL_NONE, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA, this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = RenderState.DEPTHTEST_LESS, this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
                        break;
                    default:
                        throw new Error("MeshEffectMaterial : renderMode value error.")
                }
            }

            get colorR() {
                return this._TintColorR
            }

            set colorR(value) {
                this._TintColorR = value
            }

            get colorG() {
                return this._TintColorG
            }

            set colorG(value) {
                this._TintColorG = value
            }

            get colorB() {
                return this._TintColorB
            }

            set colorB(value) {
                this._TintColorB = value
            }

            get colorA() {
                return this._TintColorA
            }

            set colorA(value) {
                this._TintColorA = value
            }

            get color() {
                return this._shaderValues.getVector(EffectMaterial.TINTCOLOR)
            }

            set color(value) {
                this._shaderValues.setVector(EffectMaterial.TINTCOLOR, value)
            }

            get texture() {
                return this._shaderValues.getTexture(EffectMaterial.MAINTEXTURE)
            }

            set texture(value) {
                value ? this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_MAINTEXTURE), this._shaderValues.setTexture(EffectMaterial.MAINTEXTURE, value)
            }

            get tilingOffsetX() {
                return this._MainTex_STX
            }

            set tilingOffsetX(x) {
                this._MainTex_STX = x
            }

            get tilingOffsetY() {
                return this._MainTex_STY
            }

            set tilingOffsetY(y) {
                this._MainTex_STY = y
            }

            get tilingOffsetZ() {
                return this._MainTex_STZ
            }

            set tilingOffsetZ(z) {
                this._MainTex_STZ = z
            }

            get tilingOffsetW() {
                return this._MainTex_STW
            }

            set tilingOffsetW(w) {
                this._MainTex_STW = w
            }

            get tilingOffset() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET)
            }

            set tilingOffset(value) {
                value && (1 != value.x || 1 != value.y || 0 != value.z || 0 != value.w) ? this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET), this._shaderValues.setVector(EffectMaterial.TILINGOFFSET, value)
            }

            set depthWrite(value) {
                this._shaderValues.setBool(EffectMaterial.DEPTH_WRITE, value)
            }

            get depthWrite() {
                return this._shaderValues.getBool(EffectMaterial.DEPTH_WRITE)
            }

            set cull(value) {
                this._shaderValues.setInt(EffectMaterial.CULL, value)
            }

            get cull() {
                return this._shaderValues.getInt(EffectMaterial.CULL)
            }

            set blend(value) {
                this._shaderValues.setInt(EffectMaterial.BLEND, value)
            }

            get blend() {
                return this._shaderValues.getInt(EffectMaterial.BLEND)
            }

            set blendSrc(value) {
                this._shaderValues.setInt(EffectMaterial.BLEND_SRC, value)
            }

            get blendSrc() {
                return this._shaderValues.getInt(EffectMaterial.BLEND_SRC)
            }

            set blendDst(value) {
                this._shaderValues.setInt(EffectMaterial.BLEND_DST, value)
            }

            get blendDst() {
                return this._shaderValues.getInt(EffectMaterial.BLEND_DST)
            }

            set depthTest(value) {
                this._shaderValues.setInt(EffectMaterial.DEPTH_TEST, value)
            }

            get depthTest() {
                return this._shaderValues.getInt(EffectMaterial.DEPTH_TEST)
            }

            clone() {
                var dest = new EffectMaterial;
                return this.cloneTo(dest), dest
            }
        }

        EffectMaterial.RENDERMODE_ADDTIVE = 0, EffectMaterial.RENDERMODE_ALPHABLENDED = 1, EffectMaterial.MAINTEXTURE = Shader3D.propertyNameToID("u_AlbedoTexture"), EffectMaterial.TINTCOLOR = Shader3D.propertyNameToID("u_AlbedoColor"), EffectMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset"), EffectMaterial.CULL = Shader3D.propertyNameToID("s_Cull"), EffectMaterial.BLEND = Shader3D.propertyNameToID("s_Blend"), EffectMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc"), EffectMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst"), EffectMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest"), EffectMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite"), EffectMaterial.shaderDefines = null;

        class ExtendTerrainMaterial extends BaseMaterial {
            constructor() {
                super(), this._enableLighting = !0, this.setShaderName("ExtendTerrain"), this.renderMode = ExtendTerrainMaterial.RENDERMODE_OPAQUE
            }

            static __initDefine__() {
                ExtendTerrainMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines), ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM1"), ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM2"), ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM3"), ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM4"), ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM5")
            }

            get splatAlphaTexture() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE)
            }

            set splatAlphaTexture(value) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE, value)
            }

            set diffuseTexture1(value) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1, value), this._setDetailNum(1)
            }

            get diffuseTexture2() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2)
            }

            set diffuseTexture2(value) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2, value), this._setDetailNum(2)
            }

            get diffuseTexture3() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3)
            }

            set diffuseTexture3(value) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3, value), this._setDetailNum(3)
            }

            get diffuseTexture4() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4)
            }

            set diffuseTexture4(value) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4, value), this._setDetailNum(4)
            }

            get diffuseTexture5() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5)
            }

            set diffuseTexture5(value) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5, value), this._setDetailNum(5)
            }

            _setDetailNum(value) {
                switch (value) {
                    case 1:
                        this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                        break;
                    case 2:
                        this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                        break;
                    case 3:
                        this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                        break;
                    case 4:
                        this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                        break;
                    case 5:
                        this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4)
                }
            }

            set diffuseScaleOffset1(scaleOffset1) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET1, scaleOffset1)
            }

            set diffuseScaleOffset2(scaleOffset2) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET2, scaleOffset2)
            }

            set diffuseScaleOffset3(scaleOffset3) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET3, scaleOffset3)
            }

            set diffuseScaleOffset4(scaleOffset4) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET4, scaleOffset4)
            }

            set diffuseScaleOffset5(scaleOffset5) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET5, scaleOffset5)
            }

            get enableLighting() {
                return this._enableLighting
            }

            set enableLighting(value) {
                this._enableLighting !== value && (value ? this._disablePublicDefineDatas.remove(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT) : this._disablePublicDefineDatas.add(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT | Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT), this._enableLighting = value)
            }

            set renderMode(value) {
                switch (value) {
                    case ExtendTerrainMaterial.RENDERMODE_OPAQUE:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE, this.depthWrite = !0, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_DISABLE, this.depthTest = RenderState.DEPTHTEST_LESS;
                        break;
                    case ExtendTerrainMaterial.RENDERMODE_TRANSPARENT:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE, this.depthWrite = !1, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA, this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = RenderState.DEPTHTEST_LEQUAL;
                        break;
                    default:
                        throw new Error("ExtendTerrainMaterial:renderMode value error.")
                }
            }

            set depthWrite(value) {
                this._shaderValues.setBool(ExtendTerrainMaterial.DEPTH_WRITE, value)
            }

            get depthWrite() {
                return this._shaderValues.getBool(ExtendTerrainMaterial.DEPTH_WRITE)
            }

            set cull(value) {
                this._shaderValues.setInt(ExtendTerrainMaterial.CULL, value)
            }

            get cull() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.CULL)
            }

            set blend(value) {
                this._shaderValues.setInt(ExtendTerrainMaterial.BLEND, value)
            }

            get blend() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND)
            }

            set blendSrc(value) {
                this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_SRC, value)
            }

            get blendSrc() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_SRC)
            }

            set blendDst(value) {
                this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_DST, value)
            }

            get blendDst() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_DST)
            }

            set depthTest(value) {
                this._shaderValues.setInt(ExtendTerrainMaterial.DEPTH_TEST, value)
            }

            get depthTest() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.DEPTH_TEST)
            }

            clone() {
                var dest = new ExtendTerrainMaterial;
                return this.cloneTo(dest), dest
            }
        }

        ExtendTerrainMaterial.RENDERMODE_OPAQUE = 1, ExtendTerrainMaterial.RENDERMODE_TRANSPARENT = 2, ExtendTerrainMaterial.SPLATALPHATEXTURE = Shader3D.propertyNameToID("u_SplatAlphaTexture"), ExtendTerrainMaterial.DIFFUSETEXTURE1 = Shader3D.propertyNameToID("u_DiffuseTexture1"), ExtendTerrainMaterial.DIFFUSETEXTURE2 = Shader3D.propertyNameToID("u_DiffuseTexture2"), ExtendTerrainMaterial.DIFFUSETEXTURE3 = Shader3D.propertyNameToID("u_DiffuseTexture3"), ExtendTerrainMaterial.DIFFUSETEXTURE4 = Shader3D.propertyNameToID("u_DiffuseTexture4"), ExtendTerrainMaterial.DIFFUSETEXTURE5 = Shader3D.propertyNameToID("u_DiffuseTexture5"), ExtendTerrainMaterial.DIFFUSESCALEOFFSET1 = Shader3D.propertyNameToID("u_DiffuseScaleOffset1"), ExtendTerrainMaterial.DIFFUSESCALEOFFSET2 = Shader3D.propertyNameToID("u_DiffuseScaleOffset2"), ExtendTerrainMaterial.DIFFUSESCALEOFFSET3 = Shader3D.propertyNameToID("u_DiffuseScaleOffset3"), ExtendTerrainMaterial.DIFFUSESCALEOFFSET4 = Shader3D.propertyNameToID("u_DiffuseScaleOffset4"), ExtendTerrainMaterial.DIFFUSESCALEOFFSET5 = Shader3D.propertyNameToID("u_DiffuseScaleOffset5"), ExtendTerrainMaterial.CULL = Shader3D.propertyNameToID("s_Cull"), ExtendTerrainMaterial.BLEND = Shader3D.propertyNameToID("s_Blend"), ExtendTerrainMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc"), ExtendTerrainMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst"), ExtendTerrainMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest"), ExtendTerrainMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite"), ExtendTerrainMaterial.shaderDefines = null;

        class PBRSpecularMaterial extends BaseMaterial {
            constructor() {
                super(), this.setShaderName("PBRSpecular"), this._albedoColor = new Vector4(1, 1, 1, 1), this._shaderValues.setVector(PBRSpecularMaterial.ALBEDOCOLOR, new Vector4(1, 1, 1, 1)), this._emissionColor = new Vector4(0, 0, 0, 0), this._shaderValues.setVector(PBRSpecularMaterial.EMISSIONCOLOR, new Vector4(0, 0, 0, 0)), this._specularColor = new Vector4(.2, .2, .2, .2), this._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, new Vector4(.2, .2, .2, .2)), this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESS, .5), this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESSSCALE, 1), this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESSSOURCE, 0), this._shaderValues.setNumber(PBRSpecularMaterial.OCCLUSIONSTRENGTH, 1), this._shaderValues.setNumber(PBRSpecularMaterial.NORMALSCALE, 1), this._shaderValues.setNumber(PBRSpecularMaterial.PARALLAXSCALE, .001), this._shaderValues.setBool(PBRSpecularMaterial.ENABLEEMISSION, !1), this._shaderValues.setNumber(BaseMaterial.ALPHATESTVALUE, .5), this.renderMode = PBRSpecularMaterial.RENDERMODE_OPAQUE
            }

            static __initDefine__() {
                PBRSpecularMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines), PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("ALBEDOTEXTURE"), PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("SPECULARTEXTURE"), PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = PBRSpecularMaterial.shaderDefines.registerDefine("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA"), PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("NORMALTEXTURE"), PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("PARALLAXTEXTURE"), PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("OCCLUSIONTEXTURE"), PBRSpecularMaterial.SHADERDEFINE_EMISSION = PBRSpecularMaterial.shaderDefines.registerDefine("EMISSION"), PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("EMISSIONTEXTURE"), PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET = PBRSpecularMaterial.shaderDefines.registerDefine("TILINGOFFSET"), PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY = PBRSpecularMaterial.shaderDefines.registerDefine("ALPHAPREMULTIPLY")
            }

            get _ColorR() {
                return this._albedoColor.x
            }

            set _ColorR(value) {
                this._albedoColor.x = value, this.albedoColor = this._albedoColor
            }

            get _ColorG() {
                return this._albedoColor.y
            }

            set _ColorG(value) {
                this._albedoColor.y = value, this.albedoColor = this._albedoColor
            }

            get _ColorB() {
                return this._albedoColor.z
            }

            set _ColorB(value) {
                this._albedoColor.z = value, this.albedoColor = this._albedoColor
            }

            get _ColorA() {
                return this._albedoColor.w
            }

            set _ColorA(value) {
                this._albedoColor.w = value, this.albedoColor = this._albedoColor
            }

            get _SpecColorR() {
                return this._specularColor.x
            }

            set _SpecColorR(value) {
                this._specularColor.x = value, this.specularColor = this._specularColor
            }

            get _SpecColorG() {
                return this._specularColor.y
            }

            set _SpecColorG(value) {
                this._specularColor.y = value, this.specularColor = this._specularColor
            }

            get _SpecColorB() {
                return this._specularColor.z
            }

            set _SpecColorB(value) {
                this._specularColor.z = value, this.specularColor = this._specularColor
            }

            get _SpecColorA() {
                return this._specularColor.w
            }

            set _SpecColorA(value) {
                this._specularColor.w = value, this.specularColor = this._specularColor
            }

            get _Glossiness() {
                return this._shaderValues.getNumber(PBRSpecularMaterial.SMOOTHNESS)
            }

            set _Glossiness(value) {
                this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESS, value)
            }

            get _GlossMapScale() {
                return this._shaderValues.getNumber(PBRSpecularMaterial.SMOOTHNESSSCALE)
            }

            set _GlossMapScale(value) {
                this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESSSCALE, value)
            }

            get _BumpScale() {
                return this._shaderValues.getNumber(PBRSpecularMaterial.NORMALSCALE)
            }

            set _BumpScale(value) {
                this._shaderValues.setNumber(PBRSpecularMaterial.NORMALSCALE, value)
            }

            get _Parallax() {
                return this._shaderValues.getNumber(PBRSpecularMaterial.PARALLAXSCALE)
            }

            set _Parallax(value) {
                this._shaderValues.setNumber(PBRSpecularMaterial.PARALLAXSCALE, value)
            }

            get _OcclusionStrength() {
                return this._shaderValues.getNumber(PBRSpecularMaterial.OCCLUSIONSTRENGTH)
            }

            set _OcclusionStrength(value) {
                this._shaderValues.setNumber(PBRSpecularMaterial.OCCLUSIONSTRENGTH, value)
            }

            get _EmissionColorR() {
                return this._emissionColor.x
            }

            set _EmissionColorR(value) {
                this._emissionColor.x = value, this.emissionColor = this._emissionColor
            }

            get _EmissionColorG() {
                return this._emissionColor.y
            }

            set _EmissionColorG(value) {
                this._emissionColor.y = value, this.emissionColor = this._emissionColor
            }

            get _EmissionColorB() {
                return this._emissionColor.z
            }

            set _EmissionColorB(value) {
                this._emissionColor.z = value, this.emissionColor = this._emissionColor
            }

            get _EmissionColorA() {
                return this._emissionColor.w
            }

            set _EmissionColorA(value) {
                this._emissionColor.w = value, this.emissionColor = this._emissionColor
            }

            get _MainTex_STX() {
                return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).x
            }

            set _MainTex_STX(x) {
                var tilOff = this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
                tilOff.x = x, this.tilingOffset = tilOff
            }

            get _MainTex_STY() {
                return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).y
            }

            set _MainTex_STY(y) {
                var tilOff = this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
                tilOff.y = y, this.tilingOffset = tilOff
            }

            get _MainTex_STZ() {
                return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).z
            }

            set _MainTex_STZ(z) {
                var tilOff = this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
                tilOff.z = z, this.tilingOffset = tilOff
            }

            get _MainTex_STW() {
                return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).w
            }

            set _MainTex_STW(w) {
                var tilOff = this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
                tilOff.w = w, this.tilingOffset = tilOff
            }

            get _Cutoff() {
                return this.alphaTestValue
            }

            set _Cutoff(value) {
                this.alphaTestValue = value
            }

            get albedoColorR() {
                return this._ColorR
            }

            set albedoColorR(value) {
                this._ColorR = value
            }

            get albedoColorG() {
                return this._ColorG
            }

            set albedoColorG(value) {
                this._ColorG = value
            }

            get albedoColorB() {
                return this._ColorB
            }

            set albedoColorB(value) {
                this._ColorB = value
            }

            get albedoColorA() {
                return this._ColorA
            }

            set albedoColorA(value) {
                this._ColorA = value
            }

            get albedoColor() {
                return this._albedoColor
            }

            set albedoColor(value) {
                this._albedoColor = value, this._shaderValues.setVector(PBRSpecularMaterial.ALBEDOCOLOR, value)
            }

            get albedoTexture() {
                return this._shaderValues.getTexture(PBRSpecularMaterial.ALBEDOTEXTURE)
            }

            set albedoTexture(value) {
                value ? this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE), this._shaderValues.setTexture(PBRSpecularMaterial.ALBEDOTEXTURE, value)
            }

            get normalTexture() {
                return this._shaderValues.getTexture(PBRSpecularMaterial.NORMALTEXTURE)
            }

            set normalTexture(value) {
                value ? this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE), this._shaderValues.setTexture(PBRSpecularMaterial.NORMALTEXTURE, value)
            }

            get normalTextureScale() {
                return this._BumpScale
            }

            set normalTextureScale(value) {
                this._BumpScale = value
            }

            get parallaxTexture() {
                return this._shaderValues.getTexture(PBRSpecularMaterial.PARALLAXTEXTURE)
            }

            set parallaxTexture(value) {
                value ? this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE) : this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE), this._shaderValues.setTexture(PBRSpecularMaterial.PARALLAXTEXTURE, value)
            }

            get parallaxTextureScale() {
                return this._Parallax
            }

            set parallaxTextureScale(value) {
                this._Parallax = Math.max(.005, Math.min(.08, value))
            }

            get occlusionTexture() {
                return this._shaderValues.getTexture(PBRSpecularMaterial.OCCLUSIONTEXTURE)
            }

            set occlusionTexture(value) {
                value ? this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE) : this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE), this._shaderValues.setTexture(PBRSpecularMaterial.OCCLUSIONTEXTURE, value)
            }

            get occlusionTextureStrength() {
                return this._OcclusionStrength
            }

            set occlusionTextureStrength(value) {
                this._OcclusionStrength = Math.max(0, Math.min(1, value))
            }

            get specularTexture() {
                return this._shaderValues.getTexture(PBRSpecularMaterial.SPECULARTEXTURE)
            }

            set specularTexture(value) {
                value ? this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE) : this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE), this._shaderValues.setTexture(PBRSpecularMaterial.SPECULARTEXTURE, value)
            }

            get specularColorR() {
                return this._SpecColorR
            }

            set specularColorR(value) {
                this._SpecColorR = value
            }

            get specularColorG() {
                return this._SpecColorG
            }

            set specularColorG(value) {
                this._SpecColorG = value
            }

            get specularColorB() {
                return this._SpecColorB
            }

            set specularColorB(value) {
                this._SpecColorB = value
            }

            get specularColorA() {
                return this._SpecColorA
            }

            set specularColorA(value) {
                this._SpecColorA = value
            }

            get specularColor() {
                return this._shaderValues.getVector(PBRSpecularMaterial.SPECULARCOLOR)
            }

            set specularColor(value) {
                this._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, value)
            }

            get smoothness() {
                return this._Glossiness
            }

            set smoothness(value) {
                this._Glossiness = Math.max(0, Math.min(1, value))
            }

            get smoothnessTextureScale() {
                return this._GlossMapScale
            }

            set smoothnessTextureScale(value) {
                this._GlossMapScale = Math.max(0, Math.min(1, value))
            }

            get smoothnessSource() {
                return this._shaderValues.getInt(PBRSpecularMaterial.SMOOTHNESSSOURCE)
            }

            set smoothnessSource(value) {
                value ? (this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA), this._shaderValues.setInt(PBRSpecularMaterial.SMOOTHNESSSOURCE, 1)) : (this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA), this._shaderValues.setInt(PBRSpecularMaterial.SMOOTHNESSSOURCE, 0))
            }

            get enableEmission() {
                return this._shaderValues.getBool(PBRSpecularMaterial.ENABLEEMISSION)
            }

            set enableEmission(value) {
                value ? this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_EMISSION) : this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_EMISSION), this._shaderValues.setBool(PBRSpecularMaterial.ENABLEEMISSION, value)
            }

            get emissionColor() {
                return this._shaderValues.getVector(PBRSpecularMaterial.EMISSIONCOLOR)
            }

            set emissionColor(value) {
                this._shaderValues.setVector(PBRSpecularMaterial.EMISSIONCOLOR, value)
            }

            get emissionTexture() {
                return this._shaderValues.getTexture(PBRSpecularMaterial.EMISSIONTEXTURE)
            }

            set emissionTexture(value) {
                value ? this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE) : this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE), this._shaderValues.setTexture(PBRSpecularMaterial.EMISSIONTEXTURE, value)
            }

            get enableReflection() {
                return this._shaderValues.getBool(PBRSpecularMaterial.ENABLEREFLECT)
            }

            set enableReflection(value) {
                this._shaderValues.setBool(PBRSpecularMaterial.ENABLEREFLECT, !0), value ? this._disablePublicDefineDatas.remove(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP) : this._disablePublicDefineDatas.add(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP)
            }

            get tilingOffsetX() {
                return this._MainTex_STX
            }

            set tilingOffsetX(x) {
                this._MainTex_STX = x
            }

            get tilingOffsetY() {
                return this._MainTex_STY
            }

            set tilingOffsetY(y) {
                this._MainTex_STY = y
            }

            get tilingOffsetZ() {
                return this._MainTex_STZ
            }

            set tilingOffsetZ(z) {
                this._MainTex_STZ = z
            }

            get tilingOffsetW() {
                return this._MainTex_STW
            }

            set tilingOffsetW(w) {
                this._MainTex_STW = w
            }

            get tilingOffset() {
                return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET)
            }

            set tilingOffset(value) {
                value && (1 != value.x || 1 != value.y || 0 != value.z || 0 != value.w) ? this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET), this._shaderValues.setVector(PBRSpecularMaterial.TILINGOFFSET, value)
            }

            set renderMode(value) {
                switch (value) {
                    case PBRSpecularMaterial.RENDERMODE_OPAQUE:
                        this.alphaTest = !1, this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE, this.depthWrite = !0, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_DISABLE, this.depthTest = RenderState.DEPTHTEST_LESS, this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                        break;
                    case PBRSpecularMaterial.RENDERMODE_CUTOUT:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_DISABLE, this.depthTest = RenderState.DEPTHTEST_LESS, this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                        break;
                    case PBRSpecularMaterial.RENDERMODE_FADE:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA, this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = RenderState.DEPTHTEST_LESS, this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                        break;
                    case PBRSpecularMaterial.RENDERMODE_TRANSPARENT:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_ONE, this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = RenderState.DEPTHTEST_LESS, this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                        break;
                    default:
                        throw new Error("PBRSpecularMaterial : renderMode value error.")
                }
            }

            set depthWrite(value) {
                this._shaderValues.setBool(PBRSpecularMaterial.DEPTH_WRITE, value)
            }

            get depthWrite() {
                return this._shaderValues.getBool(PBRSpecularMaterial.DEPTH_WRITE)
            }

            set cull(value) {
                this._shaderValues.setInt(PBRSpecularMaterial.CULL, value)
            }

            get cull() {
                return this._shaderValues.getInt(PBRSpecularMaterial.CULL)
            }

            set blend(value) {
                this._shaderValues.setInt(PBRSpecularMaterial.BLEND, value)
            }

            get blend() {
                return this._shaderValues.getInt(PBRSpecularMaterial.BLEND)
            }

            set blendSrc(value) {
                this._shaderValues.setInt(PBRSpecularMaterial.BLEND_SRC, value)
            }

            get blendSrc() {
                return this._shaderValues.getInt(PBRSpecularMaterial.BLEND_SRC)
            }

            set blendDst(value) {
                this._shaderValues.setInt(PBRSpecularMaterial.BLEND_DST, value)
            }

            get blendDst() {
                return this._shaderValues.getInt(PBRSpecularMaterial.BLEND_DST)
            }

            set depthTest(value) {
                this._shaderValues.setInt(PBRSpecularMaterial.DEPTH_TEST, value)
            }

            get depthTest() {
                return this._shaderValues.getInt(PBRSpecularMaterial.DEPTH_TEST)
            }

            clone() {
                var dest = new PBRSpecularMaterial;
                return this.cloneTo(dest), dest
            }

            cloneTo(destObject) {
                super.cloneTo(destObject);
                var destMaterial = destObject;
                this._albedoColor.cloneTo(destMaterial._albedoColor), this._specularColor.cloneTo(destMaterial._specularColor), this._emissionColor.cloneTo(destMaterial._emissionColor)
            }
        }

        PBRSpecularMaterial.SmoothnessSource_SpecularTexture_Alpha = 0, PBRSpecularMaterial.SmoothnessSource_AlbedoTexture_Alpha = 1, PBRSpecularMaterial.RENDERMODE_OPAQUE = 0, PBRSpecularMaterial.RENDERMODE_CUTOUT = 1, PBRSpecularMaterial.RENDERMODE_FADE = 2, PBRSpecularMaterial.RENDERMODE_TRANSPARENT = 3, PBRSpecularMaterial.ALBEDOTEXTURE = Shader3D.propertyNameToID("u_AlbedoTexture"), PBRSpecularMaterial.SPECULARTEXTURE = Shader3D.propertyNameToID("u_SpecularTexture"), PBRSpecularMaterial.NORMALTEXTURE = Shader3D.propertyNameToID("u_NormalTexture"), PBRSpecularMaterial.PARALLAXTEXTURE = Shader3D.propertyNameToID("u_ParallaxTexture"), PBRSpecularMaterial.OCCLUSIONTEXTURE = Shader3D.propertyNameToID("u_OcclusionTexture"), PBRSpecularMaterial.EMISSIONTEXTURE = Shader3D.propertyNameToID("u_EmissionTexture"), PBRSpecularMaterial.ALBEDOCOLOR = Shader3D.propertyNameToID("u_AlbedoColor"), PBRSpecularMaterial.SPECULARCOLOR = Shader3D.propertyNameToID("u_SpecularColor"), PBRSpecularMaterial.EMISSIONCOLOR = Shader3D.propertyNameToID("u_EmissionColor"), PBRSpecularMaterial.SMOOTHNESS = Shader3D.propertyNameToID("u_smoothness"), PBRSpecularMaterial.SMOOTHNESSSCALE = Shader3D.propertyNameToID("u_smoothnessScale"), PBRSpecularMaterial.SMOOTHNESSSOURCE = -1, PBRSpecularMaterial.OCCLUSIONSTRENGTH = Shader3D.propertyNameToID("u_occlusionStrength"), PBRSpecularMaterial.NORMALSCALE = Shader3D.propertyNameToID("u_normalScale"), PBRSpecularMaterial.PARALLAXSCALE = Shader3D.propertyNameToID("u_parallaxScale"), PBRSpecularMaterial.ENABLEEMISSION = -1, PBRSpecularMaterial.ENABLEREFLECT = -1, PBRSpecularMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset"), PBRSpecularMaterial.CULL = Shader3D.propertyNameToID("s_Cull"), PBRSpecularMaterial.BLEND = Shader3D.propertyNameToID("s_Blend"), PBRSpecularMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc"), PBRSpecularMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst"), PBRSpecularMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest"), PBRSpecularMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite"), PBRSpecularMaterial.shaderDefines = null;

        class PBRStandardMaterial extends BaseMaterial {
            constructor() {
                super(), this.setShaderName("PBRStandard"), this._albedoColor = new Vector4(1, 1, 1, 1), this._shaderValues.setVector(PBRStandardMaterial.ALBEDOCOLOR, new Vector4(1, 1, 1, 1)), this._emissionColor = new Vector4(0, 0, 0, 0), this._shaderValues.setVector(PBRStandardMaterial.EMISSIONCOLOR, new Vector4(0, 0, 0, 0)), this._shaderValues.setNumber(PBRStandardMaterial.METALLIC, 0), this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESS, .5), this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESSSCALE, 1), this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESSSOURCE, 0), this._shaderValues.setNumber(PBRStandardMaterial.OCCLUSIONSTRENGTH, 1), this._shaderValues.setNumber(PBRStandardMaterial.NORMALSCALE, 1), this._shaderValues.setNumber(PBRStandardMaterial.PARALLAXSCALE, .001), this._shaderValues.setBool(PBRStandardMaterial.ENABLEEMISSION, !1), this._shaderValues.setBool(PBRStandardMaterial.ENABLEREFLECT, !0), this._shaderValues.setNumber(BaseMaterial.ALPHATESTVALUE, .5), this._disablePublicDefineDatas.remove(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP), this.renderMode = PBRStandardMaterial.RENDERMODE_OPAQUE
            }

            static __initDefine__() {
                PBRStandardMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines), PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("ALBEDOTEXTURE"), PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("METALLICGLOSSTEXTURE"), PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = PBRStandardMaterial.shaderDefines.registerDefine("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA"), PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("NORMALTEXTURE"), PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("PARALLAXTEXTURE"), PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("OCCLUSIONTEXTURE"), PBRStandardMaterial.SHADERDEFINE_EMISSION = PBRStandardMaterial.shaderDefines.registerDefine("EMISSION"), PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("EMISSIONTEXTURE"), PBRStandardMaterial.SHADERDEFINE_REFLECTMAP = PBRStandardMaterial.shaderDefines.registerDefine("REFLECTMAP"), PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET = PBRStandardMaterial.shaderDefines.registerDefine("TILINGOFFSET"), PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY = PBRStandardMaterial.shaderDefines.registerDefine("ALPHAPREMULTIPLY")
            }

            get _ColorR() {
                return this._albedoColor.x
            }

            set _ColorR(value) {
                this._albedoColor.x = value, this.albedoColor = this._albedoColor
            }

            get _ColorG() {
                return this._albedoColor.y
            }

            set _ColorG(value) {
                this._albedoColor.y = value, this.albedoColor = this._albedoColor
            }

            get _ColorB() {
                return this._albedoColor.z
            }

            set _ColorB(value) {
                this._albedoColor.z = value, this.albedoColor = this._albedoColor
            }

            get _ColorA() {
                return this._albedoColor.w
            }

            set _ColorA(value) {
                this._albedoColor.w = value, this.albedoColor = this._albedoColor
            }

            get _Metallic() {
                return this._shaderValues.getNumber(PBRStandardMaterial.METALLIC)
            }

            set _Metallic(value) {
                this._shaderValues.setNumber(PBRStandardMaterial.METALLIC, value)
            }

            get _Glossiness() {
                return this._shaderValues.getNumber(PBRStandardMaterial.SMOOTHNESS)
            }

            set _Glossiness(value) {
                this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESS, value)
            }

            get _GlossMapScale() {
                return this._shaderValues.getNumber(PBRStandardMaterial.SMOOTHNESSSCALE)
            }

            set _GlossMapScale(value) {
                this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESSSCALE, value)
            }

            get _BumpScale() {
                return this._shaderValues.getNumber(PBRStandardMaterial.NORMALSCALE)
            }

            set _BumpScale(value) {
                this._shaderValues.setNumber(PBRStandardMaterial.NORMALSCALE, value)
            }

            get _Parallax() {
                return this._shaderValues.getNumber(PBRStandardMaterial.PARALLAXSCALE)
            }

            set _Parallax(value) {
                this._shaderValues.setNumber(PBRStandardMaterial.PARALLAXSCALE, value)
            }

            get _OcclusionStrength() {
                return this._shaderValues.getNumber(PBRStandardMaterial.OCCLUSIONSTRENGTH)
            }

            set _OcclusionStrength(value) {
                this._shaderValues.setNumber(PBRStandardMaterial.OCCLUSIONSTRENGTH, value)
            }

            get _EmissionColorR() {
                return this._emissionColor.x
            }

            set _EmissionColorR(value) {
                this._emissionColor.x = value, this.emissionColor = this._emissionColor
            }

            get _EmissionColorG() {
                return this._emissionColor.y
            }

            set _EmissionColorG(value) {
                this._emissionColor.y = value, this.emissionColor = this._emissionColor
            }

            get _EmissionColorB() {
                return this._emissionColor.z
            }

            set _EmissionColorB(value) {
                this._emissionColor.z = value, this.emissionColor = this._emissionColor
            }

            get _EmissionColorA() {
                return this._emissionColor.w
            }

            set _EmissionColorA(value) {
                this._emissionColor.w = value, this.emissionColor = this._emissionColor
            }

            get _MainTex_STX() {
                return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).x
            }

            set _MainTex_STX(x) {
                var tilOff = this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
                tilOff.x = x, this.tilingOffset = tilOff
            }

            get _MainTex_STY() {
                return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).y
            }

            set _MainTex_STY(y) {
                var tilOff = this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
                tilOff.y = y, this.tilingOffset = tilOff
            }

            get _MainTex_STZ() {
                return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).z
            }

            set _MainTex_STZ(z) {
                var tilOff = this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
                tilOff.z = z, this.tilingOffset = tilOff
            }

            get _MainTex_STW() {
                return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).w
            }

            set _MainTex_STW(w) {
                var tilOff = this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
                tilOff.w = w, this.tilingOffset = tilOff
            }

            get _Cutoff() {
                return this.alphaTestValue
            }

            set _Cutoff(value) {
                this.alphaTestValue = value
            }

            get albedoColorR() {
                return this._ColorR
            }

            set albedoColorR(value) {
                this._ColorR = value
            }

            get albedoColorG() {
                return this._ColorG
            }

            set albedoColorG(value) {
                this._ColorG = value
            }

            get albedoColorB() {
                return this._ColorB
            }

            set albedoColorB(value) {
                this._ColorB = value
            }

            get albedoColorA() {
                return this._ColorA
            }

            set albedoColorA(value) {
                this._ColorA = value
            }

            get albedoColor() {
                return this._albedoColor
            }

            set albedoColor(value) {
                this._albedoColor = value, this._shaderValues.setVector(PBRStandardMaterial.ALBEDOCOLOR, value)
            }

            get albedoTexture() {
                return this._shaderValues.getTexture(PBRStandardMaterial.ALBEDOTEXTURE)
            }

            set albedoTexture(value) {
                value ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE), this._shaderValues.setTexture(PBRStandardMaterial.ALBEDOTEXTURE, value)
            }

            get normalTexture() {
                return this._shaderValues.getTexture(PBRStandardMaterial.NORMALTEXTURE)
            }

            set normalTexture(value) {
                value ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE), this._shaderValues.setTexture(PBRStandardMaterial.NORMALTEXTURE, value)
            }

            get normalTextureScale() {
                return this._BumpScale
            }

            set normalTextureScale(value) {
                this._BumpScale = value
            }

            get parallaxTexture() {
                return this._shaderValues.getTexture(PBRStandardMaterial.PARALLAXTEXTURE)
            }

            set parallaxTexture(value) {
                value ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE), this._shaderValues.setTexture(PBRStandardMaterial.PARALLAXTEXTURE, value)
            }

            get parallaxTextureScale() {
                return this._Parallax
            }

            set parallaxTextureScale(value) {
                this._Parallax = Math.max(.005, Math.min(.08, value))
            }

            get occlusionTexture() {
                return this._shaderValues.getTexture(PBRStandardMaterial.OCCLUSIONTEXTURE)
            }

            set occlusionTexture(value) {
                value ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE), this._shaderValues.setTexture(PBRStandardMaterial.OCCLUSIONTEXTURE, value)
            }

            get occlusionTextureStrength() {
                return this._OcclusionStrength
            }

            set occlusionTextureStrength(value) {
                this._OcclusionStrength = Math.max(0, Math.min(1, value))
            }

            get metallicGlossTexture() {
                return this._shaderValues.getTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE)
            }

            set metallicGlossTexture(value) {
                value ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE), this._shaderValues.setTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE, value)
            }

            get metallic() {
                return this._Metallic
            }

            set metallic(value) {
                this._Metallic = Math.max(0, Math.min(1, value))
            }

            get smoothness() {
                return this._Glossiness
            }

            set smoothness(value) {
                this._Glossiness = Math.max(0, Math.min(1, value))
            }

            get smoothnessTextureScale() {
                return this._GlossMapScale
            }

            set smoothnessTextureScale(value) {
                this._GlossMapScale = Math.max(0, Math.min(1, value))
            }

            get smoothnessSource() {
                return this._shaderValues.getInt(PBRStandardMaterial.SMOOTHNESSSOURCE)
            }

            set smoothnessSource(value) {
                value ? (this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA), this._shaderValues.setInt(PBRStandardMaterial.SMOOTHNESSSOURCE, 1)) : (this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA), this._shaderValues.setInt(PBRStandardMaterial.SMOOTHNESSSOURCE, 0))
            }

            get enableEmission() {
                return this._shaderValues.getBool(PBRStandardMaterial.ENABLEEMISSION)
            }

            set enableEmission(value) {
                value ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_EMISSION) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_EMISSION), this._shaderValues.setBool(PBRStandardMaterial.ENABLEEMISSION, value)
            }

            get emissionColorR() {
                return this._EmissionColorR
            }

            set emissionColorR(value) {
                this._EmissionColorR = value
            }

            get emissionColorG() {
                return this._EmissionColorG
            }

            set emissionColorG(value) {
                this._EmissionColorG = value
            }

            get emissionColorB() {
                return this._EmissionColorB
            }

            set emissionColorB(value) {
                this._EmissionColorB = value
            }

            get emissionColorA() {
                return this._EmissionColorA
            }

            set emissionColorA(value) {
                this._EmissionColorA = value
            }

            get emissionColor() {
                return this._shaderValues.getVector(PBRStandardMaterial.EMISSIONCOLOR)
            }

            set emissionColor(value) {
                this._shaderValues.setVector(PBRStandardMaterial.EMISSIONCOLOR, value)
            }

            get emissionTexture() {
                return this._shaderValues.getTexture(PBRStandardMaterial.EMISSIONTEXTURE)
            }

            set emissionTexture(value) {
                value ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE), this._shaderValues.setTexture(PBRStandardMaterial.EMISSIONTEXTURE, value)
            }

            get enableReflection() {
                return this._shaderValues.getBool(PBRStandardMaterial.ENABLEREFLECT)
            }

            set enableReflection(value) {
                this._shaderValues.setBool(PBRStandardMaterial.ENABLEREFLECT, !0), value ? this._disablePublicDefineDatas.remove(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP) : this._disablePublicDefineDatas.add(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP)
            }

            get tilingOffsetX() {
                return this._MainTex_STX
            }

            set tilingOffsetX(x) {
                this._MainTex_STX = x
            }

            get tilingOffsetY() {
                return this._MainTex_STY
            }

            set tilingOffsetY(y) {
                this._MainTex_STY = y
            }

            get tilingOffsetZ() {
                return this._MainTex_STZ
            }

            set tilingOffsetZ(z) {
                this._MainTex_STZ = z
            }

            get tilingOffsetW() {
                return this._MainTex_STW
            }

            set tilingOffsetW(w) {
                this._MainTex_STW = w
            }

            get tilingOffset() {
                return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET)
            }

            set tilingOffset(value) {
                value && (1 != value.x || 1 != value.y || 0 != value.z || 0 != value.w) ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET), this._shaderValues.setVector(PBRStandardMaterial.TILINGOFFSET, value)
            }

            set renderMode(value) {
                switch (value) {
                    case PBRStandardMaterial.RENDERMODE_OPAQUE:
                        this.alphaTest = !1, this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE, this.depthWrite = !0, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_DISABLE, this.depthTest = RenderState.DEPTHTEST_LESS, this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                        break;
                    case PBRStandardMaterial.RENDERMODE_CUTOUT:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_DISABLE, this.depthTest = RenderState.DEPTHTEST_LESS, this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                        break;
                    case PBRStandardMaterial.RENDERMODE_FADE:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA, this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = RenderState.DEPTHTEST_LESS, this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                        break;
                    case PBRStandardMaterial.RENDERMODE_TRANSPARENT:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_ONE, this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = RenderState.DEPTHTEST_LESS, this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                        break;
                    default:
                        throw new Error("PBRSpecularMaterial : renderMode value error.")
                }
            }

            set depthWrite(value) {
                this._shaderValues.setBool(PBRStandardMaterial.DEPTH_WRITE, value)
            }

            get depthWrite() {
                return this._shaderValues.getBool(PBRStandardMaterial.DEPTH_WRITE)
            }

            set cull(value) {
                this._shaderValues.setInt(PBRStandardMaterial.CULL, value)
            }

            get cull() {
                return this._shaderValues.getInt(PBRStandardMaterial.CULL)
            }

            set blend(value) {
                this._shaderValues.setInt(PBRStandardMaterial.BLEND, value)
            }

            get blend() {
                return this._shaderValues.getInt(PBRStandardMaterial.BLEND)
            }

            set blendSrc(value) {
                this._shaderValues.setInt(PBRStandardMaterial.BLEND_SRC, value)
            }

            get blendSrc() {
                return this._shaderValues.getInt(PBRStandardMaterial.BLEND_SRC)
            }

            set blendDst(value) {
                this._shaderValues.setInt(PBRStandardMaterial.BLEND_DST, value)
            }

            get blendDst() {
                return this._shaderValues.getInt(PBRStandardMaterial.BLEND_DST)
            }

            set depthTest(value) {
                this._shaderValues.setInt(PBRStandardMaterial.DEPTH_TEST, value)
            }

            get depthTest() {
                return this._shaderValues.getInt(PBRStandardMaterial.DEPTH_TEST)
            }

            clone() {
                var dest = new PBRStandardMaterial;
                return this.cloneTo(dest), dest
            }

            cloneTo(destObject) {
                super.cloneTo(destObject);
                var destMaterial = destObject;
                this._albedoColor.cloneTo(destMaterial._albedoColor), this._emissionColor.cloneTo(destMaterial._emissionColor)
            }
        }

        PBRStandardMaterial.SmoothnessSource_MetallicGlossTexture_Alpha = 0, PBRStandardMaterial.SmoothnessSource_AlbedoTexture_Alpha = 1, PBRStandardMaterial.RENDERMODE_OPAQUE = 0, PBRStandardMaterial.RENDERMODE_CUTOUT = 1, PBRStandardMaterial.RENDERMODE_FADE = 2, PBRStandardMaterial.RENDERMODE_TRANSPARENT = 3, PBRStandardMaterial.ALBEDOTEXTURE = Shader3D.propertyNameToID("u_AlbedoTexture"), PBRStandardMaterial.METALLICGLOSSTEXTURE = Shader3D.propertyNameToID("u_MetallicGlossTexture"), PBRStandardMaterial.NORMALTEXTURE = Shader3D.propertyNameToID("u_NormalTexture"), PBRStandardMaterial.PARALLAXTEXTURE = Shader3D.propertyNameToID("u_ParallaxTexture"), PBRStandardMaterial.OCCLUSIONTEXTURE = Shader3D.propertyNameToID("u_OcclusionTexture"), PBRStandardMaterial.EMISSIONTEXTURE = Shader3D.propertyNameToID("u_EmissionTexture"), PBRStandardMaterial.ALBEDOCOLOR = Shader3D.propertyNameToID("u_AlbedoColor"), PBRStandardMaterial.EMISSIONCOLOR = Shader3D.propertyNameToID("u_EmissionColor"), PBRStandardMaterial.METALLIC = Shader3D.propertyNameToID("u_metallic"), PBRStandardMaterial.SMOOTHNESS = Shader3D.propertyNameToID("u_smoothness"), PBRStandardMaterial.SMOOTHNESSSCALE = Shader3D.propertyNameToID("u_smoothnessScale"), PBRStandardMaterial.SMOOTHNESSSOURCE = -1, PBRStandardMaterial.OCCLUSIONSTRENGTH = Shader3D.propertyNameToID("u_occlusionStrength"), PBRStandardMaterial.NORMALSCALE = Shader3D.propertyNameToID("u_normalScale"), PBRStandardMaterial.PARALLAXSCALE = Shader3D.propertyNameToID("u_parallaxScale"), PBRStandardMaterial.ENABLEEMISSION = -1, PBRStandardMaterial.ENABLEREFLECT = -1, PBRStandardMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset"), PBRStandardMaterial.CULL = Shader3D.propertyNameToID("s_Cull"), PBRStandardMaterial.BLEND = Shader3D.propertyNameToID("s_Blend"), PBRStandardMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc"), PBRStandardMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst"), PBRStandardMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest"), PBRStandardMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite"), PBRStandardMaterial.shaderDefines = null;

        class SkyProceduralMaterial extends BaseMaterial {
            constructor() {
                super(), this.setShaderName("SkyBoxProcedural"), this.sunDisk = SkyProceduralMaterial.SUN_HIGH_QUALITY, this.sunSize = .04, this.sunSizeConvergence = 5, this.atmosphereThickness = 1, this.skyTint = new Vector4(.5, .5, .5, 1), this.groundTint = new Vector4(.369, .349, .341, 1), this.exposure = 1.3
            }

            static __initDefine__() {
                SkyProceduralMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines), SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY = SkyProceduralMaterial.shaderDefines.registerDefine("SUN_HIGH_QUALITY"), SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE = SkyProceduralMaterial.shaderDefines.registerDefine("SUN_SIMPLE")
            }

            get sunDisk() {
                return this._sunDisk
            }

            set sunDisk(value) {
                switch (value) {
                    case SkyProceduralMaterial.SUN_HIGH_QUALITY:
                        this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE), this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                        break;
                    case SkyProceduralMaterial.SUN_SIMPLE:
                        this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY), this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                        break;
                    case SkyProceduralMaterial.SUN_NODE:
                        this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY), this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                        break;
                    default:
                        throw"SkyBoxProceduralMaterial: unknown sun value."
                }
                this._sunDisk = value
            }

            get sunSize() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZE)
            }

            set sunSize(value) {
                value = Math.min(Math.max(0, value), 1), this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZE, value)
            }

            get sunSizeConvergence() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE)
            }

            set sunSizeConvergence(value) {
                value = Math.min(Math.max(0, value), 20), this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE, value)
            }

            get atmosphereThickness() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS)
            }

            set atmosphereThickness(value) {
                value = Math.min(Math.max(0, value), 5), this._shaderValues.setNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS, value)
            }

            get skyTint() {
                return this._shaderValues.getVector(SkyProceduralMaterial.SKYTINT)
            }

            set skyTint(value) {
                this._shaderValues.setVector(SkyProceduralMaterial.SKYTINT, value)
            }

            get groundTint() {
                return this._shaderValues.getVector(SkyProceduralMaterial.GROUNDTINT)
            }

            set groundTint(value) {
                this._shaderValues.setVector(SkyProceduralMaterial.GROUNDTINT, value)
            }

            get exposure() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.EXPOSURE)
            }

            set exposure(value) {
                value = Math.min(Math.max(0, value), 8), this._shaderValues.setNumber(SkyProceduralMaterial.EXPOSURE, value)
            }

            clone() {
                var dest = new SkyProceduralMaterial;
                return this.cloneTo(dest), dest
            }
        }

        SkyProceduralMaterial.SUN_NODE = 0, SkyProceduralMaterial.SUN_SIMPLE = 1, SkyProceduralMaterial.SUN_HIGH_QUALITY = 2, SkyProceduralMaterial.SUNSIZE = Shader3D.propertyNameToID("u_SunSize"), SkyProceduralMaterial.SUNSIZECONVERGENCE = Shader3D.propertyNameToID("u_SunSizeConvergence"), SkyProceduralMaterial.ATMOSPHERETHICKNESS = Shader3D.propertyNameToID("u_AtmosphereThickness"), SkyProceduralMaterial.SKYTINT = Shader3D.propertyNameToID("u_SkyTint"), SkyProceduralMaterial.GROUNDTINT = Shader3D.propertyNameToID("u_GroundTint"), SkyProceduralMaterial.EXPOSURE = Shader3D.propertyNameToID("u_Exposure"), SkyProceduralMaterial.shaderDefines = null;

        class UnlitMaterial extends BaseMaterial {
            constructor() {
                super(), this._albedoColor = new Vector4(1, 1, 1, 1), this._albedoIntensity = 1, this._enableVertexColor = !1, this.setShaderName("Unlit"), this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, new Vector4(1, 1, 1, 1)), this.renderMode = UnlitMaterial.RENDERMODE_OPAQUE
            }

            static __initDefine__() {
                UnlitMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines), UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE = UnlitMaterial.shaderDefines.registerDefine("ALBEDOTEXTURE"), UnlitMaterial.SHADERDEFINE_TILINGOFFSET = UnlitMaterial.shaderDefines.registerDefine("TILINGOFFSET"), UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = UnlitMaterial.shaderDefines.registerDefine("ENABLEVERTEXCOLOR")
            }

            get _ColorR() {
                return this._albedoColor.x
            }

            set _ColorR(value) {
                this._albedoColor.x = value, this.albedoColor = this._albedoColor
            }

            get _ColorG() {
                return this._albedoColor.y
            }

            set _ColorG(value) {
                this._albedoColor.y = value, this.albedoColor = this._albedoColor
            }

            get _ColorB() {
                return this._albedoColor.z
            }

            set _ColorB(value) {
                this._albedoColor.z = value, this.albedoColor = this._albedoColor
            }

            get _ColorA() {
                return this._albedoColor.w
            }

            set _ColorA(value) {
                this._albedoColor.w = value, this.albedoColor = this._albedoColor
            }

            get _AlbedoIntensity() {
                return this._albedoIntensity
            }

            set _AlbedoIntensity(value) {
                if (this._albedoIntensity !== value) {
                    var finalAlbedo = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
                    Vector4.scale(this._albedoColor, value, finalAlbedo), this._albedoIntensity = value, this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, finalAlbedo)
                }
            }

            get _MainTex_STX() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).x
            }

            set _MainTex_STX(x) {
                var tilOff = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                tilOff.x = x, this.tilingOffset = tilOff
            }

            get _MainTex_STY() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).y
            }

            set _MainTex_STY(y) {
                var tilOff = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                tilOff.y = y, this.tilingOffset = tilOff
            }

            get _MainTex_STZ() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).z
            }

            set _MainTex_STZ(z) {
                var tilOff = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                tilOff.z = z, this.tilingOffset = tilOff
            }

            get _MainTex_STW() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).w
            }

            set _MainTex_STW(w) {
                var tilOff = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                tilOff.w = w, this.tilingOffset = tilOff
            }

            get _Cutoff() {
                return this.alphaTestValue
            }

            set _Cutoff(value) {
                this.alphaTestValue = value
            }

            get albedoColorR() {
                return this._ColorR
            }

            set albedoColorR(value) {
                this._ColorR = value
            }

            get albedoColorG() {
                return this._ColorG
            }

            set albedoColorG(value) {
                this._ColorG = value
            }

            get albedoColorB() {
                return this._ColorB
            }

            set albedoColorB(value) {
                this._ColorB = value
            }

            get albedoColorA() {
                return this._ColorA
            }

            set albedoColorA(value) {
                this._ColorA = value
            }

            get albedoColor() {
                return this._albedoColor
            }

            set albedoColor(value) {
                var finalAlbedo = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
                Vector4.scale(value, this._albedoIntensity, finalAlbedo), this._albedoColor = value, this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, finalAlbedo)
            }

            get albedoIntensity() {
                return this._albedoIntensity
            }

            set albedoIntensity(value) {
                this._AlbedoIntensity = value
            }

            get albedoTexture() {
                return this._shaderValues.getTexture(UnlitMaterial.ALBEDOTEXTURE)
            }

            set albedoTexture(value) {
                value ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE), this._shaderValues.setTexture(UnlitMaterial.ALBEDOTEXTURE, value)
            }

            get tilingOffsetX() {
                return this._MainTex_STX
            }

            set tilingOffsetX(x) {
                this._MainTex_STX = x
            }

            get tilingOffsetY() {
                return this._MainTex_STY
            }

            set tilingOffsetY(y) {
                this._MainTex_STY = y
            }

            get tilingOffsetZ() {
                return this._MainTex_STZ
            }

            set tilingOffsetZ(z) {
                this._MainTex_STZ = z
            }

            get tilingOffsetW() {
                return this._MainTex_STW
            }

            set tilingOffsetW(w) {
                this._MainTex_STW = w
            }

            get tilingOffset() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET)
            }

            set tilingOffset(value) {
                value && (1 != value.x || 1 != value.y || 0 != value.z || 0 != value.w) ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET), this._shaderValues.setVector(UnlitMaterial.TILINGOFFSET, value)
            }

            get enableVertexColor() {
                return this._enableVertexColor
            }

            set enableVertexColor(value) {
                this._enableVertexColor = value, value ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR)
            }

            set renderMode(value) {
                switch (value) {
                    case UnlitMaterial.RENDERMODE_OPAQUE:
                        this.alphaTest = !1, this.renderQueue = BaseMaterial.RENDERQUEUE_OPAQUE, this.depthWrite = !0, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_DISABLE, this.depthTest = RenderState.DEPTHTEST_LESS;
                        break;
                    case UnlitMaterial.RENDERMODE_CUTOUT:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_DISABLE, this.depthTest = RenderState.DEPTHTEST_LESS;
                        break;
                    case UnlitMaterial.RENDERMODE_TRANSPARENT:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA, this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = RenderState.DEPTHTEST_LESS;
                        break;
                    default:
                        throw new Error("UnlitMaterial : renderMode value error.")
                }
            }

            set depthWrite(value) {
                this._shaderValues.setBool(UnlitMaterial.DEPTH_WRITE, value)
            }

            get depthWrite() {
                return this._shaderValues.getBool(UnlitMaterial.DEPTH_WRITE)
            }

            set cull(value) {
                this._shaderValues.setInt(UnlitMaterial.CULL, value)
            }

            get cull() {
                return this._shaderValues.getInt(UnlitMaterial.CULL)
            }

            set blend(value) {
                this._shaderValues.setInt(UnlitMaterial.BLEND, value)
            }

            get blend() {
                return this._shaderValues.getInt(UnlitMaterial.BLEND)
            }

            set blendSrc(value) {
                this._shaderValues.setInt(UnlitMaterial.BLEND_SRC, value)
            }

            get blendSrc() {
                return this._shaderValues.getInt(UnlitMaterial.BLEND_SRC)
            }

            set blendDst(value) {
                this._shaderValues.setInt(UnlitMaterial.BLEND_DST, value)
            }

            get blendDst() {
                return this._shaderValues.getInt(UnlitMaterial.BLEND_DST)
            }

            set depthTest(value) {
                this._shaderValues.setInt(UnlitMaterial.DEPTH_TEST, value)
            }

            get depthTest() {
                return this._shaderValues.getInt(UnlitMaterial.DEPTH_TEST)
            }

            clone() {
                var dest = new UnlitMaterial;
                return this.cloneTo(dest), dest
            }
        }

        UnlitMaterial.RENDERMODE_OPAQUE = 0, UnlitMaterial.RENDERMODE_CUTOUT = 1, UnlitMaterial.RENDERMODE_TRANSPARENT = 2, UnlitMaterial.RENDERMODE_ADDTIVE = 3, UnlitMaterial.ALBEDOTEXTURE = Shader3D.propertyNameToID("u_AlbedoTexture"), UnlitMaterial.ALBEDOCOLOR = Shader3D.propertyNameToID("u_AlbedoColor"), UnlitMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset"), UnlitMaterial.CULL = Shader3D.propertyNameToID("s_Cull"), UnlitMaterial.BLEND = Shader3D.propertyNameToID("s_Blend"), UnlitMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc"), UnlitMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst"), UnlitMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest"), UnlitMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite"), UnlitMaterial.shaderDefines = null;

        class WaterPrimaryMaterial extends BaseMaterial {
            constructor() {
                super(), this.setShaderName("WaterPrimary"), this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, new Vector4(.172, .463, .435, 0)), this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, .15), this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, new Vector4(19, 9, -16, -7))
            }

            static __initDefine__() {
                WaterPrimaryMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines), WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE = WaterPrimaryMaterial.shaderDefines.registerDefine("MAINTEXTURE"), WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE = WaterPrimaryMaterial.shaderDefines.registerDefine("NORMALTEXTURE")
            }

            get horizonColor() {
                return this._shaderValues.getVector(WaterPrimaryMaterial.HORIZONCOLOR)
            }

            set horizonColor(value) {
                this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, value)
            }

            get mainTexture() {
                return this._shaderValues.getTexture(WaterPrimaryMaterial.MAINTEXTURE)
            }

            set mainTexture(value) {
                value ? this._shaderValues.addDefine(WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE), this._shaderValues.setTexture(WaterPrimaryMaterial.MAINTEXTURE, value)
            }

            get normalTexture() {
                return this._shaderValues.getTexture(WaterPrimaryMaterial.NORMALTEXTURE)
            }

            set normalTexture(value) {
                value ? this._shaderValues.addDefine(WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE), this._shaderValues.setTexture(WaterPrimaryMaterial.NORMALTEXTURE, value)
            }

            get waveScale() {
                return this._shaderValues.getNumber(WaterPrimaryMaterial.WAVESCALE)
            }

            set waveScale(value) {
                this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, value)
            }

            get waveSpeed() {
                return this._shaderValues.getVector(WaterPrimaryMaterial.WAVESPEED)
            }

            set waveSpeed(value) {
                this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, value)
            }

            clone() {
                var dest = new WaterPrimaryMaterial;
                return this.cloneTo(dest), dest
            }
        }

        WaterPrimaryMaterial.HORIZONCOLOR = Shader3D.propertyNameToID("u_HorizonColor"), WaterPrimaryMaterial.MAINTEXTURE = Shader3D.propertyNameToID("u_MainTexture"), WaterPrimaryMaterial.NORMALTEXTURE = Shader3D.propertyNameToID("u_NormalTexture"), WaterPrimaryMaterial.WAVESCALE = Shader3D.propertyNameToID("u_WaveScale"), WaterPrimaryMaterial.WAVESPEED = Shader3D.propertyNameToID("u_WaveSpeed"), WaterPrimaryMaterial.shaderDefines = null;

        class SkinnedMeshSprite3DShaderDeclaration {
        }

        class SkinnedMeshRenderer extends MeshRenderer {
            constructor(owner) {
                super(owner), this._bones = [], this._skinnedDataLoopMarks = [], this._localBounds = new Bounds(Vector3._ZERO, Vector3._ZERO), this._cacheAnimationNode = []
            }

            get localBounds() {
                return this._localBounds
            }

            set localBounds(value) {
                this._localBounds = value
            }

            get rootBone() {
                return this._cacheRootBone
            }

            set rootBone(value) {
                this._cacheRootBone != value && (this._cacheRootBone ? this._cacheRootBone.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), value ? value.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), this._cacheRootBone = value, this._onWorldMatNeedChange(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE))
            }

            get bones() {
                return this._bones
            }

            _computeSkinnedData() {
                if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar) for (var bindPoses = this._cacheMesh._inverseBindPoses, meshBindPoseIndices = this._cacheMesh._bindPoseIndices, pathMarks = this._cacheMesh._skinDataPathMarks, i = 0, n = this._cacheMesh.subMeshCount; i < n; i++) for (var subMeshBoneIndices = this._cacheMesh.getSubMesh(i)._boneIndicesList, subData = this._skinnedData[i], j = 0, m = subMeshBoneIndices.length; j < m; j++) {
                    var boneIndices = subMeshBoneIndices[j];
                    this._computeSubSkinnedData(bindPoses, boneIndices, meshBindPoseIndices, subData[j], pathMarks)
                }
            }

            _computeSubSkinnedData(bindPoses, boneIndices, meshBindPoseInices, data, pathMarks) {
                for (var k = 0, q = boneIndices.length; k < q; k++) {
                    var index = boneIndices[k];
                    if (this._skinnedDataLoopMarks[index] === Laya.Stat.loopCount) for (var p = pathMarks[index], preData = this._skinnedData[p[0]][p[1]], srcIndex = 16 * p[2], dstIndex = 16 * k, d = 0; d < 16; d++) data[dstIndex + d] = preData[srcIndex + d]; else {
                        if (this._cacheAvatar) Utils3D._mulMatrixArray(this._cacheAnimationNode[index].transform.getWorldMatrix(), bindPoses[meshBindPoseInices[index]], data, 16 * k); else {
                            var boneIndex = meshBindPoseInices[index];
                            Utils3D._mulMatrixArray(this._bones[boneIndex].transform.worldMatrix.elements, bindPoses[boneIndex], data, 16 * k)
                        }
                        this._skinnedDataLoopMarks[index] = Laya.Stat.loopCount
                    }
                }
            }

            _onWorldMatNeedChange(flag) {
                this._boundsChange = !0, this._octreeNode && (this._cacheAvatar ? -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this) : (flag &= Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this))
            }

            _createRenderElement() {
                return new RenderElement
            }

            _onMeshChange(value) {
                super._onMeshChange(value), this._cacheMesh = value;
                var subMeshCount = value.subMeshCount;
                this._skinnedData = [], this._skinnedDataLoopMarks.length = value._bindPoseIndices.length;
                for (var i = 0; i < subMeshCount; i++) for (var subBoneIndices = value.getSubMesh(i)._boneIndicesList, subCount = subBoneIndices.length, subData = this._skinnedData[i] = [], j = 0; j < subCount; j++) subData[j] = new Float32Array(16 * subBoneIndices[j].length);
                this._cacheAvatar && value && this._getCacheAnimationNodes()
            }

            _setCacheAnimator(animator) {
                this._cacheAnimator = animator, this._shaderValues.addDefine(SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_BONE), this._setRootNode()
            }

            _calculateBoundingBox() {
                if (this._cacheAvatar) if (this._cacheAnimator && this._rootBone) {
                    var worldMat = SkinnedMeshRenderer._tempMatrix4x4;
                    Utils3D.matrix4x4MultiplyMFM(this._cacheAnimator.owner.transform.worldMatrix, this._cacheRootAnimationNode.transform.getWorldMatrix(), worldMat), this._localBounds._tranform(worldMat, this._bounds)
                } else super._calculateBoundingBox(); else this._cacheRootBone ? this._localBounds._tranform(this._cacheRootBone.transform.worldMatrix, this._bounds) : this._localBounds._tranform(this._owner.transform.worldMatrix, this._bounds);
                if (Laya.Render.supportWebGLPlusCulling) {
                    var min = this._bounds.getMin(), max = this._bounds.getMax(),
                        buffer = FrustumCulling._cullingBuffer;
                    buffer[this._cullingBufferIndex + 1] = min.x, buffer[this._cullingBufferIndex + 2] = min.y, buffer[this._cullingBufferIndex + 3] = min.z, buffer[this._cullingBufferIndex + 4] = max.x, buffer[this._cullingBufferIndex + 5] = max.y, buffer[this._cullingBufferIndex + 6] = max.z
                }
            }

            _renderUpdate(context, transform) {
                if (this._cacheAnimator) if (this._computeSkinnedData(), this._cacheAvatar) {
                    var aniOwnerTrans = this._cacheAnimator.owner._transform;
                    this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, aniOwnerTrans.worldMatrix)
                } else this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, Matrix4x4.DEFAULT); else this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, transform.worldMatrix)
            }

            _renderUpdateWithCamera(context, transform) {
                var projectionView = context.projectionViewMatrix;
                if (this._cacheAnimator) if (this._cacheAvatar) {
                    var aniOwnerTrans = this._cacheAnimator.owner._transform;
                    Matrix4x4.multiply(projectionView, aniOwnerTrans.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, this._projectionViewWorldMatrix)
                } else this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, projectionView); else Matrix4x4.multiply(projectionView, transform.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, this._projectionViewWorldMatrix)
            }

            _destroy() {
                super._destroy(), this._cacheAvatar ? this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._cacheRootBone ? !this._cacheRootBone.destroyed && this._cacheRootBone.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner && !this._owner.destroyed && this._owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange)
            }

            get bounds() {
                return (this._boundsChange || this._cacheAvatar) && (this._calculateBoundingBox(), this._boundsChange = !1), this._bounds
            }

            _setRootBone(name) {
                this._rootBone = name, this._setRootNode()
            }

            _setRootNode() {
                var rootNode;
                rootNode = this._cacheAnimator && this._rootBone && this._cacheAvatar ? this._cacheAnimator._avatarNodeMap[this._rootBone] : null, this._cacheRootAnimationNode != rootNode && (this._onWorldMatNeedChange(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE), this._owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), rootNode && rootNode.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), this._cacheRootAnimationNode = rootNode)
            }

            _getCacheAnimationNodes() {
                var meshBoneNames = this._cacheMesh._boneNames, bindPoseIndices = this._cacheMesh._bindPoseIndices,
                    innerBindPoseCount = bindPoseIndices.length;
                if (Laya.Render.supportWebGLPlusAnimation) {
                    this._cacheAnimationNodeIndices = new Uint16Array(innerBindPoseCount);
                    var nodeMapC = this._cacheAnimator._avatarNodeMap;
                    for (i = 0; i < innerBindPoseCount; i++) {
                        var nodeC = nodeMapC[meshBoneNames[bindPoseIndices[i]]];
                        this._cacheAnimationNodeIndices[i] = nodeC._worldMatrixIndex
                    }
                } else {
                    this._cacheAnimationNode.length = innerBindPoseCount;
                    for (var nodeMap = this._cacheAnimator._avatarNodeMap, i = 0; i < innerBindPoseCount; i++) {
                        var node = nodeMap[meshBoneNames[bindPoseIndices[i]]];
                        this._cacheAnimationNode[i] = node
                    }
                }
            }

            _setCacheAvatar(value) {
                this._cacheAvatar !== value && (this._cacheMesh ? (this._cacheAvatar = value, value && (this._shaderValues.addDefine(SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_BONE), this._getCacheAnimationNodes())) : this._cacheAvatar = value, this._setRootNode())
            }

            _computeSubSkinnedDataNative(worldMatrixs, cacheAnimationNodeIndices, inverseBindPosesBuffer, boneIndices, bindPoseInices, data) {
                Laya.LayaGL.instance.computeSubSkinnedData(worldMatrixs, cacheAnimationNodeIndices, inverseBindPosesBuffer, boneIndices, bindPoseInices, data)
            }

            _computeSkinnedDataForNative() {
                if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar) for (var bindPoses = this._cacheMesh._inverseBindPoses, meshBindPoseIndices = this._cacheMesh._bindPoseIndices, pathMarks = this._cacheMesh._skinDataPathMarks, i = 0, n = this._cacheMesh.subMeshCount; i < n; i++) for (var subMeshBoneIndices = this._cacheMesh.getSubMesh(i)._boneIndicesList, subData = this._skinnedData[i], j = 0, m = subMeshBoneIndices.length; j < m; j++) {
                    var boneIndices = subMeshBoneIndices[j];
                    this._cacheAvatar && Laya.Render.supportWebGLPlusAnimation ? this._computeSubSkinnedDataNative(this._cacheAnimator._animationNodeWorldMatrixs, this._cacheAnimationNodeIndices, this._cacheMesh._inverseBindPosesBuffer, boneIndices, meshBindPoseIndices, subData[j]) : this._computeSubSkinnedData(bindPoses, boneIndices, meshBindPoseIndices, subData[j], pathMarks)
                }
            }
        }

        SkinnedMeshRenderer._tempMatrix4x4 = new Matrix4x4;

        class SkinnedMeshSprite3D extends RenderableSprite3D {
            constructor(mesh = null, name = null) {
                super(name), this._meshFilter = new MeshFilter(this), this._render = new SkinnedMeshRenderer(this), mesh && (this._meshFilter.sharedMesh = mesh)
            }

            static __init__() {
                SkinnedMeshSprite3D.shaderDefines = new ShaderDefines(MeshSprite3D.shaderDefines), SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_BONE = SkinnedMeshSprite3D.shaderDefines.registerDefine("BONE")
            }

            get meshFilter() {
                return this._meshFilter
            }

            get skinnedMeshRenderer() {
                return this._render
            }

            _parse(data, spriteMap) {
                super._parse(data, spriteMap);
                var render = this.skinnedMeshRenderer, lightmapIndex = data.lightmapIndex;
                null != lightmapIndex && (render.lightmapIndex = lightmapIndex);
                var meshPath, lightmapScaleOffsetArray = data.lightmapScaleOffset;
                if (lightmapScaleOffsetArray && (render.lightmapScaleOffset = new Vector4(lightmapScaleOffsetArray[0], lightmapScaleOffsetArray[1], lightmapScaleOffsetArray[2], lightmapScaleOffsetArray[3])), meshPath = data.meshPath) {
                    var mesh = Laya.Loader.getRes(meshPath);
                    mesh && (this.meshFilter.sharedMesh = mesh)
                }
                var materials = data.materials;
                if (materials) {
                    var sharedMaterials = render.sharedMaterials, materialCount = materials.length;
                    sharedMaterials.length = materialCount;
                    for (var i = 0; i < materialCount; i++) sharedMaterials[i] = Laya.Loader.getRes(materials[i].path);
                    render.sharedMaterials = sharedMaterials
                }
                var boundBox = data.boundBox, min = boundBox.min, max = boundBox.max;
                if (render.localBounds.setMin(new Vector3(min[0], min[1], min[2])), render.localBounds.setMax(new Vector3(max[0], max[1], max[2])), spriteMap) {
                    var rootBoneData = data.rootBone;
                    render.rootBone = spriteMap[rootBoneData];
                    var n, bonesData = data.bones;
                    for (i = 0, n = bonesData.length; i < n; i++) render.bones.push(spriteMap[bonesData[i]])
                } else data.rootBone && render._setRootBone(data.rootBone)
            }

            _changeHierarchyAnimator(animator) {
                super._changeHierarchyAnimator(animator), this.skinnedMeshRenderer._setCacheAnimator(animator)
            }

            _changeAnimatorAvatar(avatar) {
                this.skinnedMeshRenderer._setCacheAvatar(avatar)
            }

            _cloneTo(destObject, srcRoot, dstRoot) {
                var meshSprite3D = destObject;
                meshSprite3D.meshFilter.sharedMesh = this.meshFilter.sharedMesh;
                var meshRender = this._render, destMeshRender = meshSprite3D._render;
                destMeshRender.enable = meshRender.enable, destMeshRender.sharedMaterials = meshRender.sharedMaterials, destMeshRender.castShadow = meshRender.castShadow;
                var lightmapScaleOffset = meshRender.lightmapScaleOffset;
                lightmapScaleOffset && (destMeshRender.lightmapScaleOffset = lightmapScaleOffset.clone()), destMeshRender.receiveShadow = meshRender.receiveShadow, destMeshRender.sortingFudge = meshRender.sortingFudge, destMeshRender._rootBone = meshRender._rootBone;
                var bones = meshRender.bones, destBones = destMeshRender.bones, bonesCount = bones.length;
                destBones.length = bonesCount;
                var rootBone = meshRender.rootBone;
                if (rootBone) {
                    var pathes = Utils3D._getHierarchyPath(srcRoot, rootBone, SkinnedMeshSprite3D._tempArray0);
                    destMeshRender.rootBone = pathes ? Utils3D._getNodeByHierarchyPath(dstRoot, pathes) : rootBone
                }
                for (var i = 0; i < bones.length; i++) pathes = Utils3D._getHierarchyPath(srcRoot, bones[i], SkinnedMeshSprite3D._tempArray0), destBones[i] = pathes ? Utils3D._getNodeByHierarchyPath(dstRoot, pathes) : bones[i];
                var lbb = meshRender.localBounds;
                lbb && lbb.cloneTo(destMeshRender.localBounds), super._cloneTo(destObject, srcRoot, dstRoot)
            }

            destroy(destroyChild = !0) {
                this.destroyed || (super.destroy(destroyChild), this._meshFilter.destroy())
            }

            _create() {
                return new SkinnedMeshSprite3D
            }
        }

        SkinnedMeshSprite3D._tempArray0 = [], SkinnedMeshSprite3D.BONES = Shader3D.propertyNameToID("u_Bones"), SkinnedMeshSprite3D.shaderDefines = null;

        class TrailMaterial extends BaseMaterial {
            constructor() {
                super(), this.setShaderName("Trail"), this._color = new Vector4(1, 1, 1, 1), this._shaderValues.setVector(TrailMaterial.TINTCOLOR, new Vector4(1, 1, 1, 1)), this.renderMode = TrailMaterial.RENDERMODE_ALPHABLENDED
            }

            static __initDefine__() {
                TrailMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines), TrailMaterial.SHADERDEFINE_MAINTEXTURE = TrailMaterial.shaderDefines.registerDefine("MAINTEXTURE"), TrailMaterial.SHADERDEFINE_TILINGOFFSET = TrailMaterial.shaderDefines.registerDefine("TILINGOFFSET"), TrailMaterial.SHADERDEFINE_ADDTIVEFOG = TrailMaterial.shaderDefines.registerDefine("ADDTIVEFOG")
            }

            get _TintColorR() {
                return this._color.x
            }

            set _TintColorR(value) {
                this._color.x = value, this.color = this._color
            }

            get _TintColorG() {
                return this._color.y
            }

            set _TintColorG(value) {
                this._color.y = value, this.color = this._color
            }

            get _TintColorB() {
                return this._color.z
            }

            set _TintColorB(value) {
                this._color.z = value, this.color = this._color
            }

            get _TintColorA() {
                return this._color.w
            }

            set _TintColorA(value) {
                this._color.w = value, this.color = this._color
            }

            get _MainTex_STX() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).x
            }

            set _MainTex_STX(x) {
                var tilOff = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                tilOff.x = x, this.tilingOffset = tilOff
            }

            get _MainTex_STY() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).y
            }

            set _MainTex_STY(y) {
                var tilOff = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                tilOff.y = y, this.tilingOffset = tilOff
            }

            get _MainTex_STZ() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).z
            }

            set _MainTex_STZ(z) {
                var tilOff = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                tilOff.z = z, this.tilingOffset = tilOff
            }

            get _MainTex_STW() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).w
            }

            set _MainTex_STW(w) {
                var tilOff = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                tilOff.w = w, this.tilingOffset = tilOff
            }

            set renderMode(value) {
                switch (value) {
                    case TrailMaterial.RENDERMODE_ADDTIVE:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, this.cull = RenderState.CULL_NONE, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA, this.blendDst = RenderState.BLENDPARAM_ONE, this.depthTest = RenderState.DEPTHTEST_LESS, this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                        break;
                    case TrailMaterial.RENDERMODE_ALPHABLENDED:
                        this.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, this.cull = RenderState.CULL_NONE, this.blend = RenderState.BLEND_ENABLE_ALL, this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA, this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = RenderState.DEPTHTEST_LESS, this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                        break;
                    default:
                        throw new Error("TrailMaterial : renderMode value error.")
                }
            }

            get colorR() {
                return this._TintColorR
            }

            set colorR(value) {
                this._TintColorR = value
            }

            get colorG() {
                return this._TintColorG
            }

            set colorG(value) {
                this._TintColorG = value
            }

            get colorB() {
                return this._TintColorB
            }

            set colorB(value) {
                this._TintColorB = value
            }

            get colorA() {
                return this._TintColorA
            }

            set colorA(value) {
                this._TintColorA = value
            }

            get color() {
                return this._shaderValues.getVector(TrailMaterial.TINTCOLOR)
            }

            set color(value) {
                this._shaderValues.setVector(TrailMaterial.TINTCOLOR, value)
            }

            get texture() {
                return this._shaderValues.getTexture(TrailMaterial.MAINTEXTURE)
            }

            set texture(value) {
                value ? this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE), this._shaderValues.setTexture(TrailMaterial.MAINTEXTURE, value)
            }

            get tilingOffsetX() {
                return this._MainTex_STX
            }

            set tilingOffsetX(x) {
                this._MainTex_STX = x
            }

            get tilingOffsetY() {
                return this._MainTex_STY
            }

            set tilingOffsetY(y) {
                this._MainTex_STY = y
            }

            get tilingOffsetZ() {
                return this._MainTex_STZ
            }

            set tilingOffsetZ(z) {
                this._MainTex_STZ = z
            }

            get tilingOffsetW() {
                return this._MainTex_STW
            }

            set tilingOffsetW(w) {
                this._MainTex_STW = w
            }

            get tilingOffset() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET)
            }

            set tilingOffset(value) {
                value && (1 != value.x || 1 != value.y || 0 != value.z || 0 != value.w) ? this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET), this._shaderValues.setVector(TrailMaterial.TILINGOFFSET, value)
            }

            set depthWrite(value) {
                this._shaderValues.setBool(TrailMaterial.DEPTH_WRITE, value)
            }

            get depthWrite() {
                return this._shaderValues.getBool(TrailMaterial.DEPTH_WRITE)
            }

            set cull(value) {
                this._shaderValues.setInt(TrailMaterial.CULL, value)
            }

            get cull() {
                return this._shaderValues.getInt(TrailMaterial.CULL)
            }

            set blend(value) {
                this._shaderValues.setInt(TrailMaterial.BLEND, value)
            }

            get blend() {
                return this._shaderValues.getInt(TrailMaterial.BLEND)
            }

            set blendSrc(value) {
                this._shaderValues.setInt(TrailMaterial.BLEND_SRC, value)
            }

            get blendSrc() {
                return this._shaderValues.getInt(TrailMaterial.BLEND_SRC)
            }

            set blendDst(value) {
                this._shaderValues.setInt(TrailMaterial.BLEND_DST, value)
            }

            get blendDst() {
                return this._shaderValues.getInt(TrailMaterial.BLEND_DST)
            }

            set depthTest(value) {
                this._shaderValues.setInt(TrailMaterial.DEPTH_TEST, value)
            }

            get depthTest() {
                return this._shaderValues.getInt(TrailMaterial.DEPTH_TEST)
            }

            clone() {
                var dest = new TrailMaterial;
                return this.cloneTo(dest), dest
            }
        }

        TrailMaterial.RENDERMODE_ALPHABLENDED = 0, TrailMaterial.RENDERMODE_ADDTIVE = 1, TrailMaterial.MAINTEXTURE = Shader3D.propertyNameToID("u_MainTexture"), TrailMaterial.TINTCOLOR = Shader3D.propertyNameToID("u_MainColor"), TrailMaterial.TILINGOFFSET = Shader3D.propertyNameToID("u_TilingOffset"), TrailMaterial.CULL = Shader3D.propertyNameToID("s_Cull"), TrailMaterial.BLEND = Shader3D.propertyNameToID("s_Blend"), TrailMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc"), TrailMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst"), TrailMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest"), TrailMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite"), TrailMaterial.shaderDefines = null;

        class Keyframe {
            constructor() {
            }

            cloneTo(destObject) {
                destObject.time = this.time
            }

            clone() {
                var dest = new Keyframe;
                return this.cloneTo(dest), dest
            }
        }

        class FloatKeyframe extends Keyframe {
            constructor() {
                super()
            }

            cloneTo(destObject) {
                super.cloneTo(destObject);
                var destKeyFrame = destObject;
                destKeyFrame.inTangent = this.inTangent, destKeyFrame.outTangent = this.outTangent, destKeyFrame.value = this.value
            }
        }

        window.conch && window.conchFloatKeyframe && (FloatKeyframe = window.conchFloatKeyframe);

        class TextureMode {
        }

        var TrailAlignment;
        TextureMode.Stretch = 0, TextureMode.Tile = 1, (TrailAlignment = exports.TrailAlignment || (exports.TrailAlignment = {}))[TrailAlignment.View = 0] = "View", TrailAlignment[TrailAlignment.TransformZ = 1] = "TransformZ";

        class VertexTrail {
            constructor() {
            }

            static get vertexDeclaration1() {
                return VertexTrail._vertexDeclaration1
            }

            static get vertexDeclaration2() {
                return VertexTrail._vertexDeclaration2
            }

            get vertexDeclaration() {
                return VertexTrail._vertexDeclaration1
            }

            static __init__() {
                VertexTrail._vertexDeclaration1 = new VertexDeclaration(32, [new VertexElement(0, VertexElementFormat.Vector3, VertexTrail.TRAIL_POSITION0), new VertexElement(12, VertexElementFormat.Vector3, VertexTrail.TRAIL_OFFSETVECTOR), new VertexElement(24, VertexElementFormat.Single, VertexTrail.TRAIL_TIME0), new VertexElement(28, VertexElementFormat.Single, VertexTrail.TRAIL_TEXTURECOORDINATE0Y)]), VertexTrail._vertexDeclaration2 = new VertexDeclaration(20, [new VertexElement(0, VertexElementFormat.Single, VertexTrail.TRAIL_TEXTURECOORDINATE0X), new VertexElement(4, VertexElementFormat.Color, VertexTrail.TRAIL_COLOR)])
            }
        }

        VertexTrail.TRAIL_POSITION0 = 0, VertexTrail.TRAIL_OFFSETVECTOR = 1, VertexTrail.TRAIL_TIME0 = 2, VertexTrail.TRAIL_TEXTURECOORDINATE0Y = 3, VertexTrail.TRAIL_TEXTURECOORDINATE0X = 4, VertexTrail.TRAIL_COLOR = 5;

        class TrailGeometry extends GeometryElement {
            constructor(owner) {
                super(), this._floatCountPerVertices1 = 8, this._floatCountPerVertices2 = 5, this._increaseSegementCount = 16, this._activeIndex = 0, this._endIndex = 0, this._needAddFirstVertex = !1, this._isTempEndVertex = !1, this._vertices1 = null, this._vertices2 = null, this._lastFixedVertexPosition = new Vector3, this._bufferState = new BufferState, this.tmpColor = new Color, this._disappearBoundsMode = !1, this._owner = owner, this._segementCount = this._increaseSegementCount, this._resizeData(this._segementCount, this._bufferState);
                var bounds = this._owner._owner.trailRenderer.bounds, min = bounds.getMin(), max = bounds.getMax();
                min.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), max.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), bounds.setMin(min), bounds.setMax(max), Laya.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative()
            }

            _resizeData(segementCount, bufferState) {
                this._subBirthTime = new Float32Array(segementCount), this._subDistance = new Float64Array(segementCount);
                var gl = Laya.LayaGL.instance, vertexCount = 2 * segementCount,
                    vertexDeclaration1 = VertexTrail.vertexDeclaration1,
                    vertexDeclaration2 = VertexTrail.vertexDeclaration2, vertexBuffers = [],
                    vertexbuffer1Size = vertexCount * vertexDeclaration1.vertexStride,
                    vertexbuffer2Size = vertexCount * vertexDeclaration2.vertexStride,
                    memorySize = vertexbuffer1Size + vertexbuffer2Size;
                this._vertices1 = new Float32Array(vertexCount * this._floatCountPerVertices1), this._vertices2 = new Float32Array(vertexCount * this._floatCountPerVertices2), this._vertexBuffer1 = new VertexBuffer3D(vertexbuffer1Size, gl.STATIC_DRAW, !1), this._vertexBuffer1.vertexDeclaration = vertexDeclaration1, this._vertexBuffer2 = new VertexBuffer3D(vertexbuffer2Size, gl.DYNAMIC_DRAW, !1), this._vertexBuffer2.vertexDeclaration = vertexDeclaration2, vertexBuffers.push(this._vertexBuffer1), vertexBuffers.push(this._vertexBuffer2), bufferState.bind(), bufferState.applyVertexBuffers(vertexBuffers), bufferState.unBind(), Laya.Resource._addMemory(memorySize, memorySize)
            }

            _resetData() {
                var count = this._endIndex - this._activeIndex,
                    oldVertices1 = new Float32Array(this._vertices1.buffer, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * count),
                    oldVertices2 = new Float32Array(this._vertices2.buffer, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * count),
                    oldSubDistance = new Float64Array(this._subDistance.buffer, 8 * this._activeIndex, count),
                    oldSubBirthTime = new Float32Array(this._subBirthTime.buffer, 4 * this._activeIndex, count);
                count === this._segementCount && (this._vertexBuffer1.destroy(), this._vertexBuffer2.destroy(), this._segementCount += this._increaseSegementCount, this._resizeData(this._segementCount, this._bufferState)), this._vertices1.set(oldVertices1, 0), this._vertices2.set(oldVertices2, 0), this._subDistance.set(oldSubDistance, 0), this._subBirthTime.set(oldSubBirthTime, 0), this._endIndex = count, this._activeIndex = 0, this._vertexBuffer1.setData(this._vertices1.buffer, 0, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * count * 4), this._vertexBuffer2.setData(this._vertices2.buffer, 0, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * count * 4)
            }

            _updateTrail(camera, lastPosition, position) {
                Vector3.equals(lastPosition, position) || (this._endIndex - this._activeIndex == 0 ? this._addTrailByFirstPosition(camera, position) : this._addTrailByNextPosition(camera, position))
            }

            _addTrailByFirstPosition(camera, position) {
                this._endIndex === this._segementCount && this._resetData(), this._subDistance[this._endIndex] = 0, this._subBirthTime[this._endIndex] = this._owner._curtime, this._endIndex++, position.cloneTo(this._lastFixedVertexPosition), this._needAddFirstVertex = !0
            }

            _addTrailByNextPosition(camera, position) {
                var cameraMatrix = camera.viewMatrix;
                Vector3.transformCoordinate(position, cameraMatrix, TrailGeometry._tempVector33);
                var delVector3 = TrailGeometry._tempVector30, pointAtoBVector3 = TrailGeometry._tempVector31;
                switch (Vector3.transformCoordinate(this._lastFixedVertexPosition, cameraMatrix, TrailGeometry._tempVector34), Vector3.subtract(TrailGeometry._tempVector33, TrailGeometry._tempVector34, delVector3), this._owner.alignment) {
                    case exports.TrailAlignment.View:
                        Vector3.cross(TrailGeometry._tempVector33, delVector3, pointAtoBVector3);
                        break;
                    case exports.TrailAlignment.TransformZ:
                        var forward = TrailGeometry._tempVector32;
                        this._owner._owner.transform.getForward(forward), Vector3.cross(delVector3, forward, pointAtoBVector3)
                }
                Vector3.normalize(pointAtoBVector3, pointAtoBVector3), Vector3.scale(pointAtoBVector3, this._owner.widthMultiplier / 2, pointAtoBVector3);
                var tempEndIndex, offset, delLength = Vector3.scalarLength(delVector3);
                this._needAddFirstVertex && (this._updateVerticesByPositionData(position, pointAtoBVector3, this._endIndex - 1), this._needAddFirstVertex = !1), delLength - this._owner.minVertexDistance >= MathUtils3D.zeroTolerance ? (this._isTempEndVertex ? (tempEndIndex = this._endIndex - 1, offset = delLength - this._subDistance[tempEndIndex], this._updateVerticesByPosition(position, pointAtoBVector3, delLength, tempEndIndex), this._owner._totalLength += offset) : (this._endIndex === this._segementCount && this._resetData(), this._updateVerticesByPosition(position, pointAtoBVector3, delLength, this._endIndex), this._owner._totalLength += delLength, this._endIndex++), position.cloneTo(this._lastFixedVertexPosition), this._isTempEndVertex = !1) : (this._isTempEndVertex ? (tempEndIndex = this._endIndex - 1, offset = delLength - this._subDistance[tempEndIndex], this._updateVerticesByPosition(position, pointAtoBVector3, delLength, tempEndIndex), this._owner._totalLength += offset) : (this._endIndex === this._segementCount && this._resetData(), this._updateVerticesByPosition(position, pointAtoBVector3, delLength, this._endIndex), this._owner._totalLength += delLength, this._endIndex++), this._isTempEndVertex = !0)
            }

            _updateVerticesByPositionData(position, pointAtoBVector3, index) {
                var vertexOffset = 2 * this._floatCountPerVertices1 * index, curtime = this._owner._curtime;
                this._vertices1[vertexOffset] = position.x, this._vertices1[vertexOffset + 1] = position.y, this._vertices1[vertexOffset + 2] = position.z, this._vertices1[vertexOffset + 3] = -pointAtoBVector3.x, this._vertices1[vertexOffset + 4] = -pointAtoBVector3.y, this._vertices1[vertexOffset + 5] = -pointAtoBVector3.z, this._vertices1[vertexOffset + 6] = curtime, this._vertices1[vertexOffset + 7] = 1, this._vertices1[vertexOffset + 8] = position.x, this._vertices1[vertexOffset + 9] = position.y, this._vertices1[vertexOffset + 10] = position.z, this._vertices1[vertexOffset + 11] = pointAtoBVector3.x, this._vertices1[vertexOffset + 12] = pointAtoBVector3.y, this._vertices1[vertexOffset + 13] = pointAtoBVector3.z, this._vertices1[vertexOffset + 14] = curtime, this._vertices1[vertexOffset + 15] = 0;
                var bounds = this._owner._owner.trailRenderer.bounds, min = bounds.getMin(), max = bounds.getMax(),
                    up = TrailGeometry._tempVector35, down = TrailGeometry._tempVector36,
                    out = TrailGeometry._tempVector32;
                Vector3.add(position, pointAtoBVector3, up), Vector3.subtract(position, pointAtoBVector3, down), Vector3.min(down, up, out), Vector3.min(min, out, min), bounds.setMin(min), Vector3.max(up, down, out), Vector3.max(max, out, max), bounds.setMax(max), Laya.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
                var floatCount = 2 * this._floatCountPerVertices1;
                this._vertexBuffer1.setData(this._vertices1.buffer, 4 * vertexOffset, 4 * vertexOffset, 4 * floatCount)
            }

            _updateVerticesByPosition(position, pointAtoBVector3, delDistance, index) {
                this._updateVerticesByPositionData(position, pointAtoBVector3, index), this._subDistance[index] = delDistance, this._subBirthTime[index] = this._owner._curtime
            }

            _updateVertexBufferUV() {
                var bounds, min, max;
                this._disappearBoundsMode && (min = (bounds = this._owner._owner.trailRenderer.bounds).getMin(), max = bounds.getMax(), min.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), max.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), Laya.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative());
                for (var vertexCount = this._endIndex, curLength = 0, gradient = this._owner.colorGradient, startAlphaIndex = gradient.colorAlphaKeysCount - 1, startColorIndex = gradient.colorRGBKeysCount - 1, totalLength = this._owner._totalLength, stride = 2 * this._floatCountPerVertices2, i = this._activeIndex; i < vertexCount; i++) {
                    var uvX, lerpFactor;
                    i !== this._activeIndex && (curLength += this._subDistance[i]), this._owner.textureMode == TextureMode.Stretch ? lerpFactor = uvX = 1 - curLength / totalLength : (lerpFactor = 1 - curLength / totalLength, uvX = 1 - (totalLength - curLength)), startColorIndex = gradient.evaluateColorRGB(lerpFactor, this.tmpColor, startColorIndex, !0), startAlphaIndex = gradient.evaluateColorAlpha(lerpFactor, this.tmpColor, startAlphaIndex, !0);
                    var index = i * stride;
                    if (this._vertices2[index + 0] = uvX, this._vertices2[index + 1] = this.tmpColor.r, this._vertices2[index + 2] = this.tmpColor.g, this._vertices2[index + 3] = this.tmpColor.b, this._vertices2[index + 4] = this.tmpColor.a, this._vertices2[index + 5] = uvX, this._vertices2[index + 6] = this.tmpColor.r, this._vertices2[index + 7] = this.tmpColor.g, this._vertices2[index + 8] = this.tmpColor.b, this._vertices2[index + 9] = this.tmpColor.a, this._disappearBoundsMode) {
                        var posOffset = 2 * this._floatCountPerVertices1 * i, pos = TrailGeometry._tempVector32,
                            up = TrailGeometry._tempVector33, side = TrailGeometry._tempVector34;
                        pos.setValue(this._vertices1[posOffset + 0], this._vertices1[posOffset + 1], this._vertices1[posOffset + 2]), up.setValue(this._vertices1[posOffset + 3], this._vertices1[posOffset + 4], this._vertices1[posOffset + 5]), Vector3.add(pos, up, side), Vector3.min(side, min, min), Vector3.max(side, max, max), Vector3.subtract(pos, up, side), Vector3.min(side, min, min), Vector3.max(side, max, max)
                    }
                }
                this._disappearBoundsMode && (bounds.setMin(min), bounds.setMax(max), this._disappearBoundsMode = !1, Laya.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative());
                var offset = this._activeIndex * stride;
                this._vertexBuffer2.setData(this._vertices2.buffer, 4 * offset, 4 * offset, 4 * (vertexCount * stride - offset))
            }

            _updateDisappear() {
                for (var count = this._endIndex, i = this._activeIndex; i < count && this._owner._curtime - this._subBirthTime[i] >= this._owner.time + MathUtils3D.zeroTolerance; i++) {
                    var nextIndex = i + 1;
                    if (nextIndex !== count && (this._owner._totalLength -= this._subDistance[nextIndex]), this._isTempEndVertex && nextIndex === count - 1) {
                        this._floatCountPerVertices1;
                        var fixedPos = this._lastFixedVertexPosition;
                        fixedPos.x = this._vertices1[0], fixedPos.y = this._vertices1[1], fixedPos.z = this._vertices1[2], this._isTempEndVertex = !1
                    }
                    this._activeIndex++, this._disappearBoundsMode = !0
                }
            }

            _getType() {
                return TrailGeometry._type
            }

            _prepareRender(state) {
                return this._endIndex - this._activeIndex > 1
            }

            _render(state) {
                this._bufferState.bind();
                var gl = Laya.LayaGL.instance, start = 2 * this._activeIndex, count = 2 * this._endIndex - start;
                gl.drawArrays(gl.TRIANGLE_STRIP, start, count), Laya.Stat.renderBatches++, Laya.Stat.trianglesFaces += count - 2
            }

            destroy() {
                super.destroy();
                var memorySize = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
                Laya.Resource._addMemory(-memorySize, -memorySize), this._bufferState.destroy(), this._vertexBuffer1.destroy(), this._vertexBuffer2.destroy(), this._bufferState = null, this._vertices1 = null, this._vertexBuffer1 = null, this._vertices2 = null, this._vertexBuffer2 = null, this._subBirthTime = null, this._subDistance = null, this._lastFixedVertexPosition = null, this._disappearBoundsMode = !1
            }

            _calculateBoundingBoxForNative() {
                var trail = this._owner._owner.trailRenderer, bounds = trail.bounds, min = bounds.getMin(),
                    max = bounds.getMax(), buffer = FrustumCulling._cullingBuffer;
                buffer[trail._cullingBufferIndex + 1] = min.x, buffer[trail._cullingBufferIndex + 2] = min.y, buffer[trail._cullingBufferIndex + 3] = min.z, buffer[trail._cullingBufferIndex + 4] = max.x, buffer[trail._cullingBufferIndex + 5] = max.y, buffer[trail._cullingBufferIndex + 6] = max.z
            }
        }

        TrailGeometry.ALIGNMENT_VIEW = 0, TrailGeometry.ALIGNMENT_TRANSFORM_Z = 1, TrailGeometry._tempVector30 = new Vector3, TrailGeometry._tempVector31 = new Vector3, TrailGeometry._tempVector32 = new Vector3, TrailGeometry._tempVector33 = new Vector3, TrailGeometry._tempVector34 = new Vector3, TrailGeometry._tempVector35 = new Vector3, TrailGeometry._tempVector36 = new Vector3, TrailGeometry._type = GeometryElement._typeCounter++;

        class TrailFilter {
            constructor(owner) {
                this._totalLength = 0, this._lastPosition = new Vector3, this._curtime = 0, this.alignment = TrailFilter.ALIGNMENT_VIEW, this._owner = owner, this._initDefaultData(), this.addRenderElement()
            }

            get time() {
                return this._time
            }

            set time(value) {
                this._time = value, this._owner._render._shaderValues.setNumber(TrailFilter.LIFETIME, value)
            }

            get minVertexDistance() {
                return this._minVertexDistance
            }

            set minVertexDistance(value) {
                this._minVertexDistance = value
            }

            get widthMultiplier() {
                return this._widthMultiplier
            }

            set widthMultiplier(value) {
                this._widthMultiplier = value
            }

            get widthCurve() {
                return this._widthCurve
            }

            set widthCurve(value) {
                this._widthCurve = value;
                var i, j, widthCurveFloatArray = new Float32Array(4 * value.length), index = 0;
                for (i = 0, j = value.length; i < j; i++) widthCurveFloatArray[index++] = value[i].time, widthCurveFloatArray[index++] = value[i].inTangent, widthCurveFloatArray[index++] = value[i].outTangent, widthCurveFloatArray[index++] = value[i].value;
                this._owner._render._shaderValues.setBuffer(TrailFilter.WIDTHCURVE, widthCurveFloatArray), this._owner._render._shaderValues.setInt(TrailFilter.WIDTHCURVEKEYLENGTH, value.length)
            }

            get colorGradient() {
                return this._colorGradient
            }

            set colorGradient(value) {
                this._colorGradient = value
            }

            get textureMode() {
                return this._textureMode
            }

            set textureMode(value) {
                this._textureMode = value
            }

            addRenderElement() {
                var render = this._owner._render, elements = render._renderElements,
                    material = render.sharedMaterials[0];
                material || (material = TrailMaterial.defaultMaterial);
                var element = new RenderElement;
                element.setTransform(this._owner._transform), element.render = render, element.material = material, this._trialGeometry = new TrailGeometry(this), element.setGeometry(this._trialGeometry), elements.push(element)
            }

            _update(state) {
                var render = this._owner._render;
                this._curtime += state.scene.timer._delta / 1e3, render._shaderValues.setNumber(TrailFilter.CURTIME, this._curtime);
                var curPos = this._owner.transform.position, element = render._renderElements[0]._geometry;
                element._updateDisappear(), element._updateTrail(state.camera, this._lastPosition, curPos), element._updateVertexBufferUV(), curPos.cloneTo(this._lastPosition)
            }

            _initDefaultData() {
                this.time = 5, this.minVertexDistance = .1, this.widthMultiplier = 1, this.textureMode = TextureMode.Stretch;
                var widthKeyFrames = [], widthKeyFrame1 = new FloatKeyframe;
                widthKeyFrame1.time = 0, widthKeyFrame1.inTangent = 0, widthKeyFrame1.outTangent = 0, widthKeyFrame1.value = 1, widthKeyFrames.push(widthKeyFrame1);
                var widthKeyFrame2 = new FloatKeyframe;
                widthKeyFrame2.time = 1, widthKeyFrame2.inTangent = 0, widthKeyFrame2.outTangent = 0, widthKeyFrame2.value = 1, widthKeyFrames.push(widthKeyFrame2), this.widthCurve = widthKeyFrames;
                var gradient = new Gradient(2, 2);
                gradient.mode = GradientMode.Blend, gradient.addColorRGB(0, Color.WHITE), gradient.addColorRGB(1, Color.WHITE), gradient.addColorAlpha(0, 1), gradient.addColorAlpha(1, 1), this.colorGradient = gradient
            }

            destroy() {
                this._trialGeometry.destroy(), this._trialGeometry = null, this._widthCurve = null, this._colorGradient = null
            }
        }

        TrailFilter.CURTIME = Shader3D.propertyNameToID("u_CurTime"), TrailFilter.LIFETIME = Shader3D.propertyNameToID("u_LifeTime"), TrailFilter.WIDTHCURVE = Shader3D.propertyNameToID("u_WidthCurve"), TrailFilter.WIDTHCURVEKEYLENGTH = Shader3D.propertyNameToID("u_WidthCurveKeyLength"), TrailFilter.ALIGNMENT_VIEW = 0, TrailFilter.ALIGNMENT_TRANSFORM_Z = 1;

        class TrailRenderer extends BaseRender {
            constructor(owner) {
                super(owner), this._projectionViewWorldMatrix = new Matrix4x4
            }

            _calculateBoundingBox() {
            }

            _needRender(boundFrustum, context) {
                return this._owner.trailFilter._update(context), !boundFrustum || boundFrustum.intersects(this.bounds._getBoundBox())
            }

            _updateForNative(context) {
                this._owner.trailFilter._update(context)
            }

            _renderUpdate(state, transform) {
                super._renderUpdate(state, transform)
            }

            _renderUpdateWithCamera(context, transform) {
                var projectionView = context.projectionViewMatrix;
                transform ? (Matrix4x4.multiply(projectionView, transform.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX, projectionView)
            }
        }

        class TrailSprite3D extends RenderableSprite3D {
            static __init__() {
                TrailSprite3D.shaderDefines = new ShaderDefines(RenderableSprite3D.shaderDefines)
            }

            get trailFilter() {
                return this._geometryFilter
            }

            get trailRenderer() {
                return this._render
            }

            constructor(name = null) {
                super(name), this._render = new TrailRenderer(this), this._geometryFilter = new TrailFilter(this)
            }

            _parse(data, spriteMap) {
                super._parse(data, spriteMap);
                var i, j, render = this._render, filter = this._geometryFilter, materials = data.materials;
                if (materials) {
                    var sharedMaterials = render.sharedMaterials, materialCount = materials.length;
                    for (sharedMaterials.length = materialCount, i = 0; i < materialCount; i++) sharedMaterials[i] = Laya.Loader.getRes(materials[i].path);
                    render.sharedMaterials = sharedMaterials
                }
                filter.time = data.time, filter.minVertexDistance = data.minVertexDistance, filter.widthMultiplier = data.widthMultiplier, filter.textureMode = data.textureMode, null != data.alignment && (filter.alignment = data.alignment);
                var widthCurve = [], widthCurveData = data.widthCurve;
                for (i = 0, j = widthCurveData.length; i < j; i++) {
                    var trailkeyframe = new FloatKeyframe;
                    trailkeyframe.time = widthCurveData[i].time, trailkeyframe.inTangent = widthCurveData[i].inTangent, trailkeyframe.outTangent = widthCurveData[i].outTangent, trailkeyframe.value = widthCurveData[i].value, widthCurve.push(trailkeyframe)
                }
                filter.widthCurve = widthCurve;
                var colorGradientData = data.colorGradient, colorKeys = colorGradientData.colorKeys,
                    alphaKeys = colorGradientData.alphaKeys,
                    colorGradient = new Gradient(colorKeys.length, alphaKeys.length);
                for (colorGradient.mode = colorGradientData.mode, i = 0, j = colorKeys.length; i < j; i++) {
                    var colorKey = colorKeys[i];
                    colorGradient.addColorRGB(colorKey.time, new Color(colorKey.value[0], colorKey.value[1], colorKey.value[2], 1))
                }
                for (i = 0, j = alphaKeys.length; i < j; i++) {
                    var alphaKey = alphaKeys[i];
                    colorGradient.addColorAlpha(alphaKey.time, alphaKey.value)
                }
                filter.colorGradient = colorGradient
            }

            _onActive() {
                super._onActive(), this._transform.position.cloneTo(this._geometryFilter._lastPosition)
            }

            _cloneTo(destObject, srcSprite, dstSprite) {
                var i, j;
                super._cloneTo(destObject, srcSprite, dstSprite);
                var destTrailSprite3D = destObject, destTrailFilter = destTrailSprite3D.trailFilter;
                destTrailFilter.time = this.trailFilter.time, destTrailFilter.minVertexDistance = this.trailFilter.minVertexDistance, destTrailFilter.widthMultiplier = this.trailFilter.widthMultiplier, destTrailFilter.textureMode = this.trailFilter.textureMode;
                var widthCurveData = this.trailFilter.widthCurve, widthCurve = [];
                for (i = 0, j = widthCurveData.length; i < j; i++) {
                    var keyFrame = new FloatKeyframe;
                    widthCurveData[i].cloneTo(keyFrame), widthCurve.push(keyFrame)
                }
                destTrailFilter.widthCurve = widthCurve;
                var destColorGradient = new Gradient(this.trailFilter.colorGradient.maxColorRGBKeysCount, this.trailFilter.colorGradient.maxColorAlphaKeysCount);
                this.trailFilter.colorGradient.cloneTo(destColorGradient), destTrailFilter.colorGradient = destColorGradient, destTrailSprite3D.trailRenderer.sharedMaterial = this.trailRenderer.sharedMaterial
            }

            destroy(destroyChild = !0) {
                this.destroyed || (super.destroy(destroyChild), this._geometryFilter.destroy(), this._geometryFilter = null)
            }

            _create() {
                return new TrailSprite3D
            }
        }

        class ShaderVariable {
            constructor() {
                this.textureID = -1
            }
        }

        class ShaderInstance extends Laya.Resource {
            constructor(vs, ps, attributeMap, uniformMap, shaderPass) {
                super(), this._stateParamsMap = [], this._uploadMark = -1, this._uploadRenderType = -1, this._vs = vs, this._ps = ps, this._attributeMap = attributeMap, this._uniformMap = uniformMap, this._shaderPass = shaderPass, this._create(), this.lock = !0
            }

            _create() {
                var gl = Laya.LayaGL.instance;
                for (var k in this._program = gl.createProgram(), this._vshader = this._createShader(gl, this._vs, gl.VERTEX_SHADER), this._pshader = this._createShader(gl, this._ps, gl.FRAGMENT_SHADER), gl.attachShader(this._program, this._vshader), gl.attachShader(this._program, this._pshader), this._attributeMap) gl.bindAttribLocation(this._program, this._attributeMap[k], k);
                if (gl.linkProgram(this._program), !Laya.Render.isConchApp && Shader3D.debugMode && !gl.getProgramParameter(this._program, gl.LINK_STATUS)) throw gl.getProgramInfoLog(this._program);
                var sceneParms = [], cameraParms = [], spriteParms = [], materialParms = [], customParms = [];
                this._customUniformParamsMap = [];
                var one, i, n, nUniformNum = gl.getProgramParameter(this._program, gl.ACTIVE_UNIFORMS);
                for (Laya.WebGLContext.useProgram(gl, this._program), this._curActTexIndex = 0, i = 0; i < nUniformNum; i++) {
                    var uniformData = gl.getActiveUniform(this._program, i), uniName = uniformData.name;
                    (one = new ShaderVariable).location = gl.getUniformLocation(this._program, uniName), uniName.indexOf("[0]") > 0 ? (one.name = uniName = uniName.substr(0, uniName.length - 3), one.isArray = !0) : (one.name = uniName, one.isArray = !1), one.type = uniformData.type, this._addShaderUnifiormFun(one);
                    var uniformPeriod = this._uniformMap[uniName];
                    if (null != uniformPeriod) switch (one.dataOffset = Shader3D.propertyNameToID(uniName), uniformPeriod) {
                        case Shader3D.PERIOD_CUSTOM:
                            customParms.push(one);
                            break;
                        case Shader3D.PERIOD_MATERIAL:
                            materialParms.push(one);
                            break;
                        case Shader3D.PERIOD_SPRITE:
                            spriteParms.push(one);
                            break;
                        case Shader3D.PERIOD_CAMERA:
                            cameraParms.push(one);
                            break;
                        case Shader3D.PERIOD_SCENE:
                            sceneParms.push(one);
                            break;
                        default:
                            throw new Error("Shader3D: period is unkonw.")
                    }
                }
                for (this._sceneUniformParamsMap = Laya.LayaGL.instance.createCommandEncoder(4 * sceneParms.length * 5 + 4, 64, !0), i = 0, n = sceneParms.length; i < n; i++) this._sceneUniformParamsMap.addShaderUniform(sceneParms[i]);
                for (this._cameraUniformParamsMap = Laya.LayaGL.instance.createCommandEncoder(4 * cameraParms.length * 5 + 4, 64, !0), i = 0, n = cameraParms.length; i < n; i++) this._cameraUniformParamsMap.addShaderUniform(cameraParms[i]);
                for (this._spriteUniformParamsMap = Laya.LayaGL.instance.createCommandEncoder(4 * spriteParms.length * 5 + 4, 64, !0), i = 0, n = spriteParms.length; i < n; i++) this._spriteUniformParamsMap.addShaderUniform(spriteParms[i]);
                for (this._materialUniformParamsMap = Laya.LayaGL.instance.createCommandEncoder(4 * materialParms.length * 5 + 4, 64, !0), i = 0, n = materialParms.length; i < n; i++) this._materialUniformParamsMap.addShaderUniform(materialParms[i]);
                for (this._customUniformParamsMap.length = customParms.length, i = 0, n = customParms.length; i < n; i++) {
                    var custom = customParms[i];
                    this._customUniformParamsMap[custom.dataOffset] = custom
                }
                var stateMap = this._shaderPass._stateMap;
                for (var s in stateMap) this._stateParamsMap[stateMap[s]] = Shader3D.propertyNameToID(s)
            }

            _getRenderState(shaderDatas, stateIndex) {
                var stateID = this._stateParamsMap[stateIndex];
                return null == stateID ? null : shaderDatas[stateID]
            }

            _disposeResource() {
                Laya.LayaGL.instance.deleteShader(this._vshader), Laya.LayaGL.instance.deleteShader(this._pshader), Laya.LayaGL.instance.deleteProgram(this._program), this._vshader = this._pshader = this._program = null, this._setGPUMemory(0), this._curActTexIndex = 0
            }

            _addShaderUnifiormFun(one) {
                var gl = Laya.LayaGL.instance;
                one.caller = this;
                var isArray = one.isArray;
                switch (one.type) {
                    case gl.BOOL:
                        one.fun = this._uniform1i, one.uploadedValue = new Array(1);
                        break;
                    case gl.INT:
                        one.fun = isArray ? this._uniform1iv : this._uniform1i, one.uploadedValue = new Array(1);
                        break;
                    case gl.FLOAT:
                        one.fun = isArray ? this._uniform1fv : this._uniform1f, one.uploadedValue = new Array(1);
                        break;
                    case gl.FLOAT_VEC2:
                        one.fun = isArray ? this._uniform_vec2v : this._uniform_vec2, one.uploadedValue = new Array(2);
                        break;
                    case gl.FLOAT_VEC3:
                        one.fun = isArray ? this._uniform_vec3v : this._uniform_vec3, one.uploadedValue = new Array(3);
                        break;
                    case gl.FLOAT_VEC4:
                        one.fun = isArray ? this._uniform_vec4v : this._uniform_vec4, one.uploadedValue = new Array(4);
                        break;
                    case gl.FLOAT_MAT2:
                        one.fun = this._uniformMatrix2fv;
                        break;
                    case gl.FLOAT_MAT3:
                        one.fun = this._uniformMatrix3fv;
                        break;
                    case gl.FLOAT_MAT4:
                        one.fun = isArray ? this._uniformMatrix4fv : this._uniformMatrix4f;
                        break;
                    case gl.SAMPLER_2D:
                        gl.uniform1i(one.location, this._curActTexIndex), one.textureID = Laya.WebGLContext._glTextureIDs[this._curActTexIndex++], one.fun = this._uniform_sampler2D;
                        break;
                    case 35679:
                        gl.uniform1i(one.location, this._curActTexIndex), one.textureID = Laya.WebGLContext._glTextureIDs[this._curActTexIndex++], one.fun = this._uniform_sampler3D;
                        break;
                    case gl.SAMPLER_CUBE:
                        gl.uniform1i(one.location, this._curActTexIndex), one.textureID = Laya.WebGLContext._glTextureIDs[this._curActTexIndex++], one.fun = this._uniform_samplerCube;
                        break;
                    default:
                        throw new Error("compile shader err!")
                }
            }

            _createShader(gl, str, type) {
                var shader = gl.createShader(type);
                if (gl.shaderSource(shader, str), gl.compileShader(shader), Shader3D.debugMode && !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(shader);
                return shader
            }

            _uniform1f(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value ? (Laya.LayaGL.instance.uniform1f(one.location, uploadedValue[0] = value), 1) : 0
            }

            _uniform1fv(one, value) {
                if (value.length < 4) {
                    var uploadedValue = one.uploadedValue;
                    return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3] ? (Laya.LayaGL.instance.uniform1fv(one.location, value), uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3], 1) : 0
                }
                return Laya.LayaGL.instance.uniform1fv(one.location, value), 1
            }

            _uniform_vec2(one, v) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== v.x || uploadedValue[1] !== v.y ? (Laya.LayaGL.instance.uniform2f(one.location, uploadedValue[0] = v.x, uploadedValue[1] = v.y), 1) : 0
            }

            _uniform_vec2v(one, value) {
                if (value.length < 2) {
                    var uploadedValue = one.uploadedValue;
                    return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3] ? (Laya.LayaGL.instance.uniform2fv(one.location, value), uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3], 1) : 0
                }
                return Laya.LayaGL.instance.uniform2fv(one.location, value), 1
            }

            _uniform_vec3(one, v) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== v.x || uploadedValue[1] !== v.y || uploadedValue[2] !== v.z ? (Laya.LayaGL.instance.uniform3f(one.location, uploadedValue[0] = v.x, uploadedValue[1] = v.y, uploadedValue[2] = v.z), 1) : 0
            }

            _uniform_vec3v(one, v) {
                return Laya.LayaGL.instance.uniform3fv(one.location, v), 1
            }

            _uniform_vec4(one, v) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== v.x || uploadedValue[1] !== v.y || uploadedValue[2] !== v.z || uploadedValue[3] !== v.w ? (Laya.LayaGL.instance.uniform4f(one.location, uploadedValue[0] = v.x, uploadedValue[1] = v.y, uploadedValue[2] = v.z, uploadedValue[3] = v.w), 1) : 0
            }

            _uniform_vec4v(one, v) {
                return Laya.LayaGL.instance.uniform4fv(one.location, v), 1
            }

            _uniformMatrix2fv(one, value) {
                return Laya.LayaGL.instance.uniformMatrix2fv(one.location, !1, value), 1
            }

            _uniformMatrix3fv(one, value) {
                return Laya.LayaGL.instance.uniformMatrix3fv(one.location, !1, value), 1
            }

            _uniformMatrix4f(one, m) {
                var value = m.elements;
                return Laya.LayaGL.instance.uniformMatrix4fv(one.location, !1, value), 1
            }

            _uniformMatrix4fv(one, m) {
                return Laya.LayaGL.instance.uniformMatrix4fv(one.location, !1, m), 1
            }

            _uniform1i(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value ? (Laya.LayaGL.instance.uniform1i(one.location, uploadedValue[0] = value), 1) : 0
            }

            _uniform1iv(one, value) {
                return Laya.LayaGL.instance.uniform1iv(one.location, value), 1
            }

            _uniform_ivec2(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] ? (Laya.LayaGL.instance.uniform2i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]), 1) : 0
            }

            _uniform_ivec2v(one, value) {
                return Laya.LayaGL.instance.uniform2iv(one.location, value), 1
            }

            _uniform_vec3i(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] ? (Laya.LayaGL.instance.uniform3i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]), 1) : 0
            }

            _uniform_vec3vi(one, value) {
                return Laya.LayaGL.instance.uniform3iv(one.location, value), 1
            }

            _uniform_vec4i(one, value) {
                var uploadedValue = one.uploadedValue;
                return uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3] ? (Laya.LayaGL.instance.uniform4i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]), 1) : 0
            }

            _uniform_vec4vi(one, value) {
                return Laya.LayaGL.instance.uniform4iv(one.location, value), 1
            }

            _uniform_sampler2D(one, texture) {
                var value = texture._getSource() || texture.defaulteTexture._getSource(), gl = Laya.LayaGL.instance;
                return Laya.WebGLContext.activeTexture(gl, one.textureID), Laya.WebGLContext.bindTexture(gl, gl.TEXTURE_2D, value), 0
            }

            _uniform_sampler3D(one, texture) {
                var value = texture._getSource() || texture.defaulteTexture._getSource(), gl = Laya.LayaGL.instance;
                return Laya.WebGLContext.activeTexture(gl, one.textureID), Laya.WebGLContext.bindTexture(gl, WebGL2RenderingContext.TEXTURE_3D, value), 0
            }

            _uniform_samplerCube(one, texture) {
                var value = texture._getSource() || texture.defaulteTexture._getSource(), gl = Laya.LayaGL.instance;
                return Laya.WebGLContext.activeTexture(gl, one.textureID), Laya.WebGLContext.bindTexture(gl, gl.TEXTURE_CUBE_MAP, value), 0
            }

            bind() {
                return Laya.WebGLContext.useProgram(Laya.LayaGL.instance, this._program)
            }

            uploadUniforms(shaderUniform, shaderDatas, uploadUnTexture) {
                Laya.Stat.shaderCall += Laya.LayaGLRunner.uploadShaderUniforms(Laya.LayaGL.instance, shaderUniform, shaderDatas, uploadUnTexture)
            }

            uploadRenderStateBlendDepth(shaderDatas) {
                var gl = Laya.LayaGL.instance, renderState = this._shaderPass.renderState,
                    datas = shaderDatas.getData(),
                    depthWrite = this._getRenderState(datas, Shader3D.RENDER_STATE_DEPTH_WRITE),
                    depthTest = this._getRenderState(datas, Shader3D.RENDER_STATE_DEPTH_TEST),
                    blend = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND);
                switch (null == depthWrite && (depthWrite = renderState.depthWrite), null == depthTest && (depthTest = renderState.depthTest), null == blend && (blend = renderState.blend), Laya.WebGLContext.setDepthMask(gl, depthWrite), depthTest === RenderState.DEPTHTEST_OFF ? Laya.WebGLContext.setDepthTest(gl, !1) : (Laya.WebGLContext.setDepthTest(gl, !0), Laya.WebGLContext.setDepthFunc(gl, depthTest)), blend) {
                    case RenderState.BLEND_DISABLE:
                        Laya.WebGLContext.setBlend(gl, !1);
                        break;
                    case RenderState.BLEND_ENABLE_ALL:
                        Laya.WebGLContext.setBlend(gl, !0);
                        var srcBlend = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_SRC);
                        null == srcBlend && (srcBlend = renderState.srcBlend);
                        var dstBlend = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_DST);
                        null == dstBlend && (dstBlend = renderState.dstBlend), Laya.WebGLContext.setBlendFunc(gl, srcBlend, dstBlend);
                        break;
                    case RenderState.BLEND_ENABLE_SEPERATE:
                        Laya.WebGLContext.setBlend(gl, !0);
                        var srcRGB = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_SRC_RGB);
                        null == srcRGB && (srcRGB = renderState.srcBlendRGB);
                        var dstRGB = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_DST_RGB);
                        null == dstRGB && (dstRGB = renderState.dstBlendRGB);
                        var srcAlpha = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_SRC_ALPHA);
                        null == srcAlpha && (srcAlpha = renderState.srcBlendAlpha);
                        var dstAlpha = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_DST_ALPHA);
                        null == dstAlpha && (dstAlpha = renderState.dstBlendAlpha), Laya.WebGLContext.setBlendFuncSeperate(gl, srcRGB, dstRGB, srcAlpha, dstAlpha)
                }
            }

            uploadRenderStateFrontFace(shaderDatas, isTarget, invertFront) {
                var forntFace, gl = Laya.LayaGL.instance, renderState = this._shaderPass.renderState,
                    datas = shaderDatas.getData(), cull = this._getRenderState(datas, Shader3D.RENDER_STATE_CULL);
                switch (null == cull && (cull = renderState.cull), cull) {
                    case RenderState.CULL_NONE:
                        Laya.WebGLContext.setCullFace(gl, !1);
                        break;
                    case RenderState.CULL_FRONT:
                        Laya.WebGLContext.setCullFace(gl, !0), forntFace = isTarget ? invertFront ? gl.CCW : gl.CW : invertFront ? gl.CW : gl.CCW, Laya.WebGLContext.setFrontFace(gl, forntFace);
                        break;
                    case RenderState.CULL_BACK:
                        Laya.WebGLContext.setCullFace(gl, !0), forntFace = isTarget ? invertFront ? gl.CW : gl.CCW : invertFront ? gl.CCW : gl.CW, Laya.WebGLContext.setFrontFace(gl, forntFace)
                }
            }

            uploadCustomUniform(index, data) {
                Laya.Stat.shaderCall += Laya.LayaGLRunner.uploadCustomUniform(Laya.LayaGL.instance, this._customUniformParamsMap, index, data)
            }

            _uniformMatrix2fvForNative(one, value) {
                return Laya.LayaGL.instance.uniformMatrix2fvEx(one.location, !1, value), 1
            }

            _uniformMatrix3fvForNative(one, value) {
                return Laya.LayaGL.instance.uniformMatrix3fvEx(one.location, !1, value), 1
            }

            _uniformMatrix4fvForNative(one, m) {
                return Laya.LayaGL.instance.uniformMatrix4fvEx(one.location, !1, m), 1
            }
        }

        class ShaderPass extends Laya.ShaderCompile {
            constructor(owner, vs, ps, stateMap) {
                super(vs, ps, null), this._renderState = new RenderState, this._owner = owner, this._cacheSharders = [], this._publicValidDefine = 0, this._spriteValidDefine = 0, this._materialValidDefine = 0;
                var publicDefineMap = this._owner._publicDefinesMap, spriteDefineMap = this._owner._spriteDefinesMap,
                    materialDefineMap = this._owner._materialDefinesMap;
                for (var k in this.defs) null != publicDefineMap[k] ? this._publicValidDefine |= publicDefineMap[k] : null != spriteDefineMap[k] ? this._spriteValidDefine |= spriteDefineMap[k] : null != materialDefineMap[k] && (this._materialValidDefine |= materialDefineMap[k]);
                this._stateMap = stateMap
            }

            get renderState() {
                return this._renderState
            }

            _definesToNameDic(value, int2Name) {
                for (var o = {}, d = 1, i = 0; i < 32 && !((d = 1 << i) > value); i++) {
                    value & d && (o[int2Name[d]] = "")
                }
                return o
            }

            _compileToTree(parent, lines, start, includefiles, defs) {
                var node, preNode, text, name, fname, ofs, words, noUseNode, i, n, j;
                for (i = start; i < lines.length; i++) if (!((text = lines[i]).length < 1) && 0 !== (ofs = text.indexOf("//"))) {
                    if (ofs >= 0 && (text = text.substr(0, ofs)), node = noUseNode || new Laya.ShaderNode(includefiles), noUseNode = null, node.text = text, (ofs = text.indexOf("#")) >= 0) {
                        for (name = "#", j = ofs + 1, n = text.length; j < n; j++) {
                            var c = text.charAt(j);
                            if (" " === c || "\t" === c || "?" === c) break;
                            name += c
                        }
                        switch (node.name = name, name) {
                            case"#ifdef":
                            case"#ifndef":
                                if (node.setParent(parent), parent = node, defs) for (words = text.substr(j).split(Laya.ShaderCompile._splitToWordExps3), j = 0; j < words.length; j++) (text = words[j]).length && (defs[text] = !0);
                                continue;
                            case"#if":
                            case"#elif":
                                if (node.setParent(parent), parent = node, defs) for (words = text.substr(j).split(Laya.ShaderCompile._splitToWordExps3), j = 0; j < words.length; j++) (text = words[j]).length && "defined" != text && (defs[text] = !0);
                                continue;
                            case"#else":
                                preNode = (parent = parent.parent).childs[parent.childs.length - 1], node.setParent(parent), parent = node;
                                continue;
                            case"#endif":
                                preNode = (parent = parent.parent).childs[parent.childs.length - 1], node.setParent(parent);
                                continue;
                            case"#include":
                                words = Laya.ShaderCompile.splitToWords(text, null);
                                var inlcudeFile = Laya.ShaderCompile.includes[words[1]];
                                if (!inlcudeFile) throw"ShaderCompile error no this include file:" + words[1];
                                if ((ofs = words[0].indexOf("?")) < 0) {
                                    node.setParent(parent), text = inlcudeFile.getWith("with" == words[2] ? words[3] : null), this._compileToTree(node, text.split("\n"), 0, includefiles, defs), node.text = "";
                                    continue
                                }
                                node.setCondition(words[0].substr(ofs + 1), Laya.ShaderCompile.IFDEF_YES), node.text = inlcudeFile.getWith("with" == words[2] ? words[3] : null);
                                break;
                            case"#import":
                                fname = (words = Laya.ShaderCompile.splitToWords(text, null))[1], includefiles.push({
                                    node: node,
                                    file: Laya.ShaderCompile.includes[fname],
                                    ofs: node.text.length
                                });
                                continue
                        }
                    } else {
                        if ((preNode = parent.childs[parent.childs.length - 1]) && !preNode.name) {
                            includefiles.length > 0 && Laya.ShaderCompile.splitToWords(text, preNode), noUseNode = node, preNode.text += "\n" + text;
                            continue
                        }
                        includefiles.length > 0 && Laya.ShaderCompile.splitToWords(text, node)
                    }
                    node.setParent(parent)
                }
            }

            withCompile(publicDefine, spriteDefine, materialDefine) {
                var shader, spriteDefShaders, materialDefShaders;
                if (publicDefine &= this._publicValidDefine, spriteDefine &= this._spriteValidDefine, materialDefine &= this._materialValidDefine, spriteDefShaders = this._cacheSharders[publicDefine]) if (materialDefShaders = spriteDefShaders[spriteDefine]) {
                    if (shader = materialDefShaders[materialDefine]) return shader
                } else materialDefShaders = spriteDefShaders[spriteDefine] = []; else materialDefShaders = (spriteDefShaders = this._cacheSharders[publicDefine] = [])[spriteDefine] = [];
                var key, publicDefGroup = this._definesToNameDic(publicDefine, this._owner._publicDefines),
                    spriteDefGroup = this._definesToNameDic(spriteDefine, this._owner._spriteDefines),
                    materialDefGroup = this._definesToNameDic(materialDefine, this._owner._materialDefines);
                if (Shader3D.debugMode) {
                    var publicDefGroupStr = "";
                    for (key in publicDefGroup) publicDefGroupStr += key + " ";
                    var spriteDefGroupStr = "";
                    for (key in spriteDefGroup) spriteDefGroupStr += key + " ";
                    var materialDefGroupStr = "";
                    for (key in materialDefGroup) materialDefGroupStr += key + " ";
                    Laya.WebGL.shaderHighPrecision || (publicDefine += Shader3D.SHADERDEFINE_HIGHPRECISION), console.log("%cShader3DDebugMode---(Name:" + this._owner._owner._name + " SubShaderIndex:" + this._owner._owner._subShaders.indexOf(this._owner) + " PassIndex:" + this._owner._passes.indexOf(this) + " PublicDefine:" + publicDefine + " SpriteDefine:" + spriteDefine + " MaterialDefine:" + materialDefine + " PublicDefineGroup:" + publicDefGroupStr + " SpriteDefineGroup:" + spriteDefGroupStr + "MaterialDefineGroup: " + materialDefGroupStr + ")---ShaderCompile3DDebugMode", "color:green")
                }
                var defMap = {}, defineStr = "";
                if (publicDefGroup) for (key in publicDefGroup) defineStr += "#define " + key + "\n", defMap[key] = !0;
                if (spriteDefGroup) for (key in spriteDefGroup) defineStr += "#define " + key + "\n", defMap[key] = !0;
                if (materialDefGroup) for (key in materialDefGroup) defineStr += "#define " + key + "\n", defMap[key] = !0;
                var vs = this._VS.toscript(defMap, []), vsVersion = "";
                0 == vs[0].indexOf("#version") && (vsVersion = vs[0] + "\n", vs.shift());
                var ps = this._PS.toscript(defMap, []), psVersion = "";
                return 0 == ps[0].indexOf("#version") && (psVersion = ps[0] + "\n", ps.shift()), shader = new ShaderInstance(vsVersion + defineStr + vs.join("\n"), psVersion + defineStr + ps.join("\n"), this._owner._attributeMap || this._owner._owner._attributeMap, this._owner._uniformMap || this._owner._owner._uniformMap, this), materialDefShaders[materialDefine] = shader, shader
            }
        }

        class SubShader {
            constructor(attributeMap, uniformMap, spriteDefines = null, materialDefines = null) {
                this._flags = {}, this._passes = [], this._publicDefines = [], this._publicDefinesMap = {}, this._spriteDefines = [], this._spriteDefinesMap = {}, this._materialDefines = [], this._materialDefinesMap = {}, this._addDefines(this._publicDefines, this._publicDefinesMap, Shader3D._globleDefines), spriteDefines && this._addDefines(this._spriteDefines, this._spriteDefinesMap, spriteDefines.defines), materialDefines && this._addDefines(this._materialDefines, this._materialDefinesMap, materialDefines.defines), this._attributeMap = attributeMap, this._uniformMap = uniformMap
            }

            _addDefines(defines, definesMap, supportDefines) {
                for (var k in supportDefines) {
                    var name = supportDefines[k], i = parseInt(k);
                    defines[i] = name, definesMap[name] = i
                }
            }

            getMaterialDefineByName(name) {
                return this._materialDefinesMap[name]
            }

            setFlag(key, value) {
                value ? this._flags[key] = value : delete this._flags[key]
            }

            getFlag(key) {
                return this._flags[key]
            }

            addShaderPass(vs, ps, stateMap = null) {
                var shaderPass = new ShaderPass(this, vs, ps, stateMap);
                return this._passes.push(shaderPass), shaderPass
            }
        }

        var BlitScreenPS = "#ifdef FSHIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTex;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_FragColor = texture2D(u_MainTex, v_Texcoord0);\r\n}\r\n\r\n",
            BlitScreenVS = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
            EffectPS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  2.0 * u_AlbedoColor;\r\n\t#ifdef COLOR\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t#ifdef MAINTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\n",
            EffectVS = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec4 a_Color;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\t\t\r\n\t#ifdef COLOR\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
            extendTerrainPS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_Normal;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tuniform DirectionLight u_DirectionLight;\r\n#endif\r\n\r\n#ifdef POINTLIGHT\r\n\tuniform PointLight u_PointLight;\r\n#endif\r\n\r\n#ifdef SPOTLIGHT\r\n\tuniform SpotLight u_SpotLight;\r\n#endif\r\n\r\n#include "ShadowHelper.glsl"\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\nvarying float v_posViewZ;\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\nuniform sampler2D u_SplatAlphaTexture;\r\n\r\nuniform sampler2D u_DiffuseTexture1;\r\nuniform sampler2D u_DiffuseTexture2;\r\nuniform sampler2D u_DiffuseTexture3;\r\nuniform sampler2D u_DiffuseTexture4;\r\nuniform sampler2D u_DiffuseTexture5;\r\n\r\nuniform vec4 u_DiffuseScaleOffset1;\r\nuniform vec4 u_DiffuseScaleOffset2;\r\nuniform vec4 u_DiffuseScaleOffset3;\r\nuniform vec4 u_DiffuseScaleOffset4;\r\nuniform vec4 u_DiffuseScaleOffset5;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform sampler2D u_LightMap;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 splatAlpha = vec4(1.0);\r\n\t#ifdef ExtendTerrain_DETAIL_NUM1\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r;\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM2\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM3\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM4\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM5\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tvec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\r\n\t#endif\r\n\t\tgl_FragColor.w = splatAlpha.a;\r\n\t\t\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n    vec3 normal = v_Normal;\r\n\tvec3 dif, spe;\r\n#endif\r\n\r\nvec3 diffuse = vec3(0.0);\r\nvec3 specular= vec3(0.0);\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\tvec3 toEye;\r\n\t#ifdef FOG\r\n\t\ttoEye=u_CameraPos-v_PositionWorld;\r\n\t\tfloat toEyeLength=length(toEye);\r\n\t\ttoEye/=toEyeLength;\r\n\t#else\r\n\t\ttoEye=normalize(u_CameraPos-v_PositionWorld);\r\n\t#endif\r\n#endif\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tLayaAirBlinnPhongDiectionLight(vec3(0.0), 1.0, normal, vec3(1.0), toEye,u_DirectionLight, dif, spe);\r\n\tdiffuse+=dif;\r\n\tspecular+=spe;\r\n#endif\r\n \r\n#ifdef POINTLIGHT\r\n\tLayaAirBlinnPhongPointLight(v_PositionWorld, vec3(0.0), 1.0, normal, vec3(1.0), toEye, u_PointLight, dif, spe);\r\n\tdiffuse+=dif;\r\n\tspecular+=spe;\r\n#endif\r\n\r\n#ifdef SPOTLIGHT\r\n\tLayaAirBlinnPhongSpotLight(v_PositionWorld, vec3(0.0), 1.0, normal, vec3(1.0), toEye, u_SpotLight, dif, spe);\r\n\tdiffuse+=dif;\r\n\tspecular+=spe;\r\n#endif\r\n\r\nvec3 globalDiffuse = u_AmbientColor;\r\n#ifdef LIGHTMAP\r\n\tglobalDiffuse += DecodeLightmap(texture2D(u_LightMap, v_LightMapUV));\r\n#endif\r\n\r\n#ifdef RECEIVESHADOW\r\n\tfloat shadowValue = 1.0;\r\n\t#ifdef SHADOWMAP_PSSM3\r\n\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM2\r\n\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t#endif \r\n\t#ifdef SHADOWMAP_PSSM1\r\n\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t#endif\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse) * shadowValue, gl_FragColor.a);\r\n#else\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse), gl_FragColor.a);\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef RECEIVESHADOW\r\n\t\tgl_FragColor.rgb += specular * shadowValue;\r\n\t#else\r\n\t\tgl_FragColor.rgb += specular;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FOG\r\n\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\r\n\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n#endif\r\n}\r\n\r\n\r\n\r\n\r\n\r\n',
            extendTerrainVS = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec2 a_Texcoord0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\r\n\tattribute vec3 a_Normal;\r\n\tvarying vec3 v_Normal;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\r\n\tuniform mat4 u_WorldMat;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n#endif\r\n\r\n#ifdef RECEIVESHADOW\r\n\tvarying float v_posViewZ;\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n  \r\n\tv_Texcoord0 = a_Texcoord0;\r\n  \r\n\t#ifdef LIGHTMAP\r\n\t\tv_LightMapUV = vec2(a_Texcoord0.x, 1.0 - a_Texcoord0.y) * u_LightmapScaleOffset.xy + u_LightmapScaleOffset.zw;\r\n\t\tv_LightMapUV.y = 1.0 - v_LightMapUV.y;\r\n\t#endif\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_Normal = a_Normal;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\r\n\t\tv_PositionWorld=(u_WorldMat*a_Position).xyz;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
            LightingGLSL = "\r\nstruct DirectionLight {\r\n\tvec3 Color;\r\n\tvec3 Direction;\r\n};\r\n\r\nstruct PointLight {\r\n\tvec3 Color;\r\n\tvec3 Position;\r\n\tfloat Range;\r\n};\r\n\r\nstruct SpotLight {\r\n\tvec3 Color;\r\n\tvec3 Position;\r\n\tvec3 Direction;\r\n\tfloat Spot;\r\n\tfloat Range;\r\n};\r\n\r\n// Laya中使用衰减纹理\r\nfloat LayaAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\r\n\tfRatio *= fRatio;\r\n\treturn 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\r\n}\r\n\r\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\r\nfloat BasicAttenuation(in vec3 L,in float invLightRadius) {\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius));\r\n\treturn attenuation * attenuation;\r\n}\r\n\r\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread\r\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat attenuationFactor = 30.0;\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\r\n\tattenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\r\n\t// Second we move down the function therewith it reaches zero at abscissa 1:\r\n\tattenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\r\n\tattenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\r\n\t// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\r\n\tattenuation /= 1.0 - attenuationFactor;\r\n\treturn attenuation;\r\n}\r\n\r\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tmediump vec3 h = normalize(viewDir-lightVec);\r\n\tlowp float ln = max (0.0, dot (-lightVec,normal));\r\n\tfloat nh = max (0.0, dot (h,normal));\r\n\tdiffuseColor=lightColor * ln;\r\n\tspecularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\r\n}\r\n\r\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec=normalize(light.Direction);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec,diffuseColor,specularColor);\r\n}\r\n\r\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.Position;\r\n\t//if( length(lightVec) > light.Range )\r\n\t//\treturn;\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec/length(lightVec),diffuseColor,specularColor);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range);\r\n\tdiffuseColor *= attenuate;\r\n\tspecularColor*= attenuate;\r\n}\r\n\r\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.Position;\r\n\t//if( length(lightVec) > light.Range)\r\n\t//\treturn;\r\n\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,normalLightVec,diffuseColor,specularColor);\r\n\tvec2 cosAngles=cos(vec2(light.Spot,light.Spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.Direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range)*dl;\r\n\tdiffuseColor *=attenuate;\r\n\tspecularColor *=attenuate;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal) {\r\n\tvec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\r\n\r\n\t// Build orthonormal basis.\r\n\tvec3 N = normalize(unitNormal);\r\n\tvec3 T = normalize(tangent);\r\n\tvec3 B = normalize(binormal);\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal = TBN*normalT;\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace1(vec4 normalMapSample, vec3 tangent, vec3 binormal, vec3 unitNormal) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 T = normalize(tangent);\r\n\tvec3 B = normalize(binormal);\r\n\tvec3 N = normalize(unitNormal);\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal = TBN * normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 DecodeLightmap(vec4 color) {\r\n\treturn color.rgb*color.a*5.0;\r\n}\r\n\r\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\r\n\tvec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\r\n\ttransTexcoord.y+=1.0;\r\n\treturn transTexcoord;\r\n}\r\n\r\nvec4 remapGLPositionZ(vec4 position) {\r\n\tposition.z=position.z * 2.0 - position.w;\r\n\treturn position;\r\n}\r\n\r\nmat3 inverse(mat3 m) {\r\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\r\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\r\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\r\n\r\n  float b01 = a22 * a11 - a12 * a21;\r\n  float b11 = -a22 * a10 + a12 * a20;\r\n  float b21 = a21 * a10 - a11 * a20;\r\n\r\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\r\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\r\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n}\r\n\r\n",
            linePS = "#ifdef HIGHPRECISION\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nuniform vec4 u_Color;\r\n\r\nvoid main()\r\n{\r\n  gl_FragColor = v_Color * u_Color; \r\n}\r\n\r\n",
            lineVS = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_MvpMatrix;\r\nuniform vec4 u_Color;\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n\tv_Color=a_Color*u_Color;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
            MeshBlinnPhongPS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nuniform vec4 u_DiffuseColor;\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tvarying vec3 v_ViewDir; \r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef DIFFUSEMAP\r\n\tuniform sampler2D u_DiffuseTexture;\r\n#endif\r\n\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tuniform vec3 u_MaterialSpecular;\r\n\tuniform float u_Shininess;\r\n\t#ifdef SPECULARMAP \r\n\t\tuniform sampler2D u_SpecularTexture;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tvarying vec3 v_Normal;\r\n#endif\r\n\r\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\r\n\tuniform sampler2D u_NormalTexture;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tuniform DirectionLight u_DirectionLight;\r\n#endif\r\n\r\n#ifdef POINTLIGHT\r\n\tuniform PointLight u_PointLight;\r\n#endif\r\n\r\n#ifdef SPOTLIGHT\r\n\tuniform SpotLight u_SpotLight;\r\n#endif\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\n\r\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#include "ShadowHelper.glsl"\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\t//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}\r\nvoid main_normal()\r\n{\r\n\tvec3 globalDiffuse=u_AmbientColor;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tglobalDiffuse += DecodeLightmap(texture2D(u_LightMap, v_LightMapUV));\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 normal;\r\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\r\n\t\t\tvec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\r\n\t\t\tnormal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\r\n\t\t#else\r\n\t\t\tnormal = normalize(v_Normal);\r\n\t\t#endif\r\n\t\tvec3 viewDir= normalize(v_ViewDir);\r\n\t#endif\r\n\t\r\n\tvec4 mainColor=u_DiffuseColor;\r\n\t#ifdef DIFFUSEMAP\r\n\t\tvec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\r\n\t\tmainColor=mainColor*difTexColor;\r\n\t#endif \r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tmainColor=mainColor*v_Color;\r\n\t#endif \r\n    \r\n\t#ifdef ALPHATEST\r\n\t\tif(mainColor.a<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n  \r\n\t\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 dif,spe;\r\n\t\t#ifdef SPECULARMAP\r\n\t\t\tvec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\r\n\t\t#else\r\n\t\t\t#ifdef DIFFUSEMAP\r\n\t\t\t\tvec3 gloss=vec3(difTexColor.a);\r\n\t\t\t#else\r\n\t\t\t\tvec3 gloss=vec3(1.0);\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t\r\n\t#ifdef DIRECTIONLIGHT\r\n\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\r\n\t\tdiffuse+=dif;\r\n\t\tspecular+=spe;\r\n\t#endif\r\n \r\n\t#ifdef POINTLIGHT\r\n\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\r\n\t\tdiffuse+=dif;\r\n\t\tspecular+=spe;\r\n\t#endif\r\n\r\n\t#ifdef SPOTLIGHT\r\n\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\r\n\t\tdiffuse+=dif;\r\n\t\tspecular+=spe;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tfloat shadowValue = 1.0;\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3(u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2(u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1(u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse*shadowValue),mainColor.a);\r\n\t#else\r\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse),mainColor.a);\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t#ifdef RECEIVESHADOW\r\n\t\t\tgl_FragColor.rgb+=specular*shadowValue;\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb+=specular;\r\n\t\t#endif\r\n\t#endif\r\n\t  \r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif  \r\n}\r\n\r\n',
            MeshBlinnPhongVS = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tattribute vec4 a_Color;\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tattribute vec3 a_Normal;\r\n\tvarying vec3 v_Normal; \r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_ViewDir; \r\n#endif\r\n\r\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t#ifdef GPU_INSTANCE\r\n\t\tattribute mat4 a_WorldMat;\r\n\t#else\r\n\t\tuniform mat4 u_WorldMat;\r\n\t#endif\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n  #ifdef SHADOWMAP_PSSM1 \r\n  varying vec4 v_lightMVPPos;\r\n  uniform mat4 u_lightShadowVP[4];\r\n  #endif\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}\r\n\r\nvoid main_normal()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t\tmat4 worldMat;\r\n\t\t#ifdef GPU_INSTANCE\r\n\t\t\tworldMat = a_WorldMat;\r\n\t\t#else\r\n\t\t\tworldMat = u_WorldMat;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tmat3 worldInvMat;\r\n\t\t#ifdef BONE\r\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\r\n\t\t#else\r\n\t\t\tworldInvMat=inverse(mat3(worldMat));\r\n\t\t#endif  \r\n\t\tv_Normal=a_Normal*worldInvMat;\r\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\r\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\r\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t\tv_PositionWorld=(worldMat*position).xyz;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\r\n\t#endif\r\n\r\n\t#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\t#ifdef SCALEOFFSETLIGHTINGMAPUV\r\n\t\t\t#ifdef UV1\r\n\t\t\t\tv_LightMapUV=vec2(a_Texcoord1.x,1.0-a_Texcoord1.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t\t#else\r\n\t\t\t\tv_LightMapUV=vec2(a_Texcoord0.x,1.0-a_Texcoord0.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t\t#endif \r\n\t\t\tv_LightMapUV.y=1.0-v_LightMapUV.y;\r\n\t\t#else\r\n\t\t\t#ifdef UV1\r\n\t\t\t\tv_LightMapUV=a_Texcoord1;\r\n\t\t\t#else\r\n\t\t\t\tv_LightMapUV=a_Texcoord0;\r\n\t\t\t#endif \r\n\t\t#endif \r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color=a_Color;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif\r\n}',
            ParticleShuriKenPS = "#ifdef HIGHPRECISION\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\nvarying float v_Discard;\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\nuniform sampler2D u_texture;\r\nuniform vec4 u_Tintcolor;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\n#ifdef FOG\r\n\t//varying vec3 v_PositionWorld;\r\n\t//uniform vec3 u_CameraPos;\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_MeshColor;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\t\t\r\n\t#ifdef DIFFUSEMAP\r\n\t\tif(v_Discard!=0.0)\r\n\t\t\tdiscard;\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=v_Color;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\t//vec3 toEye=u_CameraPos-v_PositionWorld;\r\n\t\t//float toEyeLength=length(toEye);\r\n\t\t//toEye/=toEyeLength;\r\n\t\t\r\n\t\t//float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\t//gl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\r\n\t\t#else\r\n\t\t\t//gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}",
            ParticleShuriKenVS = '#include "Lighting.glsl";\r\n\r\n#ifdef HIGHPRECISION\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec4 a_CornerTextureCoordinate;\r\n#endif\r\n#ifdef RENDERMODE_MESH\r\n\tattribute vec3 a_MeshPosition;\r\n\tattribute vec4 a_MeshColor;\r\n\tattribute vec2 a_MeshTextureCoordinate;\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\nattribute vec4 a_ShapePositionStartLifeTime;\r\nattribute vec4 a_DirectionTime;\r\nattribute vec4 a_StartColor;\r\nattribute vec3 a_StartSize;\r\nattribute vec3 a_StartRotation0;\r\nattribute float a_StartSpeed;\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n  attribute vec4 a_Random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  attribute vec4 a_Random1;\r\n#endif\r\nattribute vec3 a_SimulationWorldPostion;\r\nattribute vec4 a_SimulationWorldRotation;\r\n\r\nvarying float v_Discard;\r\nvarying vec4 v_Color;\r\n#ifdef DIFFUSEMAP\r\n\tvarying vec2 v_TextureCoordinate;\r\n#endif\r\n\r\nuniform float u_CurrentTime;\r\nuniform vec3 u_Gravity;\r\n\r\nuniform vec3 u_WorldPosition;\r\nuniform vec4 u_WorldRotation;\r\nuniform bool u_ThreeDStartRotation;\r\nuniform int u_ScalingMode;\r\nuniform vec3 u_PositionScale;\r\nuniform vec3 u_SizeScale;\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\n#ifdef STRETCHEDBILLBOARD\r\n\tuniform vec3 u_CameraPos;\r\n#endif\r\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\r\nuniform vec3 u_CameraUp;\r\n\r\nuniform  float u_StretchedBillboardLengthScale;\r\nuniform  float u_StretchedBillboardSpeedScale;\r\nuniform int u_SimulationSpace;\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  int  u_VOLSpaceType;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\r\n  uniform  vec3 u_VOLVelocityConst;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n  uniform  vec3 u_VOLVelocityConstMax;\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\r\n#endif\r\n\r\n#ifdef COLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n#ifdef RANDOMCOLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n\r\n\r\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\r\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\r\n#endif\r\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\r\n#endif\r\n\r\n\r\n#ifdef ROTATIONOVERLIFETIME\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  float u_ROLAngularVelocityConst;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  float u_ROLAngularVelocityConstMax;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\r\n  #endif\r\n#endif\r\n#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\r\n\tuniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\r\n  #endif\r\n#endif\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\n  uniform  float u_TSACycles;\r\n  uniform  vec2 u_TSASubUVLength;\r\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\r\n#endif\r\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\r\n#endif\r\n\r\n#ifdef FOG\r\n\t//varying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\r\n{\r\n\tfloat halfRoll = rot.z * 0.5;\r\n    float halfPitch = rot.x * 0.5;\r\n\tfloat halfYaw = rot.y * 0.5;\r\n\r\n\tfloat sinRoll = sin(halfRoll);\r\n\tfloat cosRoll = cos(halfRoll);\r\n\tfloat sinPitch = sin(halfPitch);\r\n\tfloat cosPitch = cos(halfPitch);\r\n\tfloat sinYaw = sin(halfYaw);\r\n\tfloat cosYaw = cos(halfYaw);\r\n\r\n\tfloat quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n\tfloat quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n\tfloat quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n\tfloat quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\n//假定axis已经归一化\r\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\r\n{\r\n\tfloat halfAngle = angle * 0.5;\r\n\tfloat sin = sin(halfAngle);\r\n\t\r\n\tfloat quaX = axis.x * sin;\r\n\tfloat quaY = axis.y * sin;\r\n\tfloat quaZ = axis.z * sin;\r\n\tfloat quaW = cos(halfAngle);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \r\n{\r\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\r\n\r\n \r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat curValue;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\tcurValue=mix(lastGradientNumber.y,gradientNumber.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn curValue;\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat totalValue=0.0;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\tfloat lastValue=lastGradientNumber.y;\r\n\t\t\r\n\t\tif(key>=normalizedAge){\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\ttotalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse{\r\n\t\t\ttotalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\r\n\t\t}\r\n\t}\r\n\treturn totalValue;\r\n}\r\n#endif\r\n\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\r\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\r\n{\r\n\tvec4 overTimeColor;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientAlpha=gradientAlphas[i];\r\n\t\tfloat alphaKey=gradientAlpha.x;\r\n\t\tif(alphaKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientAlpha=gradientAlphas[i-1];\r\n\t\t\tfloat lastAlphaKey=lastGradientAlpha.x;\r\n\t\t\tfloat age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\r\n\t\t\toverTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec4 gradientColor=gradientColors[i];\r\n\t\tfloat colorKey=gradientColor.x;\r\n\t\tif(colorKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec4 lastGradientColor=gradientColors[i-1];\r\n\t\t\tfloat lastColorKey=lastGradientColor.x;\r\n\t\t\tfloat age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\r\n\t\t\toverTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn overTimeColor;\r\n}\r\n#endif\r\n\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\r\n{\r\n\tfloat overTimeFrame;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientFrame=gradientFrames[i];\r\n\t\tfloat key=gradientFrame.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientFrame=gradientFrames[i-1];\r\n\t\t\tfloat lastKey=lastGradientFrame.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\toverTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn floor(overTimeFrame);\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\nvec3 computeParticleLifeVelocity(in float normalizedAge)\r\n{\r\n  vec3 outLifeVelocity;\r\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t outLifeVelocity=u_VOLVelocityConst; \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMECURVE\r\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\r\n\t                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\r\n\t\t\t\t\t mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n  #endif\r\n\t\t\t\t\t\r\n  return outLifeVelocity;\r\n} \r\n#endif\r\n\r\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\r\n{\r\n   vec3 startPosition;\r\n   vec3 lifePosition;\r\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t#ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMECURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n\t#endif\r\n\t\r\n\tvec3 finalPosition;\r\n\tif(u_VOLSpaceType==0){\r\n\t  if(u_ScalingMode!=2)\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\r\n\t  else\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\r\n\t}\r\n\telse{\r\n\t  if(u_ScalingMode!=2)\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\r\n\t  else\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\r\n\t}\r\n  #else\r\n\t startPosition=startVelocity*age;\r\n\t vec3 finalPosition;\r\n\t if(u_ScalingMode!=2)\r\n\t\t\tfinalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\r\n\t else\r\n\t   \tfinalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\r\n  #endif\r\n  \r\n  if(u_SimulationSpace==0)\r\n    finalPosition=finalPosition+a_SimulationWorldPostion;\r\n  else if(u_SimulationSpace==1) \r\n    finalPosition=finalPosition+u_WorldPosition;\r\n  \r\n  finalPosition+=0.5*gravityVelocity*age;\r\n \r\n  return  finalPosition;\r\n}\r\n\r\n\r\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\r\n{\r\n\t#ifdef COLOROVERLIFETIME\r\n\t  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\r\n\t#endif\r\n\t\r\n\t#ifdef RANDOMCOLOROVERLIFETIME\r\n\t  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\r\n\t#endif\r\n\r\n    return color;\r\n}\r\n\r\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n\r\n#ifdef RENDERMODE_MESH\r\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\r\n\t\t,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n#endif\r\n\r\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n\r\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\r\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tvec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tvec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n#endif\r\n\r\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\r\n{ \r\n\t#ifdef TEXTURESHEETANIMATIONCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\t#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\r\n\t    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\treturn uv;\r\n}\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_CurrentTime - a_DirectionTime.w;\r\n\tfloat normalizedAge = age/a_ShapePositionStartLifeTime.w;\r\n\tvec3 lifeVelocity;\r\n\tif(normalizedAge<1.0){ \r\n\tvec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\r\n\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\tlifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\r\n\t#endif \r\n\tvec3 gravityVelocity=u_Gravity*age;\r\n\t\r\n\tvec4 worldRotation;\r\n\tif(u_SimulationSpace==0)\r\n\t\tworldRotation=a_SimulationWorldRotation;\r\n\telse\r\n\t\tworldRotation=u_WorldRotation;\r\n\t\r\n\tvec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\r\n   \r\n   \r\n   #ifdef SPHERHBILLBOARD\r\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n        vec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\r\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n        vec3 upVector = normalize(cross(sideVector,u_CameraDirection));\r\n\t    corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\r\n\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\tfloat c = cos(rot);\r\n\t\t\t\tfloat s = sin(rot);\r\n\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t}\r\n\t\t#else\r\n\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tfloat c = cos(a_StartRotation0.x);\r\n\t\t\t\tfloat s = sin(a_StartRotation0.x);\r\n\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t}\r\n\t\t#endif\r\n   #endif\r\n   \r\n   #ifdef STRETCHEDBILLBOARD\r\n\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\tvec3 velocity;\r\n\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t    if(u_VOLSpaceType==0)\r\n\t\t  velocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\r\n\t    else\r\n\t\t  velocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\r\n    #else\r\n\t    velocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\r\n    #endif\t\r\n\t\tvec3 cameraUpVector = normalize(velocity);\r\n\t\tvec3 direction = normalize(center-u_CameraPos);\r\n        vec3 sideVector = normalize(cross(direction,normalize(velocity)));\r\n\t\t\r\n\t\tsideVector=u_SizeScale.xzy*sideVector;\r\n\t\tcameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\r\n\t\t\r\n\t    vec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\r\n\t    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\r\n\t    corner=rotaionZHalfPI*corner;\r\n\t    corner.y=corner.y-abs(corner.y);\r\n\t\t\r\n\t    float speed=length(velocity);//TODO:\r\n\t    center +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\r\n   #endif\r\n   \r\n   #ifdef HORIZONTALBILLBOARD\r\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n        const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\r\n\t    const vec3 sideVector = vec3(-1.0,0.0,0.0);\r\n\t\t\r\n\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n        float c = cos(rot);\r\n        float s = sin(rot);\r\n        mat2 rotation= mat2(c, -s, s, c);\r\n\t    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n   #endif\r\n   \r\n   #ifdef VERTICALBILLBOARD\r\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n        const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\r\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\r\n\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n        float c = cos(rot);\r\n        float s = sin(rot);\r\n        mat2 rotation= mat2(c, -s, s, c);\r\n\t    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n   #endif\r\n   \r\n   #ifdef RENDERMODE_MESH\r\n\t    vec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\r\n\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\r\n\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t\t\t\tfloat angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\tcenter+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t\t\t\t//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\r\n\t\t\t\t\tvec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,-a_StartRotation0.x), age,normalizedAge);\r\n\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\r\n\t\t\t\t#endif\t\t\r\n\t\t\t}\r\n\t\t#else\r\n\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\r\n\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\tcenter+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\r\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);\t\r\n\t\t\t\t\t#else\r\n\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\r\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\r\n\t\t\t\t\t#endif\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t#endif\r\n\t\tv_MeshColor=a_MeshColor;\r\n   #endif\r\n   \r\n    gl_Position=u_Projection*u_View*vec4(center,1.0);\r\n    v_Color = computeParticleColor(a_StartColor, normalizedAge);\r\n\t#ifdef DIFFUSEMAP\r\n\t\t#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\t\t\tv_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef RENDERMODE_MESH\r\n\t\t\tv_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\r\n\t\t#endif\r\n\t\t\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y)*u_TilingOffset.xy+vec2(u_TilingOffset.z,-u_TilingOffset.w);//需要特殊处理\r\n\t\t\tv_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y);//需要特殊处理\r\n\t\t#endif\r\n\t#endif\r\n    v_Discard=0.0;\r\n\t  \r\n\t#ifdef FOG\r\n\t\t//v_PositionWorld=center;\r\n\t#endif\r\n   }\r\n   else\r\n\t{\r\n\t\tv_Discard=1.0;\r\n\t}\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\n',
            BRDFGLSL = "struct LayaGI\r\n{\r\n\tvec3 diffuse;\r\n\tvec3 specular;\r\n};\r\n\r\nvec4 LayaAirBRDF(in vec3 diffuseColor, in vec3 specularColor, in float oneMinusReflectivity, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\r\n{\r\n\tfloat perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\r\n\tvec3 halfDir = SafeNormalize(viewDir - lightDir);\r\n\t\r\n\tfloat nv = abs(dot(normal, viewDir));\r\n\t\r\n\tfloat nl = clamp(dot(normal,   -lightDir),  0.0, 1.0);\r\n\tfloat nh = clamp(dot(normal,     halfDir),  0.0, 1.0);\r\n\tfloat lv = clamp(dot(lightDir,   viewDir),  0.0, 1.0);\r\n\tfloat lh = clamp(dot(lightDir,  -halfDir),  0.0, 1.0);\r\n\t\r\n\tfloat diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\r\n\t\r\n\tfloat roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\r\n\t\r\n\t//#if UNITY_BRDF_GGX\r\n\t // GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\r\n\troughness = max(roughness,0.014);\r\n\tfloat V = SmithJointGGXVisibilityTerm(nl, nv, roughness);\r\n\tfloat D = GGXTerm(nh, roughness);\r\n\t\r\n\tfloat specularTerm = V * D * PI;\r\n\t\r\n\tspecularTerm = sqrt(max(0.0001, specularTerm));\r\n\tspecularTerm = max(0.0, specularTerm * nl);\r\n\t\r\n\tfloat surfaceReduction = 1.0 - 0.28 * roughness * perceptualRoughness;\r\n\tfloat grazingTerm = clamp(smoothness + (1.0 - oneMinusReflectivity), 0.0, 1.0);\r\n\t\r\n\tvec4 color;\r\n\tcolor.rgb = diffuseColor * (gi.diffuse+lightColor * diffuseTerm) \r\n\t\t\t  + specularTerm * lightColor * FresnelTerm (specularColor, lh);\r\n\t\t\t  //+ surfaceReduction * gi.specular * FresnelLerp(specularColor, vec3(grazingTerm), nv);\r\n\t\r\n\treturn color;\r\n}\r\nvec4 LayaAirStandardReflect(in vec4 albedoColor,in float metallic,in float smoothness,in LayaGI gi)\r\n{\r\n\tvec3 diffuseColor;\r\n\tvec3 specularColor;\r\n\tfloat alpha;\r\n\tfloat oneMinusReflectivity;\r\n\tdiffuseColor = DiffuseAndSpecularFromMetallic (albedoColor.rgb, metallic, specularColor, oneMinusReflectivity);\r\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\r\n\tfloat perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\r\n\tfloat roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat surfaceReduction = 1.0 - 0.28 * roughness * perceptualRoughness;\r\n\tvec4 color;\r\n\tcolor.rgb = surfaceReduction * gi.specular;\r\n\tcolor.a = alpha;\r\n\treturn color;\r\n\r\n}\r\n\r\nvec4 LayaAirSpecularReflect(in vec4 albedoColor,in vec3 specularColor,in float smoothness,in LayaGI gi)\r\n{\r\n\tfloat oneMinusReflectivity;\r\n\tvec3 diffuseColor;\r\n\tfloat alpha;\r\n\t\r\n\tdiffuseColor = EnergyConservationBetweenDiffuseAndSpecular (albedoColor.rgb, specularColor, oneMinusReflectivity);\r\n\t\r\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\r\n\r\n\tfloat perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\r\n\tfloat roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat surfaceReduction = 1.0 - 0.28 * roughness * perceptualRoughness;\r\n\tvec4 color;\r\n\tcolor.rgb = surfaceReduction * gi.specular;\r\n\tcolor.a = alpha;\r\n\treturn color;\r\n}",
            PBRSpecularLightingGLSL = '#include "PBRUtils.glsl"\r\n#include "BRDF.glsl"\r\n\r\nvec4 PBRSpecularLight(in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\r\n{\r\n\tfloat oneMinusReflectivity;\r\n\tvec3 diffuseColor;\r\n\tfloat alpha;\r\n\t\r\n\tdiffuseColor = EnergyConservationBetweenDiffuseAndSpecular (albedoColor.rgb, specularColor, oneMinusReflectivity);\r\n\t\r\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\r\n\t\r\n\tvec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\r\n\tcolor.a = alpha;\r\n\treturn color;\r\n}\r\n\r\nvec4 PBRSpecularDiectionLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in LayaGI gi)\r\n{\r\n\tvec3 lightVec = normalize(light.Direction);\r\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi);\r\n}\r\n#ifdef POINTLIGHT\r\nvec4 PBRSpecularPointLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in PointLight light, in vec3 pos, in LayaGI gi)\r\n{\r\n\tvec3 lightCoord = (u_PointLightMatrix * vec4(pos, 1.0)).xyz;\r\n\tfloat distance = dot(lightCoord, lightCoord);\r\n\tfloat attenuate = texture2D(u_RangeTexture, vec2(distance)).w;\r\n\tvec3 lightVec = normalize(pos - light.Position);\r\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n}\r\n#endif\r\nvec4 PBRSpecularSpotLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\r\n{\r\n\tvec3 lightVec =  pos - light.Position;\r\n\tvec3 normalLightVec = normalize(lightVec);\r\n\tvec2 cosAngles = cos(vec2(light.SpotAngle, light.SpotAngle*0.5) * 0.5);//ConeAttenuation\r\n\tfloat dl = dot(normalize(light.Direction), normalLightVec);\r\n\tdl *= smoothstep(cosAngles[0], cosAngles[1], dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range) * dl;\r\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n}\r\n\r\n//vec4 PBRStandardSpotLight1 (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\r\n//{\r\n//\tvec4 lightCoord = u_SpotLightMatrix * vec4(pos, 1.0);\r\n//\t\r\n//\tfloat distance = dot(lightCoord, lightCoord);\r\n//\tfloat attenuate = (lightCoord.z < 0.0) ? texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\r\n//\t//float attenuate = (lightCoord.z < 0.0) ? texture2D(u_AngleTexture, vec2(lightCoord.x / lightCoord.w + 0.5, lightCoord.y / lightCoord.w + 0.5)).r * texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\r\n//\t//vec2 _uv = vec2(pos.x * 180.0/(2.0 * pos.z) + 0.5, pos.y * 180.0/(2.0 * pos.z) + 0.5);\r\n//\tvec3 lightVec = normalize(pos - light.Position);\r\n//\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n//}\r\n\r\nvec4 SpecularGloss(float albedoTextureAlpha, in vec2 uv0)\r\n{\r\n    vec4 sg;\r\n\t\r\n\t#ifdef SPECULARTEXTURE\r\n\t\tvec4 specularTextureColor = texture2D(u_SpecularTexture, uv0);\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tsg.rgb = specularTextureColor.rgb;\r\n\t\t\tsg.a = albedoTextureAlpha;\r\n\t\t#else\r\n\t\t\tsg = specularTextureColor;\r\n\t\t#endif\r\n\t\tsg.a *= u_smoothnessScale;\r\n\t#else\r\n\t\tsg.rgb = u_SpecularColor.rgb;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tsg.a = albedoTextureAlpha * u_smoothnessScale;\r\n\t\t#else\r\n\t\t\tsg.a = u_smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n    return sg;\r\n}\r\n\r\n',
            PBRStandardLightingGLSL = '#include "PBRUtils.glsl"\r\n#include "BRDF.glsl"\r\n\r\nvec4 PBRStandardLight(in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\r\n{\r\n\tfloat oneMinusReflectivity;\r\n\tvec3 diffuseColor;\r\n\tvec3 specularColor;\r\n\tfloat alpha;\r\n\t\r\n\tdiffuseColor = DiffuseAndSpecularFromMetallic (albedoColor.rgb, metallic, specularColor, oneMinusReflectivity);\r\n\t\r\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\r\n\t\r\n\tvec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\r\n\tcolor.a = alpha;\r\n\treturn color;\r\n}\r\n\r\nvec4 PBRStandardDiectionLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in LayaGI gi)\r\n{\r\n\tvec3 lightVec = normalize(light.Direction);\r\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi);\r\n}\r\n#ifdef POINTLIGHT\r\nvec4 PBRStandardPointLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in PointLight light, in vec3 pos, in LayaGI gi)\r\n{\r\n\tvec3 lightCoord = (u_PointLightMatrix * vec4(pos, 1.0)).xyz;\r\n\tfloat distance = dot(lightCoord, lightCoord);\r\n\tfloat attenuate = texture2D(u_RangeTexture, vec2(distance)).w;\r\n\tvec3 lightVec = normalize(pos - light.Position);\r\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n}\r\n#endif\r\nvec4 PBRStandardSpotLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\r\n{\r\n\tvec3 lightVec =  pos - light.Position;\r\n\tvec3 normalLightVec = normalize(lightVec);\r\n\tvec2 cosAngles = cos(vec2(light.SpotAngle, light.SpotAngle*0.5) * 0.5);//ConeAttenuation\r\n\tfloat dl = dot(normalize(light.Direction), normalLightVec);\r\n\tdl *= smoothstep(cosAngles[0], cosAngles[1], dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range) * dl;\r\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n}\r\n\r\n//vec4 PBRStandardSpotLight1 (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\r\n//{\r\n//\tvec4 lightCoord = u_SpotLightMatrix * vec4(pos, 1.0);\r\n//\t\r\n//\tfloat distance = dot(lightCoord, lightCoord);\r\n//\tfloat attenuate = (lightCoord.z < 0.0) ? texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\r\n//\t//float attenuate = (lightCoord.z < 0.0) ? texture2D(u_AngleTexture, vec2(lightCoord.x / lightCoord.w + 0.5, lightCoord.y / lightCoord.w + 0.5)).r * texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\r\n//\t//vec2 _uv = vec2(pos.x * 180.0/(2.0 * pos.z) + 0.5, pos.y * 180.0/(2.0 * pos.z) + 0.5);\r\n//\tvec3 lightVec = normalize(pos - light.Position);\r\n//\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n//}\r\n\r\nvec2 MetallicGloss(in float albedoTextureAlpha, in vec2 uv0)\r\n{\r\n\tvec2 mg;\r\n\t\r\n\t#ifdef METALLICGLOSSTEXTURE\r\n\t\tvec4 metallicGlossTextureColor = texture2D(u_MetallicGlossTexture, uv0);\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tmg.r = metallicGlossTextureColor.r;\r\n\t\t\tmg.g = albedoTextureAlpha;\r\n\t\t#else\r\n\t\t    mg = metallicGlossTextureColor.ra;\r\n\t\t#endif\r\n\t\tmg.g *= u_smoothnessScale;\r\n\t#else\r\n\t\tmg.r = u_metallic;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tmg.g = albedoTextureAlpha * u_smoothnessScale;\r\n\t\t#else\r\n\t\t\tmg.g = u_smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\treturn mg;\r\n}\r\n\r\n',
            PBRUtilsGLSL = "struct DirectionLight\r\n{\r\n\tvec3 Color;\r\n\tvec3 Direction;\r\n};\r\n\r\nstruct PointLight\r\n{\r\n\tvec3 Color;\r\n\tvec3 Position;\r\n\tfloat Range;\r\n};\r\n\r\nstruct SpotLight\r\n{\r\n\tvec3 Color;\r\n\tvec3 Position;\r\n\tvec3 Direction;\r\n\tfloat SpotAngle;\r\n\tfloat Range;\r\n};\r\n\r\nvec3 UnpackScaleNormal(in vec2 uv0)\r\n{\r\n\t#ifdef NORMALTEXTURE\r\n\t\tvec3 normalT;\r\n\t\tvec4 normalMapSample = texture2D(u_NormalTexture, uv0);\r\n\t\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\t\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\t\tnormalT.xy *= u_normalScale;\r\n\t\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\t\t\r\n\t\tvec3 T = normalize(v_Tangent);\r\n\t\tvec3 B = normalize(v_Binormal);\r\n\t\tvec3 N = normalize(v_Normal);\r\n\t\tmat3 TBN = mat3(T, B, N);\r\n\t\t\r\n\t\tvec3 bumpedNormal = TBN * normalize(normalT);\r\n\t\treturn bumpedNormal;\r\n\t#else\r\n\t\treturn normalize(v_Normal);\r\n\t#endif\r\n}\r\n\r\nvec4 DielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\r\n\r\nfloat PI = 3.14159265359;\r\n\r\nvec3 FresnelTerm (in vec3 F0, in float cosA)\r\n{\r\n\treturn F0 + (vec3(1.0) - F0) * pow(1.0 - cosA, 5.0);\r\n}\r\n\r\nvec3 FresnelLerp (in vec3 F0, in vec3 F90, float cosA)\r\n{\r\n    float t = pow(1.0 - cosA, 5.0);\r\n    return mix(F0, F90, t);\r\n}\r\n\r\nfloat PerceptualRoughnessToRoughness(in float perceptualRoughness)\r\n{\r\n\treturn perceptualRoughness * perceptualRoughness;\r\n}\r\n\r\nfloat PerceptualRoughnessToSpecularPower(in float perceptualRoughness)\r\n{\r\n\tfloat m = PerceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat sq = max(0.0001, m * m);\r\n\tfloat n = (2.0 / sq) - 2.0;\r\n\tn = max(n, 0.0001);\r\n\treturn n;\r\n}\r\n\r\nfloat RoughnessToPerceptualRoughness(in float roughness)\r\n{\r\n\treturn sqrt(roughness);\r\n}\r\n\r\nfloat SmoothnessToRoughness(in float smoothness)\r\n{\r\n\treturn (1.0 - smoothness) * (1.0 - smoothness);\r\n}\r\n\r\nfloat SmoothnessToPerceptualRoughness(in float smoothness)\r\n{\r\n\treturn (1.0 - smoothness);\r\n}\r\n\r\nvec3 SafeNormalize(in vec3 inVec)\r\n{\r\n\tfloat dp3 = max(0.001,dot(inVec,inVec));\r\n\treturn inVec * (1.0 / sqrt(dp3));\r\n}\r\n\r\nfloat DisneyDiffuse(in float NdotV, in float NdotL, in float LdotH, in float perceptualRoughness)\r\n{\r\n\tfloat fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\r\n\tfloat lightScatter\t= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotL,5.0));\r\n\tfloat viewScatter\t= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotV,5.0));\r\n\r\n\treturn lightScatter * viewScatter;\r\n}\r\n\r\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\r\n{\r\n\tfloat a = roughness;\r\n\tfloat lambdaV = NdotL * (NdotV * (1.0 - a) + a);\r\n\tfloat lambdaL = NdotV * (NdotL * (1.0 - a) + a);\r\n\r\n\treturn 0.5 / (lambdaV + lambdaL + 0.00001);\r\n}\r\n\r\nfloat GGXTerm (float NdotH, float roughness)\r\n{\r\n\tfloat a2 = roughness * roughness;\r\n\tfloat d = (NdotH * a2 - NdotH) * NdotH + 1.0;\r\n\treturn 0.31830988618 * a2 / (d * d + 0.0000001);\r\n}\r\n\r\nfloat OneMinusReflectivityFromMetallic(in float metallic)\r\n{\r\n\tfloat oneMinusDielectricSpec = DielectricSpecularColor.a;\r\n\treturn oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\r\n}\r\n\r\nfloat SpecularStrength(vec3 specular)\r\n{\r\n    //(SHADER_TARGET < 30)return specular.r; \r\n    return max (max (specular.r, specular.g), specular.b);\r\n}\r\n\r\nvec3 DiffuseAndSpecularFromMetallic(in vec3 diffuseColor, in float metallic, out vec3 specularColor, out float oneMinusReflectivity)\r\n{\r\n\tspecularColor = mix(DielectricSpecularColor.rgb, diffuseColor, metallic);\r\n\toneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\r\n\treturn diffuseColor * oneMinusReflectivity;\r\n}\r\n\r\nvec3 EnergyConservationBetweenDiffuseAndSpecular(in vec3 diffuseColor, in vec3 specularColor, out float oneMinusReflectivity)\r\n{\r\n\toneMinusReflectivity = 1.0 - SpecularStrength(specularColor);\r\n\treturn diffuseColor * oneMinusReflectivity;\r\n}\r\n\r\nvec4 Occlusion(in vec2 uv0){\r\n\t#ifdef OCCLUSIONTEXTURE\r\n\t\tvec4 occlusionTextureColor = texture2D(u_OcclusionTexture, uv0);\r\n\t\tfloat occ = occlusionTextureColor.g;\r\n\t\tfloat oneMinusT = 1.0 - u_occlusionStrength;\r\n\t\tfloat lerpOneTo = oneMinusT + occ * u_occlusionStrength;\r\n\t\treturn occlusionTextureColor * lerpOneTo;\r\n\t#else\r\n\t\treturn vec4(1.0);\r\n\t#endif\r\n}\r\n\r\nvec2 ParallaxOffset(in vec3 viewDir){\r\n\t#ifdef PARALLAXTEXTURE\r\n\t\tfloat h = texture2D(u_ParallaxTexture, v_Texcoord0).g;\r\n\t\th = h * u_parallaxScale - u_parallaxScale / 2.0;\r\n\t\tvec3 v = viewDir;\r\n\t\tv.z += 0.42;\r\n\t\tvec2 offset = h * (v.xy / v.z);\r\n\t\treturn v_Texcoord0 + offset;\r\n\t#else\r\n\t\treturn v_Texcoord0;\r\n\t#endif\r\n}\r\n\r\nvec3 ReflectCubeMap(in vec3 viewDir, in vec3 normal){\r\n\t#ifdef REFLECTMAP\r\n\t\tvec3 incident = -viewDir;\r\n\t\tvec3 reflectionVector = reflect(incident, normal);\r\n\t\tvec3 reflectionColor = textureCube(u_ReflectTexture, vec3(-reflectionVector.x, reflectionVector.yz)).rgb;\r\n\t\treturn reflectionColor * u_ReflectIntensity;\r\n\t#else\r\n\t\treturn vec3(0.0);\r\n\t#endif\r\n}\r\n\r\nfloat LayaAttenuation(in vec3 L, in float invLightRadius)\r\n{\r\n\tfloat fRatio = clamp(length(L) * invLightRadius, 0.0, 1.0);\r\n\tfRatio *= fRatio;\r\n\treturn 1.0 / (1.0 + 25.0 * fRatio) * clamp(4.0*(1.0 - fRatio), 0.0, 1.0); //fade to black as if 4 pixel texture\r\n}\r\n\r\nvec3 LayaPreMultiplyAlpha(vec3 diffColor, float alpha, float oneMinusReflectivity, out float outModifiedAlpha)\r\n{\r\n\t#ifdef ALPHAPREMULTIPLY\r\n\t\tdiffColor *= alpha;\r\n\t\toutModifiedAlpha = 1.0 - oneMinusReflectivity + alpha * oneMinusReflectivity;\r\n\t#else\r\n\t\toutModifiedAlpha = alpha;\r\n\t#endif\r\n\treturn diffColor;\r\n}\r\n\r\n",
            PBRSpecularPS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec3 v_PositionWorld;\r\n\r\nuniform vec3 u_AmbientColor;\r\nuniform vec4 u_AlbedoColor;\r\nuniform vec4 u_SpecularColor;\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n#ifdef SPECULARTEXTURE\r\n\tuniform sampler2D u_SpecularTexture;\r\n#endif\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n\tuniform float u_normalScale;\r\n#endif\r\n#ifdef PARALLAXTEXTURE\r\n\tuniform sampler2D u_ParallaxTexture;\r\n\tuniform float u_parallaxScale;\r\n#endif\r\n#ifdef OCCLUSIONTEXTURE\r\n\tuniform sampler2D u_OcclusionTexture;\r\n\tuniform float u_occlusionStrength;\r\n#endif\r\n#ifdef EMISSION\r\n\t#ifdef EMISSIONTEXTURE\r\n\t\tuniform sampler2D u_EmissionTexture;\r\n\t#endif\r\n\tuniform vec4 u_EmissionColor;\r\n#endif\r\n#ifdef REFLECTMAP\r\n\tuniform samplerCube u_ReflectTexture;\r\n\tuniform float u_ReflectIntensity;\r\n#endif\r\n\r\nuniform float u_AlphaTestValue;\r\nuniform float u_metallic;\r\nuniform float u_smoothness;\r\nuniform float u_smoothnessScale;\r\n\r\nuniform sampler2D u_RangeTexture;\r\n//uniform sampler2D u_AngleTexture;\r\n#ifdef POINTLIGHT\r\n\tuniform mat4 u_PointLightMatrix;\r\n#endif\r\n//uniform mat4 u_SpotLightMatrix;\r\n\r\n#include "PBRSpecularLighting.glsl"\r\n#include "ShadowHelper.glsl"\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tuniform DirectionLight u_DirectionLight;\r\n#endif\r\n#ifdef POINTLIGHT\r\n\tuniform PointLight u_PointLight;\r\n#endif\r\n#ifdef SPOTLIGHT\r\n\tuniform SpotLight u_SpotLight;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}\r\n\r\nvoid main_normal()\r\n{\t\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\t\r\n\tvec2 uv0 = ParallaxOffset(viewDir);\r\n\t\r\n\tvec4 sg;\r\n\tvec4 albedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tvec4 albedoTextureColor = texture2D(u_AlbedoTexture, uv0);\r\n\t\talbedoColor = albedoTextureColor * u_AlbedoColor;\r\n\t\tsg = SpecularGloss(albedoTextureColor.a, uv0);\r\n\t#else\r\n\t\talbedoColor = u_AlbedoColor;\r\n\t\tsg = SpecularGloss(1.0, uv0);\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(albedoColor.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n  \r\n\tvec3 normal = UnpackScaleNormal(uv0);\r\n\t\r\n\tLayaGI gi;\r\n\tgi.diffuse = u_AmbientColor * Occlusion(uv0).rgb;\r\n\tgi.specular = ReflectCubeMap(viewDir, normal);\r\n\t\r\n\t//float a = (sg.r+sg.g+sg.b) / 3.0;\r\n  \r\n\tvec4 color = vec4(0.0);\r\n\t\r\n\t#ifdef DIRECTIONLIGHT\r\n\t\tcolor += PBRSpecularDiectionLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_DirectionLight, gi);\r\n\t#endif\r\n \r\n\t#ifdef POINTLIGHT\r\n\t\tcolor.a = 0.0;\r\n\t\tcolor += PBRSpecularPointLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_PointLight, v_PositionWorld, gi);\r\n\t#endif\r\n\t\r\n\t#ifdef SPOTLIGHT\r\n\t\tcolor.a = 0.0;\r\n\t\tcolor += PBRSpecularSpotLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_SpotLight, v_PositionWorld, gi);\r\n\t#endif\r\n\r\n\t#ifdef REFLECTMAP\r\n\t \tcolor += LayaAirSpecularReflect(albedoColor,sg.rgb,sg.a,gi);\r\n\t#endif\r\n\r\n\t#ifdef EMISSION\r\n\t\tvec4 emissionColor = u_EmissionColor;\r\n\t\t#ifdef EMISSIONTEXTURE\r\n\t\t\temissionColor *=  texture2D(u_EmissionTexture, uv0);\r\n\t\t#endif\r\n\t\tcolor.rgb += emissionColor.rgb;\r\n\t#endif\r\n\t\r\n\t#ifdef RECEIVESHADOW\r\n\t\tfloat shadowValue = 1.0;\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\tgl_FragColor = vec4(color.rgb * shadowValue, color.a);\r\n\t#else\r\n\t\tgl_FragColor = color;\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t#endif\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif  \r\n}\r\n\r\n',
            PBRSpecularVS = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\nuniform vec3 u_CameraPos;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec3 v_PositionWorld;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n  #ifdef SHADOWMAP_PSSM1 \r\n\t  varying vec4 v_lightMVPPos;\r\n\t  uniform mat4 u_lightShadowVP[4];\r\n  #endif\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t \r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0 = a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}\r\n\r\nvoid main_normal()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)||defined(REFLECTMAP)\r\n\t\tmat4 worldMat;\r\n\t\t#ifdef GPU_INSTANCE\r\n\t\t\tworldMat = a_WorldMat;\r\n\t\t#else\r\n\t\t\tworldMat = u_WorldMat;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\r\n\t\tmat3 worldInvMat;\r\n\t\t#ifdef BONE\r\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\r\n\t\t#else\r\n\t\t\tworldInvMat=inverse(mat3(worldMat));\r\n\t\t#endif  \r\n\t\tv_Normal=a_Normal*worldInvMat;\r\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))\r\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\r\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)||defined(REFLECTMAP)\r\n\t\tv_PositionWorld=(worldMat*position).xyz;\r\n\t#endif\r\n\t\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\r\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n  \r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif\r\n}',
            PBRStandardPS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec3 v_PositionWorld;\r\n\r\nuniform vec3 u_AmbientColor;\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n#ifdef METALLICGLOSSTEXTURE\r\n\tuniform sampler2D u_MetallicGlossTexture;\r\n#endif\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n\tuniform float u_normalScale;\r\n#endif\r\n#ifdef PARALLAXTEXTURE\r\n\tuniform sampler2D u_ParallaxTexture;\r\n\tuniform float u_parallaxScale;\r\n#endif\r\n#ifdef OCCLUSIONTEXTURE\r\n\tuniform sampler2D u_OcclusionTexture;\r\n\tuniform float u_occlusionStrength;\r\n#endif\r\n#ifdef EMISSION\r\n\t#ifdef EMISSIONTEXTURE\r\n\t\tuniform sampler2D u_EmissionTexture;\r\n\t#endif\r\n\tuniform vec4 u_EmissionColor;\r\n#endif\r\n#ifdef REFLECTMAP\r\n\tuniform samplerCube u_ReflectTexture;\r\n\tuniform float u_ReflectIntensity;\r\n#endif\r\n\r\nuniform float u_AlphaTestValue;\r\nuniform float u_metallic;\r\nuniform float u_smoothness;\r\nuniform float u_smoothnessScale;\r\n\r\nuniform sampler2D u_RangeTexture;\r\n//uniform sampler2D u_AngleTexture;\r\n#ifdef POINTLIGHT\r\n\tuniform mat4 u_PointLightMatrix;\r\n#endif\r\n//uniform mat4 u_SpotLightMatrix;\r\n\r\n#include "PBRStandardLighting.glsl"\r\n#include "ShadowHelper.glsl"\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tuniform DirectionLight u_DirectionLight;\r\n#endif\r\n#ifdef POINTLIGHT\r\n\tuniform PointLight u_PointLight;\r\n#endif\r\n#ifdef SPOTLIGHT\r\n\tuniform SpotLight u_SpotLight;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}\r\n\r\nvoid main_normal()\r\n{\t\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\t\r\n\tvec2 uv0 = ParallaxOffset(viewDir);\r\n\t\r\n\tvec2 mg;\r\n\tvec4 albedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tvec4 abledoTextureColor = texture2D(u_AlbedoTexture, uv0);\r\n\t\talbedoColor = abledoTextureColor * u_AlbedoColor;\r\n\t\tmg = MetallicGloss(abledoTextureColor.a, uv0);\r\n\t#else\r\n\t\talbedoColor = u_AlbedoColor;\r\n\t\tmg = MetallicGloss(1.0, uv0);\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(albedoColor.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\t\r\n\tvec3 normal = UnpackScaleNormal(uv0);\r\n  \r\n\tLayaGI gi;\r\n\tgi.diffuse = u_AmbientColor * Occlusion(uv0).rgb;\r\n\tgi.specular = ReflectCubeMap(viewDir, normal);\r\n  \r\n\tvec4 color = vec4(0.0);\r\n\t\r\n\t#ifdef DIRECTIONLIGHT\r\n\t\tcolor += PBRStandardDiectionLight(albedoColor, mg.r, mg.g, normal, viewDir, u_DirectionLight, gi);\r\n\t#endif\r\n \r\n\t#ifdef POINTLIGHT\r\n\t\tcolor.a = 0.0;\r\n\t\tcolor += PBRStandardPointLight(albedoColor, mg.r, mg.g, normal, viewDir, u_PointLight, v_PositionWorld, gi);\r\n\t#endif\r\n\t\r\n\t#ifdef SPOTLIGHT\r\n\t\tcolor.a = 0.0;\r\n\t\tcolor += PBRStandardSpotLight(albedoColor, mg.r, mg.g, normal, viewDir, u_SpotLight, v_PositionWorld, gi);\r\n\t#endif\r\n\t\r\n\t#ifdef REFLECTMAP\r\n\t \tcolor += LayaAirStandardReflect(albedoColor,mg.r,mg.g,gi);\r\n\t#endif\r\n\r\n\t#ifdef EMISSION\r\n\t\tvec4 emissionColor = u_EmissionColor;\r\n\t\t#ifdef EMISSIONTEXTURE\r\n\t\t\temissionColor *=  texture2D(u_EmissionTexture, uv0);\r\n\t\t#endif\r\n\t\tcolor.rgb += emissionColor.rgb;\r\n\t#endif\r\n\t\r\n\t#ifdef RECEIVESHADOW\r\n\t\tfloat shadowValue = 1.0;\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\tgl_FragColor = vec4(color.rgb * shadowValue, color.a);\r\n\t#else\r\n\t\tgl_FragColor = color;\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t#endif\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif  \r\n}',
            PBRStandardVS = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\nuniform vec3 u_CameraPos;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec3 v_PositionWorld;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n  #ifdef SHADOWMAP_PSSM1 \r\n\t  varying vec4 v_lightMVPPos;\r\n\t  uniform mat4 u_lightShadowVP[4];\r\n  #endif\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t \r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0 = a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}\r\n\r\nvoid main_normal()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)||defined(REFLECTMAP)\r\n\t\tmat4 worldMat;\r\n\t\t#ifdef GPU_INSTANCE\r\n\t\t\tworldMat = a_WorldMat;\r\n\t\t#else\r\n\t\t\tworldMat = u_WorldMat;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\r\n\t\tmat3 worldInvMat;\r\n\t\t#ifdef BONE\r\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\r\n\t\t#else\r\n\t\t\tworldInvMat=inverse(mat3(worldMat));\r\n\t\t#endif  \r\n\t\tv_Normal=a_Normal*worldInvMat;\r\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))\r\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\r\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)||defined(REFLECTMAP)\r\n\t\tv_PositionWorld=(worldMat*position).xyz;\r\n\t#endif\r\n\t\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)||defined(REFLECTMAP)\r\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n  \r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif\r\n}',
            BloomVS = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
            BloomDownsample13PS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample13();\r\n}',
            BloomDownsample4PS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample4();\r\n}',
            BloomPrefilter13PS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter13();\r\n}',
            BloomPrefilter4PS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter4();\r\n}',
            BloomUpsampleBoxPS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleBox() {\r\n\tmediump vec4 bloom = upsampleBox(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleBox();\r\n}',
            BloomUpsampleTentPS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleTent() {\r\n\tmediump vec4 bloom = upsampleTent(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleTent();\r\n}',
            ColorsGLSL = '#include "StdLib.glsl";\r\n\r\n#define EPSILON 1.0e-4\r\n\r\n// Quadratic color thresholding\r\n// curve = (threshold - knee, knee * 2, 0.25 / knee)\r\nmediump vec4 quadraticThreshold(mediump vec4 color, mediump float threshold, mediump vec3 curve) {\r\n\t// Pixel brightness\r\n\tmediump float br = max3(color.r, color.g, color.b);\r\n\r\n\t// Under-threshold part: quadratic curve\r\n\tmediump float rq = clamp(br - curve.x, 0.0, curve.y);\r\n\trq = curve.z * rq * rq;\r\n\r\n\t// Combine and apply the brightness response curve.\r\n\tcolor *= max(rq, br - threshold) / max(br, EPSILON);\r\n\r\n\treturn color;\r\n}\r\n\r\n\r\n\r\n//\r\n// sRGB transfer functions\r\n// Fast path ref: http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n//\r\nmediump vec3 sRGBToLinear(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn c * c;\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\r\n\t#else\r\n\t\tmediump vec3 linearRGBLo = c / 12.92;\r\n\t\tmediump vec3 power=vec3(2.4, 2.4, 2.4);\r\n\t\tmediump vec3 linearRGBHi = positivePow((c + 0.055) / 1.055, power);\r\n\t\tmediump vec3 linearRGB =vec3((c.r<=0.04045) ? linearRGBLo.r : linearRGBHi.r,(c.g<=0.04045) ? linearRGBLo.g : linearRGBHi.g,(c.b<=0.04045) ? linearRGBLo.b : linearRGBHi.b);\r\n\t\treturn linearRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 sRGBToLinear(mediump vec4 c){\r\n    return vec4(sRGBToLinear(c.rgb), c.a);\r\n}\r\n\r\n\r\n\r\nmediump vec3 linearToSRGB(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn sqrt(c);\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn max(1.055 * PositivePow(c, 0.416666667) - 0.055, 0.0);\r\n\t#else\r\n\t\tmediump vec3 sRGBLo = c * 12.92;\r\n\t\tmediump vec3 power=vec3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4);\r\n\t\tmediump vec3 sRGBHi = (positivePow(c, power) * 1.055) - 0.055;\r\n\t\tmediump vec3 sRGB =vec3((c.r<=0.0031308) ? sRGBLo.r : sRGBHi.r,(c.g<=0.0031308) ? sRGBLo.g : sRGBHi.g,(c.b<=0.0031308) ? sRGBLo.b : sRGBHi.b);\r\n\t\treturn sRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 linearToSRGB(mediump vec4 c){\r\n    return vec4(linearToSRGB(c.rgb), c.a);\r\n}',
            CompositePS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform sampler2D u_Bloom_DirtTex;\r\nuniform vec4 u_BloomTex_TexelSize;\r\nuniform vec4 u_Bloom_DirtTileOffset; // xy: tiling, zw: offset\r\nuniform mediump vec3 u_Bloom_Settings;// x: sampleScale, y: intensity, z: dirt intensity\r\nuniform mediump vec3 u_Bloom_Color;\r\n\r\nvoid main() {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, v_Texcoord0).r;\r\n\tmediump vec4 color=vec4(0.0);\r\n\tcolor = texture2D(u_MainTex, v_Texcoord0);\r\n\t\r\n\tcolor = sRGBToLinear(color);\r\n\tcolor.rgb *= autoExposure;\r\n\t\r\n\t#if defined(BLOOM)||defined(BLOOM_LOW)\r\n\t\t#ifdef BLOOM\r\n\t\t\tmediump vec4 bloom = upsampleTent(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#else\r\n\t\t\tmediump vec4 bloom = upsampleBox(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#endif\r\n\r\n\t\t// UVs should be Distort(uv * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw)\r\n\t\t// but considering we use a cover-style scale on the dirt texture the difference\r\n\t\t// isn\'t massive so we chose to save a few ALUs here instead in case lens distortion\r\n\t\t// is active\r\n\t\tmediump vec4 dirt =vec4(texture2D(u_Bloom_DirtTex, v_Texcoord0 * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw).rgb, 0.0);\r\n\r\n\t\t// Additive bloom (artist friendly)\r\n\t\tbloom *= u_Bloom_Settings.y;\r\n\t\tdirt *= u_Bloom_Settings.z;\r\n\t\tmediump vec4 bloomColor=vec4(u_Bloom_Color, 1.0);\r\n\t\tcolor += bloom * bloomColor;\r\n\t\tcolor += dirt * bloom;\r\n\t#endif\r\n\t\r\n\tmediump vec4 finalColor = color;\r\n\tfinalColor = linearToSRGB(finalColor);\r\n\t//finalColor.rgb = Dither(finalColor.rgb, v_Texcoord0);//TODO:抖动\r\n\tgl_FragColor = finalColor;\r\n}',
            CompositeVS = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
            SamplingGLSL = "// Better, temporally stable box filtering\r\n// [Jimenez14] http://goo.gl/eomGso\r\n// . . . . . . .\r\n// . A . B . C .\r\n// . . D . E . .\r\n// . F . G . H .\r\n// . . I . J . .\r\n// . K . L . M .\r\n// . . . . . . .\r\nmediump vec4 downsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    mediump vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\r\n    mediump vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\r\n    mediump vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\r\n    mediump vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\r\n    mediump vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\r\n    mediump vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\r\n    mediump vec4 G = texture2D(tex, uv);\r\n    mediump vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\r\n    mediump vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\r\n    mediump vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\r\n    mediump vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\r\n    mediump vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\r\n    mediump vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\r\n\r\n\tmediump vec2 scale= vec2(0.5, 0.125);\r\n    mediump vec2 div = (1.0 / 4.0) * scale;\r\n\r\n    mediump vec4 o = (D + E + I + J) * div.x;\r\n    o += (A + B + G + F) * div.y;\r\n    o += (B + C + H + G) * div.y;\r\n    o += (F + G + L + K) * div.y;\r\n    o += (G + H + M + L) * div.y;\r\n\r\n    return o;\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 downsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}\r\n\r\n// 9-tap bilinear upsampler (tent filter)\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\n// . 2 . 4 . 2 .\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\nmediump vec4 upsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv - d.xy);\r\n    s += texture2D(tex, uv - d.wy) * 2.0;\r\n    s += texture2D(tex, uv - d.zy);\r\n\r\n    s += texture2D(tex, uv + d.zw) * 2.0;\r\n    s += texture2D(tex, uv) * 4.0;\r\n    s += texture2D(tex,\tuv + d.xw) * 2.0;\r\n\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.wy) * 2.0;\r\n    s += texture2D(tex, uv + d.xy);\r\n\r\n    return s * (1.0 / 16.0);\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 upsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * 0.5 * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}",
            StdLibGLSL = "#define HALF_MAX       65504.0 // (2 - 2^-10) * 2^15\r\n\r\n#define FLT_EPSILON    1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0\r\n\r\nmediump vec4 safeHDR(mediump vec4 c)\r\n{\r\n    return min(c, HALF_MAX);\r\n}\r\n\r\nfloat max3(float a, float b, float c)\r\n{\r\n    return max(max(a, b), c);\r\n}\r\n\r\nvec3 positivePow(vec3 base, vec3 power)\r\n{\r\n    return pow(max(abs(base), vec3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);\r\n}",
            ShadowHelperGLSL = "uniform sampler2D u_shadowMap1;\r\nuniform sampler2D u_shadowMap2;\r\nuniform sampler2D u_shadowMap3;\r\nuniform vec2\t  u_shadowPCFoffset;\r\nuniform vec4     u_shadowPSSMDistance;\r\nvec4 packDepth(const in float depth)\r\n{\r\n\tconst vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\r\n\tconst vec4 bitMask\t= vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\r\n\tvec4 res = mod(depth*bitShift*vec4(255), vec4(256))/vec4(255);\r\n\tres -= res.xxyz * bitMask;\r\n\treturn res;\r\n}\r\nfloat unpackDepth(const in vec4 rgbaDepth)\r\n{\r\n\tconst vec4 bitShift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\r\n\tfloat depth = dot(rgbaDepth, bitShift);\r\n\treturn depth;\r\n}\r\nfloat tex2DPCF( sampler2D shadowMap,vec2 texcoord,vec2 invsize,float zRef )\r\n{\r\n\tvec2 texelpos =texcoord / invsize;\r\n\tvec2 lerps = fract( texelpos );\r\n\tfloat sourcevals[4];\r\n\tsourcevals[0] = float( unpackDepth(texture2D(shadowMap,texcoord)) > zRef );\r\n\tsourcevals[1] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x,0))) > zRef );\r\n\tsourcevals[2] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(0,invsize.y))) > zRef );\r\n\tsourcevals[3] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x, invsize.y) )) > zRef );\r\n\treturn mix( mix(sourcevals[0],sourcevals[2],lerps.y),mix(sourcevals[1],sourcevals[3],lerps.y),lerps.x );\r\n}\r\nfloat getShadowPSSM3( sampler2D shadowMap1,sampler2D shadowMap2,sampler2D shadowMap3,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tint nPSNum = int(posViewZ>pssmDistance.x);\r\n\tnPSNum += int(posViewZ>pssmDistance.y);\r\n\tnPSNum += int(posViewZ>pssmDistance.z);\r\n\t//真SB,webgl不支持在PS中直接访问数组\r\n\tmat4 lightVP;\r\n\tif( nPSNum == 0 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[1];\r\n\t}\r\n\telse if( nPSNum == 1 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[2];\r\n\t}\r\n\telse if( nPSNum == 2 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[3];\r\n\t}\r\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\r\n\t//为了效率，在CPU计算/2.0 + 0.5\r\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\r\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\r\n\tfloat fMyZ = vText.z - zBias;\r\n\t/*\r\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\tbool bInFrustum = all( bInFrustumVec );\r\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\tbool bFrustumTest = all( bFrustumTestVec );\r\n\tif ( bFrustumTest ) \r\n\t*/\r\n\tif( fMyZ <= 1.0 )\r\n\t{\r\n\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue = value/4.0;\r\n\t\t} \r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\r\n\t\tvec4 color;\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap3,vText.xy );\r\n\t\t}\r\n\t\tzdepth = unpackDepth(color);\r\n\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t}\r\n\treturn value;\r\n}\r\nfloat getShadowPSSM2( sampler2D shadowMap1,sampler2D shadowMap2,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tint nPSNum = int(posViewZ>pssmDistance.x);\r\n\tnPSNum += int(posViewZ>pssmDistance.y);\r\n\t//真SB,webgl不支持在PS中直接访问数组\r\n\tmat4 lightVP;\r\n\tif( nPSNum == 0 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[1];\r\n\t}\r\n\telse if( nPSNum == 1 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[2];\r\n\t}\r\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\r\n\t//为了效率，在CPU计算/2.0 + 0.5\r\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\r\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\r\n\tfloat fMyZ = vText.z - zBias;\r\n\t/*\r\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\tbool bInFrustum = all( bInFrustumVec );\r\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\tbool bFrustumTest = all( bFrustumTestVec );\r\n\tif ( bFrustumTest ) \r\n\t*/\r\n\tif( fMyZ <= 1.0 )\r\n\t{\r\n\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue = value/4.0;\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\r\n\t\tvec4 color;\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\r\n\t\t}\r\n\t\tzdepth = unpackDepth(color);\r\n\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t}\r\n\treturn value;\r\n}\r\nfloat getShadowPSSM1( sampler2D shadowMap1,vec4 lightMVPPos,vec4 pssmDistance,vec2 shadowPCFOffset,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tif( posViewZ < pssmDistance.x )\r\n\t{\r\n\t\tvec3 vText = lightMVPPos.xyz / lightMVPPos.w;\r\n\t\tfloat fMyZ = vText.z - zBias;\r\n\t\t/*\r\n\t\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\t\tbool bInFrustum = all( bInFrustumVec );\r\n\t\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\t\tbool bFrustumTest = all( bFrustumTestVec );\r\n\t\t*/\r\n\t\tif ( fMyZ <= 1.0 ) \r\n\t\t{\r\n\t\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue = value/4.0;\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\t\t\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\t\t\r\n\t\t\tvec4 color = texture2D( shadowMap1,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t\t}\r\n\t}\r\n\treturn value;\r\n}",
            SkyBoxPS = "#ifdef HIGHPRECISION\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec3 v_Texcoord;\r\n\r\nuniform samplerCube u_CubeTexture;\r\nuniform float u_Exposure;\r\nuniform vec4 u_TintColor;\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\r\n\tgl_FragColor=vec4(color,1.0);\r\n}\r\n\r\n",
            SkyBoxVS = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\nvarying vec3 v_Texcoord;\r\n\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * 3.141593 / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\r\n\tgl_Position = (u_ViewProjection*position).xyww;\r\n\tv_Texcoord=vec3(-a_Position.x,a_Position.yz);//转换坐标系\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n',
            SkyBoxProceduralPS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nconst float MIE_G = -0.990;\r\nconst float MIE_G2 = 0.9801;\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\n\r\nuniform float u_SunSize;\r\nuniform float u_SunSizeConvergence;\r\nuniform DirectionLight u_DirectionLight;\r\n\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Mie phase function\r\nfloat getMiePhase(float eyeCos, float eyeCos2) {\r\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\r\n\ttemp = pow(temp, pow(u_SunSize,0.65) * 10.0);\r\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\r\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\r\n\treturn temp;\r\n}\r\n\r\n// Calculates the sun shape\r\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\r\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\r\n\t#else //SUN_SIMPLE\r\n\t\tvec3 delta = lightPos - ray;\r\n\t\tfloat dist = length(delta);\r\n\t\tfloat spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\r\n\t\treturn spot * spot;\r\n\t#endif\r\n}\r\n\r\nvoid main() {\r\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\r\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\r\n\t// if y < 0 [eyeRay.y > 0] - sky\r\n\tvec3 col = vec3(0.0, 0.0, 0.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tvec3 ray = normalize(v_Vertex);\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tvec3 ray = v_RayDir;\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\r\n\t#else\r\n\t\tfloat y = v_SkyGroundFactor;\r\n\t#endif\r\n\r\n\t// if we did precalculate color in vprog: just do lerp between them\r\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\r\n\r\n\t#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\t\tif (y < 0.0)\r\n\t\t\tcol += v_SunColor * calcSunAttenuation(-u_DirectionLight.Direction, -ray);\r\n\t#endif\r\n\r\n\tcol = sqrt(col);//linear space convert to gamma space\r\n\tgl_FragColor=vec4(col,1.0);\r\n}\r\n\r\n',
            SkyBoxProceduralVS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Lighting.glsl\";\r\n\r\n#define OUTER_RADIUS 1.025\r\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\r\n#define MIE 0.0010             // Mie constant 米氏散射\r\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\r\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\r\n\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\nconst float outerRadius = OUTER_RADIUS;\r\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\r\nconst float innerRadius = 1.0;\r\nconst float innerRadius2 = 1.0;\r\nconst float cameraHeight = 0.0001;\r\n\r\nconst float HDSundiskIntensityFactor = 15.0;\r\nconst float simpleSundiskIntensityFactor = 27.0;\r\n\r\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\r\nconst float kmESun = MIE * SUN_BRIGHTNESS;\r\nconst float km4PI = MIE * 4.0 * 3.14159265;\r\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\r\nconst float scaleDepth = 0.25;\r\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\r\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\r\n\r\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\r\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\r\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform vec3 u_SkyTint;\r\nuniform vec3 u_GroundTint;\r\nuniform float u_Exposure;\r\nuniform float u_AtmosphereThickness;\r\nuniform DirectionLight u_DirectionLight;\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Rayleigh phase function\r\nfloat getRayleighPhase(vec3 light, vec3 ray) \r\n{\r\n\tfloat eyeCos = dot(light, ray);\r\n\treturn 0.75 + 0.75*eyeCos*eyeCos;\r\n}\r\n\r\nfloat scaleAngle(float inCos)\r\n{\r\n\tfloat x = 1.0 - inCos;\r\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\n\r\nvoid main () {\r\n\tgl_Position = (u_ViewProjection*a_Position).xyww;\r\n\r\n\tvec3 skyTintInGammaSpace = u_SkyTint;//支持非GAMMA空间后要调整\r\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\r\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\r\n\r\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\r\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\r\n\r\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\r\n\r\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n\tvec3 eyeRay = normalize(a_Position.xyz);\r\n\r\n\tfloat far = 0.0;\r\n\tvec3 cIn, cOut;\r\n\tif (eyeRay.y >= 0.0) {// Sky\r\n\t\t// Calculate the length of the \"atmosphere\"\r\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat height = innerRadius + cameraHeight;\r\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\r\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\r\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\tvec3 frontColor = vec3(0.0);\r\n\t\t//unrolling this manually to avoid some platform for loop slow\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\r\n\t\tcIn = frontColor * (invWavelength * krESun);\r\n\t\tcOut = frontColor * kmESun;\r\n\t} else {// Ground\r\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\r\n\t\tvec3 pos = cameraPos + far * eyeRay;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\r\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\r\n\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, pos);\r\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\r\n\t\tfloat lightScale = scaleAngle(lightAngle);\r\n\t\tfloat cameraOffset = depth*cameraScale;\r\n\t\tfloat temp = lightScale + cameraScale;\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\t// Now loop through the sample rays\r\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\r\n\t\tvec3 attenuate;\r\n\r\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat scatter = depth*temp - cameraOffset;\r\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\r\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\r\n\t}\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tv_Vertex = -a_Position.xyz;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_RayDir = -eyeRay;\r\n\t#else\r\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\r\n\t#endif\r\n\r\n\t// if we want to calculate color in vprog:\r\n\t// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\r\n\tv_GroundColor = u_Exposure * (cIn + u_GroundTint*u_GroundTint * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\r\n\tv_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_DirectionLight.Direction, -eyeRay));\r\n\r\n\t\r\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\r\n\t// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\r\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\r\n\tfloat lightColorIntensity = clamp(length(u_DirectionLight.Color), 0.25, 1.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY \r\n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_DirectionLight.Color / lightColorIntensity;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_DirectionLight.Color / lightColorIntensity;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n",
            TrailPS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTexture;\r\nuniform vec4 u_MainColor;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nvoid main()\r\n{\r\n\tvec4 color = 2.0 * u_MainColor * v_Color;\r\n\t#ifdef MAINTEXTURE\r\n\t\tvec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\r\n\t\tcolor *= mainTextureColor;\r\n\t#endif\r\n\tgl_FragColor = color;\r\n}\r\n\r\n     ",
            TrailVS = '#include "Lighting.glsl";\r\n\r\nattribute vec3 a_Position;\r\nattribute vec3 a_OffsetVector;\r\nattribute vec4 a_Color;\r\nattribute float a_Texcoord0X;\r\nattribute float a_Texcoord0Y;\r\nattribute float a_BirthTime;\r\n\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\nuniform vec4 u_TilingOffset;\r\n\r\nuniform float u_CurTime;\r\nuniform float u_LifeTime;\r\nuniform vec4 u_WidthCurve[10];\r\nuniform int u_WidthCurveKeyLength;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\r\n{\r\n\tfloat t2 = t * t;\r\n\tfloat t3 = t2 * t;\r\n\tfloat a = 2.0 * t3 - 3.0 * t2 + 1.0;\r\n\tfloat b = t3 - 2.0 * t2 + t;\r\n\tfloat c = t3 - t2;\r\n\tfloat d = -2.0 * t3 + 3.0 * t2;\r\n\treturn a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\r\n}\r\n\r\nfloat getCurWidth(in float normalizeTime)\r\n{\r\n\tfloat width;\r\n\tif(normalizeTime == 0.0){\r\n\t\twidth=u_WidthCurve[0].w;\r\n\t}\r\n\telse if(normalizeTime >= 1.0){\r\n\t\twidth=u_WidthCurve[u_WidthCurveKeyLength - 1].w;\r\n\t}\r\n\telse{\r\n\t\tfor(int i = 0; i < 10; i ++ )\r\n\t\t{\r\n\t\t\tif(normalizeTime == u_WidthCurve[i].x){\r\n\t\t\t\twidth=u_WidthCurve[i].w;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvec4 lastFrame = u_WidthCurve[i];\r\n\t\t\tvec4 nextFrame = u_WidthCurve[i + 1];\r\n\t\t\tif(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\r\n\t\t\t{\r\n\t\t\t\tfloat duration = nextFrame.x - lastFrame.x;\r\n\t\t\t\tfloat t = (normalizeTime - lastFrame.x) / duration;\r\n\t\t\t\tfloat outTangent = lastFrame.z;\r\n\t\t\t\tfloat inTangent = nextFrame.y;\r\n\t\t\t\tfloat value1 = lastFrame.w;\r\n\t\t\t\tfloat value2 = nextFrame.w;\r\n\t\t\t\twidth=hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn width;\r\n}\t\r\n\r\nvoid main()\r\n{\r\n\tfloat normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\r\n\t#else\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\r\n\t#endif\r\n\t\r\n\tv_Color = a_Color;\r\n\t\r\n\tgl_Position = u_Projection * u_View * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n',
            UnlitPS = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  u_AlbedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(color.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n}\r\n\r\n",
            UnlitVS = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main() {\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
            WaterPrimaryPS = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_MainTexture;\r\n#endif\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n#endif\r\n\r\nuniform vec4 u_HorizonColor;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\n#include "Lighting.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 bumpColor1 = texture2D(u_NormalTexture, v_Texcoord0);\r\n\tvec4 bumpColor2 = texture2D(u_NormalTexture, v_Texcoord1);\r\n\t\r\n\tvec3 normal1 = NormalSampleToWorldSpace1(bumpColor1, v_Tangent, v_Binormal, v_Normal);\r\n\tvec3 normal2 = NormalSampleToWorldSpace1(bumpColor2, v_Tangent, v_Binormal, v_Normal);\r\n\t\r\n\tvec3 normal = normalize((normal1 + normal2) * 0.5);\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\tfloat fresnel = dot(viewDir, normal);\r\n\t\r\n\tvec4 waterColor = texture2D(u_MainTexture, vec2(fresnel, fresnel));\r\n\t\r\n\tvec4 color;\r\n\tcolor.rgb = mix(waterColor.rgb, u_HorizonColor.rgb, vec3(waterColor.a));\r\n\tcolor.a = u_HorizonColor.a;\r\n\t\r\n\tgl_FragColor = color;\r\n}\r\n\r\n',
            WaterPrimaryVS = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\nuniform mat4 u_WorldMat;\r\nuniform vec3 u_CameraPos;\r\nuniform float u_WaveScale;\r\nuniform vec4 u_WaveSpeed;\r\nuniform float u_Time;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionWorld = u_WorldMat * a_Position;\r\n\tvec4 position = u_MvpMatrix * a_Position;\r\n\t\r\n\tvec4 temp = vec4(positionWorld.x, positionWorld.z, positionWorld.x, positionWorld.z) * u_WaveScale + u_WaveSpeed * u_WaveScale * u_Time;\r\n\t\r\n\tv_Texcoord0 = temp.xy * vec2(0.4, 0.45);\r\n\tv_Texcoord1 = temp.wz;\r\n\t\r\n\tmat3 worldMat = mat3(u_WorldMat);\r\n\tv_Normal = worldMat * a_Normal;\r\n\tv_Tangent = worldMat * a_Tangent0.xyz;\r\n\tv_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\r\n\t\r\n\tv_ViewDir = u_CameraPos - positionWorld.xyz;\r\n\tgl_Position = position;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}';

        class ShaderInit3D {
            constructor() {
            }

            static __init__() {
                ShaderInit3D._rangeAttenTex = Utils3D._buildTexture2D(1024, 1, Laya.BaseTexture.FORMAT_ALPHA8, TextureGenerator.lightAttenTexture), ShaderInit3D._rangeAttenTex.wrapModeU = Laya.BaseTexture.WARPMODE_CLAMP, ShaderInit3D._rangeAttenTex.wrapModeV = Laya.BaseTexture.WARPMODE_CLAMP, ShaderInit3D._rangeAttenTex.lock = !0, Shader3D.SHADERDEFINE_HIGHPRECISION = Shader3D.registerPublicDefine("HIGHPRECISION"), Shader3D.addInclude("Lighting.glsl", LightingGLSL), Shader3D.addInclude("ShadowHelper.glsl", ShadowHelperGLSL), Shader3D.addInclude("BRDF.glsl", BRDFGLSL), Shader3D.addInclude("PBRUtils.glsl", PBRUtilsGLSL), Shader3D.addInclude("PBRStandardLighting.glsl", PBRStandardLightingGLSL), Shader3D.addInclude("PBRSpecularLighting.glsl", PBRSpecularLightingGLSL), Shader3D.addInclude("Colors.glsl", ColorsGLSL), Shader3D.addInclude("Sampling.glsl", SamplingGLSL), Shader3D.addInclude("StdLib.glsl", StdLibGLSL);
                var attributeMap = {
                        a_Position: VertexMesh.MESH_POSITION0,
                        a_Color: VertexMesh.MESH_COLOR0,
                        a_Normal: VertexMesh.MESH_NORMAL0,
                        a_Texcoord0: VertexMesh.MESH_TEXTURECOORDINATE0,
                        a_Texcoord1: VertexMesh.MESH_TEXTURECOORDINATE1,
                        a_BoneWeights: VertexMesh.MESH_BLENDWEIGHT0,
                        a_BoneIndices: VertexMesh.MESH_BLENDINDICES0,
                        a_Tangent0: VertexMesh.MESH_TANGENT0,
                        a_MvpMatrix: VertexMesh.MESH_MVPMATRIX_ROW0,
                        a_WorldMat: VertexMesh.MESH_WORLDMATRIX_ROW0
                    }, uniformMap = {
                        u_Bones: Shader3D.PERIOD_CUSTOM,
                        u_DiffuseTexture: Shader3D.PERIOD_MATERIAL,
                        u_SpecularTexture: Shader3D.PERIOD_MATERIAL,
                        u_NormalTexture: Shader3D.PERIOD_MATERIAL,
                        u_AlphaTestValue: Shader3D.PERIOD_MATERIAL,
                        u_DiffuseColor: Shader3D.PERIOD_MATERIAL,
                        u_MaterialSpecular: Shader3D.PERIOD_MATERIAL,
                        u_Shininess: Shader3D.PERIOD_MATERIAL,
                        u_TilingOffset: Shader3D.PERIOD_MATERIAL,
                        u_WorldMat: Shader3D.PERIOD_SPRITE,
                        u_MvpMatrix: Shader3D.PERIOD_SPRITE,
                        u_LightmapScaleOffset: Shader3D.PERIOD_SPRITE,
                        u_LightMap: Shader3D.PERIOD_SPRITE,
                        u_CameraPos: Shader3D.PERIOD_CAMERA,
                        u_ReflectTexture: Shader3D.PERIOD_SCENE,
                        u_ReflectIntensity: Shader3D.PERIOD_SCENE,
                        u_FogStart: Shader3D.PERIOD_SCENE,
                        u_FogRange: Shader3D.PERIOD_SCENE,
                        u_FogColor: Shader3D.PERIOD_SCENE,
                        "u_DirectionLight.Color": Shader3D.PERIOD_SCENE,
                        "u_DirectionLight.Direction": Shader3D.PERIOD_SCENE,
                        "u_PointLight.Position": Shader3D.PERIOD_SCENE,
                        "u_PointLight.Range": Shader3D.PERIOD_SCENE,
                        "u_PointLight.Color": Shader3D.PERIOD_SCENE,
                        "u_SpotLight.Position": Shader3D.PERIOD_SCENE,
                        "u_SpotLight.Direction": Shader3D.PERIOD_SCENE,
                        "u_SpotLight.Range": Shader3D.PERIOD_SCENE,
                        "u_SpotLight.Spot": Shader3D.PERIOD_SCENE,
                        "u_SpotLight.Color": Shader3D.PERIOD_SCENE,
                        u_AmbientColor: Shader3D.PERIOD_SCENE,
                        u_shadowMap1: Shader3D.PERIOD_SCENE,
                        u_shadowMap2: Shader3D.PERIOD_SCENE,
                        u_shadowMap3: Shader3D.PERIOD_SCENE,
                        u_shadowPSSMDistance: Shader3D.PERIOD_SCENE,
                        u_lightShadowVP: Shader3D.PERIOD_SCENE,
                        u_shadowPCFoffset: Shader3D.PERIOD_SCENE
                    }, stateMap = {
                        s_Cull: Shader3D.RENDER_STATE_CULL,
                        s_Blend: Shader3D.RENDER_STATE_BLEND,
                        s_BlendSrc: Shader3D.RENDER_STATE_BLEND_SRC,
                        s_BlendDst: Shader3D.RENDER_STATE_BLEND_DST,
                        s_DepthTest: Shader3D.RENDER_STATE_DEPTH_TEST,
                        s_DepthWrite: Shader3D.RENDER_STATE_DEPTH_WRITE
                    }, shader = Shader3D.add("BLINNPHONG", null, null, !0),
                    subShader = new SubShader(attributeMap, uniformMap, SkinnedMeshSprite3D.shaderDefines, BlinnPhongMaterial.shaderDefines);
                shader.addSubShader(subShader), subShader.addShaderPass(MeshBlinnPhongVS, MeshBlinnPhongPS, stateMap), attributeMap = {
                    a_Position: VertexMesh.MESH_POSITION0,
                    a_Color: VertexMesh.MESH_COLOR0
                }, uniformMap = {
                    u_MvpMatrix: Shader3D.PERIOD_SPRITE,
                    u_Color: Shader3D.PERIOD_MATERIAL
                }, stateMap = {
                    s_Cull: Shader3D.RENDER_STATE_CULL,
                    s_Blend: Shader3D.RENDER_STATE_BLEND,
                    s_BlendSrc: Shader3D.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: Shader3D.RENDER_STATE_BLEND_DST,
                    s_DepthTest: Shader3D.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: Shader3D.RENDER_STATE_DEPTH_WRITE
                }, shader = Shader3D.add("LineShader"), subShader = new SubShader(attributeMap, uniformMap), shader.addSubShader(subShader), subShader.addShaderPass(lineVS, linePS, stateMap), attributeMap = {
                    a_Position: VertexMesh.MESH_POSITION0,
                    a_Normal: VertexMesh.MESH_NORMAL0,
                    a_Tangent0: VertexMesh.MESH_TANGENT0,
                    a_Texcoord0: VertexMesh.MESH_TEXTURECOORDINATE0,
                    a_BoneWeights: VertexMesh.MESH_BLENDWEIGHT0,
                    a_BoneIndices: VertexMesh.MESH_BLENDINDICES0,
                    a_MvpMatrix: VertexMesh.MESH_MVPMATRIX_ROW0,
                    a_WorldMat: VertexMesh.MESH_WORLDMATRIX_ROW0
                }, uniformMap = {
                    u_Bones: Shader3D.PERIOD_CUSTOM,
                    u_MvpMatrix: Shader3D.PERIOD_SPRITE,
                    u_WorldMat: Shader3D.PERIOD_SPRITE,
                    u_CameraPos: Shader3D.PERIOD_CAMERA,
                    u_AlphaTestValue: Shader3D.PERIOD_MATERIAL,
                    u_AlbedoColor: Shader3D.PERIOD_MATERIAL,
                    u_EmissionColor: Shader3D.PERIOD_MATERIAL,
                    u_AlbedoTexture: Shader3D.PERIOD_MATERIAL,
                    u_NormalTexture: Shader3D.PERIOD_MATERIAL,
                    u_ParallaxTexture: Shader3D.PERIOD_MATERIAL,
                    u_MetallicGlossTexture: Shader3D.PERIOD_MATERIAL,
                    u_OcclusionTexture: Shader3D.PERIOD_MATERIAL,
                    u_EmissionTexture: Shader3D.PERIOD_MATERIAL,
                    u_metallic: Shader3D.PERIOD_MATERIAL,
                    u_smoothness: Shader3D.PERIOD_MATERIAL,
                    u_smoothnessScale: Shader3D.PERIOD_MATERIAL,
                    u_occlusionStrength: Shader3D.PERIOD_MATERIAL,
                    u_normalScale: Shader3D.PERIOD_MATERIAL,
                    u_parallaxScale: Shader3D.PERIOD_MATERIAL,
                    u_TilingOffset: Shader3D.PERIOD_MATERIAL,
                    "u_DirectionLight.Direction": Shader3D.PERIOD_SCENE,
                    "u_DirectionLight.Color": Shader3D.PERIOD_SCENE,
                    u_PointLightMatrix: Shader3D.PERIOD_SCENE,
                    "u_PointLight.Position": Shader3D.PERIOD_SCENE,
                    "u_PointLight.Range": Shader3D.PERIOD_SCENE,
                    "u_PointLight.Color": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Position": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Direction": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Range": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.SpotAngle": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Color": Shader3D.PERIOD_SCENE,
                    u_RangeTexture: Shader3D.PERIOD_SCENE,
                    u_ReflectTexture: Shader3D.PERIOD_SCENE,
                    u_ReflectIntensity: Shader3D.PERIOD_SCENE,
                    u_AmbientColor: Shader3D.PERIOD_SCENE,
                    u_shadowMap1: Shader3D.PERIOD_SCENE,
                    u_shadowMap2: Shader3D.PERIOD_SCENE,
                    u_shadowMap3: Shader3D.PERIOD_SCENE,
                    u_shadowPSSMDistance: Shader3D.PERIOD_SCENE,
                    u_lightShadowVP: Shader3D.PERIOD_SCENE,
                    u_shadowPCFoffset: Shader3D.PERIOD_SCENE,
                    u_FogStart: Shader3D.PERIOD_SCENE,
                    u_FogRange: Shader3D.PERIOD_SCENE,
                    u_FogColor: Shader3D.PERIOD_SCENE
                }, stateMap = {
                    s_Cull: Shader3D.RENDER_STATE_CULL,
                    s_Blend: Shader3D.RENDER_STATE_BLEND,
                    s_BlendSrc: Shader3D.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: Shader3D.RENDER_STATE_BLEND_DST,
                    s_DepthTest: Shader3D.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: Shader3D.RENDER_STATE_DEPTH_WRITE
                }, shader = Shader3D.add("PBRStandard", null, null, !0), subShader = new SubShader(attributeMap, uniformMap, SkinnedMeshSprite3D.shaderDefines, PBRStandardMaterial.shaderDefines), shader.addSubShader(subShader), subShader.addShaderPass(PBRStandardVS, PBRStandardPS, stateMap), attributeMap = {
                    a_Position: VertexMesh.MESH_POSITION0,
                    a_Normal: VertexMesh.MESH_NORMAL0,
                    a_Tangent0: VertexMesh.MESH_TANGENT0,
                    a_Texcoord0: VertexMesh.MESH_TEXTURECOORDINATE0,
                    a_BoneWeights: VertexMesh.MESH_BLENDWEIGHT0,
                    a_BoneIndices: VertexMesh.MESH_BLENDINDICES0,
                    a_MvpMatrix: VertexMesh.MESH_MVPMATRIX_ROW0,
                    a_WorldMat: VertexMesh.MESH_WORLDMATRIX_ROW0
                }, uniformMap = {
                    u_Bones: Shader3D.PERIOD_CUSTOM,
                    u_MvpMatrix: Shader3D.PERIOD_SPRITE,
                    u_WorldMat: Shader3D.PERIOD_SPRITE,
                    u_CameraPos: Shader3D.PERIOD_CAMERA,
                    u_AlphaTestValue: Shader3D.PERIOD_MATERIAL,
                    u_AlbedoColor: Shader3D.PERIOD_MATERIAL,
                    u_SpecularColor: Shader3D.PERIOD_MATERIAL,
                    u_EmissionColor: Shader3D.PERIOD_MATERIAL,
                    u_AlbedoTexture: Shader3D.PERIOD_MATERIAL,
                    u_NormalTexture: Shader3D.PERIOD_MATERIAL,
                    u_ParallaxTexture: Shader3D.PERIOD_MATERIAL,
                    u_SpecularTexture: Shader3D.PERIOD_MATERIAL,
                    u_OcclusionTexture: Shader3D.PERIOD_MATERIAL,
                    u_EmissionTexture: Shader3D.PERIOD_MATERIAL,
                    u_smoothness: Shader3D.PERIOD_MATERIAL,
                    u_smoothnessScale: Shader3D.PERIOD_MATERIAL,
                    u_occlusionStrength: Shader3D.PERIOD_MATERIAL,
                    u_normalScale: Shader3D.PERIOD_MATERIAL,
                    u_parallaxScale: Shader3D.PERIOD_MATERIAL,
                    u_TilingOffset: Shader3D.PERIOD_MATERIAL,
                    "u_DirectionLight.Direction": Shader3D.PERIOD_SCENE,
                    "u_DirectionLight.Color": Shader3D.PERIOD_SCENE,
                    u_PointLightMatrix: Shader3D.PERIOD_SCENE,
                    "u_PointLight.Position": Shader3D.PERIOD_SCENE,
                    "u_PointLight.Range": Shader3D.PERIOD_SCENE,
                    "u_PointLight.Color": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Position": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Direction": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Range": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.SpotAngle": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Color": Shader3D.PERIOD_SCENE,
                    u_RangeTexture: Shader3D.PERIOD_SCENE,
                    u_ReflectTexture: Shader3D.PERIOD_SCENE,
                    u_ReflectIntensity: Shader3D.PERIOD_SCENE,
                    u_AmbientColor: Shader3D.PERIOD_SCENE,
                    u_shadowMap1: Shader3D.PERIOD_SCENE,
                    u_shadowMap2: Shader3D.PERIOD_SCENE,
                    u_shadowMap3: Shader3D.PERIOD_SCENE,
                    u_shadowPSSMDistance: Shader3D.PERIOD_SCENE,
                    u_lightShadowVP: Shader3D.PERIOD_SCENE,
                    u_shadowPCFoffset: Shader3D.PERIOD_SCENE,
                    u_FogStart: Shader3D.PERIOD_SCENE,
                    u_FogRange: Shader3D.PERIOD_SCENE,
                    u_FogColor: Shader3D.PERIOD_SCENE
                }, stateMap = {
                    s_Cull: Shader3D.RENDER_STATE_CULL,
                    s_Blend: Shader3D.RENDER_STATE_BLEND,
                    s_BlendSrc: Shader3D.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: Shader3D.RENDER_STATE_BLEND_DST,
                    s_DepthTest: Shader3D.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: Shader3D.RENDER_STATE_DEPTH_WRITE
                }, shader = Shader3D.add("PBRSpecular", null, null, !0), subShader = new SubShader(attributeMap, uniformMap, SkinnedMeshSprite3D.shaderDefines, PBRSpecularMaterial.shaderDefines), shader.addSubShader(subShader), subShader.addShaderPass(PBRSpecularVS, PBRSpecularPS, stateMap), attributeMap = {
                    a_Position: VertexMesh.MESH_POSITION0,
                    a_Color: VertexMesh.MESH_COLOR0,
                    a_Texcoord0: VertexMesh.MESH_TEXTURECOORDINATE0,
                    a_BoneWeights: VertexMesh.MESH_BLENDWEIGHT0,
                    a_BoneIndices: VertexMesh.MESH_BLENDINDICES0,
                    a_MvpMatrix: VertexMesh.MESH_MVPMATRIX_ROW0
                }, uniformMap = {
                    u_Bones: Shader3D.PERIOD_CUSTOM,
                    u_AlbedoTexture: Shader3D.PERIOD_MATERIAL,
                    u_AlbedoColor: Shader3D.PERIOD_MATERIAL,
                    u_TilingOffset: Shader3D.PERIOD_MATERIAL,
                    u_AlphaTestValue: Shader3D.PERIOD_MATERIAL,
                    u_MvpMatrix: Shader3D.PERIOD_SPRITE,
                    u_FogStart: Shader3D.PERIOD_SCENE,
                    u_FogRange: Shader3D.PERIOD_SCENE,
                    u_FogColor: Shader3D.PERIOD_SCENE
                }, stateMap = {
                    s_Cull: Shader3D.RENDER_STATE_CULL,
                    s_Blend: Shader3D.RENDER_STATE_BLEND,
                    s_BlendSrc: Shader3D.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: Shader3D.RENDER_STATE_BLEND_DST,
                    s_DepthTest: Shader3D.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: Shader3D.RENDER_STATE_DEPTH_WRITE
                }, shader = Shader3D.add("Unlit", null, null, !0), subShader = new SubShader(attributeMap, uniformMap, SkinnedMeshSprite3D.shaderDefines, UnlitMaterial.shaderDefines), shader.addSubShader(subShader), subShader.addShaderPass(UnlitVS, UnlitPS, stateMap), attributeMap = {
                    a_Position: VertexMesh.MESH_POSITION0,
                    a_Texcoord0: VertexMesh.MESH_TEXTURECOORDINATE0,
                    a_BoneWeights: VertexMesh.MESH_BLENDWEIGHT0,
                    a_BoneIndices: VertexMesh.MESH_BLENDINDICES0,
                    a_MvpMatrix: VertexMesh.MESH_MVPMATRIX_ROW0
                }, uniformMap = {
                    u_Bones: Shader3D.PERIOD_CUSTOM,
                    u_AlbedoTexture: Shader3D.PERIOD_MATERIAL,
                    u_AlbedoColor: Shader3D.PERIOD_MATERIAL,
                    u_TilingOffset: Shader3D.PERIOD_MATERIAL,
                    u_AlphaTestValue: Shader3D.PERIOD_MATERIAL,
                    u_MvpMatrix: Shader3D.PERIOD_SPRITE,
                    u_FogStart: Shader3D.PERIOD_SCENE,
                    u_FogRange: Shader3D.PERIOD_SCENE,
                    u_FogColor: Shader3D.PERIOD_SCENE
                }, stateMap = {
                    s_Cull: Shader3D.RENDER_STATE_CULL,
                    s_Blend: Shader3D.RENDER_STATE_BLEND,
                    s_BlendSrc: Shader3D.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: Shader3D.RENDER_STATE_BLEND_DST,
                    s_DepthTest: Shader3D.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: Shader3D.RENDER_STATE_DEPTH_WRITE
                }, shader = Shader3D.add("Effect", null, null, !0), subShader = new SubShader(attributeMap, uniformMap, SkinnedMeshSprite3D.shaderDefines, EffectMaterial.shaderDefines), shader.addSubShader(subShader), subShader.addShaderPass(EffectVS, EffectPS, stateMap), attributeMap = {
                    a_CornerTextureCoordinate: VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0,
                    a_MeshPosition: VertexShuriKenParticle.PARTICLE_POSITION0,
                    a_MeshColor: VertexShuriKenParticle.PARTICLE_COLOR0,
                    a_MeshTextureCoordinate: VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0,
                    a_ShapePositionStartLifeTime: VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME,
                    a_DirectionTime: VertexShuriKenParticle.PARTICLE_DIRECTIONTIME,
                    a_StartColor: VertexShuriKenParticle.PARTICLE_STARTCOLOR0,
                    a_EndColor: VertexShuriKenParticle.PARTICLE_ENDCOLOR0,
                    a_StartSize: VertexShuriKenParticle.PARTICLE_STARTSIZE,
                    a_StartRotation0: VertexShuriKenParticle.PARTICLE_STARTROTATION,
                    a_StartSpeed: VertexShuriKenParticle.PARTICLE_STARTSPEED,
                    a_Random0: VertexShuriKenParticle.PARTICLE_RANDOM0,
                    a_Random1: VertexShuriKenParticle.PARTICLE_RANDOM1,
                    a_SimulationWorldPostion: VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION,
                    a_SimulationWorldRotation: VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION
                }, uniformMap = {
                    u_Tintcolor: Shader3D.PERIOD_MATERIAL,
                    u_TilingOffset: Shader3D.PERIOD_MATERIAL,
                    u_texture: Shader3D.PERIOD_MATERIAL,
                    u_WorldPosition: Shader3D.PERIOD_SPRITE,
                    u_WorldRotation: Shader3D.PERIOD_SPRITE,
                    u_PositionScale: Shader3D.PERIOD_SPRITE,
                    u_SizeScale: Shader3D.PERIOD_SPRITE,
                    u_ScalingMode: Shader3D.PERIOD_SPRITE,
                    u_Gravity: Shader3D.PERIOD_SPRITE,
                    u_ThreeDStartRotation: Shader3D.PERIOD_SPRITE,
                    u_StretchedBillboardLengthScale: Shader3D.PERIOD_SPRITE,
                    u_StretchedBillboardSpeedScale: Shader3D.PERIOD_SPRITE,
                    u_SimulationSpace: Shader3D.PERIOD_SPRITE,
                    u_CurrentTime: Shader3D.PERIOD_SPRITE,
                    u_ColorOverLifeGradientAlphas: Shader3D.PERIOD_SPRITE,
                    u_ColorOverLifeGradientColors: Shader3D.PERIOD_SPRITE,
                    u_MaxColorOverLifeGradientAlphas: Shader3D.PERIOD_SPRITE,
                    u_MaxColorOverLifeGradientColors: Shader3D.PERIOD_SPRITE,
                    u_VOLVelocityConst: Shader3D.PERIOD_SPRITE,
                    u_VOLVelocityGradientX: Shader3D.PERIOD_SPRITE,
                    u_VOLVelocityGradientY: Shader3D.PERIOD_SPRITE,
                    u_VOLVelocityGradientZ: Shader3D.PERIOD_SPRITE,
                    u_VOLVelocityConstMax: Shader3D.PERIOD_SPRITE,
                    u_VOLVelocityGradientMaxX: Shader3D.PERIOD_SPRITE,
                    u_VOLVelocityGradientMaxY: Shader3D.PERIOD_SPRITE,
                    u_VOLVelocityGradientMaxZ: Shader3D.PERIOD_SPRITE,
                    u_VOLSpaceType: Shader3D.PERIOD_SPRITE,
                    u_SOLSizeGradient: Shader3D.PERIOD_SPRITE,
                    u_SOLSizeGradientX: Shader3D.PERIOD_SPRITE,
                    u_SOLSizeGradientY: Shader3D.PERIOD_SPRITE,
                    u_SOLSizeGradientZ: Shader3D.PERIOD_SPRITE,
                    u_SOLSizeGradientMax: Shader3D.PERIOD_SPRITE,
                    u_SOLSizeGradientMaxX: Shader3D.PERIOD_SPRITE,
                    u_SOLSizeGradientMaxY: Shader3D.PERIOD_SPRITE,
                    u_SOLSizeGradientMaxZ: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityConst: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityConstSeprarate: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradient: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientX: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientY: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientZ: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityConstMax: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityConstMaxSeprarate: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMax: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxX: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxY: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxZ: Shader3D.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxW: Shader3D.PERIOD_SPRITE,
                    u_TSACycles: Shader3D.PERIOD_SPRITE,
                    u_TSASubUVLength: Shader3D.PERIOD_SPRITE,
                    u_TSAGradientUVs: Shader3D.PERIOD_SPRITE,
                    u_TSAMaxGradientUVs: Shader3D.PERIOD_SPRITE,
                    u_CameraPos: Shader3D.PERIOD_CAMERA,
                    u_CameraDirection: Shader3D.PERIOD_CAMERA,
                    u_CameraUp: Shader3D.PERIOD_CAMERA,
                    u_View: Shader3D.PERIOD_CAMERA,
                    u_Projection: Shader3D.PERIOD_CAMERA,
                    u_FogStart: Shader3D.PERIOD_SCENE,
                    u_FogRange: Shader3D.PERIOD_SCENE,
                    u_FogColor: Shader3D.PERIOD_SCENE
                }, stateMap = {
                    s_Cull: Shader3D.RENDER_STATE_CULL,
                    s_Blend: Shader3D.RENDER_STATE_BLEND,
                    s_BlendSrc: Shader3D.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: Shader3D.RENDER_STATE_BLEND_DST,
                    s_DepthTest: Shader3D.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: Shader3D.RENDER_STATE_DEPTH_WRITE
                }, shader = Shader3D.add("PARTICLESHURIKEN"), subShader = new SubShader(attributeMap, uniformMap, ShuriKenParticle3D.shaderDefines, ShurikenParticleMaterial.shaderDefines), shader.addSubShader(subShader), subShader.addShaderPass(ParticleShuriKenVS, ParticleShuriKenPS, stateMap), attributeMap = {a_Position: VertexMesh.MESH_POSITION0}, uniformMap = {
                    u_TintColor: Shader3D.PERIOD_MATERIAL,
                    u_Exposure: Shader3D.PERIOD_MATERIAL,
                    u_Rotation: Shader3D.PERIOD_MATERIAL,
                    u_CubeTexture: Shader3D.PERIOD_MATERIAL,
                    u_ViewProjection: Shader3D.PERIOD_CAMERA
                }, shader = Shader3D.add("SkyBox"), subShader = new SubShader(attributeMap, uniformMap), shader.addSubShader(subShader), subShader.addShaderPass(SkyBoxVS, SkyBoxPS), attributeMap = {a_Position: VertexMesh.MESH_POSITION0}, uniformMap = {
                    u_SunSize: Shader3D.PERIOD_MATERIAL,
                    u_SunSizeConvergence: Shader3D.PERIOD_MATERIAL,
                    u_AtmosphereThickness: Shader3D.PERIOD_MATERIAL,
                    u_SkyTint: Shader3D.PERIOD_MATERIAL,
                    u_GroundTint: Shader3D.PERIOD_MATERIAL,
                    u_Exposure: Shader3D.PERIOD_MATERIAL,
                    u_ViewProjection: Shader3D.PERIOD_CAMERA,
                    "u_DirectionLight.Direction": Shader3D.PERIOD_SCENE,
                    "u_DirectionLight.Color": Shader3D.PERIOD_SCENE
                }, shader = Shader3D.add("SkyBoxProcedural"), subShader = new SubShader(attributeMap, uniformMap, null, SkyProceduralMaterial.shaderDefines), shader.addSubShader(subShader), subShader.addShaderPass(SkyBoxProceduralVS, SkyBoxProceduralPS), attributeMap = {
                    a_Position: VertexMesh.MESH_POSITION0,
                    a_Normal: VertexMesh.MESH_NORMAL0,
                    a_Texcoord0: VertexMesh.MESH_TEXTURECOORDINATE0
                }, uniformMap = {
                    u_MvpMatrix: Shader3D.PERIOD_SPRITE,
                    u_WorldMat: Shader3D.PERIOD_SPRITE,
                    u_CameraPos: Shader3D.PERIOD_CAMERA,
                    u_LightmapScaleOffset: Shader3D.PERIOD_SPRITE,
                    u_LightMap: Shader3D.PERIOD_SPRITE,
                    u_SplatAlphaTexture: Shader3D.PERIOD_MATERIAL,
                    u_DiffuseTexture1: Shader3D.PERIOD_MATERIAL,
                    u_DiffuseTexture2: Shader3D.PERIOD_MATERIAL,
                    u_DiffuseTexture3: Shader3D.PERIOD_MATERIAL,
                    u_DiffuseTexture4: Shader3D.PERIOD_MATERIAL,
                    u_DiffuseTexture5: Shader3D.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset1: Shader3D.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset2: Shader3D.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset3: Shader3D.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset4: Shader3D.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset5: Shader3D.PERIOD_MATERIAL,
                    u_FogStart: Shader3D.PERIOD_SCENE,
                    u_FogRange: Shader3D.PERIOD_SCENE,
                    u_FogColor: Shader3D.PERIOD_SCENE,
                    "u_DirectionLight.Direction": Shader3D.PERIOD_SCENE,
                    "u_DirectionLight.Color": Shader3D.PERIOD_SCENE,
                    "u_PointLight.Position": Shader3D.PERIOD_SCENE,
                    "u_PointLight.Range": Shader3D.PERIOD_SCENE,
                    "u_PointLight.Attenuation": Shader3D.PERIOD_SCENE,
                    "u_PointLight.Color": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Position": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Direction": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Range": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Spot": Shader3D.PERIOD_SCENE,
                    "u_SpotLight.Color": Shader3D.PERIOD_SCENE,
                    u_AmbientColor: Shader3D.PERIOD_SCENE,
                    u_shadowMap1: Shader3D.PERIOD_SCENE,
                    u_shadowMap2: Shader3D.PERIOD_SCENE,
                    u_shadowMap3: Shader3D.PERIOD_SCENE,
                    u_shadowPSSMDistance: Shader3D.PERIOD_SCENE,
                    u_lightShadowVP: Shader3D.PERIOD_SCENE,
                    u_shadowPCFoffset: Shader3D.PERIOD_SCENE
                }, stateMap = {
                    s_Cull: Shader3D.RENDER_STATE_CULL,
                    s_Blend: Shader3D.RENDER_STATE_BLEND,
                    s_BlendSrc: Shader3D.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: Shader3D.RENDER_STATE_BLEND_DST,
                    s_DepthTest: Shader3D.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: Shader3D.RENDER_STATE_DEPTH_WRITE
                }, shader = Shader3D.add("ExtendTerrain"), subShader = new SubShader(attributeMap, uniformMap, RenderableSprite3D.shaderDefines, ExtendTerrainMaterial.shaderDefines), shader.addSubShader(subShader), subShader.addShaderPass(extendTerrainVS, extendTerrainPS, stateMap), attributeMap = {
                    a_Position: VertexTrail.TRAIL_POSITION0,
                    a_OffsetVector: VertexTrail.TRAIL_OFFSETVECTOR,
                    a_Texcoord0X: VertexTrail.TRAIL_TEXTURECOORDINATE0X,
                    a_Texcoord0Y: VertexTrail.TRAIL_TEXTURECOORDINATE0Y,
                    a_BirthTime: VertexTrail.TRAIL_TIME0,
                    a_Color: VertexTrail.TRAIL_COLOR
                }, uniformMap = {
                    u_MvpMatrix: Shader3D.PERIOD_SPRITE,
                    u_View: Shader3D.PERIOD_CAMERA,
                    u_Projection: Shader3D.PERIOD_CAMERA,
                    u_TilingOffset: Shader3D.PERIOD_MATERIAL,
                    u_MainTexture: Shader3D.PERIOD_MATERIAL,
                    u_MainColor: Shader3D.PERIOD_MATERIAL,
                    u_CurTime: Shader3D.PERIOD_SPRITE,
                    u_LifeTime: Shader3D.PERIOD_SPRITE,
                    u_WidthCurve: Shader3D.PERIOD_SPRITE,
                    u_WidthCurveKeyLength: Shader3D.PERIOD_SPRITE,
                    u_GradientColorkey: Shader3D.PERIOD_SPRITE,
                    u_GradientAlphakey: Shader3D.PERIOD_SPRITE
                }, stateMap = {
                    s_Cull: Shader3D.RENDER_STATE_CULL,
                    s_Blend: Shader3D.RENDER_STATE_BLEND,
                    s_BlendSrc: Shader3D.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: Shader3D.RENDER_STATE_BLEND_DST,
                    s_DepthTest: Shader3D.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: Shader3D.RENDER_STATE_DEPTH_WRITE
                }, shader = Shader3D.add("Trail"), subShader = new SubShader(attributeMap, uniformMap, TrailSprite3D.shaderDefines, TrailMaterial.shaderDefines), shader.addSubShader(subShader), subShader.addShaderPass(TrailVS, TrailPS, stateMap), attributeMap = {
                    a_Position: VertexMesh.MESH_POSITION0,
                    a_Normal: VertexMesh.MESH_NORMAL0,
                    a_Tangent0: VertexMesh.MESH_TANGENT0
                }, uniformMap = {
                    u_MvpMatrix: Shader3D.PERIOD_SPRITE,
                    u_WorldMat: Shader3D.PERIOD_SPRITE,
                    u_CameraPos: Shader3D.PERIOD_CAMERA,
                    u_Time: Shader3D.PERIOD_SCENE,
                    u_MainTexture: Shader3D.PERIOD_MATERIAL,
                    u_NormalTexture: Shader3D.PERIOD_MATERIAL,
                    u_HorizonColor: Shader3D.PERIOD_MATERIAL,
                    u_WaveScale: Shader3D.PERIOD_MATERIAL,
                    u_WaveSpeed: Shader3D.PERIOD_MATERIAL
                }, shader = Shader3D.add("WaterPrimary"), subShader = new SubShader(attributeMap, uniformMap, null, WaterPrimaryMaterial.shaderDefines), shader.addSubShader(subShader), subShader.addShaderPass(WaterPrimaryVS, WaterPrimaryPS), attributeMap = {a_PositionTexcoord: VertexMesh.MESH_POSITION0}, uniformMap = {u_MainTex: Shader3D.PERIOD_MATERIAL}, shader = Shader3D.add("BlitScreen"), subShader = new SubShader(attributeMap, uniformMap, null, null), shader.addSubShader(subShader);
                var shaderPass = subShader.addShaderPass(BlitScreenVS, BlitScreenPS),
                    renderState = shaderPass.renderState;
                renderState.depthTest = RenderState.DEPTHTEST_ALWAYS, renderState.depthWrite = !1, renderState.cull = RenderState.CULL_NONE, renderState.blend = RenderState.BLEND_DISABLE, attributeMap = {a_PositionTexcoord: VertexMesh.MESH_POSITION0}, uniformMap = {
                    u_MainTex: Shader3D.PERIOD_MATERIAL,
                    u_BloomTex: Shader3D.PERIOD_MATERIAL,
                    u_AutoExposureTex: Shader3D.PERIOD_MATERIAL,
                    u_MainTex_TexelSize: Shader3D.PERIOD_MATERIAL,
                    u_SampleScale: Shader3D.PERIOD_MATERIAL,
                    u_Threshold: Shader3D.PERIOD_MATERIAL,
                    u_Params: Shader3D.PERIOD_MATERIAL
                }, shader = Shader3D.add("PostProcessBloom", attributeMap, uniformMap), subShader = new SubShader(null, null, null, null), shader.addSubShader(subShader), (renderState = (shaderPass = subShader.addShaderPass(BloomVS, BloomPrefilter13PS)).renderState).depthTest = RenderState.DEPTHTEST_ALWAYS, renderState.depthWrite = !1, renderState.cull = RenderState.CULL_NONE, renderState.blend = RenderState.BLEND_DISABLE, subShader = new SubShader(null, null, null, null), shader.addSubShader(subShader), (renderState = (shaderPass = subShader.addShaderPass(BloomVS, BloomPrefilter4PS)).renderState).depthTest = RenderState.DEPTHTEST_ALWAYS, renderState.depthWrite = !1, renderState.cull = RenderState.CULL_NONE, renderState.blend = RenderState.BLEND_DISABLE, subShader = new SubShader(null, null, null, null), shader.addSubShader(subShader), (renderState = (shaderPass = subShader.addShaderPass(BloomVS, BloomDownsample13PS)).renderState).depthTest = RenderState.DEPTHTEST_ALWAYS, renderState.depthWrite = !1, renderState.cull = RenderState.CULL_NONE, renderState.blend = RenderState.BLEND_DISABLE, subShader = new SubShader(null, null, null, null), shader.addSubShader(subShader), (renderState = (shaderPass = subShader.addShaderPass(BloomVS, BloomDownsample4PS)).renderState).depthTest = RenderState.DEPTHTEST_ALWAYS, renderState.depthWrite = !1, renderState.cull = RenderState.CULL_NONE, renderState.blend = RenderState.BLEND_DISABLE, subShader = new SubShader(null, null, null, null), shader.addSubShader(subShader), (renderState = (shaderPass = subShader.addShaderPass(BloomVS, BloomUpsampleTentPS)).renderState).depthTest = RenderState.DEPTHTEST_ALWAYS, renderState.depthWrite = !1, renderState.cull = RenderState.CULL_NONE, renderState.blend = RenderState.BLEND_DISABLE, subShader = new SubShader(null, null, null, null), shader.addSubShader(subShader), (renderState = (shaderPass = subShader.addShaderPass(BloomVS, BloomUpsampleBoxPS)).renderState).depthTest = RenderState.DEPTHTEST_ALWAYS, renderState.depthWrite = !1, renderState.cull = RenderState.CULL_NONE, renderState.blend = RenderState.BLEND_DISABLE, attributeMap = {a_PositionTexcoord: VertexMesh.MESH_POSITION0}, uniformMap = {
                    u_MainTex: Shader3D.PERIOD_MATERIAL,
                    u_BloomTex: Shader3D.PERIOD_MATERIAL,
                    u_AutoExposureTex: Shader3D.PERIOD_MATERIAL,
                    u_Bloom_DirtTileOffset: Shader3D.PERIOD_MATERIAL,
                    u_Bloom_DirtTex: Shader3D.PERIOD_MATERIAL,
                    u_BloomTex_TexelSize: Shader3D.PERIOD_MATERIAL,
                    u_Bloom_Settings: Shader3D.PERIOD_MATERIAL,
                    u_Bloom_Color: Shader3D.PERIOD_MATERIAL
                }, shader = Shader3D.add("PostProcessComposite", attributeMap, uniformMap), subShader = new SubShader(null, null, null, PostProcess.shaderDefines), shader.addSubShader(subShader), (renderState = (shaderPass = subShader.addShaderPass(CompositeVS, CompositePS)).renderState).depthTest = RenderState.DEPTHTEST_ALWAYS, renderState.depthWrite = !1, renderState.cull = RenderState.CULL_NONE, renderState.blend = RenderState.BLEND_DISABLE
            }
        }

        class PixelLineMaterial extends BaseMaterial {
            constructor() {
                super(), this.setShaderName("LineShader"), this._shaderValues.setVector(PixelLineMaterial.COLOR, new Vector4(1, 1, 1, 1))
            }

            static __initDefine__() {
                PixelLineMaterial.shaderDefines = new ShaderDefines(BaseMaterial.shaderDefines)
            }

            get color() {
                return this._shaderValues.getVector(PixelLineMaterial.COLOR)
            }

            set color(value) {
                this._shaderValues.setVector(PixelLineMaterial.COLOR, value)
            }

            set depthWrite(value) {
                this._shaderValues.setBool(PixelLineMaterial.DEPTH_WRITE, value)
            }

            get depthWrite() {
                return this._shaderValues.getBool(PixelLineMaterial.DEPTH_WRITE)
            }

            set cull(value) {
                this._shaderValues.setInt(PixelLineMaterial.CULL, value)
            }

            get cull() {
                return this._shaderValues.getInt(PixelLineMaterial.CULL)
            }

            set blend(value) {
                this._shaderValues.setInt(PixelLineMaterial.BLEND, value)
            }

            get blend() {
                return this._shaderValues.getInt(PixelLineMaterial.BLEND)
            }

            set blendSrc(value) {
                this._shaderValues.setInt(PixelLineMaterial.BLEND_SRC, value)
            }

            get blendSrc() {
                return this._shaderValues.getInt(PixelLineMaterial.BLEND_SRC)
            }

            set blendDst(value) {
                this._shaderValues.setInt(PixelLineMaterial.BLEND_DST, value)
            }

            get blendDst() {
                return this._shaderValues.getInt(PixelLineMaterial.BLEND_DST)
            }

            set depthTest(value) {
                this._shaderValues.setInt(PixelLineMaterial.DEPTH_TEST, value)
            }

            get depthTest() {
                return this._shaderValues.getInt(PixelLineMaterial.DEPTH_TEST)
            }

            clone() {
                var dest = new PixelLineMaterial;
                return this.cloneTo(dest), dest
            }
        }

        PixelLineMaterial.COLOR = Shader3D.propertyNameToID("u_Color"), PixelLineMaterial.shaderDefines = null, PixelLineMaterial.CULL = Shader3D.propertyNameToID("s_Cull"), PixelLineMaterial.BLEND = Shader3D.propertyNameToID("s_Blend"), PixelLineMaterial.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc"), PixelLineMaterial.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst"), PixelLineMaterial.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest"), PixelLineMaterial.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");

        class PixelLineVertex {
            static get vertexDeclaration() {
                return PixelLineVertex._vertexDeclaration
            }

            static __init__() {
                PixelLineVertex._vertexDeclaration = new VertexDeclaration(28, [new VertexElement(0, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0), new VertexElement(12, VertexElementFormat.Vector4, VertexMesh.MESH_COLOR0)])
            }

            get vertexDeclaration() {
                return PixelLineVertex._vertexDeclaration
            }

            constructor() {
            }
        }

        class PixelLineFilter extends GeometryElement {
            constructor(owner, maxLineCount) {
                super(), this._floatCountPerVertices = 7, this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE, this._bufferState = new BufferState, this._maxLineCount = 0, this._lineCount = 0;
                var pointCount = 2 * maxLineCount;
                this._owner = owner, this._maxLineCount = maxLineCount, this._vertices = new Float32Array(pointCount * this._floatCountPerVertices), this._vertexBuffer = new VertexBuffer3D(PixelLineVertex.vertexDeclaration.vertexStride * pointCount, Laya.LayaGL.instance.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = PixelLineVertex.vertexDeclaration, this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.unBind()
            }

            _getType() {
                return PixelLineFilter._type
            }

            _resizeLineData(maxCount) {
                var pointCount = 2 * maxCount, lastVertices = this._vertices;
                this._vertexBuffer.destroy(), this._maxLineCount = maxCount;
                var vertexCount = pointCount * this._floatCountPerVertices;
                this._vertices = new Float32Array(vertexCount), this._vertexBuffer = new VertexBuffer3D(PixelLineVertex.vertexDeclaration.vertexStride * pointCount, Laya.LayaGL.instance.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = PixelLineVertex.vertexDeclaration, vertexCount < lastVertices.length ? (this._vertices.set(new Float32Array(lastVertices.buffer, 0, vertexCount)), this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * vertexCount)) : (this._vertices.set(lastVertices), this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * lastVertices.length)), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.unBind()
            }

            _updateLineVertices(offset, startPosition, endPosition, startColor, endColor) {
                startPosition && (this._vertices[offset + 0] = startPosition.x, this._vertices[offset + 1] = startPosition.y, this._vertices[offset + 2] = startPosition.z), startColor && (this._vertices[offset + 3] = startColor.r, this._vertices[offset + 4] = startColor.g, this._vertices[offset + 5] = startColor.b, this._vertices[offset + 6] = startColor.a), endPosition && (this._vertices[offset + 7] = endPosition.x, this._vertices[offset + 8] = endPosition.y, this._vertices[offset + 9] = endPosition.z), endColor && (this._vertices[offset + 10] = endColor.r, this._vertices[offset + 11] = endColor.g, this._vertices[offset + 12] = endColor.b, this._vertices[offset + 13] = endColor.a), this._minUpdate = Math.min(this._minUpdate, offset), this._maxUpdate = Math.max(this._maxUpdate, offset + 2 * this._floatCountPerVertices)
            }

            _removeLineData(index) {
                var floatCount = 2 * this._floatCountPerVertices, nextIndex = index + 1, offset = index * floatCount,
                    rightPartVertices = new Float32Array(this._vertices.buffer, nextIndex * floatCount * 4, (this._lineCount - nextIndex) * floatCount);
                this._vertices.set(rightPartVertices, offset), this._minUpdate = Math.min(this._minUpdate, offset), this._maxUpdate = Math.max(this._maxUpdate, offset + rightPartVertices.length), this._lineCount--
            }

            _updateLineData(index, startPosition, endPosition, startColor, endColor) {
                var offset = index * (2 * this._floatCountPerVertices);
                this._updateLineVertices(offset, startPosition, endPosition, startColor, endColor)
            }

            _updateLineDatas(index, data) {
                for (var floatCount = 2 * this._floatCountPerVertices, count = data.length, i = 0; i < count; i++) {
                    var line = data[i];
                    this._updateLineVertices((index + i) * floatCount, line.startPosition, line.endPosition, line.startColor, line.endColor)
                }
            }

            _getLineData(index, out) {
                var startPosition = out.startPosition, startColor = out.startColor, endPosition = out.endPosition,
                    endColor = out.endColor, vertices = this._vertices,
                    offset = index * this._floatCountPerVertices * 2;
                startPosition.x = vertices[offset + 0], startPosition.y = vertices[offset + 1], startPosition.z = vertices[offset + 2], startColor.r = vertices[offset + 3], startColor.g = vertices[offset + 4], startColor.b = vertices[offset + 5], startColor.a = vertices[offset + 6], endPosition.x = vertices[offset + 7], endPosition.y = vertices[offset + 8], endPosition.z = vertices[offset + 9], endColor.r = vertices[offset + 10], endColor.g = vertices[offset + 11], endColor.b = vertices[offset + 12], endColor.a = vertices[offset + 13]
            }

            _prepareRender(state) {
                return !0
            }

            _render(state) {
                if (this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number.MIN_VALUE && (this._vertexBuffer.setData(this._vertices.buffer, 4 * this._minUpdate, 4 * this._minUpdate, 4 * (this._maxUpdate - this._minUpdate)), this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE), this._lineCount > 0) {
                    this._bufferState.bind();
                    var gl = Laya.LayaGL.instance;
                    gl.drawArrays(gl.LINES, 0, 2 * this._lineCount), Laya.Stat.renderBatches++
                }
            }

            destroy() {
                this._destroyed || (super.destroy(), this._bufferState.destroy(), this._vertexBuffer.destroy(), this._bufferState = null, this._vertexBuffer = null, this._vertices = null)
            }
        }

        PixelLineFilter._type = GeometryElement._typeCounter++;

        class PixelLineRenderer extends BaseRender {
            constructor(owner) {
                super(owner), this._projectionViewWorldMatrix = new Matrix4x4, this._supportOctree = !1
            }

            _calculateBoundingBox() {
                if ((min = this._bounds.getMin()).x = -Number.MAX_VALUE, min.y = -Number.MAX_VALUE, min.z = -Number.MAX_VALUE, this._bounds.setMin(min), (max = this._bounds.getMax()).x = Number.MAX_VALUE, max.y = Number.MAX_VALUE, max.z = Number.MAX_VALUE, this._bounds.setMax(max), Laya.Render.supportWebGLPlusCulling) {
                    var min = this._bounds.getMin(), max = this._bounds.getMax(),
                        buffer = FrustumCulling._cullingBuffer;
                    buffer[this._cullingBufferIndex + 1] = min.x, buffer[this._cullingBufferIndex + 2] = min.y, buffer[this._cullingBufferIndex + 3] = min.z, buffer[this._cullingBufferIndex + 4] = max.x, buffer[this._cullingBufferIndex + 5] = max.y, buffer[this._cullingBufferIndex + 6] = max.z
                }
            }

            _renderUpdateWithCamera(context, transform) {
                var projectionView = context.projectionViewMatrix, sv = this._shaderValues;
                if (transform) {
                    var worldMat = transform.worldMatrix;
                    sv.setMatrix4x4(Sprite3D.WORLDMATRIX, worldMat), Matrix4x4.multiply(projectionView, worldMat, this._projectionViewWorldMatrix), sv.setMatrix4x4(Sprite3D.MVPMATRIX, this._projectionViewWorldMatrix)
                } else sv.setMatrix4x4(Sprite3D.WORLDMATRIX, Matrix4x4.DEFAULT), sv.setMatrix4x4(Sprite3D.MVPMATRIX, projectionView)
            }
        }

        class PixelLineSprite3D extends RenderableSprite3D {
            get maxLineCount() {
                return this._geometryFilter._maxLineCount
            }

            set maxLineCount(value) {
                this._geometryFilter._resizeLineData(value), this._geometryFilter._lineCount = Math.min(this._geometryFilter._lineCount, value)
            }

            get lineCount() {
                return this._geometryFilter._lineCount
            }

            set lineCount(value) {
                if (value > this.maxLineCount) throw"PixelLineSprite3D: lineCount can't large than maxLineCount";
                this._geometryFilter._lineCount = value
            }

            get pixelLineRenderer() {
                return this._render
            }

            constructor(maxCount = 2, name = null) {
                super(name), this._geometryFilter = new PixelLineFilter(this, maxCount), this._render = new PixelLineRenderer(this), this._changeRenderObjects(this._render, 0, PixelLineMaterial.defaultMaterial)
            }

            _changeRenderObjects(sender, index, material) {
                var renderObjects = this._render._renderElements;
                material || (material = PixelLineMaterial.defaultMaterial);
                var renderElement = renderObjects[index];
                renderElement || (renderElement = renderObjects[index] = new RenderElement), renderElement.setTransform(this._transform), renderElement.setGeometry(this._geometryFilter), renderElement.render = this._render, renderElement.material = material
            }

            addLine(startPosition, endPosition, startColor, endColor) {
                if (this._geometryFilter._lineCount === this._geometryFilter._maxLineCount) throw"PixelLineSprite3D: lineCount has equal with maxLineCount.";
                this._geometryFilter._updateLineData(this._geometryFilter._lineCount++, startPosition, endPosition, startColor, endColor)
            }

            addLines(lines) {
                var lineCount = this._geometryFilter._lineCount, addCount = lines.length;
                if (lineCount + addCount > this._geometryFilter._maxLineCount) throw"PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
                this._geometryFilter._updateLineDatas(lineCount, lines), this._geometryFilter._lineCount += addCount
            }

            removeLine(index) {
                if (!(index < this._geometryFilter._lineCount)) throw"PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._removeLineData(index)
            }

            setLine(index, startPosition, endPosition, startColor, endColor) {
                if (!(index < this._geometryFilter._lineCount)) throw"PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._updateLineData(index, startPosition, endPosition, startColor, endColor)
            }

            getLine(index, out) {
                if (!(index < this.lineCount)) throw"PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._getLineData(index, out)
            }

            clear() {
                this._geometryFilter._lineCount = 0
            }

            _create() {
                return new PixelLineSprite3D
            }
        }

        class RenderQueue {
            constructor(isTransparent = !1) {
                this.isTransparent = !1, this.elements = new SingletonList, this.lastTransparentRenderElement = null, this.lastTransparentBatched = !1, this.isTransparent = isTransparent
            }

            _compare(left, right) {
                var renderQueue = left.material.renderQueue - right.material.renderQueue;
                return 0 === renderQueue ? (this.isTransparent ? right.render._distanceForSort - left.render._distanceForSort : left.render._distanceForSort - right.render._distanceForSort) + right.render.sortingFudge - left.render.sortingFudge : renderQueue
            }

            _partitionRenderObject(left, right) {
                for (var elements = this.elements.elements, pivot = elements[Math.floor((right + left) / 2)]; left <= right;) {
                    for (; this._compare(elements[left], pivot) < 0;) left++;
                    for (; this._compare(elements[right], pivot) > 0;) right--;
                    if (left < right) {
                        var temp = elements[left];
                        elements[left] = elements[right], elements[right] = temp, left++, right--
                    } else if (left === right) {
                        left++;
                        break
                    }
                }
                return left
            }

            _quickSort(left, right) {
                if (this.elements.length > 1) {
                    var index = this._partitionRenderObject(left, right), leftIndex = index - 1;
                    left < leftIndex && this._quickSort(left, leftIndex), index < right && this._quickSort(index, right)
                }
            }

            _render(context, isTarget) {
                for (var elements = this.elements.elements, i = 0, n = this.elements.length; i < n; i++) elements[i]._render(context, isTarget)
            }

            clear() {
                this.elements.length = 0, this.lastTransparentRenderElement = null, this.lastTransparentBatched = !1
            }
        }

        class BoundsOctreeNode {
            constructor(octree, parent, baseLength, center) {
                this._bounds = new BoundBox(new Vector3, new Vector3), this._objects = [], this._isContaion = !1, this.center = new Vector3, this.baseLength = 0, this._setValues(octree, parent, baseLength, center)
            }

            static _encapsulates(outerBound, innerBound) {
                return CollisionUtils.boxContainsBox(outerBound, innerBound) == ContainmentType.Contains
            }

            _setValues(octree, parent, baseLength, center) {
                this._octree = octree, this._parent = parent, this.baseLength = baseLength, center.cloneTo(this.center);
                var min = this._bounds.min, max = this._bounds.max, halfSize = octree._looseness * baseLength / 2;
                min.setValue(center.x - halfSize, center.y - halfSize, center.z - halfSize), max.setValue(center.x + halfSize, center.y + halfSize, center.z + halfSize)
            }

            _getChildBound(index) {
                if (null != this._children && this._children[index]) return this._children[index]._bounds;
                var quarter = this.baseLength / 4, halfChildSize = this.baseLength / 2 * this._octree._looseness / 2,
                    bounds = BoundsOctreeNode._tempBoundBox, min = bounds.min, max = bounds.max;
                switch (index) {
                    case 0:
                        min.x = this.center.x - quarter - halfChildSize, min.y = this.center.y + quarter - halfChildSize, min.z = this.center.z - quarter - halfChildSize, max.x = this.center.x - quarter + halfChildSize, max.y = this.center.y + quarter + halfChildSize, max.z = this.center.z - quarter + halfChildSize;
                        break;
                    case 1:
                        min.x = this.center.x + quarter - halfChildSize, min.y = this.center.y + quarter - halfChildSize, min.z = this.center.z - quarter - halfChildSize, max.x = this.center.x + quarter + halfChildSize, max.y = this.center.y + quarter + halfChildSize, max.z = this.center.z - quarter + halfChildSize;
                        break;
                    case 2:
                        min.x = this.center.x - quarter - halfChildSize, min.y = this.center.y + quarter - halfChildSize, min.z = this.center.z + quarter - halfChildSize, max.x = this.center.x - quarter + halfChildSize, max.y = this.center.y + quarter + halfChildSize, max.z = this.center.z + quarter + halfChildSize;
                        break;
                    case 3:
                        min.x = this.center.x + quarter - halfChildSize, min.y = this.center.y + quarter - halfChildSize, min.z = this.center.z + quarter - halfChildSize, max.x = this.center.x + quarter + halfChildSize, max.y = this.center.y + quarter + halfChildSize, max.z = this.center.z + quarter + halfChildSize;
                        break;
                    case 4:
                        min.x = this.center.x - quarter - halfChildSize, min.y = this.center.y - quarter - halfChildSize, min.z = this.center.z - quarter - halfChildSize, max.x = this.center.x - quarter + halfChildSize, max.y = this.center.y - quarter + halfChildSize, max.z = this.center.z - quarter + halfChildSize;
                        break;
                    case 5:
                        min.x = this.center.x + quarter - halfChildSize, min.y = this.center.y - quarter - halfChildSize, min.z = this.center.z - quarter - halfChildSize, max.x = this.center.x + quarter + halfChildSize, max.y = this.center.y - quarter + halfChildSize, max.z = this.center.z - quarter + halfChildSize;
                        break;
                    case 6:
                        min.x = this.center.x - quarter - halfChildSize, min.y = this.center.y - quarter - halfChildSize, min.z = this.center.z + quarter - halfChildSize, max.x = this.center.x - quarter + halfChildSize, max.y = this.center.y - quarter + halfChildSize, max.z = this.center.z + quarter + halfChildSize;
                        break;
                    case 7:
                        min.x = this.center.x + quarter - halfChildSize, min.y = this.center.y - quarter - halfChildSize, min.z = this.center.z + quarter - halfChildSize, max.x = this.center.x + quarter + halfChildSize, max.y = this.center.y - quarter + halfChildSize, max.z = this.center.z + quarter + halfChildSize
                }
                return bounds
            }

            _getChildCenter(index) {
                if (null != this._children) return this._children[index].center;
                var quarter = this.baseLength / 4, childCenter = BoundsOctreeNode._tempVector30;
                switch (index) {
                    case 0:
                        childCenter.x = this.center.x - quarter, childCenter.y = this.center.y + quarter, childCenter.z = this.center.z - quarter;
                        break;
                    case 1:
                        childCenter.x = this.center.x + quarter, childCenter.y = this.center.y + quarter, childCenter.z = this.center.z - quarter;
                        break;
                    case 2:
                        childCenter.x = this.center.x - quarter, childCenter.y = this.center.y + quarter, childCenter.z = this.center.z + quarter;
                        break;
                    case 3:
                        childCenter.x = this.center.x + quarter, childCenter.y = this.center.y + quarter, childCenter.z = this.center.z + quarter;
                        break;
                    case 4:
                        childCenter.x = this.center.x - quarter, childCenter.y = this.center.y - quarter, childCenter.z = this.center.z - quarter;
                        break;
                    case 5:
                        childCenter.x = this.center.x + quarter, childCenter.y = this.center.y - quarter, childCenter.z = this.center.z - quarter;
                        break;
                    case 6:
                        childCenter.x = this.center.x - quarter, childCenter.y = this.center.y - quarter, childCenter.z = this.center.z + quarter;
                        break;
                    case 7:
                        childCenter.x = this.center.x + quarter, childCenter.y = this.center.y - quarter, childCenter.z = this.center.z + quarter
                }
                return childCenter
            }

            _getChild(index) {
                var quarter = this.baseLength / 4;
                switch (this._children || (this._children = []), index) {
                    case 0:
                        return this._children[0] || (this._children[0] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x + -quarter, this.center.y + quarter, this.center.z - quarter)));
                    case 1:
                        return this._children[1] || (this._children[1] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x + quarter, this.center.y + quarter, this.center.z - quarter)));
                    case 2:
                        return this._children[2] || (this._children[2] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x - quarter, this.center.y + quarter, this.center.z + quarter)));
                    case 3:
                        return this._children[3] || (this._children[3] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x + quarter, this.center.y + quarter, this.center.z + quarter)));
                    case 4:
                        return this._children[4] || (this._children[4] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x - quarter, this.center.y - quarter, this.center.z - quarter)));
                    case 5:
                        return this._children[5] || (this._children[5] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x + quarter, this.center.y - quarter, this.center.z - quarter)));
                    case 6:
                        return this._children[6] || (this._children[6] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x - quarter, this.center.y - quarter, this.center.z + quarter)));
                    case 7:
                        return this._children[7] || (this._children[7] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Vector3(this.center.x + quarter, this.center.y - quarter, this.center.z + quarter)));
                    default:
                        throw"BoundsOctreeNode: unknown index."
                }
            }

            _shouldMerge() {
                for (var objectCount = this._objects.length, i = 0; i < 8; i++) {
                    var child = this._children[i];
                    if (child) {
                        if (null != child._children) return !1;
                        objectCount += child._objects.length
                    }
                }
                return objectCount <= BoundsOctreeNode._NUM_OBJECTS_ALLOWED
            }

            _mergeChildren() {
                for (var i = 0; i < 8; i++) {
                    var child = this._children[i];
                    if (child) {
                        child._parent = null;
                        for (var childObjects = child._objects, j = childObjects.length - 1; j >= 0; j--) {
                            var childObject = childObjects[j];
                            this._objects.push(childObject), childObject._setOctreeNode(this)
                        }
                    }
                }
                this._children = null
            }

            _merge() {
                if (null === this._children) {
                    var parent = this._parent;
                    parent && parent._shouldMerge() && (parent._mergeChildren(), parent._merge())
                }
            }

            _checkAddNode(object) {
                if (null == this._children) {
                    if (this._objects.length < BoundsOctreeNode._NUM_OBJECTS_ALLOWED || this.baseLength / 2 < this._octree._minSize) return this;
                    for (var i = this._objects.length - 1; i >= 0; i--) {
                        var existObject = this._objects[i],
                            fitChildIndex = this._bestFitChild(existObject.bounds.getCenter());
                        BoundsOctreeNode._encapsulates(this._getChildBound(fitChildIndex), existObject.bounds._getBoundBox()) && (this._objects.splice(this._objects.indexOf(existObject), 1), this._getChild(fitChildIndex)._add(existObject))
                    }
                }
                var newFitChildIndex = this._bestFitChild(object.bounds.getCenter());
                return BoundsOctreeNode._encapsulates(this._getChildBound(newFitChildIndex), object.bounds._getBoundBox()) ? this._getChild(newFitChildIndex)._checkAddNode(object) : this
            }

            _add(object) {
                var addNode = this._checkAddNode(object);
                addNode._objects.push(object), object._setOctreeNode(addNode)
            }

            _remove(object) {
                var index = this._objects.indexOf(object);
                this._objects.splice(index, 1), object._setOctreeNode(null), this._merge()
            }

            _addUp(object) {
                return CollisionUtils.boxContainsBox(this._bounds, object.bounds._getBoundBox()) === ContainmentType.Contains ? (this._add(object), !0) : !!this._parent && this._parent._addUp(object)
            }

            _getCollidingWithFrustum(context, frustum, testVisible, camPos, customShader, replacementTag) {
                if (testVisible) {
                    var type = frustum.containsBoundBox(this._bounds);
                    if (Laya.Stat.octreeNodeCulling++, type === ContainmentType.Disjoint) return;
                    testVisible = type === ContainmentType.Intersects
                }
                this._isContaion = !testVisible;
                for (var camera = context.camera, scene = context.scene, i = 0, n = this._objects.length; i < n; i++) {
                    var render = this._objects[i];
                    if (camera._isLayerVisible(render._owner.layer) && render._enable) {
                        if (testVisible && (Laya.Stat.frustumCulling++, !render._needRender(frustum, context))) continue;
                        render._distanceForSort = Vector3.distance(render.bounds.getCenter(), camPos);
                        for (var elements = render._renderElements, j = 0, m = elements.length; j < m; j++) {
                            elements[j]._update(scene, context, customShader, replacementTag)
                        }
                    }
                }
                if (null != this._children) for (i = 0; i < 8; i++) {
                    var child = this._children[i];
                    child && child._getCollidingWithFrustum(context, frustum, testVisible, camPos, customShader, replacementTag)
                }
            }

            _getCollidingWithBoundBox(checkBound, testVisible, result) {
                if (testVisible) {
                    var type = CollisionUtils.boxContainsBox(this._bounds, checkBound);
                    if (type === ContainmentType.Disjoint) return;
                    testVisible = type === ContainmentType.Intersects
                }
                if (testVisible) for (var i = 0, n = this._objects.length; i < n; i++) {
                    var object = this._objects[i];
                    CollisionUtils.intersectsBoxAndBox(object.bounds._getBoundBox(), checkBound) && result.push(object)
                }
                if (null != this._children) for (i = 0; i < 8; i++) {
                    this._children[i]._getCollidingWithBoundBox(checkBound, testVisible, result)
                }
            }

            _bestFitChild(boundCenter) {
                return (boundCenter.x <= this.center.x ? 0 : 1) + (boundCenter.y >= this.center.y ? 0 : 4) + (boundCenter.z <= this.center.z ? 0 : 2)
            }

            _update(object) {
                if (CollisionUtils.boxContainsBox(this._bounds, object.bounds._getBoundBox()) === ContainmentType.Contains) {
                    var addNode = this._checkAddNode(object);
                    if (addNode !== object._getOctreeNode()) {
                        addNode._objects.push(object), object._setOctreeNode(addNode);
                        var index = this._objects.indexOf(object);
                        this._objects.splice(index, 1), this._merge()
                    }
                    return !0
                }
                if (this._parent) {
                    var sucess = this._parent._addUp(object);
                    return sucess && (index = this._objects.indexOf(object), this._objects.splice(index, 1), this._merge()), sucess
                }
                return !1
            }

            add(object) {
                return !!BoundsOctreeNode._encapsulates(this._bounds, object.bounds._getBoundBox()) && (this._add(object), !0)
            }

            remove(object) {
                return object._getOctreeNode() === this && (this._remove(object), !0)
            }

            update(object) {
                return object._getOctreeNode() === this && this._update(object)
            }

            shrinkIfPossible(minLength) {
                if (this.baseLength < 2 * minLength) return this;
                for (var bestFit = -1, i = 0, n = this._objects.length; i < n; i++) {
                    var object = this._objects[i], newBestFit = this._bestFitChild(object.bounds.getCenter());
                    if (0 != i && newBestFit != bestFit) return this;
                    var childBounds = this._getChildBound(newBestFit);
                    if (!BoundsOctreeNode._encapsulates(childBounds, object.bounds._getBoundBox())) return this;
                    0 == i && (bestFit = newBestFit)
                }
                if (null == this._children) {
                    if (-1 != bestFit) {
                        var childCenter = this._getChildCenter(bestFit);
                        this._setValues(this._octree, null, this.baseLength / 2, childCenter)
                    }
                    return this
                }
                var childHadContent = !1;
                for (i = 0, n = this._children.length; i < n; i++) {
                    var child = this._children[i];
                    if (child && child.hasAnyObjects()) {
                        if (childHadContent) return this;
                        if (bestFit >= 0 && bestFit != i) return this;
                        childHadContent = !0, bestFit = i
                    }
                }
                if (-1 != bestFit) {
                    var newRoot = this._children[bestFit];
                    return newRoot._parent = null, newRoot
                }
                return this
            }

            hasAnyObjects() {
                if (this._objects.length > 0) return !0;
                if (null != this._children) for (var i = 0; i < 8; i++) {
                    var child = this._children[i];
                    if (child && child.hasAnyObjects()) return !0
                }
                return !1
            }

            getCollidingWithBoundBox(checkBound, result) {
                this._getCollidingWithBoundBox(checkBound, !0, result)
            }

            getCollidingWithRay(ray, result, maxDistance = Number.MAX_VALUE) {
                var distance = CollisionUtils.intersectsRayAndBoxRD(ray, this._bounds);
                if (!(-1 == distance || distance > maxDistance)) {
                    for (var i = 0, n = this._objects.length; i < n; i++) {
                        var object = this._objects[i];
                        -1 !== (distance = CollisionUtils.intersectsRayAndBoxRD(ray, object.bounds._getBoundBox())) && distance <= maxDistance && result.push(object)
                    }
                    if (null != this._children) for (i = 0; i < 8; i++) {
                        this._children[i].getCollidingWithRay(ray, result, maxDistance)
                    }
                }
            }

            getCollidingWithFrustum(context, customShader, replacementTag) {
                var cameraPos = context.camera.transform.position, boundFrustum = context.camera.boundFrustum;
                this._getCollidingWithFrustum(context, boundFrustum, !0, cameraPos, customShader, replacementTag)
            }

            isCollidingWithBoundBox(checkBound) {
                if (!CollisionUtils.intersectsBoxAndBox(this._bounds, checkBound)) return !1;
                for (var i = 0, n = this._objects.length; i < n; i++) {
                    var object = this._objects[i];
                    if (CollisionUtils.intersectsBoxAndBox(object.bounds._getBoundBox(), checkBound)) return !0
                }
                if (null != this._children) for (i = 0; i < 8; i++) {
                    if (this._children[i].isCollidingWithBoundBox(checkBound)) return !0
                }
                return !1
            }

            isCollidingWithRay(ray, maxDistance = Number.MAX_VALUE) {
                var distance = CollisionUtils.intersectsRayAndBoxRD(ray, this._bounds);
                if (-1 == distance || distance > maxDistance) return !1;
                for (var i = 0, n = this._objects.length; i < n; i++) {
                    var object = this._objects[i];
                    if (-1 !== (distance = CollisionUtils.intersectsRayAndBoxRD(ray, object.bounds._getBoundBox())) && distance <= maxDistance) return !0
                }
                if (null != this._children) for (i = 0; i < 8; i++) {
                    if (this._children[i].isCollidingWithRay(ray, maxDistance)) return !0
                }
                return !1
            }

            getBound() {
                return this._bounds
            }

            drawAllBounds(debugLine, currentDepth, maxDepth) {
                if (null !== this._children || 0 != this._objects.length) {
                    currentDepth++;
                    var color = BoundsOctreeNode._tempColor0;
                    if (this._isContaion) color.r = 0, color.g = 0, color.b = 1; else {
                        var tint = maxDepth ? currentDepth / maxDepth : 0;
                        color.r = 1 - tint, color.g = tint, color.b = 0
                    }
                    if (color.a = .3, Utils3D._drawBound(debugLine, this._bounds, color), null != this._children) for (var i = 0; i < 8; i++) {
                        var child = this._children[i];
                        child && child.drawAllBounds(debugLine, currentDepth, maxDepth)
                    }
                }
            }

            drawAllObjects(debugLine, currentDepth, maxDepth) {
                currentDepth++;
                var color = BoundsOctreeNode._tempColor0;
                if (this._isContaion) color.r = 0, color.g = 0, color.b = 1; else {
                    var tint = maxDepth ? currentDepth / maxDepth : 0;
                    color.r = 1 - tint, color.g = tint, color.b = 0
                }
                color.a = 1;
                for (var i = 0, n = this._objects.length; i < n; i++) Utils3D._drawBound(debugLine, this._objects[i].bounds._getBoundBox(), color);
                if (null != this._children) for (i = 0; i < 8; i++) {
                    var child = this._children[i];
                    child && child.drawAllObjects(debugLine, currentDepth, maxDepth)
                }
            }
        }

        BoundsOctreeNode._tempVector3 = new Vector3, BoundsOctreeNode._tempVector30 = new Vector3, BoundsOctreeNode._tempVector31 = new Vector3, BoundsOctreeNode._tempColor0 = new Color, BoundsOctreeNode._tempBoundBox = new BoundBox(new Vector3, new Vector3), BoundsOctreeNode._NUM_OBJECTS_ALLOWED = 8;

        class OctreeMotionList extends SingletonList {
            constructor() {
                super()
            }

            add(element) {
                if (-1 !== element._getIndexInMotionList()) throw"OctreeMotionList:element has  in  PhysicsUpdateList.";
                this._add(element), element._setIndexInMotionList(this.length++)
            }

            remove(element) {
                var index = element._getIndexInMotionList();
                if (this.length--, index !== this.length) {
                    var end = this.elements[this.length];
                    this.elements[index] = end, end._setIndexInMotionList(index)
                }
                element._setIndexInMotionList(-1)
            }
        }

        class BoundsOctree {
            constructor(initialWorldSize, initialWorldPos, minNodeSize, looseness) {
                this._motionObjects = new OctreeMotionList, this.count = 0, minNodeSize > initialWorldSize && (console.warn("Minimum node size must be at least as big as the initial world size. Was: " + minNodeSize + " Adjusted to: " + initialWorldSize), minNodeSize = initialWorldSize), this._initialSize = initialWorldSize, this._minSize = minNodeSize, this._looseness = Math.min(Math.max(looseness, 1), 2), this._rootNode = new BoundsOctreeNode(this, null, initialWorldSize, initialWorldPos)
            }

            _getMaxDepth(node, depth) {
                depth++;
                var children = node._children;
                if (null != children) for (var curDepth = depth, i = 0, n = children.length; i < n; i++) {
                    var child = children[i];
                    child && (depth = Math.max(this._getMaxDepth(child, curDepth), depth))
                }
                return depth
            }

            _grow(growObjectCenter) {
                var xDirection = growObjectCenter.x >= 0 ? 1 : -1, yDirection = growObjectCenter.y >= 0 ? 1 : -1,
                    zDirection = growObjectCenter.z >= 0 ? 1 : -1, oldRoot = this._rootNode,
                    half = this._rootNode.baseLength / 2, newLength = 2 * this._rootNode.baseLength,
                    rootCenter = this._rootNode.center,
                    newCenter = new Vector3(rootCenter.x + xDirection * half, rootCenter.y + yDirection * half, rootCenter.z + zDirection * half);
                if (this._rootNode = new BoundsOctreeNode(this, null, newLength, newCenter), oldRoot.hasAnyObjects()) {
                    for (var rootPos = this._rootNode._bestFitChild(oldRoot.center), children = [], i = 0; i < 8; i++) i == rootPos && (oldRoot._parent = this._rootNode, children[i] = oldRoot);
                    this._rootNode._children = children
                }
            }

            add(object) {
                for (var count = 0; !this._rootNode.add(object);) {
                    var growCenter = BoundsOctree._tempVector30;
                    if (Vector3.subtract(object.bounds.getCenter(), this._rootNode.center, growCenter), this._grow(growCenter), ++count > 20) throw"Aborted Add operation as it seemed to be going on forever (" + (count - 1) + ") attempts at growing the octree."
                }
                this.count++
            }

            remove(object) {
                var removed = object._getOctreeNode().remove(object);
                return removed && this.count--, removed
            }

            update(object) {
                var count = 0, octreeNode = object._getOctreeNode();
                if (octreeNode) {
                    for (; !octreeNode._update(object);) {
                        var growCenter = BoundsOctree._tempVector30;
                        if (Vector3.subtract(object.bounds.getCenter(), this._rootNode.center, growCenter), this._grow(growCenter), ++count > 20) throw"Aborted Add operation as it seemed to be going on forever (" + (count - 1) + ") attempts at growing the octree."
                    }
                    return !0
                }
                return !1
            }

            shrinkRootIfPossible() {
                this._rootNode = this._rootNode.shrinkIfPossible(this._initialSize)
            }

            addMotionObject(object) {
                this._motionObjects.add(object)
            }

            removeMotionObject(object) {
                this._motionObjects.remove(object)
            }

            updateMotionObjects() {
                for (var elements = this._motionObjects.elements, i = 0, n = this._motionObjects.length; i < n; i++) {
                    var object = elements[i];
                    this.update(object), object._setIndexInMotionList(-1)
                }
                this._motionObjects.length = 0
            }

            isCollidingWithBoundBox(checkBounds) {
                return this._rootNode.isCollidingWithBoundBox(checkBounds)
            }

            isCollidingWithRay(ray, maxDistance = Number.MAX_VALUE) {
                return this._rootNode.isCollidingWithRay(ray, maxDistance)
            }

            getCollidingWithBoundBox(checkBound, result) {
                this._rootNode.getCollidingWithBoundBox(checkBound, result)
            }

            getCollidingWithRay(ray, result, maxDistance = Number.MAX_VALUE) {
                this._rootNode.getCollidingWithRay(ray, result, maxDistance)
            }

            getCollidingWithFrustum(context, shader, replacementTag) {
                this._rootNode.getCollidingWithFrustum(context, shader, replacementTag)
            }

            getMaxBounds() {
                return this._rootNode.getBound()
            }

            drawAllBounds(pixelLine) {
                var maxDepth = this._getMaxDepth(this._rootNode, -1);
                this._rootNode.drawAllBounds(pixelLine, -1, maxDepth)
            }

            drawAllObjects(pixelLine) {
                var maxDepth = this._getMaxDepth(this._rootNode, -1);
                this._rootNode.drawAllObjects(pixelLine, -1, maxDepth)
            }
        }

        BoundsOctree._tempVector30 = new Vector3;

        class Scene3D extends Laya.Sprite {
            constructor() {
                if (super(), this._lights = [], this._lightmaps = [], this._skyRenderer = new SkyRenderer, this._reflectionMode = 1, this._enableLightCount = 3, this._input = new Input3D, this._timer = Laya.ILaya.timer, this._collsionTestList = [], this._renders = new SimpleSingletonList, this._opaqueQueue = new RenderQueue(!1), this._transparentQueue = new RenderQueue(!0), this._cameraPool = [], this._animatorPool = new SimpleSingletonList, this._scriptPool = new Array, this._tempScriptPool = new Array, this._needClearScriptPool = !1, this._castShadowRenders = new CastShadowList, this.currentCreationLayer = Math.pow(2, 0), this.enableLight = !0, this._key = new Laya.SubmitKey, this._time = 0, this._pickIdToSprite = new Object, Physics3D._enbalePhysics && (this._physicsSimulation = new PhysicsSimulation(Scene3D.physicsSettings)), this._shaderValues = new ShaderData(null), this.parallelSplitShadowMaps = [], this.enableFog = !1, this.fogStart = 300, this.fogRange = 1e3, this.fogColor = new Vector3(.7, .7, .7), this.ambientColor = new Vector3(.212, .227, .259), this.reflectionIntensity = 1, Laya.WebGL.shaderHighPrecision && this._shaderValues.addDefine(Shader3D.SHADERDEFINE_HIGHPRECISION), Laya.Render.supportWebGLPlusCulling && (this._cullingBufferIndices = new Int32Array(1024), this._cullingBufferResult = new Int32Array(1024)), this._shaderValues.setTexture(Scene3D.RANGEATTENUATIONTEXTURE, ShaderInit3D._rangeAttenTex), this._scene = this, this._input.__init__(Laya.Render.canvas, this), Scene3D.octreeCulling && (this._octree = new BoundsOctree(Scene3D.octreeInitialSize, Scene3D.octreeInitialCenter, Scene3D.octreeMinNodeSize, Scene3D.octreeLooseness)), FrustumCulling.debugFrustumCulling) {
                    this._debugTool = new PixelLineSprite3D;
                    var lineMaterial = new PixelLineMaterial;
                    lineMaterial.renderQueue = BaseMaterial.RENDERQUEUE_TRANSPARENT, lineMaterial.alphaTest = !1, lineMaterial.depthWrite = !1, lineMaterial.cull = RenderState.CULL_BACK, lineMaterial.blend = RenderState.BLEND_ENABLE_ALL, lineMaterial.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA, lineMaterial.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA, lineMaterial.depthTest = RenderState.DEPTHTEST_LESS, this._debugTool.pixelLineRenderer.sharedMaterial = lineMaterial
                }
            }

            static __init__() {
                Scene3DShaderDeclaration.SHADERDEFINE_FOG = Shader3D.registerPublicDefine("FOG"), Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT = Shader3D.registerPublicDefine("DIRECTIONLIGHT"), Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT = Shader3D.registerPublicDefine("POINTLIGHT"), Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT = Shader3D.registerPublicDefine("SPOTLIGHT"), Scene3DShaderDeclaration.SHADERDEFINE_CAST_SHADOW = Shader3D.registerPublicDefine("CASTSHADOW"), Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM1 = Shader3D.registerPublicDefine("SHADOWMAP_PSSM1"), Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM2 = Shader3D.registerPublicDefine("SHADOWMAP_PSSM2"), Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PSSM3 = Shader3D.registerPublicDefine("SHADOWMAP_PSSM3"), Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF_NO = Shader3D.registerPublicDefine("SHADOWMAP_PCF_NO"), Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF1 = Shader3D.registerPublicDefine("SHADOWMAP_PCF1"), Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF2 = Shader3D.registerPublicDefine("SHADOWMAP_PCF2"), Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_PCF3 = Shader3D.registerPublicDefine("SHADOWMAP_PCF3"), Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP = Shader3D.registerPublicDefine("REFLECTMAP")
            }

            static load(url, complete) {
                Laya.ILaya.loader.create(url, complete, null, Scene3D.HIERARCHY)
            }

            _allotPickColorByID(id, pickColor) {
                var pickColorR = Math.floor(id / 65025);
                id -= 255 * pickColorR * 255;
                var pickColorG = Math.floor(id / 255), pickColorB = id -= 255 * pickColorG;
                pickColor.x = pickColorR / 255, pickColor.y = pickColorG / 255, pickColor.z = pickColorB / 255, pickColor.w = 1
            }

            _searchIDByPickColor(pickColor) {
                return 255 * pickColor.x * 255 + 255 * pickColor.y + pickColor.z
            }

            get url() {
                return this._url
            }

            get enableFog() {
                return this._enableFog
            }

            set enableFog(value) {
                this._enableFog !== value && (this._enableFog = value, value ? this._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG) : this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG))
            }

            get fogColor() {
                return this._shaderValues.getVector3(Scene3D.FOGCOLOR)
            }

            set fogColor(value) {
                this._shaderValues.setVector3(Scene3D.FOGCOLOR, value)
            }

            get fogStart() {
                return this._shaderValues.getNumber(Scene3D.FOGSTART)
            }

            set fogStart(value) {
                this._shaderValues.setNumber(Scene3D.FOGSTART, value)
            }

            get fogRange() {
                return this._shaderValues.getNumber(Scene3D.FOGRANGE)
            }

            set fogRange(value) {
                this._shaderValues.setNumber(Scene3D.FOGRANGE, value)
            }

            get ambientColor() {
                return this._shaderValues.getVector3(Scene3D.AMBIENTCOLOR)
            }

            set ambientColor(value) {
                this._shaderValues.setVector3(Scene3D.AMBIENTCOLOR, value)
            }

            get skyRenderer() {
                return this._skyRenderer
            }

            get customReflection() {
                return this._shaderValues.getTexture(Scene3D.REFLECTIONTEXTURE)
            }

            set customReflection(value) {
                this._shaderValues.setTexture(Scene3D.REFLECTIONTEXTURE, value), value ? this._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP) : this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_REFLECTMAP)
            }

            get reflectionIntensity() {
                return this._shaderValues.getNumber(Scene3D.REFLETIONINTENSITY)
            }

            set reflectionIntensity(value) {
                value = Math.max(Math.min(value, 1), 0), this._shaderValues.setNumber(Scene3D.REFLETIONINTENSITY, value)
            }

            get physicsSimulation() {
                return this._physicsSimulation
            }

            get reflectionMode() {
                return this._reflectionMode
            }

            set reflectionMode(value) {
                this._reflectionMode = value
            }

            get timer() {
                return this._timer
            }

            set timer(value) {
                this._timer = value
            }

            get input() {
                return this._input
            }

            _setLightmapToChildNode(sprite) {
                sprite instanceof RenderableSprite3D && sprite._render._applyLightMapParams();
                for (var children = sprite._children, i = 0, n = children.length; i < n; i++) this._setLightmapToChildNode(children[i])
            }

            _update() {
                var delta = this.timer._delta / 1e3;
                this._time += delta, this._shaderValues.setNumber(Scene3D.TIME, this._time);
                var simulation = this._physicsSimulation;
                Physics3D._enbalePhysics && !PhysicsSimulation.disableSimulation && (simulation._updatePhysicsTransformFromRender(), PhysicsComponent._addUpdateList = !1, simulation._simulate(delta), simulation._updateCharacters(), PhysicsComponent._addUpdateList = !0, simulation._updateCollisions(), simulation._eventScripts()), this._input._update(), this._clearScript(), this._updateScript(), Animator._update(this), this._lateUpdateScript()
            }

            _binarySearchIndexInCameraPool(camera) {
                for (var mid, start = 0, end = this._cameraPool.length - 1; start <= end;) {
                    mid = Math.floor((start + end) / 2);
                    var midValue = this._cameraPool[mid]._renderingOrder;
                    if (midValue == camera._renderingOrder) return mid;
                    midValue > camera._renderingOrder ? end = mid - 1 : start = mid + 1
                }
                return start
            }

            onEnable() {
                this._input._onCanvasEvent(Laya.Render.canvas)
            }

            onDisable() {
                this._input._offCanvasEvent(Laya.Render.canvas)
            }

            _setCreateURL(url) {
                this._url = Laya.URL.formatURL(url)
            }

            _getGroup() {
                return this._group
            }

            _setGroup(value) {
                this._group = value
            }

            _clearScript() {
                if (this._needClearScriptPool) {
                    for (var scripts = this._scriptPool, i = 0, n = scripts.length; i < n; i++) {
                        var script = scripts[i];
                        script && (script._indexInPool = this._tempScriptPool.length, this._tempScriptPool.push(script))
                    }
                    this._scriptPool = this._tempScriptPool, scripts.length = 0, this._tempScriptPool = scripts, this._needClearScriptPool = !1
                }
            }

            _updateScript() {
                for (var scripts = this._scriptPool, i = 0, n = scripts.length; i < n; i++) {
                    var script = scripts[i];
                    script && script.enabled && script.onUpdate()
                }
            }

            _lateUpdateScript() {
                for (var scripts = this._scriptPool, i = 0, n = scripts.length; i < n; i++) {
                    var script = scripts[i];
                    script && script.enabled && script.onLateUpdate()
                }
            }

            _addScript(script) {
                var scripts = this._scriptPool;
                script._indexInPool = scripts.length, scripts.push(script)
            }

            _removeScript(script) {
                this._scriptPool[script._indexInPool] = null, script._indexInPool = -1, this._needClearScriptPool = !0
            }

            _preRenderScript() {
                for (var scripts = this._scriptPool, i = 0, n = scripts.length; i < n; i++) {
                    var script = scripts[i];
                    script && script.enabled && script.onPreRender()
                }
            }

            _postRenderScript() {
                for (var scripts = this._scriptPool, i = 0, n = scripts.length; i < n; i++) {
                    var script = scripts[i];
                    script && script.enabled && script.onPostRender()
                }
            }

            _prepareSceneToRender() {
                var lightCount = this._lights.length;
                if (lightCount > 0) for (var renderLightCount = 0, i = 0; i < lightCount && !(this._lights[i]._prepareToScene() && ++renderLightCount >= this._enableLightCount); i++) ;
            }

            _addCamera(camera) {
                for (var index = this._binarySearchIndexInCameraPool(camera), order = camera._renderingOrder, count = this._cameraPool.length; index < count && this._cameraPool[index]._renderingOrder <= order;) index++;
                this._cameraPool.splice(index, 0, camera)
            }

            _removeCamera(camera) {
                this._cameraPool.splice(this._cameraPool.indexOf(camera), 1)
            }

            _preCulling(context, camera, shader, replacementTag) {
                FrustumCulling.renderObjectCulling(camera, this, context, this._renders, shader, replacementTag)
            }

            _clear(gl, state) {
                var flag, viewport = state.viewport, camera = state.camera,
                    renderTexture = camera._renderTexture || camera._offScreenRenderTexture, vpW = viewport.width,
                    vpH = viewport.height, vpX = viewport.x, vpY = camera._getCanvasHeight() - viewport.y - vpH;
                gl.viewport(vpX, vpY, vpW, vpH);
                var clearFlag = camera.clearFlag;
                switch (clearFlag !== BaseCamera.CLEARFLAG_SKY || camera.skyRenderer._isAvailable() || this._skyRenderer._isAvailable() || (clearFlag = BaseCamera.CLEARFLAG_SOLIDCOLOR), clearFlag) {
                    case BaseCamera.CLEARFLAG_SOLIDCOLOR:
                        var clearColor = camera.clearColor;
                        if (gl.enable(gl.SCISSOR_TEST), gl.scissor(vpX, vpY, vpW, vpH), clearColor ? gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w) : gl.clearColor(0, 0, 0, 0), renderTexture) switch (flag = gl.COLOR_BUFFER_BIT, renderTexture.depthStencilFormat) {
                            case Laya.BaseTexture.FORMAT_DEPTH_16:
                                flag |= gl.DEPTH_BUFFER_BIT;
                                break;
                            case Laya.BaseTexture.FORMAT_STENCIL_8:
                                flag |= gl.STENCIL_BUFFER_BIT;
                                break;
                            case Laya.BaseTexture.FORMAT_DEPTHSTENCIL_16_8:
                                flag |= gl.DEPTH_BUFFER_BIT, flag |= gl.STENCIL_BUFFER_BIT
                        } else flag = gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT;
                        Laya.WebGLContext.setDepthMask(gl, !0), gl.clear(flag), gl.disable(gl.SCISSOR_TEST);
                        break;
                    case BaseCamera.CLEARFLAG_SKY:
                    case BaseCamera.CLEARFLAG_DEPTHONLY:
                        if (gl.enable(gl.SCISSOR_TEST), gl.scissor(vpX, vpY, vpW, vpH), renderTexture) switch (renderTexture.depthStencilFormat) {
                            case Laya.BaseTexture.FORMAT_DEPTH_16:
                                flag = gl.DEPTH_BUFFER_BIT;
                                break;
                            case Laya.BaseTexture.FORMAT_STENCIL_8:
                                flag = gl.STENCIL_BUFFER_BIT;
                                break;
                            case Laya.BaseTexture.FORMAT_DEPTHSTENCIL_16_8:
                                flag = gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT
                        } else flag = gl.DEPTH_BUFFER_BIT;
                        Laya.WebGLContext.setDepthMask(gl, !0), gl.clear(flag), gl.disable(gl.SCISSOR_TEST);
                        break;
                    case BaseCamera.CLEARFLAG_NONE:
                        break;
                    default:
                        throw new Error("BaseScene:camera clearFlag invalid.")
                }
            }

            _renderScene(context) {
                var camera = context.camera, renderTar = camera._renderTexture || camera._offScreenRenderTexture;
                if (renderTar ? this._opaqueQueue._render(context, !0) : this._opaqueQueue._render(context, !1), camera.clearFlag === BaseCamera.CLEARFLAG_SKY && (camera.skyRenderer._isAvailable() ? camera.skyRenderer._render(context) : this._skyRenderer._isAvailable() && this._skyRenderer._render(context)), renderTar ? this._transparentQueue._render(context, !0) : this._transparentQueue._render(context, !1), FrustumCulling.debugFrustumCulling) for (var renderElements = this._debugTool._render._renderElements, i = 0, n = renderElements.length; i < n; i++) renderElements[i]._update(this, context, null, null), renderElements[i]._render(context, !1)
            }

            _parse(data, spriteMap) {
                var lightMapsData = data.lightmaps;
                if (lightMapsData) {
                    for (var lightMapCount = lightMapsData.length, lightmaps = [], i = 0; i < lightMapCount; i++) lightmaps[i] = Laya.Loader.getRes(lightMapsData[i].path);
                    this.setlightmaps(lightmaps)
                }
                var ambientColorData = data.ambientColor;
                if (ambientColorData) {
                    var ambCol = this.ambientColor;
                    ambCol.fromArray(ambientColorData), this.ambientColor = ambCol
                }
                var skyData = data.sky;
                if (skyData) switch (this._skyRenderer.material = Laya.Loader.getRes(skyData.material.path), skyData.mesh) {
                    case"SkyBox":
                        this._skyRenderer.mesh = SkyBox.instance;
                        break;
                    case"SkyDome":
                        this._skyRenderer.mesh = SkyDome.instance;
                        break;
                    default:
                        this.skyRenderer.mesh = SkyBox.instance
                }
                var reflectionTextureData = data.reflectionTexture;
                reflectionTextureData && (this.customReflection = Laya.Loader.getRes(reflectionTextureData)), this.enableFog = data.enableFog, this.fogStart = data.fogStart, this.fogRange = data.fogRange;
                var fogColorData = data.fogColor;
                if (fogColorData) {
                    var fogCol = this.fogColor;
                    fogCol.fromArray(fogColorData), this.fogColor = fogCol
                }
            }

            _onActive() {
                super._onActive(), Laya.ILaya.stage._scene3Ds.push(this)
            }

            _onInActive() {
                super._onInActive();
                var scenes = Laya.ILaya.stage._scene3Ds;
                scenes.splice(scenes.indexOf(this), 1)
            }

            _addLight(light) {
                this._lights.indexOf(light) < 0 && this._lights.push(light)
            }

            _removeLight(light) {
                var index = this._lights.indexOf(light);
                index >= 0 && this._lights.splice(index, 1)
            }

            _addRenderObject(render) {
                if (this._octree && render._supportOctree) this._octree.add(render); else if (this._renders.add(render), Laya.Render.supportWebGLPlusCulling) {
                    var indexInList = render._getIndexInList(), length = this._cullingBufferIndices.length;
                    if (indexInList >= length) {
                        var tempIndices = this._cullingBufferIndices, tempResult = this._cullingBufferResult;
                        this._cullingBufferIndices = new Int32Array(length + 1024), this._cullingBufferResult = new Int32Array(length + 1024), this._cullingBufferIndices.set(tempIndices, 0), this._cullingBufferResult.set(tempResult, 0)
                    }
                    this._cullingBufferIndices[indexInList] = render._cullingBufferIndex
                }
            }

            _removeRenderObject(render) {
                var endRender;
                this._octree && render._supportOctree ? this._octree.remove(render) : (Laya.Render.supportWebGLPlusCulling && (endRender = this._renders.elements[this._renders.length - 1]), this._renders.remove(render), Laya.Render.supportWebGLPlusCulling && (this._cullingBufferIndices[endRender._getIndexInList()] = endRender._cullingBufferIndex))
            }

            _addShadowCastRenderObject(render) {
                this._octree || this._castShadowRenders.add(render)
            }

            _removeShadowCastRenderObject(render) {
                this._octree || this._castShadowRenders.remove(render)
            }

            _getRenderQueue(index) {
                return index <= 2500 ? this._opaqueQueue : this._transparentQueue
            }

            setlightmaps(value) {
                for (var maps = this._lightmaps, i = 0, n = maps.length; i < n; i++) maps[i]._removeReference();
                if (!value) throw new Error("Scene3D: value value can't be null.");
                var count = value.length;
                for (maps.length = count, i = 0; i < count; i++) {
                    var lightMap = value[i];
                    lightMap._addReference(), maps[i] = lightMap
                }
                for (i = 0, n = this._children.length; i < n; i++) this._setLightmapToChildNode(this._children[i])
            }

            getlightmaps() {
                return this._lightmaps.slice()
            }

            destroy(destroyChild = !0) {
                this.destroyed || (super.destroy(destroyChild), this._skyRenderer.destroy(), this._skyRenderer = null, this._lights = null, this._lightmaps = null, this._renderTargetTexture = null, this._shaderValues = null, this._renders = null, this._castShadowRenders = null, this._cameraPool = null, this._octree = null, this.parallelSplitShadowMaps = null, this._physicsSimulation && this._physicsSimulation._destroy(), Laya.Loader.clearRes(this.url))
            }

            render(ctx, x, y) {
                ctx._curSubmit = Laya.SubmitBase.RENDERBASE, this._children.length > 0 && ctx.addRenderObject(this)
            }

            renderSubmit() {
                var i, n, n1;
                Laya.LayaGL.instance;
                for (this._prepareSceneToRender(), i = 0, n1 = (n = this._cameraPool.length) - 1; i < n; i++) {
                    Laya.Render.supportWebGLPlusRendering && ShaderData.setRuntimeValueMode(i == n1);
                    var camera = this._cameraPool[i];
                    camera.enableRender && camera.render()
                }
                return Laya.Context.set2DRenderConfig(), 1
            }

            getRenderType() {
                return 0
            }

            releaseRender() {
            }

            reUse(context, pos) {
                return 0
            }
        }

        Scene3D.HIERARCHY = "HIERARCHY", Scene3D.physicsSettings = new PhysicsSettings, Scene3D.octreeCulling = !1, Scene3D.octreeInitialSize = 64, Scene3D.octreeInitialCenter = new Vector3(0, 0, 0), Scene3D.octreeMinNodeSize = 2, Scene3D.octreeLooseness = 1.25, Scene3D.REFLECTIONMODE_SKYBOX = 0, Scene3D.REFLECTIONMODE_CUSTOM = 1, Scene3D.FOGCOLOR = Shader3D.propertyNameToID("u_FogColor"), Scene3D.FOGSTART = Shader3D.propertyNameToID("u_FogStart"), Scene3D.FOGRANGE = Shader3D.propertyNameToID("u_FogRange"), Scene3D.LIGHTDIRECTION = Shader3D.propertyNameToID("u_DirectionLight.Direction"), Scene3D.LIGHTDIRCOLOR = Shader3D.propertyNameToID("u_DirectionLight.Color"), Scene3D.POINTLIGHTPOS = Shader3D.propertyNameToID("u_PointLight.Position"), Scene3D.POINTLIGHTRANGE = Shader3D.propertyNameToID("u_PointLight.Range"), Scene3D.POINTLIGHTATTENUATION = Shader3D.propertyNameToID("u_PointLight.Attenuation"), Scene3D.POINTLIGHTCOLOR = Shader3D.propertyNameToID("u_PointLight.Color"), Scene3D.SPOTLIGHTPOS = Shader3D.propertyNameToID("u_SpotLight.Position"), Scene3D.SPOTLIGHTDIRECTION = Shader3D.propertyNameToID("u_SpotLight.Direction"), Scene3D.SPOTLIGHTSPOTANGLE = Shader3D.propertyNameToID("u_SpotLight.Spot"), Scene3D.SPOTLIGHTRANGE = Shader3D.propertyNameToID("u_SpotLight.Range"), Scene3D.SPOTLIGHTCOLOR = Shader3D.propertyNameToID("u_SpotLight.Color"), Scene3D.SHADOWDISTANCE = Shader3D.propertyNameToID("u_shadowPSSMDistance"), Scene3D.SHADOWLIGHTVIEWPROJECT = Shader3D.propertyNameToID("u_lightShadowVP"), Scene3D.SHADOWMAPPCFOFFSET = Shader3D.propertyNameToID("u_shadowPCFoffset"), Scene3D.SHADOWMAPTEXTURE1 = Shader3D.propertyNameToID("u_shadowMap1"), Scene3D.SHADOWMAPTEXTURE2 = Shader3D.propertyNameToID("u_shadowMap2"), Scene3D.SHADOWMAPTEXTURE3 = Shader3D.propertyNameToID("u_shadowMap3"), Scene3D.AMBIENTCOLOR = Shader3D.propertyNameToID("u_AmbientColor"), Scene3D.REFLECTIONTEXTURE = Shader3D.propertyNameToID("u_ReflectTexture"), Scene3D.REFLETIONINTENSITY = Shader3D.propertyNameToID("u_ReflectIntensity"), Scene3D.TIME = Shader3D.propertyNameToID("u_Time"), Scene3D.ANGLEATTENUATIONTEXTURE = Shader3D.propertyNameToID("u_AngleTexture"), Scene3D.RANGEATTENUATIONTEXTURE = Shader3D.propertyNameToID("u_RangeTexture"), Scene3D.POINTLIGHTMATRIX = Shader3D.propertyNameToID("u_PointLightMatrix"), Scene3D.SPOTLIGHTMATRIX = Shader3D.propertyNameToID("u_SpotLightMatrix");

        class Scene3DUtils {
            static _createSprite3DInstance(nodeData, spriteMap, outBatchSprites) {
                var node;
                switch (nodeData.type) {
                    case"Scene3D":
                        node = new Scene3D;
                        break;
                    case"Sprite3D":
                        node = new Sprite3D;
                        break;
                    case"MeshSprite3D":
                        node = new MeshSprite3D, outBatchSprites && outBatchSprites.push(node);
                        break;
                    case"SkinnedMeshSprite3D":
                        node = new SkinnedMeshSprite3D;
                        break;
                    case"ShuriKenParticle3D":
                        node = new ShuriKenParticle3D;
                        break;
                    case"Camera":
                        node = new Camera;
                        break;
                    case"DirectionLight":
                        node = new DirectionLight;
                        break;
                    case"PointLight":
                        node = new PointLight;
                        break;
                    case"SpotLight":
                        node = new SpotLight;
                        break;
                    case"TrailSprite3D":
                        node = new TrailSprite3D;
                        break;
                    default:
                        throw new Error("Utils3D:unidentified class type in (.lh) file.")
                }
                var childData = nodeData.child;
                if (childData) for (var i = 0, n = childData.length; i < n; i++) {
                    var child = Scene3DUtils._createSprite3DInstance(childData[i], spriteMap, outBatchSprites);
                    node.addChild(child)
                }
                return spriteMap[nodeData.instanceID] = node, node
            }

            static _createComponentInstance(nodeData, spriteMap) {
                var node = spriteMap[nodeData.instanceID];
                node._parse(nodeData.props, spriteMap);
                var childData = nodeData.child;
                if (childData) for (var i = 0, n = childData.length; i < n; i++) Scene3DUtils._createComponentInstance(childData[i], spriteMap);
                var componentsData = nodeData.components;
                if (componentsData) for (var j = 0, m = componentsData.length; j < m; j++) {
                    var data = componentsData[j], clas = Laya.ClassUtils.getRegClass(data.type);
                    if (clas) node.addComponent(clas)._parse(data); else console.warn("Unkown component type.")
                }
            }

            static _createNodeByJson02(nodeData, outBatchSprites) {
                var spriteMap = {}, node = Scene3DUtils._createSprite3DInstance(nodeData, spriteMap, outBatchSprites);
                return Scene3DUtils._createComponentInstance(nodeData, spriteMap), node
            }

            static _parse(data, propertyParams = null, constructParams = null) {
                var sprite, json = data.data, outBatchSprits = [];
                switch (data.version) {
                    case"LAYAHIERARCHY:02":
                        sprite = Scene3DUtils._createNodeByJson02(json, outBatchSprits);
                        break;
                    default:
                        sprite = Scene3DUtils._createNodeByJson(json, outBatchSprits)
                }
                return StaticBatchManager.combine(sprite, outBatchSprits), sprite
            }

            static _parseScene(data, propertyParams = null, constructParams = null) {
                var scene, json = data.data, outBatchSprits = [];
                switch (data.version) {
                    case"LAYASCENE3D:02":
                        scene = Scene3DUtils._createNodeByJson02(json, outBatchSprits);
                        break;
                    default:
                        scene = Scene3DUtils._createNodeByJson(json, outBatchSprits)
                }
                return StaticBatchManager.combine(null, outBatchSprits), scene
            }

            static _createNodeByJson(nodeData, outBatchSprites) {
                var node;
                switch (nodeData.type) {
                    case"Scene3D":
                        node = new Scene3D;
                        break;
                    case"Sprite3D":
                        node = new Sprite3D;
                        break;
                    case"MeshSprite3D":
                        node = new MeshSprite3D, outBatchSprites && outBatchSprites.push(node);
                        break;
                    case"SkinnedMeshSprite3D":
                        node = new SkinnedMeshSprite3D;
                        break;
                    case"ShuriKenParticle3D":
                        node = new ShuriKenParticle3D;
                        break;
                    case"Camera":
                        node = new Camera;
                        break;
                    case"DirectionLight":
                        node = new DirectionLight;
                        break;
                    case"PointLight":
                        node = new PointLight;
                        break;
                    case"SpotLight":
                        node = new SpotLight;
                        break;
                    case"TrailSprite3D":
                        node = new TrailSprite3D;
                        break;
                    default:
                        throw new Error("Utils3D:unidentified class type in (.lh) file.")
                }
                var childData = nodeData.child;
                if (childData) for (var i = 0, n = childData.length; i < n; i++) {
                    var child = Scene3DUtils._createNodeByJson(childData[i], outBatchSprites);
                    node.addChild(child)
                }
                var componentsData = nodeData.components;
                if (componentsData) for (var j = 0, m = componentsData.length; j < m; j++) {
                    var data = componentsData[j], clas = Laya.ClassUtils.getRegClass(data.type);
                    if (clas) node.addComponent(clas)._parse(data); else console.warn("Unkown component type.")
                }
                return node._parse(nodeData.props, null), node
            }
        }

        class KeyframeNode {
            constructor() {
                this._ownerPath = [], this._propertys = [], this._keyFrames = []
            }

            get ownerPathCount() {
                return this._ownerPath.length
            }

            get propertyCount() {
                return this._propertys.length
            }

            get keyFramesCount() {
                return this._keyFrames.length
            }

            _setOwnerPathCount(value) {
                this._ownerPath.length = value
            }

            _setOwnerPathByIndex(index, value) {
                this._ownerPath[index] = value
            }

            _joinOwnerPath(sep) {
                return this._ownerPath.join(sep)
            }

            _setPropertyCount(value) {
                this._propertys.length = value
            }

            _setPropertyByIndex(index, value) {
                this._propertys[index] = value
            }

            _joinProperty(sep) {
                return this._propertys.join(sep)
            }

            _setKeyframeCount(value) {
                this._keyFrames.length = value
            }

            _setKeyframeByIndex(index, value) {
                this._keyFrames[index] = value
            }

            getOwnerPathByIndex(index) {
                return this._ownerPath[index]
            }

            getPropertyByIndex(index) {
                return this._propertys[index]
            }

            getKeyframeByIndex(index) {
                return this._keyFrames[index]
            }
        }

        window.conch && window.conchKeyframeNode && (KeyframeNode = window.conchKeyframeNode);

        class AnimationEvent {
            constructor() {
            }
        }

        class QuaternionKeyframe extends Keyframe {
            constructor() {
                super(), this.inTangent = new Vector4, this.outTangent = new Vector4, this.value = new Quaternion
            }

            cloneTo(dest) {
                super.cloneTo(dest);
                var destKeyFarme = dest;
                this.inTangent.cloneTo(destKeyFarme.inTangent), this.outTangent.cloneTo(destKeyFarme.outTangent), this.value.cloneTo(destKeyFarme.value)
            }
        }

        window.conch && window.conchFloatArrayKeyframe && (QuaternionKeyframe = window.conchFloatArrayKeyframe);

        class Vector3Keyframe extends Keyframe {
            constructor() {
                super(), this.inTangent = new Vector3, this.outTangent = new Vector3, this.value = new Vector3
            }

            cloneTo(dest) {
                super.cloneTo(dest);
                var destKeyFarme = dest;
                this.inTangent.cloneTo(destKeyFarme.inTangent), this.outTangent.cloneTo(destKeyFarme.outTangent), this.value.cloneTo(destKeyFarme.value)
            }
        }

        window.conch && window.conchFloatArrayKeyframe && (Vector3Keyframe = window.conchFloatArrayKeyframe);

        class ConchVector4 {
            constructor(x = 0, y = 0, z = 0, w = 0) {
                var v = this.elements = new Float32Array(4);
                v[0] = x, v[1] = y, v[2] = z, v[3] = w
            }

            get x() {
                return this.elements[0]
            }

            set x(value) {
                this.elements[0] = value
            }

            get y() {
                return this.elements[1]
            }

            set y(value) {
                this.elements[1] = value
            }

            get z() {
                return this.elements[2]
            }

            set z(value) {
                this.elements[2] = value
            }

            get w() {
                return this.elements[3]
            }

            set w(value) {
                this.elements[3] = value
            }

            fromArray(array, offset = 0) {
                this.elements[0] = array[offset + 0], this.elements[1] = array[offset + 1], this.elements[2] = array[offset + 2], this.elements[3] = array[offset + 3]
            }

            cloneTo(destObject) {
                var destE = destObject.elements, s = this.elements;
                destE[0] = s[0], destE[1] = s[1], destE[2] = s[2], destE[3] = s[3]
            }

            clone() {
                var destVector4 = new ConchVector4;
                return this.cloneTo(destVector4), destVector4
            }

            static lerp(a, b, t, out) {
                var e = out.elements, f = a.elements, g = b.elements, ax = f[0], ay = f[1], az = f[2], aw = f[3];
                e[0] = ax + t * (g[0] - ax), e[1] = ay + t * (g[1] - ay), e[2] = az + t * (g[2] - az), e[3] = aw + t * (g[3] - aw)
            }

            static transformByM4x4(vector4, m4x4, out) {
                var ve = vector4.elements, vx = ve[0], vy = ve[1], vz = ve[2], vw = ve[3], me = m4x4.elements,
                    oe = out.elements;
                oe[0] = vx * me[0] + vy * me[4] + vz * me[8] + vw * me[12], oe[1] = vx * me[1] + vy * me[5] + vz * me[9] + vw * me[13], oe[2] = vx * me[2] + vy * me[6] + vz * me[10] + vw * me[14], oe[3] = vx * me[3] + vy * me[7] + vz * me[11] + vw * me[15]
            }

            static equals(a, b) {
                var ae = a.elements, be = b.elements;
                return MathUtils3D.nearEqual(Math.abs(ae[0]), Math.abs(be[0])) && MathUtils3D.nearEqual(Math.abs(ae[1]), Math.abs(be[1])) && MathUtils3D.nearEqual(Math.abs(ae[2]), Math.abs(be[2])) && MathUtils3D.nearEqual(Math.abs(ae[3]), Math.abs(be[3]))
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }

            lengthSquared() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }

            static normalize(s, out) {
                var se = s.elements, oe = out.elements, len = s.length();
                len > 0 && (oe[0] = se[0] * len, oe[1] = se[1] * len, oe[2] = se[2] * len, oe[3] = se[3] * len)
            }

            static add(a, b, out) {
                var oe = out.elements, ae = a.elements, be = b.elements;
                oe[0] = ae[0] + be[0], oe[1] = ae[1] + be[1], oe[2] = ae[2] + be[2], oe[3] = ae[3] + be[3]
            }

            static subtract(a, b, out) {
                var oe = out.elements, ae = a.elements, be = b.elements;
                oe[0] = ae[0] - be[0], oe[1] = ae[1] - be[1], oe[2] = ae[2] - be[2], oe[3] = ae[3] - be[3]
            }

            static multiply(a, b, out) {
                var oe = out.elements, ae = a.elements, be = b.elements;
                oe[0] = ae[0] * be[0], oe[1] = ae[1] * be[1], oe[2] = ae[2] * be[2], oe[3] = ae[3] * be[3]
            }

            static scale(a, b, out) {
                var oe = out.elements, ae = a.elements;
                oe[0] = ae[0] * b, oe[1] = ae[1] * b, oe[2] = ae[2] * b, oe[3] = ae[3] * b
            }

            static Clamp(value, min, max, out) {
                var valuee = value.elements, x = valuee[0], y = valuee[1], z = valuee[2], w = valuee[3],
                    mine = min.elements, mineX = mine[0], mineY = mine[1], mineZ = mine[2], mineW = mine[3],
                    maxe = max.elements, maxeX = maxe[0], maxeY = maxe[1], maxeZ = maxe[2], maxeW = maxe[3],
                    oute = out.elements;
                x = (x = x > maxeX ? maxeX : x) < mineX ? mineX : x, y = (y = y > maxeY ? maxeY : y) < mineY ? mineY : y, z = (z = z > maxeZ ? maxeZ : z) < mineZ ? mineZ : z, w = (w = w > maxeW ? maxeW : w) < mineW ? mineW : w, oute[0] = x, oute[1] = y, oute[2] = z, oute[3] = w
            }

            static distanceSquared(value1, value2) {
                var value1e = value1.elements, value2e = value2.elements, x = value1e[0] - value2e[0],
                    y = value1e[1] - value2e[1], z = value1e[2] - value2e[2], w = value1e[3] - value2e[3];
                return x * x + y * y + z * z + w * w
            }

            static distance(value1, value2) {
                var value1e = value1.elements, value2e = value2.elements, x = value1e[0] - value2e[0],
                    y = value1e[1] - value2e[1], z = value1e[2] - value2e[2], w = value1e[3] - value2e[3];
                return Math.sqrt(x * x + y * y + z * z + w * w)
            }

            static dot(a, b) {
                var ae = a.elements, be = b.elements;
                return ae[0] * be[0] + ae[1] * be[1] + ae[2] * be[2] + ae[3] * be[3]
            }

            static min(a, b, out) {
                var e = out.elements, f = a.elements, g = b.elements;
                e[0] = Math.min(f[0], g[0]), e[1] = Math.min(f[1], g[1]), e[2] = Math.min(f[2], g[2]), e[3] = Math.min(f[3], g[3])
            }

            static max(a, b, out) {
                var e = out.elements, f = a.elements, g = b.elements;
                e[0] = Math.max(f[0], g[0]), e[1] = Math.max(f[1], g[1]), e[2] = Math.max(f[2], g[2]), e[3] = Math.max(f[3], g[3])
            }
        }

        ConchVector4.ZERO = new ConchVector4, ConchVector4.ONE = new ConchVector4(1, 1, 1, 1), ConchVector4.UnitX = new ConchVector4(1, 0, 0, 0), ConchVector4.UnitY = new ConchVector4(0, 1, 0, 0), ConchVector4.UnitZ = new ConchVector4(0, 0, 1, 0), ConchVector4.UnitW = new ConchVector4(0, 0, 0, 1);

        class ConchVector3 {
            constructor(x = 0, y = 0, z = 0, nativeElements = null) {
                var v;
                v = nativeElements || new Float32Array(3), this.elements = v, v[0] = x, v[1] = y, v[2] = z
            }

            static distanceSquared(value1, value2) {
                var value1e = value1.elements, value2e = value2.elements, x = value1e[0] - value2e[0],
                    y = value1e[1] - value2e[1], z = value1e[2] - value2e[2];
                return x * x + y * y + z * z
            }

            static distance(value1, value2) {
                var value1e = value1.elements, value2e = value2.elements, x = value1e[0] - value2e[0],
                    y = value1e[1] - value2e[1], z = value1e[2] - value2e[2];
                return Math.sqrt(x * x + y * y + z * z)
            }

            static min(a, b, out) {
                var e = out.elements, f = a.elements, g = b.elements;
                e[0] = Math.min(f[0], g[0]), e[1] = Math.min(f[1], g[1]), e[2] = Math.min(f[2], g[2])
            }

            static max(a, b, out) {
                var e = out.elements, f = a.elements, g = b.elements;
                e[0] = Math.max(f[0], g[0]), e[1] = Math.max(f[1], g[1]), e[2] = Math.max(f[2], g[2])
            }

            static transformQuat(source, rotation, out) {
                var destination = out.elements, se = source.elements, re = rotation.elements, x = se[0], y = se[1],
                    z = se[2], qx = re[0], qy = re[1], qz = re[2], qw = re[3], ix = qw * x + qy * z - qz * y,
                    iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
                destination[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy, destination[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz, destination[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx
            }

            static scalarLength(a) {
                var f = a.elements, x = f[0], y = f[1], z = f[2];
                return Math.sqrt(x * x + y * y + z * z)
            }

            static scalarLengthSquared(a) {
                var f = a.elements, x = f[0], y = f[1], z = f[2];
                return x * x + y * y + z * z
            }

            static normalize(s, out) {
                var se = s.elements, oe = out.elements, x = se[0], y = se[1], z = se[2], len = x * x + y * y + z * z;
                len > 0 && (len = 1 / Math.sqrt(len), oe[0] = se[0] * len, oe[1] = se[1] * len, oe[2] = se[2] * len)
            }

            static multiply(a, b, out) {
                var e = out.elements, f = a.elements, g = b.elements;
                e[0] = f[0] * g[0], e[1] = f[1] * g[1], e[2] = f[2] * g[2]
            }

            static scale(a, b, out) {
                var e = out.elements, f = a.elements;
                e[0] = f[0] * b, e[1] = f[1] * b, e[2] = f[2] * b
            }

            static lerp(a, b, t, out) {
                var e = out.elements, f = a.elements, g = b.elements, ax = f[0], ay = f[1], az = f[2];
                e[0] = ax + t * (g[0] - ax), e[1] = ay + t * (g[1] - ay), e[2] = az + t * (g[2] - az)
            }

            static transformV3ToV3(vector, transform, result) {
                var intermediate = ConchVector3._tempVector4;
                ConchVector3.transformV3ToV4(vector, transform, intermediate);
                var intermediateElem = intermediate.elements, resultElem = result.elements;
                resultElem[0] = intermediateElem[0], resultElem[1] = intermediateElem[1], resultElem[2] = intermediateElem[2]
            }

            static transformV3ToV4(vector, transform, result) {
                var vectorElem = vector.elements, vectorX = vectorElem[0], vectorY = vectorElem[1],
                    vectorZ = vectorElem[2], transformElem = transform.elements, resultElem = result.elements;
                resultElem[0] = vectorX * transformElem[0] + vectorY * transformElem[4] + vectorZ * transformElem[8] + transformElem[12], resultElem[1] = vectorX * transformElem[1] + vectorY * transformElem[5] + vectorZ * transformElem[9] + transformElem[13], resultElem[2] = vectorX * transformElem[2] + vectorY * transformElem[6] + vectorZ * transformElem[10] + transformElem[14], resultElem[3] = vectorX * transformElem[3] + vectorY * transformElem[7] + vectorZ * transformElem[11] + transformElem[15]
            }

            static TransformNormal(normal, transform, result) {
                var normalElem = normal.elements, normalX = normalElem[0], normalY = normalElem[1],
                    normalZ = normalElem[2], transformElem = transform.elements, resultElem = result.elements;
                resultElem[0] = normalX * transformElem[0] + normalY * transformElem[4] + normalZ * transformElem[8], resultElem[1] = normalX * transformElem[1] + normalY * transformElem[5] + normalZ * transformElem[9], resultElem[2] = normalX * transformElem[2] + normalY * transformElem[6] + normalZ * transformElem[10]
            }

            static transformCoordinate(coordinate, transform, result) {
                var coordinateElem = coordinate.elements, coordinateX = coordinateElem[0],
                    coordinateY = coordinateElem[1], coordinateZ = coordinateElem[2],
                    transformElem = transform.elements,
                    w = coordinateX * transformElem[3] + coordinateY * transformElem[7] + coordinateZ * transformElem[11] + transformElem[15],
                    resultElem = result.elements;
                resultElem[0] = coordinateX * transformElem[0] + coordinateY * transformElem[4] + coordinateZ * transformElem[8] + transformElem[12] / w, resultElem[1] = coordinateX * transformElem[1] + coordinateY * transformElem[5] + coordinateZ * transformElem[9] + transformElem[13] / w, resultElem[2] = coordinateX * transformElem[2] + coordinateY * transformElem[6] + coordinateZ * transformElem[10] + transformElem[14] / w
            }

            static Clamp(value, min, max, out) {
                var valuee = value.elements, x = valuee[0], y = valuee[1], z = valuee[2], mine = min.elements,
                    mineX = mine[0], mineY = mine[1], mineZ = mine[2], maxe = max.elements, maxeX = maxe[0],
                    maxeY = maxe[1], maxeZ = maxe[2], oute = out.elements;
                x = (x = x > maxeX ? maxeX : x) < mineX ? mineX : x, y = (y = y > maxeY ? maxeY : y) < mineY ? mineY : y, z = (z = z > maxeZ ? maxeZ : z) < mineZ ? mineZ : z, oute[0] = x, oute[1] = y, oute[2] = z
            }

            static add(a, b, out) {
                var e = out.elements, f = a.elements, g = b.elements;
                e[0] = f[0] + g[0], e[1] = f[1] + g[1], e[2] = f[2] + g[2]
            }

            static subtract(a, b, o) {
                var oe = o.elements, ae = a.elements, be = b.elements;
                oe[0] = ae[0] - be[0], oe[1] = ae[1] - be[1], oe[2] = ae[2] - be[2]
            }

            static cross(a, b, o) {
                var ae = a.elements, be = b.elements, oe = o.elements, ax = ae[0], ay = ae[1], az = ae[2], bx = be[0],
                    by = be[1], bz = be[2];
                oe[0] = ay * bz - az * by, oe[1] = az * bx - ax * bz, oe[2] = ax * by - ay * bx
            }

            static dot(a, b) {
                var ae = a.elements, be = b.elements;
                return ae[0] * be[0] + ae[1] * be[1] + ae[2] * be[2]
            }

            static equals(a, b) {
                var ae = a.elements, be = b.elements;
                return MathUtils3D.nearEqual(ae[0], be[0]) && MathUtils3D.nearEqual(ae[1], be[1]) && MathUtils3D.nearEqual(ae[2], be[2])
            }

            get x() {
                return this.elements[0]
            }

            set x(value) {
                this.elements[0] = value
            }

            get y() {
                return this.elements[1]
            }

            set y(value) {
                this.elements[1] = value
            }

            get z() {
                return this.elements[2]
            }

            set z(value) {
                this.elements[2] = value
            }

            setValue(x, y, z) {
                this.elements[0] = x, this.elements[1] = y, this.elements[2] = z
            }

            fromArray(array, offset = 0) {
                this.elements[0] = array[offset + 0], this.elements[1] = array[offset + 1], this.elements[2] = array[offset + 2]
            }

            cloneTo(destObject) {
                var destE = destObject.elements, s = this.elements;
                destE[0] = s[0], destE[1] = s[1], destE[2] = s[2]
            }

            clone() {
                var destVector3 = new ConchVector3;
                return this.cloneTo(destVector3), destVector3
            }

            toDefault() {
                this.elements[0] = 0, this.elements[1] = 0, this.elements[2] = 0
            }
        }

        ConchVector3._tempVector4 = new ConchVector4, ConchVector3.ZERO = new ConchVector3(0, 0, 0), ConchVector3.ONE = new ConchVector3(1, 1, 1), ConchVector3.NegativeUnitX = new ConchVector3(-1, 0, 0), ConchVector3.UnitX = new ConchVector3(1, 0, 0), ConchVector3.UnitY = new ConchVector3(0, 1, 0), ConchVector3.UnitZ = new ConchVector3(0, 0, 1), ConchVector3.ForwardRH = new ConchVector3(0, 0, -1), ConchVector3.ForwardLH = new ConchVector3(0, 0, 1), ConchVector3.Up = new ConchVector3(0, 1, 0), ConchVector3.NAN = new ConchVector3(NaN, NaN, NaN);

        class ConchQuaternion {
            constructor(x = 0, y = 0, z = 0, w = 1, nativeElements = null) {
                var v;
                (v = nativeElements || new Float32Array(4))[0] = x, v[1] = y, v[2] = z, v[3] = w, this.elements = v
            }

            static _dotArray(l, r) {
                return l[0] * r[0] + l[1] * r[1] + l[2] * r[2] + l[3] * r[3]
            }

            static _normalizeArray(f, o) {
                var x = f[0], y = f[1], z = f[2], w = f[3], len = x * x + y * y + z * z + w * w;
                len > 0 && (len = 1 / Math.sqrt(len), o[0] = x * len, o[1] = y * len, o[2] = z * len, o[3] = w * len)
            }

            static _lerpArray(l, r, amount, o) {
                var inverse = 1 - amount;
                ConchQuaternion._dotArray(l, r) >= 0 ? (o[0] = inverse * l[0] + amount * r[0], o[1] = inverse * l[1] + amount * r[1], o[2] = inverse * l[2] + amount * r[2], o[3] = inverse * l[3] + amount * r[3]) : (o[0] = inverse * l[0] - amount * r[0], o[1] = inverse * l[1] - amount * r[1], o[2] = inverse * l[2] - amount * r[2], o[3] = inverse * l[3] - amount * r[3]), ConchQuaternion._normalizeArray(o, o)
            }

            static createFromYawPitchRoll(yaw, pitch, roll, out) {
                var halfRoll = .5 * roll, halfPitch = .5 * pitch, halfYaw = .5 * yaw, sinRoll = Math.sin(halfRoll),
                    cosRoll = Math.cos(halfRoll), sinPitch = Math.sin(halfPitch), cosPitch = Math.cos(halfPitch),
                    sinYaw = Math.sin(halfYaw), cosYaw = Math.cos(halfYaw), oe = out.elements;
                oe[0] = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll, oe[1] = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll, oe[2] = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll, oe[3] = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll
            }

            static multiply(left, right, out) {
                var le = left.elements, re = right.elements, oe = out.elements, lx = le[0], ly = le[1], lz = le[2],
                    lw = le[3], rx = re[0], ry = re[1], rz = re[2], rw = re[3], a = ly * rz - lz * ry,
                    b = lz * rx - lx * rz, c = lx * ry - ly * rx, d = lx * rx + ly * ry + lz * rz;
                oe[0] = lx * rw + rx * lw + a, oe[1] = ly * rw + ry * lw + b, oe[2] = lz * rw + rz * lw + c, oe[3] = lw * rw - d
            }

            static arcTanAngle(x, y) {
                return 0 == x ? 1 == y ? Math.PI / 2 : -Math.PI / 2 : x > 0 ? Math.atan(y / x) : x < 0 ? y > 0 ? Math.atan(y / x) + Math.PI : Math.atan(y / x) - Math.PI : 0
            }

            static angleTo(from, location, angle) {
                ConchVector3.subtract(location, from, ConchQuaternion.TEMPVector30), ConchVector3.normalize(ConchQuaternion.TEMPVector30, ConchQuaternion.TEMPVector30), angle.elements[0] = Math.asin(ConchQuaternion.TEMPVector30.y), angle.elements[1] = ConchQuaternion.arcTanAngle(-ConchQuaternion.TEMPVector30.z, -ConchQuaternion.TEMPVector30.x)
            }

            static createFromAxisAngle(axis, rad, out) {
                var e = out.elements, f = axis.elements;
                rad *= .5;
                var s = Math.sin(rad);
                e[0] = s * f[0], e[1] = s * f[1], e[2] = s * f[2], e[3] = Math.cos(rad)
            }

            static createFromMatrix3x3(sou, out) {
                var fRoot, e = out.elements, f = sou.elements, fTrace = f[0] + f[4] + f[8];
                if (fTrace > 0) fRoot = Math.sqrt(fTrace + 1), e[3] = .5 * fRoot, fRoot = .5 / fRoot, e[0] = (f[5] - f[7]) * fRoot, e[1] = (f[6] - f[2]) * fRoot, e[2] = (f[1] - f[3]) * fRoot; else {
                    var i = 0;
                    f[4] > f[0] && (i = 1), f[8] > f[3 * i + i] && (i = 2);
                    var j = (i + 1) % 3, k = (i + 2) % 3;
                    fRoot = Math.sqrt(f[3 * i + i] - f[3 * j + j] - f[3 * k + k] + 1), e[i] = .5 * fRoot, fRoot = .5 / fRoot, e[3] = (f[3 * j + k] - f[3 * k + j]) * fRoot, e[j] = (f[3 * j + i] + f[3 * i + j]) * fRoot, e[k] = (f[3 * k + i] + f[3 * i + k]) * fRoot
                }
            }

            static createFromMatrix4x4(mat, out) {
                var sqrt, half, me = mat.elements, oe = out.elements, scale = me[0] + me[5] + me[10];
                scale > 0 ? (sqrt = Math.sqrt(scale + 1), oe[3] = .5 * sqrt, sqrt = .5 / sqrt, oe[0] = (me[6] - me[9]) * sqrt, oe[1] = (me[8] - me[2]) * sqrt, oe[2] = (me[1] - me[4]) * sqrt) : me[0] >= me[5] && me[0] >= me[10] ? (half = .5 / (sqrt = Math.sqrt(1 + me[0] - me[5] - me[10])), oe[0] = .5 * sqrt, oe[1] = (me[1] + me[4]) * half, oe[2] = (me[2] + me[8]) * half, oe[3] = (me[6] - me[9]) * half) : me[5] > me[10] ? (half = .5 / (sqrt = Math.sqrt(1 + me[5] - me[0] - me[10])), oe[0] = (me[4] + me[1]) * half, oe[1] = .5 * sqrt, oe[2] = (me[9] + me[6]) * half, oe[3] = (me[8] - me[2]) * half) : (half = .5 / (sqrt = Math.sqrt(1 + me[10] - me[0] - me[5])), oe[0] = (me[8] + me[2]) * half, oe[1] = (me[9] + me[6]) * half, oe[2] = .5 * sqrt, oe[3] = (me[1] - me[4]) * half)
            }

            static slerp(left, right, t, out) {
                var omega, cosom, sinom, scale0, scale1, a = left.elements, b = right.elements, oe = out.elements,
                    ax = a[0], ay = a[1], az = a[2], aw = a[3], bx = b[0], by = b[1], bz = b[2], bw = b[3];
                return (cosom = ax * bx + ay * by + az * bz + aw * bw) < 0 && (cosom = -cosom, bx = -bx, by = -by, bz = -bz, bw = -bw), 1 - cosom > 1e-6 ? (omega = Math.acos(cosom), sinom = Math.sin(omega), scale0 = Math.sin((1 - t) * omega) / sinom, scale1 = Math.sin(t * omega) / sinom) : (scale0 = 1 - t, scale1 = t), oe[0] = scale0 * ax + scale1 * bx, oe[1] = scale0 * ay + scale1 * by, oe[2] = scale0 * az + scale1 * bz, oe[3] = scale0 * aw + scale1 * bw, oe
            }

            static lerp(left, right, amount, out) {
                ConchQuaternion._lerpArray(left.elements, right.elements, amount, out.elements)
            }

            static add(left, right, out) {
                var e = out.elements, f = left.elements, g = right.elements;
                e[0] = f[0] + g[0], e[1] = f[1] + g[1], e[2] = f[2] + g[2], e[3] = f[3] + g[3]
            }

            static dot(left, right) {
                return ConchQuaternion._dotArray(left.elements, right.elements)
            }

            get x() {
                return this.elements[0]
            }

            set x(value) {
                this.elements[0] = value
            }

            get y() {
                return this.elements[1]
            }

            set y(value) {
                this.elements[1] = value
            }

            get z() {
                return this.elements[2]
            }

            set z(value) {
                this.elements[2] = value
            }

            get w() {
                return this.elements[3]
            }

            set w(value) {
                this.elements[3] = value
            }

            scaling(scaling, out) {
                var e = out.elements, f = this.elements;
                e[0] = f[0] * scaling, e[1] = f[1] * scaling, e[2] = f[2] * scaling, e[3] = f[3] * scaling
            }

            normalize(out) {
                ConchQuaternion._normalizeArray(this.elements, out.elements)
            }

            length() {
                var f = this.elements, x = f[0], y = f[1], z = f[2], w = f[3];
                return Math.sqrt(x * x + y * y + z * z + w * w)
            }

            rotateX(rad, out) {
                var e = out.elements, f = this.elements;
                rad *= .5;
                var ax = f[0], ay = f[1], az = f[2], aw = f[3], bx = Math.sin(rad), bw = Math.cos(rad);
                e[0] = ax * bw + aw * bx, e[1] = ay * bw + az * bx, e[2] = az * bw - ay * bx, e[3] = aw * bw - ax * bx
            }

            rotateY(rad, out) {
                var e = out.elements, f = this.elements;
                rad *= .5;
                var ax = f[0], ay = f[1], az = f[2], aw = f[3], by = Math.sin(rad), bw = Math.cos(rad);
                e[0] = ax * bw - az * by, e[1] = ay * bw + aw * by, e[2] = az * bw + ax * by, e[3] = aw * bw - ay * by
            }

            rotateZ(rad, out) {
                var e = out.elements, f = this.elements;
                rad *= .5;
                var ax = f[0], ay = f[1], az = f[2], aw = f[3], bz = Math.sin(rad), bw = Math.cos(rad);
                e[0] = ax * bw + ay * bz, e[1] = ay * bw - ax * bz, e[2] = az * bw + aw * bz, e[3] = aw * bw - az * bz
            }

            getYawPitchRoll(out) {
                ConchVector3.transformQuat(ConchVector3.ForwardRH, this, ConchQuaternion.TEMPVector31), ConchVector3.transformQuat(ConchVector3.Up, this, ConchQuaternion.TEMPVector32);
                var upe = ConchQuaternion.TEMPVector32.elements;
                ConchQuaternion.angleTo(ConchVector3.ZERO, ConchQuaternion.TEMPVector31, ConchQuaternion.TEMPVector33);
                var anglee = ConchQuaternion.TEMPVector33.elements;
                anglee[0] == Math.PI / 2 ? (anglee[1] = ConchQuaternion.arcTanAngle(upe[2], upe[0]), anglee[2] = 0) : anglee[0] == -Math.PI / 2 ? (anglee[1] = ConchQuaternion.arcTanAngle(-upe[2], -upe[0]), anglee[2] = 0) : (Matrix4x4.createRotationY(-anglee[1], ConchQuaternion.TEMPMatrix0), Matrix4x4.createRotationX(-anglee[0], ConchQuaternion.TEMPMatrix1), ConchVector3.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix0, ConchQuaternion.TEMPVector32), ConchVector3.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix1, ConchQuaternion.TEMPVector32), anglee[2] = ConchQuaternion.arcTanAngle(upe[1], -upe[0])), anglee[1] <= -Math.PI && (anglee[1] = Math.PI), anglee[2] <= -Math.PI && (anglee[2] = Math.PI), anglee[1] >= Math.PI && anglee[2] >= Math.PI && (anglee[1] = 0, anglee[2] = 0, anglee[0] = Math.PI - anglee[0]);
                var oe = out.elements;
                oe[0] = anglee[1], oe[1] = anglee[0], oe[2] = anglee[2]
            }

            invert(out) {
                var e = out.elements, f = this.elements, a0 = f[0], a1 = f[1], a2 = f[2], a3 = f[3],
                    dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3, invDot = dot ? 1 / dot : 0;
                e[0] = -a0 * invDot, e[1] = -a1 * invDot, e[2] = -a2 * invDot, e[3] = a3 * invDot
            }

            identity() {
                var e = this.elements;
                e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1
            }

            fromArray(array, offset = 0) {
                this.elements[0] = array[offset + 0], this.elements[1] = array[offset + 1], this.elements[2] = array[offset + 2], this.elements[3] = array[offset + 3]
            }

            cloneTo(destObject) {
                var i, s, d;
                if ((s = this.elements) !== (d = destObject.elements)) for (i = 0; i < 4; ++i) d[i] = s[i]
            }

            clone() {
                var dest = new ConchQuaternion;
                return this.cloneTo(dest), dest
            }

            equals(b) {
                var ae = this.elements, be = b.elements;
                return MathUtils3D.nearEqual(ae[0], be[0]) && MathUtils3D.nearEqual(ae[1], be[1]) && MathUtils3D.nearEqual(ae[2], be[2]) && MathUtils3D.nearEqual(ae[3], be[3])
            }

            static rotationLookAt(forward, up, out) {
                ConchQuaternion.lookAt(ConchVector3.ZERO, forward, up, out)
            }

            static lookAt(eye, target, up, out) {
                Matrix3x3.lookAt(eye, target, up, ConchQuaternion._tempMatrix3x3), ConchQuaternion.rotationMatrix(ConchQuaternion._tempMatrix3x3, out)
            }

            lengthSquared() {
                var x = this.elements[0], y = this.elements[1], z = this.elements[2], w = this.elements[3];
                return x * x + y * y + z * z + w * w
            }

            static invert(value, out) {
                var vE = value.elements, oE = out.elements, lengthSq = value.lengthSquared();
                MathUtils3D.isZero(lengthSq) || (lengthSq = 1 / lengthSq, oE[0] = -vE[0] * lengthSq, oE[1] = -vE[1] * lengthSq, oE[2] = -vE[2] * lengthSq, oE[3] = vE[3] * lengthSq)
            }

            static rotationMatrix(matrix3x3, out) {
                var sqrt, half, me = matrix3x3.elements, m11 = me[0], m12 = me[1], m13 = me[2], m21 = me[3],
                    m22 = me[4], m23 = me[5], m31 = me[6], m32 = me[7], m33 = me[8], oe = out.elements,
                    scale = m11 + m22 + m33;
                scale > 0 ? (sqrt = Math.sqrt(scale + 1), oe[3] = .5 * sqrt, sqrt = .5 / sqrt, oe[0] = (m23 - m32) * sqrt, oe[1] = (m31 - m13) * sqrt, oe[2] = (m12 - m21) * sqrt) : m11 >= m22 && m11 >= m33 ? (half = .5 / (sqrt = Math.sqrt(1 + m11 - m22 - m33)), oe[0] = .5 * sqrt, oe[1] = (m12 + m21) * half, oe[2] = (m13 + m31) * half, oe[3] = (m23 - m32) * half) : m22 > m33 ? (half = .5 / (sqrt = Math.sqrt(1 + m22 - m11 - m33)), oe[0] = (m21 + m12) * half, oe[1] = .5 * sqrt, oe[2] = (m32 + m23) * half, oe[3] = (m31 - m13) * half) : (half = .5 / (sqrt = Math.sqrt(1 + m33 - m11 - m22)), oe[0] = (m31 + m13) * half, oe[1] = (m32 + m23) * half, oe[2] = .5 * sqrt, oe[3] = (m12 - m21) * half)
            }
        }

        ConchQuaternion.TEMPVector30 = new ConchVector3, ConchQuaternion.TEMPVector31 = new ConchVector3, ConchQuaternion.TEMPVector32 = new ConchVector3, ConchQuaternion.TEMPVector33 = new ConchVector3, ConchQuaternion.TEMPMatrix0 = new Matrix4x4, ConchQuaternion.TEMPMatrix1 = new Matrix4x4, ConchQuaternion._tempMatrix3x3 = new Matrix3x3, ConchQuaternion.DEFAULT = new ConchQuaternion, ConchQuaternion.NAN = new ConchQuaternion(NaN, NaN, NaN, NaN);

        class AnimationClipParser03 {
            static READ_DATA() {
                AnimationClipParser03._DATA.offset = AnimationClipParser03._reader.getUint32(), AnimationClipParser03._DATA.size = AnimationClipParser03._reader.getUint32()
            }

            static READ_BLOCK() {
                for (var count = AnimationClipParser03._BLOCK.count = AnimationClipParser03._reader.getUint16(), blockStarts = AnimationClipParser03._BLOCK.blockStarts = [], blockLengths = AnimationClipParser03._BLOCK.blockLengths = [], i = 0; i < count; i++) blockStarts.push(AnimationClipParser03._reader.getUint32()), blockLengths.push(AnimationClipParser03._reader.getUint32())
            }

            static READ_STRINGS() {
                var offset = AnimationClipParser03._reader.getUint32(),
                    count = AnimationClipParser03._reader.getUint16(), prePos = AnimationClipParser03._reader.pos;
                AnimationClipParser03._reader.pos = offset + AnimationClipParser03._DATA.offset;
                for (var i = 0; i < count; i++) AnimationClipParser03._strings[i] = AnimationClipParser03._reader.readUTFString();
                AnimationClipParser03._reader.pos = prePos
            }

            static parse(clip, reader) {
                AnimationClipParser03._animationClip = clip, AnimationClipParser03._reader = reader;
                reader.__getBuffer();
                AnimationClipParser03.READ_DATA(), AnimationClipParser03.READ_BLOCK(), AnimationClipParser03.READ_STRINGS();
                for (var i = 0, n = AnimationClipParser03._BLOCK.count; i < n; i++) {
                    var index = reader.getUint16(), blockName = AnimationClipParser03._strings[index],
                        fn = AnimationClipParser03["READ_" + blockName];
                    if (null == fn) throw new Error("model file err,no this function:" + index + " " + blockName);
                    fn.call(null)
                }
            }

            static READ_ANIMATIONS() {
                var i, j, node, reader = AnimationClipParser03._reader, startTimeTypes = (reader.__getBuffer(), []),
                    startTimeTypeCount = reader.getUint16();
                for (startTimeTypes.length = startTimeTypeCount, i = 0; i < startTimeTypeCount; i++) startTimeTypes[i] = reader.getFloat32();
                var clip = AnimationClipParser03._animationClip;
                clip.name = AnimationClipParser03._strings[reader.getUint16()];
                var clipDur = clip._duration = reader.getFloat32();
                clip.islooping = !!reader.getByte(), clip._frameRate = reader.getInt16();
                var nodeCount = reader.getInt16(), nodes = clip._nodes;
                nodes.count = nodeCount;
                var nodesMap = clip._nodesMap = {}, nodesDic = clip._nodesDic = {};
                for (i = 0; i < nodeCount; i++) {
                    node = new KeyframeNode, nodes.setNodeByIndex(i, node), node._indexInList = i;
                    var type = node.type = reader.getUint8(), pathLength = reader.getUint16();
                    for (node._setOwnerPathCount(pathLength), j = 0; j < pathLength; j++) node._setOwnerPathByIndex(j, AnimationClipParser03._strings[reader.getUint16()]);
                    var nodePath = node._joinOwnerPath("/"), mapArray = nodesMap[nodePath];
                    mapArray || (nodesMap[nodePath] = mapArray = []), mapArray.push(node), node.propertyOwner = AnimationClipParser03._strings[reader.getUint16()];
                    var propertyLength = reader.getUint16();
                    for (node._setPropertyCount(propertyLength), j = 0; j < propertyLength; j++) node._setPropertyByIndex(j, AnimationClipParser03._strings[reader.getUint16()]);
                    var fullPath = nodePath + "." + node.propertyOwner + "." + node._joinProperty(".");
                    nodesDic[fullPath] = node, node.fullPath = fullPath;
                    var keyframeCount = reader.getUint16();
                    switch (node._setKeyframeCount(keyframeCount), type) {
                        case 0:
                            break;
                        case 1:
                        case 3:
                        case 4:
                            node.data = Laya.Render.supportWebGLPlusAnimation ? new ConchVector3 : new Vector3;
                            break;
                        case 2:
                            node.data = Laya.Render.supportWebGLPlusAnimation ? new ConchQuaternion : new Quaternion;
                            break;
                        default:
                            throw"AnimationClipParser03:unknown type."
                    }
                    for (j = 0; j < keyframeCount; j++) switch (type) {
                        case 0:
                            var floatKeyframe = new FloatKeyframe;
                            node._setKeyframeByIndex(j, floatKeyframe), floatKeyframe.time = startTimeTypes[reader.getUint16()], floatKeyframe.inTangent = reader.getFloat32(), floatKeyframe.outTangent = reader.getFloat32(), floatKeyframe.value = reader.getFloat32();
                            break;
                        case 1:
                        case 3:
                        case 4:
                            var floatArrayKeyframe = new Vector3Keyframe;
                            if (node._setKeyframeByIndex(j, floatArrayKeyframe), floatArrayKeyframe.time = startTimeTypes[reader.getUint16()], Laya.Render.supportWebGLPlusAnimation) {
                                for (var data = floatArrayKeyframe.data = new Float32Array(9), k = 0; k < 3; k++) data[k] = reader.getFloat32();
                                for (k = 0; k < 3; k++) data[3 + k] = reader.getFloat32();
                                for (k = 0; k < 3; k++) data[6 + k] = reader.getFloat32()
                            } else {
                                var inTangent = floatArrayKeyframe.inTangent,
                                    outTangent = floatArrayKeyframe.outTangent, value = floatArrayKeyframe.value;
                                inTangent.x = reader.getFloat32(), inTangent.y = reader.getFloat32(), inTangent.z = reader.getFloat32(), outTangent.x = reader.getFloat32(), outTangent.y = reader.getFloat32(), outTangent.z = reader.getFloat32(), value.x = reader.getFloat32(), value.y = reader.getFloat32(), value.z = reader.getFloat32()
                            }
                            break;
                        case 2:
                            var quaArrayKeyframe = new QuaternionKeyframe;
                            if (node._setKeyframeByIndex(j, quaArrayKeyframe), quaArrayKeyframe.time = startTimeTypes[reader.getUint16()], Laya.Render.supportWebGLPlusAnimation) {
                                for (data = quaArrayKeyframe.data = new Float32Array(12), k = 0; k < 4; k++) data[k] = reader.getFloat32();
                                for (k = 0; k < 4; k++) data[4 + k] = reader.getFloat32();
                                for (k = 0; k < 4; k++) data[8 + k] = reader.getFloat32()
                            } else {
                                var inTangentQua = quaArrayKeyframe.inTangent,
                                    outTangentQua = quaArrayKeyframe.outTangent, valueQua = quaArrayKeyframe.value;
                                inTangentQua.x = reader.getFloat32(), inTangentQua.y = reader.getFloat32(), inTangentQua.z = reader.getFloat32(), inTangentQua.w = reader.getFloat32(), outTangentQua.x = reader.getFloat32(), outTangentQua.y = reader.getFloat32(), outTangentQua.z = reader.getFloat32(), outTangentQua.w = reader.getFloat32(), valueQua.x = reader.getFloat32(), valueQua.y = reader.getFloat32(), valueQua.z = reader.getFloat32(), valueQua.w = reader.getFloat32()
                            }
                            break;
                        default:
                            throw"AnimationClipParser03:unknown type."
                    }
                }
                var eventCount = reader.getUint16();
                for (i = 0; i < eventCount; i++) {
                    var params, event = new AnimationEvent;
                    event.time = Math.min(clipDur, reader.getFloat32()), event.eventName = AnimationClipParser03._strings[reader.getUint16()];
                    var paramCount = reader.getUint16();
                    for (paramCount > 0 && (event.params = params = []), j = 0; j < paramCount; j++) {
                        switch (reader.getByte()) {
                            case 0:
                                params.push(!!reader.getByte());
                                break;
                            case 1:
                                params.push(reader.getInt32());
                                break;
                            case 2:
                                params.push(reader.getFloat32());
                                break;
                            case 3:
                                params.push(AnimationClipParser03._strings[reader.getUint16()]);
                                break;
                            default:
                                throw new Error("unknown type.")
                        }
                    }
                    clip.addEvent(event)
                }
            }
        }

        AnimationClipParser03._strings = [], AnimationClipParser03._BLOCK = {count: 0}, AnimationClipParser03._DATA = {
            offset: 0,
            size: 0
        };

        class HalfFloatUtils {
            static __init__() {
                for (var i = 0; i < 256; ++i) {
                    var e = i - 127;
                    e < -27 ? (HalfFloatUtils._baseTable[0 | i] = 0, HalfFloatUtils._baseTable[256 | i] = 32768, HalfFloatUtils._shiftTable[0 | i] = 24, HalfFloatUtils._shiftTable[256 | i] = 24) : e < -14 ? (HalfFloatUtils._baseTable[0 | i] = 1024 >> -e - 14, HalfFloatUtils._baseTable[256 | i] = 1024 >> -e - 14 | 32768, HalfFloatUtils._shiftTable[0 | i] = -e - 1, HalfFloatUtils._shiftTable[256 | i] = -e - 1) : e <= 15 ? (HalfFloatUtils._baseTable[0 | i] = e + 15 << 10, HalfFloatUtils._baseTable[256 | i] = e + 15 << 10 | 32768, HalfFloatUtils._shiftTable[0 | i] = 13, HalfFloatUtils._shiftTable[256 | i] = 13) : e < 128 ? (HalfFloatUtils._baseTable[0 | i] = 31744, HalfFloatUtils._baseTable[256 | i] = 64512, HalfFloatUtils._shiftTable[0 | i] = 24, HalfFloatUtils._shiftTable[256 | i] = 24) : (HalfFloatUtils._baseTable[0 | i] = 31744, HalfFloatUtils._baseTable[256 | i] = 64512, HalfFloatUtils._shiftTable[0 | i] = 13, HalfFloatUtils._shiftTable[256 | i] = 13)
                }
                for (HalfFloatUtils._mantissaTable[0] = 0, i = 1; i < 1024; ++i) {
                    var m = i << 13;
                    for (e = 0; 0 == (8388608 & m);) e -= 8388608, m <<= 1;
                    m &= -8388609, e += 947912704, HalfFloatUtils._mantissaTable[i] = m | e
                }
                for (i = 1024; i < 2048; ++i) HalfFloatUtils._mantissaTable[i] = 939524096 + (i - 1024 << 13);
                for (HalfFloatUtils._exponentTable[0] = 0, i = 1; i < 31; ++i) HalfFloatUtils._exponentTable[i] = i << 23;
                for (HalfFloatUtils._exponentTable[31] = 1199570944, HalfFloatUtils._exponentTable[32] = 2147483648, i = 33; i < 63; ++i) HalfFloatUtils._exponentTable[i] = 2147483648 + (i - 32 << 23);
                for (HalfFloatUtils._exponentTable[63] = 3347054592, HalfFloatUtils._offsetTable[0] = 0, i = 1; i < 64; ++i) HalfFloatUtils._offsetTable[i] = 32 === i ? 0 : 1024
            }

            static roundToFloat16Bits(num) {
                HalfFloatUtils._floatView[0] = num;
                var f = HalfFloatUtils._uint32View[0], e = f >> 23 & 511;
                return HalfFloatUtils._baseTable[e] + ((8388607 & f) >> HalfFloatUtils._shiftTable[e])
            }

            static convertToNumber(float16bits) {
                var m = float16bits >> 10;
                return HalfFloatUtils._uint32View[0] = HalfFloatUtils._mantissaTable[HalfFloatUtils._offsetTable[m] + (1023 & float16bits)] + HalfFloatUtils._exponentTable[m], HalfFloatUtils._floatView[0]
            }
        }

        HalfFloatUtils._buffer = new ArrayBuffer(4), HalfFloatUtils._floatView = new Float32Array(HalfFloatUtils._buffer), HalfFloatUtils._uint32View = new Uint32Array(HalfFloatUtils._buffer), HalfFloatUtils._baseTable = new Uint32Array(512), HalfFloatUtils._shiftTable = new Uint32Array(512), HalfFloatUtils._mantissaTable = new Uint32Array(2048), HalfFloatUtils._exponentTable = new Uint32Array(64), HalfFloatUtils._offsetTable = new Uint32Array(64);

        class AnimationClipParser04 {
            static READ_DATA() {
                AnimationClipParser04._DATA.offset = AnimationClipParser04._reader.getUint32(), AnimationClipParser04._DATA.size = AnimationClipParser04._reader.getUint32()
            }

            static READ_BLOCK() {
                for (var count = AnimationClipParser04._BLOCK.count = AnimationClipParser04._reader.getUint16(), blockStarts = AnimationClipParser04._BLOCK.blockStarts = [], blockLengths = AnimationClipParser04._BLOCK.blockLengths = [], i = 0; i < count; i++) blockStarts.push(AnimationClipParser04._reader.getUint32()), blockLengths.push(AnimationClipParser04._reader.getUint32())
            }

            static READ_STRINGS() {
                var offset = AnimationClipParser04._reader.getUint32(),
                    count = AnimationClipParser04._reader.getUint16(), prePos = AnimationClipParser04._reader.pos;
                AnimationClipParser04._reader.pos = offset + AnimationClipParser04._DATA.offset;
                for (var i = 0; i < count; i++) AnimationClipParser04._strings[i] = AnimationClipParser04._reader.readUTFString();
                AnimationClipParser04._reader.pos = prePos
            }

            static parse(clip, reader, version) {
                AnimationClipParser04._animationClip = clip, AnimationClipParser04._reader = reader, AnimationClipParser04._version = version, AnimationClipParser04.READ_DATA(), AnimationClipParser04.READ_BLOCK(), AnimationClipParser04.READ_STRINGS();
                for (var i = 0, n = AnimationClipParser04._BLOCK.count; i < n; i++) {
                    var index = reader.getUint16(), blockName = AnimationClipParser04._strings[index],
                        fn = AnimationClipParser04["READ_" + blockName];
                    if (null == fn) throw new Error("model file err,no this function:" + index + " " + blockName);
                    fn.call(null)
                }
                AnimationClipParser04._version = null, AnimationClipParser04._reader = null, AnimationClipParser04._animationClip = null
            }

            static READ_ANIMATIONS() {
                var i, j, node, reader = AnimationClipParser04._reader, startTimeTypes = (reader.__getBuffer(), []),
                    startTimeTypeCount = reader.getUint16();
                for (startTimeTypes.length = startTimeTypeCount, i = 0; i < startTimeTypeCount; i++) startTimeTypes[i] = reader.getFloat32();
                var clip = AnimationClipParser04._animationClip;
                clip.name = AnimationClipParser04._strings[reader.getUint16()];
                var clipDur = clip._duration = reader.getFloat32();
                clip.islooping = !!reader.getByte(), clip._frameRate = reader.getInt16();
                var nodeCount = reader.getInt16(), nodes = clip._nodes;
                nodes.count = nodeCount;
                var nodesMap = clip._nodesMap = {}, nodesDic = clip._nodesDic = {};
                for (i = 0; i < nodeCount; i++) {
                    node = new KeyframeNode, nodes.setNodeByIndex(i, node), node._indexInList = i;
                    var type = node.type = reader.getUint8(), pathLength = reader.getUint16();
                    for (node._setOwnerPathCount(pathLength), j = 0; j < pathLength; j++) node._setOwnerPathByIndex(j, AnimationClipParser04._strings[reader.getUint16()]);
                    var nodePath = node._joinOwnerPath("/"), mapArray = nodesMap[nodePath];
                    mapArray || (nodesMap[nodePath] = mapArray = []), mapArray.push(node), node.propertyOwner = AnimationClipParser04._strings[reader.getUint16()];
                    var propertyLength = reader.getUint16();
                    for (node._setPropertyCount(propertyLength), j = 0; j < propertyLength; j++) node._setPropertyByIndex(j, AnimationClipParser04._strings[reader.getUint16()]);
                    var fullPath = nodePath + "." + node.propertyOwner + "." + node._joinProperty(".");
                    nodesDic[fullPath] = node, node.fullPath = fullPath;
                    var keyframeCount = reader.getUint16();
                    switch (node._setKeyframeCount(keyframeCount), type) {
                        case 0:
                            break;
                        case 1:
                        case 3:
                        case 4:
                            node.data = Laya.Render.supportWebGLPlusAnimation ? new ConchVector3 : new Vector3;
                            break;
                        case 2:
                            node.data = Laya.Render.supportWebGLPlusAnimation ? new ConchQuaternion : new Quaternion;
                            break;
                        default:
                            throw"AnimationClipParser04:unknown type."
                    }
                    switch (AnimationClipParser04._version) {
                        case"LAYAANIMATION:04":
                            for (j = 0; j < keyframeCount; j++) switch (type) {
                                case 0:
                                    var floatKeyframe = new FloatKeyframe;
                                    node._setKeyframeByIndex(j, floatKeyframe), floatKeyframe.time = startTimeTypes[reader.getUint16()], floatKeyframe.inTangent = reader.getFloat32(), floatKeyframe.outTangent = reader.getFloat32(), floatKeyframe.value = reader.getFloat32();
                                    break;
                                case 1:
                                case 3:
                                case 4:
                                    var floatArrayKeyframe = new Vector3Keyframe;
                                    if (node._setKeyframeByIndex(j, floatArrayKeyframe), floatArrayKeyframe.time = startTimeTypes[reader.getUint16()], Laya.Render.supportWebGLPlusAnimation) {
                                        for (var data = floatArrayKeyframe.data = new Float32Array(9), k = 0; k < 3; k++) data[k] = reader.getFloat32();
                                        for (k = 0; k < 3; k++) data[3 + k] = reader.getFloat32();
                                        for (k = 0; k < 3; k++) data[6 + k] = reader.getFloat32()
                                    } else {
                                        var inTangent = floatArrayKeyframe.inTangent,
                                            outTangent = floatArrayKeyframe.outTangent,
                                            value = floatArrayKeyframe.value;
                                        inTangent.x = reader.getFloat32(), inTangent.y = reader.getFloat32(), inTangent.z = reader.getFloat32(), outTangent.x = reader.getFloat32(), outTangent.y = reader.getFloat32(), outTangent.z = reader.getFloat32(), value.x = reader.getFloat32(), value.y = reader.getFloat32(), value.z = reader.getFloat32()
                                    }
                                    break;
                                case 2:
                                    var quaternionKeyframe = new QuaternionKeyframe;
                                    if (node._setKeyframeByIndex(j, quaternionKeyframe), quaternionKeyframe.time = startTimeTypes[reader.getUint16()], Laya.Render.supportWebGLPlusAnimation) {
                                        for (data = quaternionKeyframe.data = new Float32Array(12), k = 0; k < 4; k++) data[k] = reader.getFloat32();
                                        for (k = 0; k < 4; k++) data[4 + k] = reader.getFloat32();
                                        for (k = 0; k < 4; k++) data[8 + k] = reader.getFloat32()
                                    } else {
                                        var inTangentQua = quaternionKeyframe.inTangent,
                                            outTangentQua = quaternionKeyframe.outTangent,
                                            valueQua = quaternionKeyframe.value;
                                        inTangentQua.x = reader.getFloat32(), inTangentQua.y = reader.getFloat32(), inTangentQua.z = reader.getFloat32(), inTangentQua.w = reader.getFloat32(), outTangentQua.x = reader.getFloat32(), outTangentQua.y = reader.getFloat32(), outTangentQua.z = reader.getFloat32(), outTangentQua.w = reader.getFloat32(), valueQua.x = reader.getFloat32(), valueQua.y = reader.getFloat32(), valueQua.z = reader.getFloat32(), valueQua.w = reader.getFloat32()
                                    }
                                    break;
                                default:
                                    throw"AnimationClipParser04:unknown type."
                            }
                            break;
                        case"LAYAANIMATION:COMPRESSION_04":
                            for (j = 0; j < keyframeCount; j++) switch (type) {
                                case 0:
                                    floatKeyframe = new FloatKeyframe, node._setKeyframeByIndex(j, floatKeyframe), floatKeyframe.time = startTimeTypes[reader.getUint16()], floatKeyframe.inTangent = HalfFloatUtils.convertToNumber(reader.getUint16()), floatKeyframe.outTangent = HalfFloatUtils.convertToNumber(reader.getUint16()), floatKeyframe.value = HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                case 1:
                                case 3:
                                case 4:
                                    if (floatArrayKeyframe = new Vector3Keyframe, node._setKeyframeByIndex(j, floatArrayKeyframe), floatArrayKeyframe.time = startTimeTypes[reader.getUint16()], Laya.Render.supportWebGLPlusAnimation) {
                                        for (data = floatArrayKeyframe.data = new Float32Array(9), k = 0; k < 3; k++) data[k] = HalfFloatUtils.convertToNumber(reader.getUint16());
                                        for (k = 0; k < 3; k++) data[3 + k] = HalfFloatUtils.convertToNumber(reader.getUint16());
                                        for (k = 0; k < 3; k++) data[6 + k] = HalfFloatUtils.convertToNumber(reader.getUint16())
                                    } else inTangent = floatArrayKeyframe.inTangent, outTangent = floatArrayKeyframe.outTangent, value = floatArrayKeyframe.value, inTangent.x = HalfFloatUtils.convertToNumber(reader.getUint16()), inTangent.y = HalfFloatUtils.convertToNumber(reader.getUint16()), inTangent.z = HalfFloatUtils.convertToNumber(reader.getUint16()), outTangent.x = HalfFloatUtils.convertToNumber(reader.getUint16()), outTangent.y = HalfFloatUtils.convertToNumber(reader.getUint16()), outTangent.z = HalfFloatUtils.convertToNumber(reader.getUint16()), value.x = HalfFloatUtils.convertToNumber(reader.getUint16()), value.y = HalfFloatUtils.convertToNumber(reader.getUint16()), value.z = HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                case 2:
                                    if (quaternionKeyframe = new QuaternionKeyframe, node._setKeyframeByIndex(j, quaternionKeyframe), quaternionKeyframe.time = startTimeTypes[reader.getUint16()], Laya.Render.supportWebGLPlusAnimation) {
                                        for (data = quaternionKeyframe.data = new Float32Array(12), k = 0; k < 4; k++) data[k] = HalfFloatUtils.convertToNumber(reader.getUint16());
                                        for (k = 0; k < 4; k++) data[4 + k] = HalfFloatUtils.convertToNumber(reader.getUint16());
                                        for (k = 0; k < 4; k++) data[8 + k] = HalfFloatUtils.convertToNumber(reader.getUint16())
                                    } else inTangentQua = quaternionKeyframe.inTangent, outTangentQua = quaternionKeyframe.outTangent, valueQua = quaternionKeyframe.value, inTangentQua.x = HalfFloatUtils.convertToNumber(reader.getUint16()), inTangentQua.y = HalfFloatUtils.convertToNumber(reader.getUint16()), inTangentQua.z = HalfFloatUtils.convertToNumber(reader.getUint16()), inTangentQua.w = HalfFloatUtils.convertToNumber(reader.getUint16()), outTangentQua.x = HalfFloatUtils.convertToNumber(reader.getUint16()), outTangentQua.y = HalfFloatUtils.convertToNumber(reader.getUint16()), outTangentQua.z = HalfFloatUtils.convertToNumber(reader.getUint16()), outTangentQua.w = HalfFloatUtils.convertToNumber(reader.getUint16()), valueQua.x = HalfFloatUtils.convertToNumber(reader.getUint16()), valueQua.y = HalfFloatUtils.convertToNumber(reader.getUint16()), valueQua.z = HalfFloatUtils.convertToNumber(reader.getUint16()), valueQua.w = HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                default:
                                    throw"AnimationClipParser04:unknown type."
                            }
                    }
                }
                var eventCount = reader.getUint16();
                for (i = 0; i < eventCount; i++) {
                    var params, event = new AnimationEvent;
                    event.time = Math.min(clipDur, reader.getFloat32()), event.eventName = AnimationClipParser04._strings[reader.getUint16()];
                    var paramCount = reader.getUint16();
                    for (paramCount > 0 && (event.params = params = []), j = 0; j < paramCount; j++) {
                        switch (reader.getByte()) {
                            case 0:
                                params.push(!!reader.getByte());
                                break;
                            case 1:
                                params.push(reader.getInt32());
                                break;
                            case 2:
                                params.push(reader.getFloat32());
                                break;
                            case 3:
                                params.push(AnimationClipParser04._strings[reader.getUint16()]);
                                break;
                            default:
                                throw new Error("unknown type.")
                        }
                    }
                    clip.addEvent(event)
                }
            }
        }

        AnimationClipParser04._strings = [], AnimationClipParser04._BLOCK = {count: 0}, AnimationClipParser04._DATA = {
            offset: 0,
            size: 0
        };

        class KeyframeNodeList {
            constructor() {
                this._nodes = []
            }

            get count() {
                return this._nodes.length
            }

            set count(value) {
                this._nodes.length = value
            }

            getNodeByIndex(index) {
                return this._nodes[index]
            }

            setNodeByIndex(index, node) {
                this._nodes[index] = node
            }
        }

        window.conch && window.conchKeyframeNodeList && (KeyframeNodeList = window.conchKeyframeNodeList);

        class AnimationClip extends Laya.Resource {
            constructor() {
                super(), this._nodes = new KeyframeNodeList, this._animationEvents = []
            }

            static _parse(data, propertyParams = null, constructParams = null) {
                var clip = new AnimationClip, reader = new Laya.Byte(data), version = reader.readUTFString();
                switch (version) {
                    case"LAYAANIMATION:03":
                        AnimationClipParser03.parse(clip, reader);
                        break;
                    case"LAYAANIMATION:04":
                    case"LAYAANIMATION:COMPRESSION_04":
                        AnimationClipParser04.parse(clip, reader, version);
                        break;
                    default:
                        throw"unknown animationClip version."
                }
                return clip
            }

            static load(url, complete) {
                Laya.ILaya.loader.create(url, complete, null, AnimationClip.ANIMATIONCLIP)
            }

            duration() {
                return this._duration
            }

            _hermiteInterpolate(frame, nextFrame, t, dur) {
                var t0 = frame.outTangent, t1 = nextFrame.inTangent;
                if (Number.isFinite(t0) && Number.isFinite(t1)) {
                    var t2 = t * t, t3 = t2 * t, b = t3 - 2 * t2 + t, c = t3 - t2, d = -2 * t3 + 3 * t2;
                    return (2 * t3 - 3 * t2 + 1) * frame.value + b * t0 * dur + c * t1 * dur + d * nextFrame.value
                }
                return frame.value
            }

            _hermiteInterpolateVector3(frame, nextFrame, t, dur, out) {
                var p0 = frame.value, tan0 = frame.outTangent, p1 = nextFrame.value, tan1 = nextFrame.inTangent,
                    t2 = t * t, t3 = t2 * t, a = 2 * t3 - 3 * t2 + 1, b = t3 - 2 * t2 + t, c = t3 - t2,
                    d = -2 * t3 + 3 * t2, t0 = tan0.x, t1 = tan1.x;
                Number.isFinite(t0) && Number.isFinite(t1) ? out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x : out.x = p0.x, t0 = tan0.y, t1 = tan1.y, Number.isFinite(t0) && Number.isFinite(t1) ? out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y : out.y = p0.y, t0 = tan0.z, t1 = tan1.z, Number.isFinite(t0) && Number.isFinite(t1) ? out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z : out.z = p0.z
            }

            _hermiteInterpolateQuaternion(frame, nextFrame, t, dur, out) {
                var p0 = frame.value, tan0 = frame.outTangent, p1 = nextFrame.value, tan1 = nextFrame.inTangent,
                    t2 = t * t, t3 = t2 * t, a = 2 * t3 - 3 * t2 + 1, b = t3 - 2 * t2 + t, c = t3 - t2,
                    d = -2 * t3 + 3 * t2, t0 = tan0.x, t1 = tan1.x;
                Number.isFinite(t0) && Number.isFinite(t1) ? out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x : out.x = p0.x, t0 = tan0.y, t1 = tan1.y, Number.isFinite(t0) && Number.isFinite(t1) ? out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y : out.y = p0.y, t0 = tan0.z, t1 = tan1.z, Number.isFinite(t0) && Number.isFinite(t1) ? out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z : out.z = p0.z, t0 = tan0.w, t1 = tan1.w, Number.isFinite(t0) && Number.isFinite(t1) ? out.w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w : out.w = p0.w
            }

            _evaluateClipDatasRealTime(nodes, playCurTime, realTimeCurrentFrameIndexes, addtive, frontPlay) {
                for (var i = 0, n = nodes.count; i < n; i++) {
                    var nextFrameIndex, node = nodes.getNodeByIndex(i), type = node.type, keyFrames = node._keyFrames,
                        keyFramesCount = keyFrames.length, frameIndex = realTimeCurrentFrameIndexes[i];
                    if (frontPlay) for (-1 !== frameIndex && playCurTime < keyFrames[frameIndex].time && (frameIndex = -1, realTimeCurrentFrameIndexes[i] = frameIndex), nextFrameIndex = frameIndex + 1; nextFrameIndex < keyFramesCount && !(keyFrames[nextFrameIndex].time > playCurTime);) frameIndex++, nextFrameIndex++, realTimeCurrentFrameIndexes[i] = frameIndex; else for ((nextFrameIndex = frameIndex + 1) !== keyFramesCount && playCurTime > keyFrames[nextFrameIndex].time && (frameIndex = keyFramesCount - 1, realTimeCurrentFrameIndexes[i] = frameIndex), nextFrameIndex = frameIndex + 1; frameIndex > -1 && !(keyFrames[frameIndex].time < playCurTime);) frameIndex--, nextFrameIndex--, realTimeCurrentFrameIndexes[i] = frameIndex;
                    var isEnd = nextFrameIndex === keyFramesCount;
                    switch (type) {
                        case 0:
                            if (-1 !== frameIndex) {
                                var frame = keyFrames[frameIndex];
                                if (isEnd) node.data = frame.value; else {
                                    var t, nextFarme = keyFrames[nextFrameIndex], d = nextFarme.time - frame.time;
                                    t = 0 !== d ? (playCurTime - frame.time) / d : 0, node.data = this._hermiteInterpolate(frame, nextFarme, t, d)
                                }
                            } else node.data = keyFrames[0].value;
                            addtive && (node.data -= keyFrames[0].value);
                            break;
                        case 1:
                        case 4:
                            var clipData = node.data;
                            if (this._evaluateFrameNodeVector3DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, clipData), addtive) {
                                var firstFrameValue = keyFrames[0].value;
                                clipData.x -= firstFrameValue.x, clipData.y -= firstFrameValue.y, clipData.z -= firstFrameValue.z
                            }
                            break;
                        case 2:
                            var clipQuat = node.data;
                            if (this._evaluateFrameNodeQuaternionDatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, clipQuat), addtive) {
                                var tempQuat = AnimationClip._tempQuaternion0, firstFrameValueQua = keyFrames[0].value;
                                Utils3D.quaternionConjugate(firstFrameValueQua, tempQuat), Quaternion.multiply(tempQuat, clipQuat, clipQuat)
                            }
                            break;
                        case 3:
                            clipData = node.data, this._evaluateFrameNodeVector3DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, clipData), addtive && (firstFrameValue = keyFrames[0].value, clipData.x /= firstFrameValue.x, clipData.y /= firstFrameValue.y, clipData.z /= firstFrameValue.z);
                            break;
                        default:
                            throw"AnimationClip:unknown node type."
                    }
                }
            }

            _evaluateClipDatasRealTimeForNative(nodes, playCurTime, realTimeCurrentFrameIndexes, addtive) {
                Laya.LayaGL.instance.evaluateClipDatasRealTime(nodes._nativeObj, playCurTime, realTimeCurrentFrameIndexes, addtive)
            }

            _evaluateFrameNodeVector3DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, outDatas) {
                if (-1 !== frameIndex) {
                    var frame = keyFrames[frameIndex];
                    if (isEnd) {
                        var frameData = frame.value;
                        outDatas.x = frameData.x, outDatas.y = frameData.y, outDatas.z = frameData.z
                    } else {
                        var t, nextKeyFrame = keyFrames[frameIndex + 1], startTime = frame.time,
                            d = nextKeyFrame.time - startTime;
                        t = 0 !== d ? (playCurTime - startTime) / d : 0, this._hermiteInterpolateVector3(frame, nextKeyFrame, t, d, outDatas)
                    }
                } else {
                    var firstFrameDatas = keyFrames[0].value;
                    outDatas.x = firstFrameDatas.x, outDatas.y = firstFrameDatas.y, outDatas.z = firstFrameDatas.z
                }
            }

            _evaluateFrameNodeQuaternionDatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, outDatas) {
                if (-1 !== frameIndex) {
                    var frame = keyFrames[frameIndex];
                    if (isEnd) {
                        var frameData = frame.value;
                        outDatas.x = frameData.x, outDatas.y = frameData.y, outDatas.z = frameData.z, outDatas.w = frameData.w
                    } else {
                        var t, nextKeyFrame = keyFrames[frameIndex + 1], startTime = frame.time,
                            d = nextKeyFrame.time - startTime;
                        t = 0 !== d ? (playCurTime - startTime) / d : 0, this._hermiteInterpolateQuaternion(frame, nextKeyFrame, t, d, outDatas)
                    }
                } else {
                    var firstFrameDatas = keyFrames[0].value;
                    outDatas.x = firstFrameDatas.x, outDatas.y = firstFrameDatas.y, outDatas.z = firstFrameDatas.z, outDatas.w = firstFrameDatas.w
                }
            }

            _binarySearchEventIndex(time) {
                for (var mid, start = 0, end = this._animationEvents.length - 1; start <= end;) {
                    mid = Math.floor((start + end) / 2);
                    var midValue = this._animationEvents[mid].time;
                    if (midValue == time) return mid;
                    midValue > time ? end = mid - 1 : start = mid + 1
                }
                return start
            }

            addEvent(event) {
                var index = this._binarySearchEventIndex(event.time);
                this._animationEvents.splice(index, 0, event)
            }

            _disposeResource() {
                this._nodes = null, this._nodesMap = null
            }
        }

        AnimationClip.ANIMATIONCLIP = "ANIMATIONCLIP", AnimationClip._tempQuaternion0 = new Quaternion;

        class AnimationTransform3D extends Laya.EventDispatcher {
            constructor(owner, localPosition = null, localRotation = null, localScale = null, worldMatrix = null) {
                super(), this._owner = owner, this._children = [], this._localMatrix = new Float32Array(16), Laya.Render.supportWebGLPlusAnimation ? (this._localPosition = new ConchVector3(0, 0, 0, localPosition), this._localRotation = new ConchQuaternion(0, 0, 0, 1, localRotation), this._localScale = new ConchVector3(0, 0, 0, localScale), this._worldMatrix = worldMatrix) : (this._localPosition = new Vector3, this._localRotation = new Quaternion, this._localScale = new Vector3, this._worldMatrix = new Float32Array(16)), this._localQuaternionUpdate = !1, this._locaEulerlUpdate = !1, this._localUpdate = !1, this._worldUpdate = !0
            }

            _getlocalMatrix() {
                return this._localUpdate && (Utils3D._createAffineTransformationArray(this._localPosition, this._localRotation, this._localScale, this._localMatrix), this._localUpdate = !1), this._localMatrix
            }

            _onWorldTransform() {
                if (!this._worldUpdate) {
                    this._worldUpdate = !0, this.event(Laya.Event.TRANSFORM_CHANGED);
                    for (var i = 0, n = this._children.length; i < n; i++) this._children[i]._onWorldTransform()
                }
            }

            get localPosition() {
                return this._localPosition
            }

            set localPosition(value) {
                this._localPosition = value, this._localUpdate = !0, this._onWorldTransform()
            }

            get localRotation() {
                if (this._localQuaternionUpdate) {
                    var euler = this._localRotationEuler;
                    Quaternion.createFromYawPitchRoll(euler.y / AnimationTransform3D._angleToRandin, euler.x / AnimationTransform3D._angleToRandin, euler.z / AnimationTransform3D._angleToRandin, this._localRotation), this._localQuaternionUpdate = !1
                }
                return this._localRotation
            }

            set localRotation(value) {
                this._localRotation = value, this._locaEulerlUpdate = !0, this._localQuaternionUpdate = !1, this._localUpdate = !0, this._onWorldTransform()
            }

            get localScale() {
                return this._localScale
            }

            set localScale(value) {
                this._localScale = value, this._localUpdate = !0, this._onWorldTransform()
            }

            get localRotationEuler() {
                if (this._locaEulerlUpdate) {
                    this._localRotation.getYawPitchRoll(AnimationTransform3D._tempVector3);
                    var euler = AnimationTransform3D._tempVector3, localRotationEuler = this._localRotationEuler;
                    localRotationEuler.x = euler.y * AnimationTransform3D._angleToRandin, localRotationEuler.y = euler.x * AnimationTransform3D._angleToRandin, localRotationEuler.z = euler.z * AnimationTransform3D._angleToRandin, this._locaEulerlUpdate = !1
                }
                return this._localRotationEuler
            }

            set localRotationEuler(value) {
                this._localRotationEuler = value, this._locaEulerlUpdate = !1, this._localQuaternionUpdate = !0, this._localUpdate = !0, this._onWorldTransform()
            }

            getWorldMatrix() {
                if (!Laya.Render.supportWebGLPlusAnimation && this._worldUpdate) {
                    if (null != this._parent) Utils3D.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(), this._getlocalMatrix(), this._worldMatrix); else {
                        var e = this._worldMatrix;
                        e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0, e[0] = e[5] = e[10] = e[15] = 1
                    }
                    this._worldUpdate = !1
                }
                return Laya.Render.supportWebGLPlusAnimation && this._worldUpdate && (this._worldUpdate = !1), this._worldMatrix
            }

            setParent(value) {
                if (this._parent !== value) {
                    if (this._parent) {
                        var parentChilds = this._parent._children, index = parentChilds.indexOf(this);
                        parentChilds.splice(index, 1)
                    }
                    value && (value._children.push(this), value && this._onWorldTransform()), this._parent = value
                }
            }
        }

        AnimationTransform3D._tempVector3 = new Vector3, AnimationTransform3D._angleToRandin = 180 / Math.PI;

        class AnimationNode {
            constructor(localPosition = null, localRotation = null, localScale = null, worldMatrix = null) {
                this._children = [], this.transform = new AnimationTransform3D(this, localPosition, localRotation, localScale, worldMatrix)
            }

            addChild(child) {
                child._parent = this, child.transform.setParent(this.transform), this._children.push(child)
            }

            removeChild(child) {
                var index = this._children.indexOf(child);
                -1 !== index && this._children.splice(index, 1)
            }

            getChildByName(name) {
                for (var i = 0, n = this._children.length; i < n; i++) {
                    var child = this._children[i];
                    if (child.name === name) return child
                }
                return null
            }

            getChildByIndex(index) {
                return this._children[index]
            }

            getChildCount() {
                return this._children.length
            }

            cloneTo(destObject) {
                var destNode = destObject;
                destNode.name = this.name;
                for (var i = 0, n = this._children.length; i < n; i++) {
                    var child = this._children[i], destChild = child.clone();
                    destNode.addChild(destChild);
                    var transform = child.transform, destTransform = destChild.transform,
                        destLocalPosition = destTransform.localPosition,
                        destLocalRotation = destTransform.localRotation, destLocalScale = destTransform.localScale;
                    transform.localPosition.cloneTo(destLocalPosition), transform.localRotation.cloneTo(destLocalRotation), transform.localScale.cloneTo(destLocalScale), destTransform.localPosition = destLocalPosition, destTransform.localRotation = destLocalRotation, destTransform.localScale = destLocalScale
                }
            }

            clone() {
                var dest = new AnimationNode;
                return this.cloneTo(dest), dest
            }

            _cloneNative(localPositions, localRotations, localScales, animationNodeWorldMatrixs, animationNodeParentIndices, parentIndex, avatar) {
                var curID = avatar._nativeCurCloneCount;
                animationNodeParentIndices[curID] = parentIndex;
                var localPosition = new Float32Array(localPositions.buffer, 3 * curID * 4, 3),
                    localRotation = new Float32Array(localRotations.buffer, 4 * curID * 4, 4),
                    localScale = new Float32Array(localScales.buffer, 3 * curID * 4, 3),
                    worldMatrix = new Float32Array(animationNodeWorldMatrixs.buffer, 16 * curID * 4, 16),
                    dest = new AnimationNode(localPosition, localRotation, localScale, worldMatrix);
                return dest._worldMatrixIndex = curID, this._cloneToNative(dest, localPositions, localRotations, localScales, animationNodeWorldMatrixs, animationNodeParentIndices, curID, avatar), dest
            }

            _cloneToNative(destObject, localPositions, localRotations, localScales, animationNodeWorldMatrixs, animationNodeParentIndices, parentIndex, avatar) {
                var destNode = destObject;
                destNode.name = this.name;
                for (var i = 0, n = this._children.length; i < n; i++) {
                    var child = this._children[i];
                    avatar._nativeCurCloneCount++;
                    var destChild = child._cloneNative(localPositions, localRotations, localScales, animationNodeWorldMatrixs, animationNodeParentIndices, parentIndex, avatar);
                    destNode.addChild(destChild);
                    var transform = child.transform, destTransform = destChild.transform,
                        destLocalPosition = destTransform.localPosition,
                        destLocalRotation = destTransform.localRotation, destLocalScale = destTransform.localScale;
                    transform.localPosition.cloneTo(destLocalPosition), transform.localRotation.cloneTo(destLocalRotation), transform.localScale.cloneTo(destLocalScale), destTransform.localPosition = destLocalPosition, destTransform.localRotation = destLocalRotation, destTransform.localScale = destLocalScale
                }
            }
        }

        class Avatar extends Laya.Resource {
            constructor() {
                super(), this._nativeNodeCount = 0, this._nativeCurCloneCount = 0
            }

            static _parse(data, propertyParams = null, constructParams = null) {
                var avatar = new Avatar;
                if (avatar._rootNode = new AnimationNode(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16)), Laya.Render.supportWebGLPlusAnimation && avatar._nativeNodeCount++, data.version) {
                    var rootNode = data.rootNode;
                    rootNode && avatar._parseNode(rootNode, avatar._rootNode)
                }
                return avatar
            }

            static load(url, complete) {
                Laya.ILaya.loader.create(url, complete, null, Avatar.AVATAR)
            }

            _initCloneToAnimator(destNode, destAnimator) {
                destAnimator._avatarNodeMap[destNode.name] = destNode;
                for (var i = 0, n = destNode.getChildCount(); i < n; i++) this._initCloneToAnimator(destNode.getChildByIndex(i), destAnimator)
            }

            _parseNode(nodaData, node) {
                var name = nodaData.props.name;
                node.name = name;
                var props = nodaData.props, transform = node.transform, pos = transform.localPosition,
                    rot = transform.localRotation, sca = transform.localScale;
                pos.fromArray(props.translate), rot.fromArray(props.rotation), sca.fromArray(props.scale), transform.localPosition = pos, transform.localRotation = rot, transform.localScale = sca;
                for (var childrenData = nodaData.child, j = 0, n = childrenData.length; j < n; j++) {
                    var childData = childrenData[j],
                        childBone = new AnimationNode(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16));
                    node.addChild(childBone), Laya.Render.supportWebGLPlusAnimation && this._nativeNodeCount++, this._parseNode(childData, childBone)
                }
            }

            _cloneDatasToAnimator(destAnimator) {
                var destRoot;
                destRoot = this._rootNode.clone();
                var transform = this._rootNode.transform, destTransform = destRoot.transform,
                    destPosition = destTransform.localPosition, destRotation = destTransform.localRotation,
                    destScale = destTransform.localScale;
                transform.localPosition.cloneTo(destPosition), transform.localRotation.cloneTo(destRotation), transform.localScale.cloneTo(destScale), destTransform.localPosition = destPosition, destTransform.localRotation = destRotation, destTransform.localScale = destScale, destAnimator._avatarNodeMap = {}, this._initCloneToAnimator(destRoot, destAnimator)
            }

            cloneTo(destObject) {
                var destAvatar = destObject, destRoot = this._rootNode.clone();
                destAvatar._rootNode = destRoot
            }

            clone() {
                var dest = new Avatar;
                return this.cloneTo(dest), dest
            }

            _cloneDatasToAnimatorNative(destAnimator) {
                var animationNodeLocalPositions = new Float32Array(3 * this._nativeNodeCount),
                    animationNodeLocalRotations = new Float32Array(4 * this._nativeNodeCount),
                    animationNodeLocalScales = new Float32Array(3 * this._nativeNodeCount),
                    animationNodeWorldMatrixs = new Float32Array(16 * this._nativeNodeCount),
                    animationNodeParentIndices = new Int16Array(this._nativeNodeCount);
                destAnimator._animationNodeLocalPositions = animationNodeLocalPositions, destAnimator._animationNodeLocalRotations = animationNodeLocalRotations, destAnimator._animationNodeLocalScales = animationNodeLocalScales, destAnimator._animationNodeWorldMatrixs = animationNodeWorldMatrixs, destAnimator._animationNodeParentIndices = animationNodeParentIndices, this._nativeCurCloneCount = 0;
                var destRoot = this._rootNode._cloneNative(animationNodeLocalPositions, animationNodeLocalRotations, animationNodeLocalScales, animationNodeWorldMatrixs, animationNodeParentIndices, -1, this),
                    transform = this._rootNode.transform, destTransform = destRoot.transform,
                    destPosition = destTransform.localPosition, destRotation = destTransform.localRotation,
                    destScale = destTransform.localScale;
                transform.localPosition.cloneTo(destPosition), transform.localRotation.cloneTo(destRotation), transform.localScale.cloneTo(destScale), destTransform.localPosition = destPosition, destTransform.localRotation = destRotation, destTransform.localScale = destScale, destAnimator._avatarNodeMap = {}, this._initCloneToAnimator(destRoot, destAnimator)
            }
        }

        Avatar.AVATAR = "AVATAR";

        class SkyBoxMaterial extends BaseMaterial {
            constructor() {
                super(), this.setShaderName("SkyBox"), this.tintColor = new Vector4(.5, .5, .5, .5), this.exposure = 1, this.rotation = 0
            }

            static __initDefine__() {
            }

            get tintColor() {
                return this._shaderValues.getVector(SkyBoxMaterial.TINTCOLOR)
            }

            set tintColor(value) {
                this._shaderValues.setVector(SkyBoxMaterial.TINTCOLOR, value)
            }

            get exposure() {
                return this._shaderValues.getNumber(SkyBoxMaterial.EXPOSURE)
            }

            set exposure(value) {
                this._shaderValues.setNumber(SkyBoxMaterial.EXPOSURE, value)
            }

            get rotation() {
                return this._shaderValues.getNumber(SkyBoxMaterial.ROTATION)
            }

            set rotation(value) {
                this._shaderValues.setNumber(SkyBoxMaterial.ROTATION, value)
            }

            get textureCube() {
                return this._shaderValues.getTexture(SkyBoxMaterial.TEXTURECUBE)
            }

            set textureCube(value) {
                this._shaderValues.setTexture(SkyBoxMaterial.TEXTURECUBE, value)
            }

            clone() {
                var dest = new SkyBoxMaterial;
                return this.cloneTo(dest), dest
            }
        }

        SkyBoxMaterial.TINTCOLOR = Shader3D.propertyNameToID("u_TintColor"), SkyBoxMaterial.EXPOSURE = Shader3D.propertyNameToID("u_Exposure"), SkyBoxMaterial.ROTATION = Shader3D.propertyNameToID("u_Rotation"), SkyBoxMaterial.TEXTURECUBE = Shader3D.propertyNameToID("u_CubeTexture");

        class SubMesh extends GeometryElement {
            constructor(mesh) {
                super(), this._id = ++SubMesh._uniqueIDCounter, this._mesh = mesh, this._boneIndicesList = [], this._subIndexBufferStart = [], this._subIndexBufferCount = []
            }

            get indexCount() {
                return this._indexCount
            }

            _setIndexRange(indexStart, indexCount) {
                this._indexStart = indexStart, this._indexCount = indexCount, this._indices = new Uint16Array(this._indexBuffer.getData().buffer, 2 * indexStart, indexCount)
            }

            _getType() {
                return SubMesh._type
            }

            _prepareRender(state) {
                return this._mesh._uploadVerticesData(), !0
            }

            _render(state) {
                var gl = Laya.LayaGL.instance;
                this._mesh._bufferState.bind();
                var skinnedDatas = state.renderElement.render._skinnedData;
                if (skinnedDatas) for (var subSkinnedDatas = skinnedDatas[this._indexInMesh], boneIndicesListCount = this._boneIndicesList.length, i = 0; i < boneIndicesListCount; i++) state.shader.uploadCustomUniform(SkinnedMeshSprite3D.BONES, subSkinnedDatas[i]), gl.drawElements(gl.TRIANGLES, this._subIndexBufferCount[i], gl.UNSIGNED_SHORT, 2 * this._subIndexBufferStart[i]); else gl.drawElements(gl.TRIANGLES, this._indexCount, gl.UNSIGNED_SHORT, 2 * this._indexStart);
                Laya.Stat.trianglesFaces += this._indexCount / 3, Laya.Stat.renderBatches++
            }

            getIndices() {
                if (this._mesh._isReadable) return this._indices.slice();
                throw"SubMesh:can't get indices on subMesh,mesh's isReadable must be true."
            }

            setIndices(indices) {
                this._indexBuffer.setData(indices, this._indexStart, 0, this._indexCount)
            }

            destroy() {
                this._destroyed || (super.destroy(), this._indexBuffer.destroy(), this._indexBuffer = null, this._mesh = null, this._boneIndicesList = null, this._subIndexBufferStart = null, this._subIndexBufferCount = null, this._skinAnimationDatas = null)
            }
        }

        SubMesh._uniqueIDCounter = 0, SubMesh._type = GeometryElement._typeCounter++;

        class LoadModelV04 {
            static parse(readData, version, mesh, subMeshes) {
                LoadModelV04._mesh = mesh, LoadModelV04._subMeshes = subMeshes, LoadModelV04._version = version, LoadModelV04._readData = readData, LoadModelV04.READ_DATA(), LoadModelV04.READ_BLOCK(), LoadModelV04.READ_STRINGS();
                for (var i = 0, n = LoadModelV04._BLOCK.count; i < n; i++) {
                    LoadModelV04._readData.pos = LoadModelV04._BLOCK.blockStarts[i];
                    var index = LoadModelV04._readData.getUint16(), blockName = LoadModelV04._strings[index],
                        fn = LoadModelV04["READ_" + blockName];
                    if (null == fn) throw new Error("model file err,no this function:" + index + " " + blockName);
                    fn.call(null)
                }
                LoadModelV04._mesh._bindPoseIndices = new Uint16Array(LoadModelV04._bindPoseIndices), LoadModelV04._bindPoseIndices.length = 0, LoadModelV04._strings.length = 0, LoadModelV04._readData = null, LoadModelV04._version = null, LoadModelV04._mesh = null, LoadModelV04._subMeshes = null
            }

            static _readString() {
                return LoadModelV04._strings[LoadModelV04._readData.getUint16()]
            }

            static READ_DATA() {
                LoadModelV04._DATA.offset = LoadModelV04._readData.getUint32(), LoadModelV04._DATA.size = LoadModelV04._readData.getUint32()
            }

            static READ_BLOCK() {
                for (var count = LoadModelV04._BLOCK.count = LoadModelV04._readData.getUint16(), blockStarts = LoadModelV04._BLOCK.blockStarts = [], blockLengths = LoadModelV04._BLOCK.blockLengths = [], i = 0; i < count; i++) blockStarts.push(LoadModelV04._readData.getUint32()), blockLengths.push(LoadModelV04._readData.getUint32())
            }

            static READ_STRINGS() {
                var offset = LoadModelV04._readData.getUint32(), count = LoadModelV04._readData.getUint16(),
                    prePos = LoadModelV04._readData.pos;
                LoadModelV04._readData.pos = offset + LoadModelV04._DATA.offset;
                for (var i = 0; i < count; i++) LoadModelV04._strings[i] = LoadModelV04._readData.readUTFString();
                LoadModelV04._readData.pos = prePos
            }

            static READ_MESH() {
                var i, gl = Laya.LayaGL.instance,
                    arrayBuffer = (LoadModelV04._readString(), LoadModelV04._readData.__getBuffer()), memorySize = 0,
                    vertexBufferCount = LoadModelV04._readData.getInt16(), offset = LoadModelV04._DATA.offset;
                for (i = 0; i < vertexBufferCount; i++) {
                    var vertexDeclaration, vbStart = offset + LoadModelV04._readData.getUint32(),
                        vbLength = LoadModelV04._readData.getUint32(),
                        vbArrayBuffer = arrayBuffer.slice(vbStart, vbStart + vbLength),
                        vbDatas = new Float32Array(vbArrayBuffer), bufferAttribute = LoadModelV04._readString();
                    switch (LoadModelV04._version) {
                        case"LAYAMODEL:0301":
                        case"LAYAMODEL:0400":
                            vertexDeclaration = VertexMesh.getVertexDeclaration(bufferAttribute);
                            break;
                        case"LAYAMODEL:0401":
                            vertexDeclaration = VertexMesh.getVertexDeclaration(bufferAttribute, !1);
                            break;
                        default:
                            throw new Error("LoadModelV03: unknown version.")
                    }
                    if (!vertexDeclaration) throw new Error("LoadModelV03: unknown vertexDeclaration.");
                    var vertexBuffer = new VertexBuffer3D(4 * vbDatas.length, gl.STATIC_DRAW, !0);
                    vertexBuffer.vertexDeclaration = vertexDeclaration, vertexBuffer.setData(vbDatas.buffer), LoadModelV04._mesh._vertexBuffer = vertexBuffer, LoadModelV04._mesh._vertexCount += vertexBuffer.vertexCount, memorySize += 4 * vbDatas.length
                }
                var ibStart = offset + LoadModelV04._readData.getUint32(),
                    ibLength = LoadModelV04._readData.getUint32(),
                    ibDatas = new Uint16Array(arrayBuffer.slice(ibStart, ibStart + ibLength)),
                    indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, ibLength / 2, gl.STATIC_DRAW, !0);
                indexBuffer.setData(ibDatas), LoadModelV04._mesh._indexBuffer = indexBuffer, memorySize += 2 * indexBuffer.indexCount, LoadModelV04._mesh._setBuffer(LoadModelV04._mesh._vertexBuffer, indexBuffer), LoadModelV04._mesh._setCPUMemory(memorySize), LoadModelV04._mesh._setGPUMemory(memorySize);
                var boneNames = LoadModelV04._mesh._boneNames = [], boneCount = LoadModelV04._readData.getUint16();
                for (boneNames.length = boneCount, i = 0; i < boneCount; i++) boneNames[i] = LoadModelV04._strings[LoadModelV04._readData.getUint16()];
                LoadModelV04._readData.pos += 8;
                var bindPoseDataStart = LoadModelV04._readData.getUint32(),
                    bindPoseDataLength = LoadModelV04._readData.getUint32(),
                    bindPoseDatas = new Float32Array(arrayBuffer.slice(offset + bindPoseDataStart, offset + bindPoseDataStart + bindPoseDataLength)),
                    bindPoseFloatCount = bindPoseDatas.length,
                    bindPoseBuffer = LoadModelV04._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * bindPoseFloatCount);
                for (LoadModelV04._mesh._inverseBindPoses = [], i = 0; i < bindPoseFloatCount; i += 16) {
                    var inverseGlobalBindPose = new Matrix4x4(bindPoseDatas[i + 0], bindPoseDatas[i + 1], bindPoseDatas[i + 2], bindPoseDatas[i + 3], bindPoseDatas[i + 4], bindPoseDatas[i + 5], bindPoseDatas[i + 6], bindPoseDatas[i + 7], bindPoseDatas[i + 8], bindPoseDatas[i + 9], bindPoseDatas[i + 10], bindPoseDatas[i + 11], bindPoseDatas[i + 12], bindPoseDatas[i + 13], bindPoseDatas[i + 14], bindPoseDatas[i + 15], new Float32Array(bindPoseBuffer, 4 * i, 16));
                    LoadModelV04._mesh._inverseBindPoses[i / 16] = inverseGlobalBindPose
                }
                return !0
            }

            static READ_SUBMESH() {
                var arrayBuffer = LoadModelV04._readData.__getBuffer(), subMesh = new SubMesh(LoadModelV04._mesh);
                LoadModelV04._readData.getInt16(), LoadModelV04._readData.getUint32(), LoadModelV04._readData.getUint32();
                var ibStart = LoadModelV04._readData.getUint32(), ibCount = LoadModelV04._readData.getUint32(),
                    indexBuffer = LoadModelV04._mesh._indexBuffer;
                subMesh._indexBuffer = indexBuffer, subMesh._setIndexRange(ibStart, ibCount);
                var vertexBuffer = LoadModelV04._mesh._vertexBuffer;
                subMesh._vertexBuffer = vertexBuffer;
                var offset = LoadModelV04._DATA.offset, subIndexBufferStart = subMesh._subIndexBufferStart,
                    subIndexBufferCount = subMesh._subIndexBufferCount, boneIndicesList = subMesh._boneIndicesList,
                    drawCount = LoadModelV04._readData.getUint16();
                subIndexBufferStart.length = drawCount, subIndexBufferCount.length = drawCount, boneIndicesList.length = drawCount;
                for (var pathMarks = LoadModelV04._mesh._skinDataPathMarks, bindPoseIndices = LoadModelV04._bindPoseIndices, subMeshIndex = LoadModelV04._subMeshes.length, i = 0; i < drawCount; i++) {
                    subIndexBufferStart[i] = LoadModelV04._readData.getUint32(), subIndexBufferCount[i] = LoadModelV04._readData.getUint32();
                    for (var boneDicofs = LoadModelV04._readData.getUint32(), boneDicCount = LoadModelV04._readData.getUint32(), boneIndices = boneIndicesList[i] = new Uint16Array(arrayBuffer.slice(offset + boneDicofs, offset + boneDicofs + boneDicCount)), j = 0, m = boneIndices.length; j < m; j++) {
                        var index = boneIndices[j], combineIndex = bindPoseIndices.indexOf(index);
                        -1 === combineIndex ? (boneIndices[j] = bindPoseIndices.length, bindPoseIndices.push(index), pathMarks.push([subMeshIndex, i, j])) : boneIndices[j] = combineIndex
                    }
                }
                return LoadModelV04._subMeshes.push(subMesh), !0
            }
        }

        LoadModelV04._BLOCK = {count: 0}, LoadModelV04._DATA = {
            offset: 0,
            size: 0
        }, LoadModelV04._strings = [], LoadModelV04._bindPoseIndices = [];

        class LoadModelV05 {
            static parse(readData, version, mesh, subMeshes) {
                LoadModelV05._mesh = mesh, LoadModelV05._subMeshes = subMeshes, LoadModelV05._version = version, LoadModelV05._readData = readData, LoadModelV05.READ_DATA(), LoadModelV05.READ_BLOCK(), LoadModelV05.READ_STRINGS();
                for (var i = 0, n = LoadModelV05._BLOCK.count; i < n; i++) {
                    LoadModelV05._readData.pos = LoadModelV05._BLOCK.blockStarts[i];
                    var index = LoadModelV05._readData.getUint16(), blockName = LoadModelV05._strings[index],
                        fn = LoadModelV05["READ_" + blockName];
                    if (null == fn) throw new Error("model file err,no this function:" + index + " " + blockName);
                    fn.call(null)
                }
                LoadModelV05._mesh._bindPoseIndices = new Uint16Array(LoadModelV05._bindPoseIndices), LoadModelV05._bindPoseIndices.length = 0, LoadModelV05._strings.length = 0, LoadModelV05._readData = null, LoadModelV05._version = null, LoadModelV05._mesh = null, LoadModelV05._subMeshes = null
            }

            static _readString() {
                return LoadModelV05._strings[LoadModelV05._readData.getUint16()]
            }

            static READ_DATA() {
                LoadModelV05._DATA.offset = LoadModelV05._readData.getUint32(), LoadModelV05._DATA.size = LoadModelV05._readData.getUint32()
            }

            static READ_BLOCK() {
                for (var count = LoadModelV05._BLOCK.count = LoadModelV05._readData.getUint16(), blockStarts = LoadModelV05._BLOCK.blockStarts = [], blockLengths = LoadModelV05._BLOCK.blockLengths = [], i = 0; i < count; i++) blockStarts.push(LoadModelV05._readData.getUint32()), blockLengths.push(LoadModelV05._readData.getUint32())
            }

            static READ_STRINGS() {
                var offset = LoadModelV05._readData.getUint32(), count = LoadModelV05._readData.getUint16(),
                    prePos = LoadModelV05._readData.pos;
                LoadModelV05._readData.pos = offset + LoadModelV05._DATA.offset;
                for (var i = 0; i < count; i++) LoadModelV05._strings[i] = LoadModelV05._readData.readUTFString();
                LoadModelV05._readData.pos = prePos
            }

            static READ_MESH() {
                var i, gl = Laya.LayaGL.instance, memorySize = 0,
                    arrayBuffer = (LoadModelV05._readString(), LoadModelV05._readData.__getBuffer()),
                    vertexBufferCount = LoadModelV05._readData.getInt16(), offset = LoadModelV05._DATA.offset;
                for (i = 0; i < vertexBufferCount; i++) {
                    var vertexData, floatData, uint8Data, vbStart = offset + LoadModelV05._readData.getUint32(),
                        vertexCount = LoadModelV05._readData.getUint32(), vertexFlag = LoadModelV05._readString(),
                        vertexDeclaration = VertexMesh.getVertexDeclaration(vertexFlag, !1),
                        vertexStride = vertexDeclaration.vertexStride, subVertexFlags = vertexFlag.split(","),
                        subVertexCount = subVertexFlags.length;
                    switch (LoadModelV05._version) {
                        case"LAYAMODEL:05":
                            vertexData = arrayBuffer.slice(vbStart, vbStart + vertexCount * vertexStride), floatData = new Float32Array(vertexData), uint8Data = new Uint8Array(vertexData);
                            break;
                        case"LAYAMODEL:COMPRESSION_05":
                            vertexData = new ArrayBuffer(vertexStride * vertexCount), floatData = new Float32Array(vertexData), uint8Data = new Uint8Array(vertexData);
                            var lastPosition = LoadModelV05._readData.pos;
                            LoadModelV05._readData.pos = vbStart;
                            for (var j = 0; j < vertexCount; j++) for (var subOffset, verOffset = j * vertexStride, k = 0; k < subVertexCount; k++) switch (subVertexFlags[k]) {
                                case"POSITION":
                                    floatData[subOffset = verOffset / 4] = HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16()), floatData[subOffset + 1] = HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16()), floatData[subOffset + 2] = HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16()), verOffset += 12;
                                    break;
                                case"NORMAL":
                                    floatData[subOffset = verOffset / 4] = LoadModelV05._readData.getUint8() / 127.5 - 1, floatData[subOffset + 1] = LoadModelV05._readData.getUint8() / 127.5 - 1, floatData[subOffset + 2] = LoadModelV05._readData.getUint8() / 127.5 - 1, verOffset += 12;
                                    break;
                                case"COLOR":
                                    floatData[subOffset = verOffset / 4] = LoadModelV05._readData.getUint8() / 255, floatData[subOffset + 1] = LoadModelV05._readData.getUint8() / 255, floatData[subOffset + 2] = LoadModelV05._readData.getUint8() / 255, floatData[subOffset + 3] = LoadModelV05._readData.getUint8() / 255, verOffset += 16;
                                    break;
                                case"UV":
                                case"UV1":
                                    floatData[subOffset = verOffset / 4] = HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16()), floatData[subOffset + 1] = HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16()), verOffset += 8;
                                    break;
                                case"BLENDWEIGHT":
                                    floatData[subOffset = verOffset / 4] = LoadModelV05._readData.getUint8() / 255, floatData[subOffset + 1] = LoadModelV05._readData.getUint8() / 255, floatData[subOffset + 2] = LoadModelV05._readData.getUint8() / 255, floatData[subOffset + 3] = LoadModelV05._readData.getUint8() / 255, verOffset += 16;
                                    break;
                                case"BLENDINDICES":
                                    uint8Data[verOffset] = LoadModelV05._readData.getUint8(), uint8Data[verOffset + 1] = LoadModelV05._readData.getUint8(), uint8Data[verOffset + 2] = LoadModelV05._readData.getUint8(), uint8Data[verOffset + 3] = LoadModelV05._readData.getUint8(), verOffset += 4;
                                    break;
                                case"TANGENT":
                                    floatData[subOffset = verOffset / 4] = LoadModelV05._readData.getUint8() / 127.5 - 1, floatData[subOffset + 1] = LoadModelV05._readData.getUint8() / 127.5 - 1, floatData[subOffset + 2] = LoadModelV05._readData.getUint8() / 127.5 - 1, floatData[subOffset + 3] = LoadModelV05._readData.getUint8() / 127.5 - 1, verOffset += 16
                            }
                            LoadModelV05._readData.pos = lastPosition
                    }
                    var vertexBuffer = new VertexBuffer3D(vertexData.byteLength, gl.STATIC_DRAW, !0);
                    vertexBuffer.vertexDeclaration = vertexDeclaration, vertexBuffer.setData(vertexData), LoadModelV05._mesh._vertexBuffer = vertexBuffer, LoadModelV05._mesh._vertexCount += vertexBuffer.vertexCount, memorySize += 4 * floatData.length
                }
                var ibStart = offset + LoadModelV05._readData.getUint32(),
                    ibLength = LoadModelV05._readData.getUint32(),
                    ibDatas = new Uint16Array(arrayBuffer.slice(ibStart, ibStart + ibLength)),
                    indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, ibLength / 2, gl.STATIC_DRAW, !0);
                indexBuffer.setData(ibDatas), LoadModelV05._mesh._indexBuffer = indexBuffer, LoadModelV05._mesh._setBuffer(LoadModelV05._mesh._vertexBuffer, indexBuffer), memorySize += 2 * indexBuffer.indexCount, LoadModelV05._mesh._setCPUMemory(memorySize), LoadModelV05._mesh._setGPUMemory(memorySize);
                var boneNames = LoadModelV05._mesh._boneNames = [], boneCount = LoadModelV05._readData.getUint16();
                for (boneNames.length = boneCount, i = 0; i < boneCount; i++) boneNames[i] = LoadModelV05._strings[LoadModelV05._readData.getUint16()];
                var bindPoseDataStart = LoadModelV05._readData.getUint32(),
                    bindPoseDataLength = LoadModelV05._readData.getUint32(),
                    bindPoseDatas = new Float32Array(arrayBuffer.slice(offset + bindPoseDataStart, offset + bindPoseDataStart + bindPoseDataLength)),
                    bindPoseFloatCount = bindPoseDatas.length,
                    bindPoseBuffer = LoadModelV05._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * bindPoseFloatCount);
                for (LoadModelV05._mesh._inverseBindPoses = [], i = 0; i < bindPoseFloatCount; i += 16) {
                    var inverseGlobalBindPose = new Matrix4x4(bindPoseDatas[i + 0], bindPoseDatas[i + 1], bindPoseDatas[i + 2], bindPoseDatas[i + 3], bindPoseDatas[i + 4], bindPoseDatas[i + 5], bindPoseDatas[i + 6], bindPoseDatas[i + 7], bindPoseDatas[i + 8], bindPoseDatas[i + 9], bindPoseDatas[i + 10], bindPoseDatas[i + 11], bindPoseDatas[i + 12], bindPoseDatas[i + 13], bindPoseDatas[i + 14], bindPoseDatas[i + 15], new Float32Array(bindPoseBuffer, 4 * i, 16));
                    LoadModelV05._mesh._inverseBindPoses[i / 16] = inverseGlobalBindPose
                }
                return !0
            }

            static READ_SUBMESH() {
                var arrayBuffer = LoadModelV05._readData.__getBuffer(), subMesh = new SubMesh(LoadModelV05._mesh);
                LoadModelV05._readData.getInt16();
                var ibStart = LoadModelV05._readData.getUint32(), ibCount = LoadModelV05._readData.getUint32(),
                    indexBuffer = LoadModelV05._mesh._indexBuffer;
                subMesh._indexBuffer = indexBuffer, subMesh._setIndexRange(ibStart, ibCount);
                var vertexBuffer = LoadModelV05._mesh._vertexBuffer;
                subMesh._vertexBuffer = vertexBuffer;
                var offset = LoadModelV05._DATA.offset, subIndexBufferStart = subMesh._subIndexBufferStart,
                    subIndexBufferCount = subMesh._subIndexBufferCount, boneIndicesList = subMesh._boneIndicesList,
                    drawCount = LoadModelV05._readData.getUint16();
                subIndexBufferStart.length = drawCount, subIndexBufferCount.length = drawCount, boneIndicesList.length = drawCount;
                for (var pathMarks = LoadModelV05._mesh._skinDataPathMarks, bindPoseIndices = LoadModelV05._bindPoseIndices, subMeshIndex = LoadModelV05._subMeshes.length, i = 0; i < drawCount; i++) {
                    subIndexBufferStart[i] = LoadModelV05._readData.getUint32(), subIndexBufferCount[i] = LoadModelV05._readData.getUint32();
                    for (var boneDicofs = LoadModelV05._readData.getUint32(), boneDicCount = LoadModelV05._readData.getUint32(), boneIndices = boneIndicesList[i] = new Uint16Array(arrayBuffer.slice(offset + boneDicofs, offset + boneDicofs + boneDicCount)), j = 0, m = boneIndices.length; j < m; j++) {
                        var index = boneIndices[j], combineIndex = bindPoseIndices.indexOf(index);
                        -1 === combineIndex ? (boneIndices[j] = bindPoseIndices.length, bindPoseIndices.push(index), pathMarks.push([subMeshIndex, i, j])) : boneIndices[j] = combineIndex
                    }
                }
                return LoadModelV05._subMeshes.push(subMesh), !0
            }
        }

        LoadModelV05._BLOCK = {count: 0}, LoadModelV05._DATA = {
            offset: 0,
            size: 0
        }, LoadModelV05._strings = [], LoadModelV05._bindPoseIndices = [];

        class MeshReader {
            constructor() {
            }

            static read(data, mesh, subMeshes) {
                var readData = new Laya.Byte(data);
                readData.pos = 0;
                var version = readData.readUTFString();
                switch (version) {
                    case"LAYAMODEL:0301":
                    case"LAYAMODEL:0400":
                    case"LAYAMODEL:0401":
                        LoadModelV04.parse(readData, version, mesh, subMeshes);
                        break;
                    case"LAYAMODEL:05":
                    case"LAYAMODEL:COMPRESSION_05":
                        LoadModelV05.parse(readData, version, mesh, subMeshes);
                        break;
                    default:
                        throw new Error("MeshReader: unknown mesh version.")
                }
                mesh._setSubMeshes(subMeshes)
            }
        }

        class Mesh extends Laya.Resource {
            constructor(isReadable = !0) {
                super(), this._tempVector30 = new Vector3, this._tempVector31 = new Vector3, this._tempVector32 = new Vector3, this._minVerticesUpdate = -1, this._maxVerticesUpdate = -1, this._needUpdateBounds = !0, this._bounds = new Bounds(new Vector3, new Vector3), this._bufferState = new BufferState, this._instanceBufferState = new BufferState, this._vertexBuffer = null, this._indexBuffer = null, this._vertexCount = 0, this._isReadable = isReadable, this._subMeshes = [], this._skinDataPathMarks = []
            }

            static __init__() {
                var physics3D = Physics3D._physics3D;
                physics3D && (Mesh._nativeTempVector30 = new physics3D.btVector3(0, 0, 0), Mesh._nativeTempVector31 = new physics3D.btVector3(0, 0, 0), Mesh._nativeTempVector32 = new physics3D.btVector3(0, 0, 0))
            }

            static _parse(data, propertyParams = null, constructParams = null) {
                var mesh = new Mesh;
                return MeshReader.read(data, mesh, mesh._subMeshes), mesh
            }

            static load(url, complete) {
                Laya.ILaya.loader.create(url, complete, null, Mesh.MESH)
            }

            get inverseAbsoluteBindPoses() {
                return this._inverseBindPoses
            }

            get vertexCount() {
                return this._vertexCount
            }

            get indexCount() {
                return this._indexBuffer.indexCount
            }

            get subMeshCount() {
                return this._subMeshes.length
            }

            get bounds() {
                return this._bounds
            }

            set bounds(value) {
                this._bounds !== value && value.cloneTo(this._bounds)
            }

            _getPositionElement(vertexBuffer) {
                for (var vertexElements = vertexBuffer.vertexDeclaration._vertexElements, i = 0, n = vertexElements.length; i < n; i++) {
                    var vertexElement = vertexElements[i];
                    if (vertexElement._elementFormat === VertexElementFormat.Vector3 && vertexElement._elementUsage === VertexMesh.MESH_POSITION0) return vertexElement
                }
                return null
            }

            _getVerticeElementData(data, elementUsage) {
                data.length = this._vertexCount;
                var verDec = this._vertexBuffer.vertexDeclaration,
                    element = verDec.getVertexElementByUsage(elementUsage);
                if (element) {
                    var uint8Vertices = this._vertexBuffer.getUint8Data(),
                        floatVertices = this._vertexBuffer.getFloat32Data(), uint8VerStr = verDec.vertexStride,
                        floatVerStr = uint8VerStr / 4, uint8EleOffset = element._offset,
                        floatEleOffset = uint8EleOffset / 4;
                    switch (elementUsage) {
                        case VertexMesh.MESH_TEXTURECOORDINATE0:
                        case VertexMesh.MESH_TEXTURECOORDINATE1:
                            for (var i = 0; i < this._vertexCount; i++) {
                                var offset = floatVerStr * i + floatEleOffset;
                                data[i] = new Vector2(floatVertices[offset], floatVertices[offset + 1])
                            }
                            break;
                        case VertexMesh.MESH_POSITION0:
                        case VertexMesh.MESH_NORMAL0:
                            for (i = 0; i < this._vertexCount; i++) {
                                offset = floatVerStr * i + floatEleOffset;
                                data[i] = new Vector3(floatVertices[offset], floatVertices[offset + 1], floatVertices[offset + 2])
                            }
                            break;
                        case VertexMesh.MESH_TANGENT0:
                        case VertexMesh.MESH_BLENDWEIGHT0:
                            for (i = 0; i < this._vertexCount; i++) {
                                offset = floatVerStr * i + floatEleOffset;
                                data[i] = new Vector4(floatVertices[offset], floatVertices[offset + 1], floatVertices[offset + 2], floatVertices[offset + 3])
                            }
                            break;
                        case VertexMesh.MESH_COLOR0:
                            for (i = 0; i < this._vertexCount; i++) {
                                offset = floatVerStr * i + floatEleOffset;
                                data[i] = new Color(floatVertices[offset], floatVertices[offset + 1], floatVertices[offset + 2], floatVertices[offset + 3])
                            }
                            break;
                        case VertexMesh.MESH_BLENDINDICES0:
                            for (i = 0; i < this._vertexCount; i++) {
                                offset = uint8VerStr * i + uint8EleOffset;
                                data[i] = new Vector4(uint8Vertices[offset], uint8Vertices[offset + 1], uint8Vertices[offset + 2], uint8Vertices[offset + 3])
                            }
                            break;
                        default:
                            throw"Mesh:Unknown elementUsage."
                    }
                }
            }

            _setVerticeElementData(data, elementUsage) {
                var verDec = this._vertexBuffer.vertexDeclaration,
                    element = verDec.getVertexElementByUsage(elementUsage);
                if (element) {
                    var uint8Vertices = this._vertexBuffer.getUint8Data(),
                        floatVertices = this._vertexBuffer.getFloat32Data(), uint8VerStr = verDec.vertexStride,
                        float8VerStr = uint8VerStr / 4, uint8EleOffset = element._offset,
                        floatEleOffset = uint8EleOffset / 4;
                    switch (elementUsage) {
                        case VertexMesh.MESH_TEXTURECOORDINATE0:
                        case VertexMesh.MESH_TEXTURECOORDINATE1:
                            for (var i = 0, n = data.length; i < n; i++) {
                                var offset = float8VerStr * i + floatEleOffset, vec2 = data[i];
                                floatVertices[offset] = vec2.x, floatVertices[offset + 1] = vec2.y
                            }
                            break;
                        case VertexMesh.MESH_POSITION0:
                        case VertexMesh.MESH_NORMAL0:
                            for (i = 0, n = data.length; i < n; i++) {
                                offset = float8VerStr * i + floatEleOffset;
                                var vec3 = data[i];
                                floatVertices[offset] = vec3.x, floatVertices[offset + 1] = vec3.y, floatVertices[offset + 2] = vec3.z
                            }
                            break;
                        case VertexMesh.MESH_TANGENT0:
                        case VertexMesh.MESH_BLENDWEIGHT0:
                            for (i = 0, n = data.length; i < n; i++) {
                                offset = float8VerStr * i + floatEleOffset;
                                var vec4 = data[i];
                                floatVertices[offset] = vec4.x, floatVertices[offset + 1] = vec4.y, floatVertices[offset + 2] = vec4.z, floatVertices[offset + 3] = vec4.w
                            }
                            break;
                        case VertexMesh.MESH_COLOR0:
                            for (i = 0, n = data.length; i < n; i++) {
                                offset = float8VerStr * i + floatEleOffset;
                                var cor = data[i];
                                floatVertices[offset] = cor.r, floatVertices[offset + 1] = cor.g, floatVertices[offset + 2] = cor.b, floatVertices[offset + 2] = cor.a
                            }
                            break;
                        case VertexMesh.MESH_BLENDINDICES0:
                            for (i = 0, n = data.length; i < n; i++) {
                                offset = uint8VerStr * i + uint8EleOffset, vec4 = data[i];
                                uint8Vertices[offset] = vec4.x, uint8Vertices[offset + 1] = vec4.y, uint8Vertices[offset + 2] = vec4.z, uint8Vertices[offset + 3] = vec4.w
                            }
                            break;
                        default:
                            throw"Mesh:Unknown elementUsage."
                    }
                } else console.warn("Mesh: the mesh don't have  this VertexElement.")
            }

            _disposeResource() {
                for (var i = 0, n = this._subMeshes.length; i < n; i++) this._subMeshes[i].destroy();
                this._nativeTriangleMesh && window.Physics3D.destroy(this._nativeTriangleMesh), this._vertexBuffer.destroy(), this._indexBuffer.destroy(), this._setCPUMemory(0), this._setGPUMemory(0), this._bufferState.destroy(), this._instanceBufferState.destroy(), this._bufferState = null, this._instanceBufferState = null, this._vertexBuffer = null, this._indexBuffer = null, this._subMeshes = null, this._nativeTriangleMesh = null, this._indexBuffer = null, this._boneNames = null, this._inverseBindPoses = null
            }

            _setSubMeshes(subMeshes) {
                this._subMeshes = subMeshes;
                for (var i = 0, n = subMeshes.length; i < n; i++) subMeshes[i]._indexInMesh = i;
                this.calculateBounds()
            }

            _setBuffer(vertexBuffer, indexBuffer) {
                var bufferState = this._bufferState;
                bufferState.bind(), bufferState.applyVertexBuffer(vertexBuffer), bufferState.applyIndexBuffer(indexBuffer), bufferState.unBind();
                var instanceBufferState = this._instanceBufferState;
                instanceBufferState.bind(), instanceBufferState.applyVertexBuffer(vertexBuffer), instanceBufferState.applyInstanceVertexBuffer(SubMeshInstanceBatch.instance.instanceWorldMatrixBuffer), instanceBufferState.applyInstanceVertexBuffer(SubMeshInstanceBatch.instance.instanceMVPMatrixBuffer), instanceBufferState.applyIndexBuffer(indexBuffer), instanceBufferState.unBind()
            }

            _getPhysicMesh() {
                if (!this._nativeTriangleMesh) {
                    for (var triangleMesh = new window.Physics3D.btTriangleMesh, nativePositio0 = Mesh._nativeTempVector30, nativePositio1 = Mesh._nativeTempVector31, nativePositio2 = Mesh._nativeTempVector32, position0 = this._tempVector30, position1 = this._tempVector31, position2 = this._tempVector32, vertexBuffer = this._vertexBuffer, positionElement = this._getPositionElement(vertexBuffer), verticesData = vertexBuffer.getFloat32Data(), floatCount = vertexBuffer.vertexDeclaration.vertexStride / 4, posOffset = positionElement._offset / 4, indices = this._indexBuffer.getData(), i = 0, n = indices.length; i < n; i += 3) {
                        var p0Index = indices[i] * floatCount + posOffset,
                            p1Index = indices[i + 1] * floatCount + posOffset,
                            p2Index = indices[i + 2] * floatCount + posOffset;
                        position0.setValue(verticesData[p0Index], verticesData[p0Index + 1], verticesData[p0Index + 2]), position1.setValue(verticesData[p1Index], verticesData[p1Index + 1], verticesData[p1Index + 2]), position2.setValue(verticesData[p2Index], verticesData[p2Index + 1], verticesData[p2Index + 2]), Utils3D._convertToBulletVec3(position0, nativePositio0, !0), Utils3D._convertToBulletVec3(position1, nativePositio1, !0), Utils3D._convertToBulletVec3(position2, nativePositio2, !0), triangleMesh.addTriangle(nativePositio0, nativePositio1, nativePositio2, !0)
                    }
                    this._nativeTriangleMesh = triangleMesh
                }
                return this._nativeTriangleMesh
            }

            _uploadVerticesData() {
                var min = this._minVerticesUpdate, max = this._maxVerticesUpdate;
                if (-1 !== min && -1 !== max) {
                    var offset = 4 * min;
                    this._vertexBuffer.setData(this._vertexBuffer.getUint8Data().buffer, offset, offset, 4 * (max - min)), this._minVerticesUpdate = -1, this._maxVerticesUpdate = -1
                }
            }

            getSubMesh(index) {
                return this._subMeshes[index]
            }

            getPositions(positions) {
                if (!this._isReadable) throw"Mesh:can't get positions on mesh,isReadable must be true.";
                this._getVerticeElementData(positions, VertexMesh.MESH_POSITION0)
            }

            setPositions(positions) {
                if (!this._isReadable) throw"Mesh:setPosition() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(positions, VertexMesh.MESH_POSITION0), this._needUpdateBounds = !0
            }

            getColors(colors) {
                if (!this._isReadable) throw"Mesh:can't get colors on mesh,isReadable must be true.";
                this._getVerticeElementData(colors, VertexMesh.MESH_COLOR0)
            }

            setColors(colors) {
                if (!this._isReadable) throw"Mesh:setColors() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(colors, VertexMesh.MESH_COLOR0)
            }

            getUVs(uvs, channel = 0) {
                if (!this._isReadable) throw"Mesh:can't get uvs on mesh,isReadable must be true.";
                switch (channel) {
                    case 0:
                        this._getVerticeElementData(uvs, VertexMesh.MESH_TEXTURECOORDINATE0);
                        break;
                    case 1:
                        this._getVerticeElementData(uvs, VertexMesh.MESH_TEXTURECOORDINATE1);
                        break;
                    default:
                        throw"Mesh:Invalid channel."
                }
            }

            setUVs(uvs, channel = 0) {
                if (!this._isReadable) throw"Mesh:setUVs() need isReadable must be true or use setVertices().";
                switch (channel) {
                    case 0:
                        this._setVerticeElementData(uvs, VertexMesh.MESH_TEXTURECOORDINATE0);
                        break;
                    case 1:
                        this._setVerticeElementData(uvs, VertexMesh.MESH_TEXTURECOORDINATE1);
                        break;
                    default:
                        throw"Mesh:Invalid channel."
                }
            }

            getNormals(normals) {
                if (!this._isReadable) throw"Mesh:can't get colors on mesh,isReadable must be true.";
                this._getVerticeElementData(normals, VertexMesh.MESH_NORMAL0)
            }

            setNormals(normals) {
                if (!this._isReadable) throw"Mesh:setNormals() need must be true or use setVertices().";
                this._setVerticeElementData(normals, VertexMesh.MESH_NORMAL0)
            }

            getTangents(tangents) {
                if (!this._isReadable) throw"Mesh:can't get colors on mesh,isReadable must be true.";
                this._getVerticeElementData(tangents, VertexMesh.MESH_TANGENT0)
            }

            setTangents(tangents) {
                if (!this._isReadable) throw"Mesh:setTangents() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(tangents, VertexMesh.MESH_TANGENT0)
            }

            getBoneWeights(boneWeights) {
                if (!this._isReadable) throw"Mesh:can't get boneWeights on mesh,isReadable must be true.";
                this._getVerticeElementData(boneWeights, VertexMesh.MESH_BLENDWEIGHT0)
            }

            setBoneWeights(boneWeights) {
                if (!this._isReadable) throw"Mesh:setBoneWeights() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(boneWeights, VertexMesh.MESH_BLENDWEIGHT0)
            }

            getBoneIndices(boneIndices) {
                if (!this._isReadable) throw"Mesh:can't get boneIndices on mesh,isReadable must be true.";
                this._getVerticeElementData(boneIndices, VertexMesh.MESH_BLENDINDICES0)
            }

            setBoneIndices(boneIndices) {
                if (!this._isReadable) throw"Mesh:setBoneIndices() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(boneIndices, VertexMesh.MESH_BLENDINDICES0)
            }

            markAsUnreadbale() {
                this._uploadVerticesData(), this._vertexBuffer.markAsUnreadbale(), this._isReadable = !1
            }

            getVertexDeclaration() {
                return this._vertexBuffer._vertexDeclaration
            }

            getVertices() {
                if (this._isReadable) return this._vertexBuffer.getUint8Data().buffer.slice(0);
                throw"Mesh:can't get vertices on mesh,isReadable must be true."
            }

            setVertices(vertices) {
                this._vertexBuffer.setData(vertices), this._needUpdateBounds = !0
            }

            getIndices() {
                if (this._isReadable) return this._indexBuffer.getData().slice();
                throw"Mesh:can't get indices on subMesh,mesh's isReadable must be true."
            }

            setIndices(indices) {
                this._indexBuffer.setData(indices)
            }

            calculateBounds() {
                if (!this._isReadable) throw"Mesh:can't calculate bounds on subMesh,mesh's isReadable must be true.";
                if (this._needUpdateBounds) {
                    var min = this._tempVector30, max = this._tempVector31;
                    min.x = min.y = min.z = Number.MAX_VALUE, max.x = max.y = max.z = -Number.MAX_VALUE;
                    for (var vertexBuffer = this._vertexBuffer, positionElement = this._getPositionElement(vertexBuffer), verticesData = vertexBuffer.getFloat32Data(), floatCount = vertexBuffer.vertexDeclaration.vertexStride / 4, posOffset = positionElement._offset / 4, j = 0, m = verticesData.length; j < m; j += floatCount) {
                        var ofset = j + posOffset, pX = verticesData[ofset], pY = verticesData[ofset + 1],
                            pZ = verticesData[ofset + 2];
                        min.x = Math.min(min.x, pX), min.y = Math.min(min.y, pY), min.z = Math.min(min.z, pZ), max.x = Math.max(max.x, pX), max.y = Math.max(max.y, pY), max.z = Math.max(max.z, pZ)
                    }
                    this._bounds.setMin(min), this._bounds.setMax(max), this._needUpdateBounds = !1
                }
            }

            cloneTo(destObject) {
                var destMesh = destObject, vb = this._vertexBuffer,
                    destVB = new VertexBuffer3D(vb._byteLength, vb.bufferUsage, vb.canRead);
                destVB.vertexDeclaration = vb.vertexDeclaration, destVB.setData(vb.getUint8Data().slice().buffer), destMesh._vertexBuffer = destVB, destMesh._vertexCount += destVB.vertexCount;
                var i, ib = this._indexBuffer,
                    destIB = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, ib.indexCount, ib.bufferUsage, ib.canRead);
                destIB.setData(ib.getData().slice()), destMesh._indexBuffer = destIB, destMesh._setBuffer(destMesh._vertexBuffer, destIB), destMesh._setCPUMemory(this.cpuMemory), destMesh._setGPUMemory(this.gpuMemory);
                var boneNames = this._boneNames, destBoneNames = destMesh._boneNames = [];
                for (i = 0; i < boneNames.length; i++) destBoneNames[i] = boneNames[i];
                var inverseBindPoses = this._inverseBindPoses, destInverseBindPoses = destMesh._inverseBindPoses = [];
                for (i = 0; i < inverseBindPoses.length; i++) destInverseBindPoses[i] = inverseBindPoses[i];
                for (destMesh._bindPoseIndices = new Uint16Array(this._bindPoseIndices), i = 0; i < this._skinDataPathMarks.length; i++) destMesh._skinDataPathMarks[i] = this._skinDataPathMarks[i].slice();
                for (i = 0; i < this.subMeshCount; i++) {
                    var subMesh = this._subMeshes[i], subIndexBufferStart = subMesh._subIndexBufferStart,
                        subIndexBufferCount = subMesh._subIndexBufferCount, boneIndicesList = subMesh._boneIndicesList,
                        destSubmesh = new SubMesh(destMesh);
                    destSubmesh._subIndexBufferStart.length = subIndexBufferStart.length, destSubmesh._subIndexBufferCount.length = subIndexBufferCount.length, destSubmesh._boneIndicesList.length = boneIndicesList.length;
                    for (var j = 0; j < subIndexBufferStart.length; j++) destSubmesh._subIndexBufferStart[j] = subIndexBufferStart[j];
                    for (j = 0; j < subIndexBufferCount.length; j++) destSubmesh._subIndexBufferCount[j] = subIndexBufferCount[j];
                    for (j = 0; j < boneIndicesList.length; j++) destSubmesh._boneIndicesList[j] = new Uint16Array(boneIndicesList[j]);
                    destSubmesh._indexBuffer = destIB, destSubmesh._indexStart = subMesh._indexStart, destSubmesh._indexCount = subMesh._indexCount, destSubmesh._indices = new Uint16Array(destIB.getData().buffer, 2 * subMesh._indexStart, subMesh._indexCount);
                    var vertexBuffer = destMesh._vertexBuffer;
                    destSubmesh._vertexBuffer = vertexBuffer, destMesh._subMeshes.push(destSubmesh)
                }
                destMesh._setSubMeshes(destMesh._subMeshes)
            }

            clone() {
                var dest = new Mesh;
                return this.cloneTo(dest), dest
            }
        }

        Mesh.MESH = "MESH";

        class TextureCube extends Laya.BaseTexture {
            constructor(size, format = Laya.BaseTexture.FORMAT_R8G8B8, mipmap = !1) {
                super(format, mipmap), this._glTextureType = Laya.LayaGL.instance.TEXTURE_CUBE_MAP, this._width = size, this._height = size;
                var gl = Laya.LayaGL.instance;
                if (this._setWarpMode(gl.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(gl.TEXTURE_WRAP_T, this._wrapModeV), this._setFilterMode(this._filterMode), this._setAnisotropy(this._anisoLevel), this._mipmap) {
                    this._mipmapCount = Math.ceil(Math.log2(size));
                    for (var i = 0; i < this._mipmapCount; i++) this._setPixels([], i, Math.max(size >> i, 1), Math.max(size >> i, 1));
                    this._setGPUMemory(size * size * 4 * (1 + 1 / 3) * 6)
                } else this._mipmapCount = 1, this._setGPUMemory(size * size * 4 * 6)
            }

            static __init__() {
                var pixels = new Uint8Array(3);
                pixels[0] = 128, pixels[1] = 128, pixels[2] = 128, TextureCube.grayTexture = new TextureCube(1, Laya.BaseTexture.FORMAT_R8G8B8, !1), TextureCube.grayTexture.setSixSidePixels([pixels, pixels, pixels, pixels, pixels, pixels]), TextureCube.grayTexture.lock = !0
            }

            static _parse(data, propertyParams = null, constructParams = null) {
                var texture = constructParams ? new TextureCube(0, constructParams[0], constructParams[1]) : new TextureCube(0);
                return texture.setSixSideImageSources(data), texture
            }

            static load(url, complete) {
                Laya.ILaya.loader.create(url, complete, null, TextureCube.TEXTURECUBE)
            }

            get defaulteTexture() {
                return TextureCube.grayTexture
            }

            _setPixels(pixels, miplevel, width, height) {
                var gl = Laya.LayaGL.instance, glFormat = this._getGLFormat();
                Laya.WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture), this.format === Laya.BaseTexture.FORMAT_R8G8B8 ? (gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1), gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels[0]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels[1]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels[2]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels[3]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels[4]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels[5]), gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4)) : (gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels[0]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels[1]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels[2]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels[3]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels[4]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, miplevel, glFormat, width, height, 0, glFormat, gl.UNSIGNED_BYTE, pixels[5]))
            }

            setSixSideImageSources(source, premultiplyAlpha = !1) {
                for (var width, height, i = 0; i < 6; i++) {
                    var img = source[i];
                    if (!img) return void console.log("TextureCube: image Source can't be null.");
                    var nextWidth = img.width, nextHeight = img.height;
                    if (i > 0 && width !== nextWidth) return void console.log("TextureCube: each side image's width and height must same.");
                    if ((width = nextWidth) !== (height = nextHeight)) return void console.log("TextureCube: each side image's width and height must same.")
                }
                this._width = width, this._height = height;
                var gl = Laya.LayaGL.instance;
                Laya.WebGLContext.bindTexture(gl, this._glTextureType, this._glTexture);
                var glFormat = this._getGLFormat();
                if (Laya.Render.isConchApp) {
                    if (1 == premultiplyAlpha) for (var j = 0; j < 6; j++) source[j].setPremultiplyAlpha(premultiplyAlpha);
                    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source[0]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source[1]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source[2]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source[3]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source[4]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source[5])
                } else premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFormat, glFormat, gl.UNSIGNED_BYTE, source[0]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFormat, glFormat, gl.UNSIGNED_BYTE, source[1]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFormat, glFormat, gl.UNSIGNED_BYTE, source[2]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFormat, glFormat, gl.UNSIGNED_BYTE, source[3]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFormat, glFormat, gl.UNSIGNED_BYTE, source[4]), gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFormat, glFormat, gl.UNSIGNED_BYTE, source[5]), premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);
                this._mipmap && this._isPot(width) && this._isPot(height) ? (gl.generateMipmap(this._glTextureType), this._setGPUMemory(width * height * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(width * height * 4 * 6), this._setWarpMode(gl.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(gl.TEXTURE_WRAP_T, this._wrapModeV), this._setFilterMode(this._filterMode), this._readyed = !0, this._activeResource()
            }

            setSixSidePixels(pixels, miplevel = 0) {
                if (!pixels) throw new Error("TextureCube:pixels can't be null.");
                var width = Math.max(this._width >> miplevel, 1), height = Math.max(this._height >> miplevel, 1),
                    pixelsCount = width * height * this._getFormatByteCount();
                if (pixels[0].length < pixelsCount) throw"TextureCube:pixels length should at least " + pixelsCount + ".";
                if (this._setPixels(pixels, miplevel, width, height), 0 === miplevel) {
                    var gl = Laya.LayaGL.instance;
                    this._setWarpMode(gl.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(gl.TEXTURE_WRAP_T, this._wrapModeV)
                }
                this._readyed = !0, this._activeResource()
            }

            _recoverResource() {
            }
        }

        TextureCube.TEXTURECUBE = "TEXTURECUBE";

        class PhysicsTriggerComponent extends PhysicsComponent {
            constructor(collisionGroup, canCollideWith) {
                super(collisionGroup, canCollideWith), this._isTrigger = !1
            }

            get isTrigger() {
                return this._isTrigger
            }

            set isTrigger(value) {
                if (this._isTrigger = value, this._nativeColliderObject) {
                    var flags = this._nativeColliderObject.getCollisionFlags();
                    value ? 0 == (flags & PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && this._nativeColliderObject.setCollisionFlags(flags | PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE) : 0 != (flags & PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && this._nativeColliderObject.setCollisionFlags(flags ^ PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE)
                }
            }

            _onAdded() {
                super._onAdded(), this.isTrigger = this._isTrigger
            }

            _cloneTo(dest) {
                super._cloneTo(dest), dest.isTrigger = this._isTrigger
            }
        }

        class PhysicsCollider extends PhysicsTriggerComponent {
            constructor(collisionGroup = Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER, canCollideWith = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
                super(collisionGroup, canCollideWith), this._enableProcessCollisions = !1
            }

            _addToSimulation() {
                this._simulation._addPhysicsCollider(this, this._collisionGroup, this._canCollideWith)
            }

            _removeFromSimulation() {
                this._simulation._removePhysicsCollider(this)
            }

            _onTransformChanged(flag) {
                (flag &= Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE) && (this._transformFlag |= flag, this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this))
            }

            _parse(data) {
                null != data.friction && (this.friction = data.friction), null != data.rollingFriction && (this.rollingFriction = data.rollingFriction), null != data.restitution && (this.restitution = data.restitution), null != data.isTrigger && (this.isTrigger = data.isTrigger), super._parse(data), this._parseShape(data.shapes)
            }

            _onAdded() {
                var btColObj = new Physics3D._physics3D.btCollisionObject;
                btColObj.setUserIndex(this.id), btColObj.forceActivationState(PhysicsComponent.ACTIVATIONSTATE_DISABLE_SIMULATION);
                var flags = btColObj.getCollisionFlags();
                this.owner.isStatic ? ((flags & PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (flags ^= PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT), flags |= PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT) : ((flags & PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT) > 0 && (flags ^= PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT), flags |= PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT), btColObj.setCollisionFlags(flags), this._nativeColliderObject = btColObj, super._onAdded()
            }
        }

        class CharacterController extends PhysicsComponent {
            constructor(stepheight = .1, upAxis = null, collisionGroup = Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER, canCollideWith = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
                super(collisionGroup, canCollideWith), this._upAxis = new Vector3(0, 1, 0), this._maxSlope = 45, this._jumpSpeed = 10, this._fallSpeed = 55, this._gravity = new Vector3(0, 3 * -9.8, 0), this._nativeKinematicCharacter = null, this._stepHeight = stepheight, upAxis && (this._upAxis = upAxis)
            }

            static __init__() {
                CharacterController._nativeTempVector30 = new Physics3D._physics3D.btVector3(0, 0, 0)
            }

            get fallSpeed() {
                return this._fallSpeed
            }

            set fallSpeed(value) {
                this._fallSpeed = value, this._nativeKinematicCharacter.setFallSpeed(value)
            }

            get jumpSpeed() {
                return this._jumpSpeed
            }

            set jumpSpeed(value) {
                this._jumpSpeed = value, this._nativeKinematicCharacter.setJumpSpeed(value)
            }

            get gravity() {
                return this._gravity
            }

            set gravity(value) {
                this._gravity = value;
                var nativeGravity = CharacterController._nativeTempVector30;
                nativeGravity.setValue(-value.x, value.y, value.z), this._nativeKinematicCharacter.setGravity(nativeGravity)
            }

            get maxSlope() {
                return this._maxSlope
            }

            set maxSlope(value) {
                this._maxSlope = value, this._nativeKinematicCharacter.setMaxSlope(value / 180 * Math.PI)
            }

            get isGrounded() {
                return this._nativeKinematicCharacter.onGround()
            }

            get stepHeight() {
                return this._stepHeight
            }

            set stepHeight(value) {
                this._stepHeight = value, this._constructCharacter()
            }

            get upAxis() {
                return this._upAxis
            }

            set upAxis(value) {
                this._upAxis = value, this._constructCharacter()
            }

            _constructCharacter() {
                var physics3D = Physics3D._physics3D;
                this._nativeKinematicCharacter && physics3D.destroy(this._nativeKinematicCharacter);
                var nativeUpAxis = CharacterController._nativeTempVector30;
                nativeUpAxis.setValue(this._upAxis.x, this._upAxis.y, this._upAxis.z), this._nativeKinematicCharacter = new physics3D.btKinematicCharacterController(this._nativeColliderObject, this._colliderShape._nativeShape, this._stepHeight, nativeUpAxis), this.fallSpeed = this._fallSpeed, this.maxSlope = this._maxSlope, this.jumpSpeed = this._jumpSpeed, this.gravity = this._gravity
            }

            _onShapeChange(colShape) {
                super._onShapeChange(colShape), this._constructCharacter()
            }

            _onAdded() {
                var ghostObject = new Physics3D._physics3D.btPairCachingGhostObject;
                ghostObject.setUserIndex(this.id), ghostObject.setCollisionFlags(PhysicsComponent.COLLISIONFLAGS_CHARACTER_OBJECT), this._nativeColliderObject = ghostObject, this._colliderShape && this._constructCharacter(), super._onAdded()
            }

            _addToSimulation() {
                this._simulation._characters.push(this), this._simulation._addCharacter(this, this._collisionGroup, this._canCollideWith)
            }

            _removeFromSimulation() {
                this._simulation._removeCharacter(this);
                var characters = this._simulation._characters;
                characters.splice(characters.indexOf(this), 1)
            }

            _cloneTo(dest) {
                super._cloneTo(dest);
                var destCharacterController = dest;
                destCharacterController.stepHeight = this._stepHeight, destCharacterController.upAxis = this._upAxis, destCharacterController.maxSlope = this._maxSlope, destCharacterController.jumpSpeed = this._jumpSpeed, destCharacterController.fallSpeed = this._fallSpeed, destCharacterController.gravity = this._gravity
            }

            _onDestroy() {
                Physics3D._physics3D.destroy(this._nativeKinematicCharacter), super._onDestroy(), this._nativeKinematicCharacter = null
            }

            move(movement) {
                var nativeMovement = CharacterController._nativeVector30;
                nativeMovement.setValue(-movement.x, movement.y, movement.z), this._nativeKinematicCharacter.setWalkDirection(nativeMovement)
            }

            jump(velocity = null) {
                if (velocity) {
                    var nativeVelocity = CharacterController._nativeVector30;
                    Utils3D._convertToBulletVec3(velocity, nativeVelocity, !0), this._nativeKinematicCharacter.jump(nativeVelocity)
                } else this._nativeKinematicCharacter.jump()
            }
        }

        CharacterController.UPAXIS_X = 0, CharacterController.UPAXIS_Y = 1, CharacterController.UPAXIS_Z = 2;

        class Rigidbody3D extends PhysicsTriggerComponent {
            constructor(collisionGroup = Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER, canCollideWith = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
                super(collisionGroup, canCollideWith), this._isKinematic = !1, this._mass = 1, this._gravity = new Vector3(0, -10, 0), this._angularDamping = 0, this._linearDamping = 0, this._overrideGravity = !1, this._totalTorque = new Vector3(0, 0, 0), this._totalForce = new Vector3(0, 0, 0), this._linearVelocity = new Vector3, this._angularVelocity = new Vector3, this._linearFactor = new Vector3(1, 1, 1), this._angularFactor = new Vector3(1, 1, 1), this._detectCollisions = !0
            }

            static __init__() {
                Rigidbody3D._nativeTempVector30 = new Physics3D._physics3D.btVector3(0, 0, 0), Rigidbody3D._nativeTempVector31 = new Physics3D._physics3D.btVector3(0, 0, 0), Rigidbody3D._nativeVector3Zero = new Physics3D._physics3D.btVector3(0, 0, 0), Rigidbody3D._nativeInertia = new Physics3D._physics3D.btVector3(0, 0, 0), Rigidbody3D._nativeImpulse = new Physics3D._physics3D.btVector3(0, 0, 0), Rigidbody3D._nativeImpulseOffset = new Physics3D._physics3D.btVector3(0, 0, 0), Rigidbody3D._nativeGravity = new Physics3D._physics3D.btVector3(0, 0, 0)
            }

            get mass() {
                return this._mass
            }

            set mass(value) {
                value = Math.max(value, 1e-7), this._mass = value, this._isKinematic || this._updateMass(value)
            }

            get isKinematic() {
                return this._isKinematic
            }

            set isKinematic(value) {
                this._isKinematic = value;
                var canInSimulation = !!(this._simulation && this._enabled && this._colliderShape);
                canInSimulation && this._removeFromSimulation();
                var natColObj = this._nativeColliderObject, flags = natColObj.getCollisionFlags();
                value ? (flags |= PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT, natColObj.setCollisionFlags(flags), this._nativeColliderObject.forceActivationState(PhysicsComponent.ACTIVATIONSTATE_DISABLE_DEACTIVATION), this._enableProcessCollisions = !1, this._updateMass(0)) : ((flags & PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (flags ^= PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT), natColObj.setCollisionFlags(flags), this._nativeColliderObject.setActivationState(PhysicsComponent.ACTIVATIONSTATE_ACTIVE_TAG), this._enableProcessCollisions = !0, this._updateMass(this._mass));
                var nativeZero = Rigidbody3D._nativeVector3Zero;
                natColObj.setInterpolationLinearVelocity(nativeZero), natColObj.setLinearVelocity(nativeZero), natColObj.setInterpolationAngularVelocity(nativeZero), natColObj.setAngularVelocity(nativeZero), canInSimulation && this._addToSimulation()
            }

            get linearDamping() {
                return this._linearDamping
            }

            set linearDamping(value) {
                this._linearDamping = value, this._nativeColliderObject && this._nativeColliderObject.setDamping(value, this._angularDamping)
            }

            get angularDamping() {
                return this._angularDamping
            }

            set angularDamping(value) {
                this._angularDamping = value, this._nativeColliderObject && this._nativeColliderObject.setDamping(this._linearDamping, value)
            }

            get overrideGravity() {
                return this._overrideGravity
            }

            set overrideGravity(value) {
                if (this._overrideGravity = value, this._nativeColliderObject) {
                    var flag = this._nativeColliderObject.getFlags();
                    value ? 0 == (flag & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) && this._nativeColliderObject.setFlags(flag | Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) : (flag & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) > 0 && this._nativeColliderObject.setFlags(flag ^ Rigidbody3D._BT_DISABLE_WORLD_GRAVITY)
                }
            }

            get gravity() {
                return this._gravity
            }

            set gravity(value) {
                this._gravity = value, Rigidbody3D._nativeGravity.setValue(-value.x, value.y, value.z), this._nativeColliderObject.setGravity(Rigidbody3D._nativeGravity)
            }

            get totalForce() {
                if (this._nativeColliderObject) {
                    var nativeTotalForce = this._nativeColliderObject.getTotalForce();
                    return Utils3D._convertToLayaVec3(nativeTotalForce, this._totalForce, !0), this._totalForce
                }
                return null
            }

            get linearFactor() {
                return this._nativeColliderObject ? this._linearFactor : null
            }

            set linearFactor(value) {
                if (this._linearFactor = value, this._nativeColliderObject) {
                    var nativeValue = Rigidbody3D._nativeTempVector30;
                    Utils3D._convertToBulletVec3(value, nativeValue, !1), this._nativeColliderObject.setLinearFactor(nativeValue)
                }
            }

            get linearVelocity() {
                return this._nativeColliderObject && Utils3D._convertToLayaVec3(this._nativeColliderObject.getLinearVelocity(), this._linearVelocity, !0), this._linearVelocity
            }

            set linearVelocity(value) {
                if (this._linearVelocity = value, this._nativeColliderObject) {
                    var nativeValue = Rigidbody3D._nativeTempVector30;
                    Utils3D._convertToBulletVec3(value, nativeValue, !0), this.isSleeping && this.wakeUp(), this._nativeColliderObject.setLinearVelocity(nativeValue)
                }
            }

            get angularFactor() {
                return this._nativeColliderObject ? this._angularFactor : null
            }

            set angularFactor(value) {
                if (this._angularFactor = value, this._nativeColliderObject) {
                    var nativeValue = Rigidbody3D._nativeTempVector30;
                    Utils3D._convertToBulletVec3(value, nativeValue, !1), this._nativeColliderObject.setAngularFactor(nativeValue)
                }
            }

            get angularVelocity() {
                return this._nativeColliderObject && Utils3D._convertToLayaVec3(this._nativeColliderObject.getAngularVelocity(), this._angularVelocity, !0), this._angularVelocity
            }

            set angularVelocity(value) {
                if (this._angularVelocity = value, this._nativeColliderObject) {
                    var nativeValue = Rigidbody3D._nativeTempVector30;
                    Utils3D._convertToBulletVec3(value, nativeValue, !0), this.isSleeping && this.wakeUp(), this._nativeColliderObject.setAngularVelocity(nativeValue)
                }
            }

            get totalTorque() {
                if (this._nativeColliderObject) {
                    var nativeTotalTorque = this._nativeColliderObject.getTotalTorque();
                    return Utils3D._convertToLayaVec3(nativeTotalTorque, this._totalTorque, !0), this._totalTorque
                }
                return null
            }

            get detectCollisions() {
                return this._detectCollisions
            }

            set detectCollisions(value) {
                this._detectCollisions !== value && (this._detectCollisions = value, this._colliderShape && this._enabled && this._simulation && (this._simulation._removeRigidBody(this), this._simulation._addRigidBody(this, this._collisionGroup, value ? this._canCollideWith : 0)))
            }

            get isSleeping() {
                return !!this._nativeColliderObject && this._nativeColliderObject.getActivationState() === PhysicsComponent.ACTIVATIONSTATE_ISLAND_SLEEPING
            }

            get sleepLinearVelocity() {
                return this._nativeColliderObject.getLinearSleepingThreshold()
            }

            set sleepLinearVelocity(value) {
                this._nativeColliderObject.setSleepingThresholds(value, this._nativeColliderObject.getAngularSleepingThreshold())
            }

            get sleepAngularVelocity() {
                return this._nativeColliderObject.getAngularSleepingThreshold()
            }

            set sleepAngularVelocity(value) {
                this._nativeColliderObject.setSleepingThresholds(this._nativeColliderObject.getLinearSleepingThreshold(), value)
            }

            _updateMass(mass) {
                this._nativeColliderObject && this._colliderShape && (this._colliderShape._nativeShape.calculateLocalInertia(mass, Rigidbody3D._nativeInertia), this._nativeColliderObject.setMassProps(mass, Rigidbody3D._nativeInertia), this._nativeColliderObject.updateInertiaTensor())
            }

            _delegateMotionStateGetWorldTransform(worldTransPointer) {
            }

            _delegateMotionStateSetWorldTransform(worldTransPointer) {
                var rigidBody = this._rigidbody;
                rigidBody._simulation._updatedRigidbodies++;
                var physics3D = Physics3D._physics3D,
                    worldTrans = physics3D.wrapPointer(worldTransPointer, physics3D.btTransform);
                rigidBody._updateTransformComponent(worldTrans)
            }

            _delegateMotionStateGetWorldTransformNative(ridgidBody3D, worldTransPointer) {
            }

            _delegateMotionStateSetWorldTransformNative(rigidBody3D, worldTransPointer) {
                var rigidBody = rigidBody3D;
                rigidBody._simulation._updatedRigidbodies++;
                var physics3D = Physics3D._physics3D,
                    worldTrans = physics3D.wrapPointer(worldTransPointer, physics3D.btTransform);
                rigidBody._updateTransformComponent(worldTrans)
            }

            _onScaleChange(scale) {
                super._onScaleChange(scale), this._updateMass(this._isKinematic ? 0 : this._mass)
            }

            _delegateMotionStateClear() {
                this._rigidbody = null
            }

            _onAdded() {
                var physics3D = Physics3D._physics3D, motionState = new physics3D.LayaMotionState;
                null != window.conch && physics3D.LayaMotionState.prototype.setRigidbody ? (motionState.setRigidbody(this), motionState.setNativeGetWorldTransform(this._delegateMotionStateGetWorldTransformNative), motionState.setNativeSetWorldTransform(this._delegateMotionStateSetWorldTransformNative)) : (motionState.getWorldTransform = this._delegateMotionStateGetWorldTransform, motionState.setWorldTransform = this._delegateMotionStateSetWorldTransform), motionState.clear = this._delegateMotionStateClear, motionState._rigidbody = this, this._nativeMotionState = motionState;
                var constructInfo = new physics3D.btRigidBodyConstructionInfo(0, motionState, null, Rigidbody3D._nativeVector3Zero),
                    btRigid = new physics3D.btRigidBody(constructInfo);
                btRigid.setUserIndex(this.id), this._nativeColliderObject = btRigid, super._onAdded(), this.mass = this._mass, this.linearFactor = this._linearFactor, this.angularFactor = this._angularFactor, this.linearDamping = this._linearDamping, this.angularDamping = this._angularDamping, this.overrideGravity = this._overrideGravity, this.gravity = this._gravity, this.isKinematic = this._isKinematic, physics3D.destroy(constructInfo)
            }

            _onShapeChange(colShape) {
                super._onShapeChange(colShape), this._isKinematic ? this._updateMass(0) : (this._nativeColliderObject.setCenterOfMassTransform(this._nativeColliderObject.getWorldTransform()), this._updateMass(this._mass))
            }

            _parse(data) {
                null != data.friction && (this.friction = data.friction), null != data.rollingFriction && (this.rollingFriction = data.rollingFriction), null != data.restitution && (this.restitution = data.restitution), null != data.isTrigger && (this.isTrigger = data.isTrigger), null != data.mass && (this.mass = data.mass), null != data.isKinematic && (this.isKinematic = data.isKinematic), null != data.linearDamping && (this.linearDamping = data.linearDamping), null != data.angularDamping && (this.angularDamping = data.angularDamping), null != data.overrideGravity && (this.overrideGravity = data.overrideGravity), data.gravity && (this.gravity.fromArray(data.gravity), this.gravity = this.gravity), super._parse(data), this._parseShape(data.shapes)
            }

            _onDestroy() {
                var physics3D = Physics3D._physics3D;
                this._nativeMotionState.clear(), physics3D.destroy(this._nativeMotionState), super._onDestroy(), this._nativeMotionState = null, this._gravity = null, this._totalTorque = null, this._linearVelocity = null, this._angularVelocity = null, this._linearFactor = null, this._angularFactor = null
            }

            _addToSimulation() {
                this._simulation._addRigidBody(this, this._collisionGroup, this._detectCollisions ? this._canCollideWith : 0)
            }

            _removeFromSimulation() {
                this._simulation._removeRigidBody(this)
            }

            _cloneTo(dest) {
                super._cloneTo(dest);
                var destRigidbody3D = dest;
                destRigidbody3D.isKinematic = this._isKinematic, destRigidbody3D.mass = this._mass, destRigidbody3D.gravity = this._gravity, destRigidbody3D.angularDamping = this._angularDamping, destRigidbody3D.linearDamping = this._linearDamping, destRigidbody3D.overrideGravity = this._overrideGravity, destRigidbody3D.linearVelocity = this._linearVelocity, destRigidbody3D.angularVelocity = this._angularVelocity, destRigidbody3D.linearFactor = this._linearFactor, destRigidbody3D.angularFactor = this._angularFactor, destRigidbody3D.detectCollisions = this._detectCollisions
            }

            applyForce(force, localOffset = null) {
                if (null == this._nativeColliderObject) throw"Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var nativeForce = Rigidbody3D._nativeTempVector30;
                if (nativeForce.setValue(-force.x, force.y, force.z), localOffset) {
                    var nativeOffset = Rigidbody3D._nativeTempVector31;
                    nativeOffset.setValue(-localOffset.x, localOffset.y, localOffset.z), this._nativeColliderObject.applyForce(nativeForce, nativeOffset)
                } else this._nativeColliderObject.applyCentralForce(nativeForce)
            }

            applyTorque(torque) {
                if (null == this._nativeColliderObject) throw"Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var nativeTorque = Rigidbody3D._nativeTempVector30;
                nativeTorque.setValue(-torque.x, torque.y, torque.z), this._nativeColliderObject.applyTorque(nativeTorque)
            }

            applyImpulse(impulse, localOffset = null) {
                if (null == this._nativeColliderObject) throw"Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                Rigidbody3D._nativeImpulse.setValue(-impulse.x, impulse.y, impulse.z), localOffset ? (Rigidbody3D._nativeImpulseOffset.setValue(-localOffset.x, localOffset.y, localOffset.z), this._nativeColliderObject.applyImpulse(Rigidbody3D._nativeImpulse, Rigidbody3D._nativeImpulseOffset)) : this._nativeColliderObject.applyCentralImpulse(Rigidbody3D._nativeImpulse)
            }

            applyTorqueImpulse(torqueImpulse) {
                if (null == this._nativeColliderObject) throw"Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var nativeTorqueImpulse = Rigidbody3D._nativeTempVector30;
                nativeTorqueImpulse.setValue(-torqueImpulse.x, torqueImpulse.y, torqueImpulse.z), this._nativeColliderObject.applyTorqueImpulse(nativeTorqueImpulse)
            }

            wakeUp() {
                this._nativeColliderObject && this._nativeColliderObject.activate(!1)
            }

            clearForces() {
                var rigidBody = this._nativeColliderObject;
                if (null == rigidBody) throw"Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                rigidBody.clearForces();
                var nativeZero = Rigidbody3D._nativeVector3Zero;
                rigidBody.setInterpolationLinearVelocity(nativeZero), rigidBody.setLinearVelocity(nativeZero), rigidBody.setInterpolationAngularVelocity(nativeZero), rigidBody.setAngularVelocity(nativeZero)
            }
        }

        Rigidbody3D.TYPE_STATIC = 0, Rigidbody3D.TYPE_DYNAMIC = 1, Rigidbody3D.TYPE_KINEMATIC = 2, Rigidbody3D._BT_DISABLE_WORLD_GRAVITY = 1, Rigidbody3D._BT_ENABLE_GYROPSCOPIC_FORCE = 2;

        class StaticPlaneColliderShape extends ColliderShape {
            static __init__() {
                StaticPlaneColliderShape._nativeNormal = new Physics3D._physics3D.btVector3(0, 0, 0)
            }

            constructor(normal, offset) {
                super(), this._normal = normal, this._offset = offset, this._type = ColliderShape.SHAPETYPES_STATICPLANE, StaticPlaneColliderShape._nativeNormal.setValue(-normal.x, normal.y, normal.z), this._nativeShape = new Physics3D._physics3D.btStaticPlaneShape(StaticPlaneColliderShape._nativeNormal, offset)
            }

            clone() {
                var dest = new StaticPlaneColliderShape(this._normal, this._offset);
                return this.cloneTo(dest), dest
            }
        }

        class PrimitiveMesh {
            static __init__() {
            }

            static _createMesh(vertexDeclaration, vertices, indices) {
                var gl = Laya.LayaGL.instance, mesh = new Mesh, subMesh = new SubMesh(mesh),
                    vertexBuffer = new VertexBuffer3D(4 * vertices.length, gl.STATIC_DRAW, !0);
                vertexBuffer.vertexDeclaration = vertexDeclaration, vertexBuffer.setData(vertices.buffer), mesh._vertexBuffer = vertexBuffer, mesh._vertexCount += vertexBuffer.vertexCount;
                var indexBuffer = new IndexBuffer3D(IndexBuffer3D.INDEXTYPE_USHORT, indices.length, gl.STATIC_DRAW, !0);
                indexBuffer.setData(indices), mesh._indexBuffer = indexBuffer;
                mesh._setBuffer(vertexBuffer, indexBuffer), subMesh._vertexBuffer = vertexBuffer, subMesh._indexBuffer = indexBuffer, subMesh._setIndexRange(0, indexBuffer.indexCount);
                var subIndexBufferStart = subMesh._subIndexBufferStart,
                    subIndexBufferCount = subMesh._subIndexBufferCount, boneIndicesList = subMesh._boneIndicesList;
                subIndexBufferStart.length = 1, subIndexBufferCount.length = 1, boneIndicesList.length = 1, subIndexBufferStart[0] = 0, subIndexBufferCount[0] = indexBuffer.indexCount;
                var subMeshes = [];
                subMeshes.push(subMesh), mesh._setSubMeshes(subMeshes);
                var memorySize = vertexBuffer._byteLength + indexBuffer._byteLength;
                return mesh._setCPUMemory(memorySize), mesh._setGPUMemory(memorySize), mesh
            }

            static createBox(long = 1, height = 1, width = 1) {
                var vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV"), halfLong = long / 2,
                    halfHeight = height / 2, halfWidth = width / 2,
                    vertices = new Float32Array([-halfLong, halfHeight, -halfWidth, 0, 1, 0, 0, 0, halfLong, halfHeight, -halfWidth, 0, 1, 0, 1, 0, halfLong, halfHeight, halfWidth, 0, 1, 0, 1, 1, -halfLong, halfHeight, halfWidth, 0, 1, 0, 0, 1, -halfLong, -halfHeight, -halfWidth, 0, -1, 0, 0, 1, halfLong, -halfHeight, -halfWidth, 0, -1, 0, 1, 1, halfLong, -halfHeight, halfWidth, 0, -1, 0, 1, 0, -halfLong, -halfHeight, halfWidth, 0, -1, 0, 0, 0, -halfLong, halfHeight, -halfWidth, -1, 0, 0, 0, 0, -halfLong, halfHeight, halfWidth, -1, 0, 0, 1, 0, -halfLong, -halfHeight, halfWidth, -1, 0, 0, 1, 1, -halfLong, -halfHeight, -halfWidth, -1, 0, 0, 0, 1, halfLong, halfHeight, -halfWidth, 1, 0, 0, 1, 0, halfLong, halfHeight, halfWidth, 1, 0, 0, 0, 0, halfLong, -halfHeight, halfWidth, 1, 0, 0, 0, 1, halfLong, -halfHeight, -halfWidth, 1, 0, 0, 1, 1, -halfLong, halfHeight, halfWidth, 0, 0, 1, 0, 0, halfLong, halfHeight, halfWidth, 0, 0, 1, 1, 0, halfLong, -halfHeight, halfWidth, 0, 0, 1, 1, 1, -halfLong, -halfHeight, halfWidth, 0, 0, 1, 0, 1, -halfLong, halfHeight, -halfWidth, 0, 0, -1, 1, 0, halfLong, halfHeight, -halfWidth, 0, 0, -1, 0, 0, halfLong, -halfHeight, -halfWidth, 0, 0, -1, 0, 1, -halfLong, -halfHeight, -halfWidth, 0, 0, -1, 1, 1]),
                    indices = new Uint16Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 8, 9, 10, 10, 11, 8, 12, 15, 14, 14, 13, 12, 16, 17, 18, 18, 19, 16, 20, 23, 22, 22, 21, 20]);
                return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices)
            }

            static createCapsule(radius = .5, height = 2, stacks = 16, slices = 32) {
                var stack, slice, vertexCount = (stacks + 1) * (slices + 1) * 2 + 2 * (slices + 1),
                    indexCount = 3 * stacks * (slices + 1) * 2 * 2 + 2 * slices * 3,
                    vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV"),
                    vertexFloatStride = vertexDeclaration.vertexStride / 4,
                    vertices = new Float32Array(vertexCount * vertexFloatStride), indices = new Uint16Array(indexCount),
                    stackAngle = Math.PI / 2 / stacks, sliceAngle = 2 * Math.PI / slices,
                    hcHeight = height / 2 - radius, posX = 0, posY = 0, posZ = 0, vc = 0, ic = 0, verticeCount = 0;
                for (stack = 0; stack <= stacks; stack++) for (slice = 0; slice <= slices; slice++) posX = radius * Math.cos(stack * stackAngle) * Math.cos(slice * sliceAngle + Math.PI), posY = radius * Math.sin(stack * stackAngle), posZ = radius * Math.cos(stack * stackAngle) * Math.sin(slice * sliceAngle + Math.PI), vertices[vc++] = posX, vertices[vc++] = posY + hcHeight, vertices[vc++] = posZ, vertices[vc++] = posX, vertices[vc++] = posY, vertices[vc++] = posZ, vertices[vc++] = 1 - slice / slices, vertices[vc++] = (1 - stack / stacks) * (Math.PI * radius / 2 / (height + Math.PI * radius)), stack < stacks && (indices[ic++] = stack * (slices + 1) + slice + (slices + 1), indices[ic++] = stack * (slices + 1) + slice, indices[ic++] = stack * (slices + 1) + slice + 1, indices[ic++] = stack * (slices + 1) + slice + slices, indices[ic++] = stack * (slices + 1) + slice, indices[ic++] = stack * (slices + 1) + slice + (slices + 1));
                for (verticeCount += (stacks + 1) * (slices + 1), stack = 0; stack <= stacks; stack++) for (slice = 0; slice <= slices; slice++) posX = radius * Math.cos(stack * stackAngle) * Math.cos(slice * sliceAngle + Math.PI), posY = radius * Math.sin(-stack * stackAngle), posZ = radius * Math.cos(stack * stackAngle) * Math.sin(slice * sliceAngle + Math.PI), vertices[vc++] = posX, vertices[vc++] = posY - hcHeight, vertices[vc++] = posZ, vertices[vc++] = posX, vertices[vc++] = posY, vertices[vc++] = posZ, vertices[vc++] = 1 - slice / slices, vertices[vc++] = (stack / stacks * (Math.PI * radius / 2) + (height + Math.PI * radius / 2)) / (height + Math.PI * radius), stack < stacks && (indices[ic++] = verticeCount + stack * (slices + 1) + slice, indices[ic++] = verticeCount + stack * (slices + 1) + slice + (slices + 1), indices[ic++] = verticeCount + stack * (slices + 1) + slice + 1, indices[ic++] = verticeCount + stack * (slices + 1) + slice, indices[ic++] = verticeCount + stack * (slices + 1) + slice + slices, indices[ic++] = verticeCount + stack * (slices + 1) + slice + (slices + 1));
                for (verticeCount += (stacks + 1) * (slices + 1), slice = 0; slice <= slices; slice++) posX = radius * Math.cos(slice * sliceAngle + Math.PI), posY = hcHeight, posZ = radius * Math.sin(slice * sliceAngle + Math.PI), vertices[vc++] = posX, vertices[vc + 8 * (slices + 1) - 1] = posX, vertices[vc++] = posY, vertices[vc + 8 * (slices + 1) - 1] = -posY, vertices[vc++] = posZ, vertices[vc + 8 * (slices + 1) - 1] = posZ, vertices[vc++] = posX, vertices[vc + 8 * (slices + 1) - 1] = posX, vertices[vc++] = 0, vertices[vc + 8 * (slices + 1) - 1] = 0, vertices[vc++] = posZ, vertices[vc + 8 * (slices + 1) - 1] = posZ, vertices[vc++] = 1 - 1 * slice / slices, vertices[vc + 8 * (slices + 1) - 1] = 1 - 1 * slice / slices, vertices[vc++] = Math.PI * radius / 2 / (height + Math.PI * radius), vertices[vc + 8 * (slices + 1) - 1] = (Math.PI * radius / 2 + height) / (height + Math.PI * radius);
                for (slice = 0; slice < slices; slice++) indices[ic++] = slice + verticeCount + (slices + 1), indices[ic++] = slice + verticeCount + 1, indices[ic++] = slice + verticeCount, indices[ic++] = slice + verticeCount + (slices + 1), indices[ic++] = slice + verticeCount + (slices + 1) + 1, indices[ic++] = slice + verticeCount + 1;
                return verticeCount += 2 * (slices + 1), PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices)
            }

            static createCone(radius = .5, height = 1, slices = 32) {
                for (var rotateRadius, vertexCount = slices + 1 + 1 + 2 * (slices + 1), indexCount = 6 * slices + 3 * slices, vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV"), vertexFloatStride = vertexDeclaration.vertexStride / 4, vertices = new Float32Array(vertexCount * vertexFloatStride), indices = new Uint16Array(indexCount), sliceAngle = 2 * Math.PI / slices, halfHeight = height / 2, curAngle = 0, verticeCount = 0, posX = 0, posY = 0, posZ = 0, normal = new Vector3, downV3 = new Vector3(0, -1, 0), upPoint = new Vector3(0, halfHeight, 0), downPoint = new Vector3, v3 = new Vector3, q4 = new Quaternion, rotateAxis = new Vector3, vc = 0, ic = 0, rv = 0; rv <= slices; rv++) curAngle = rv * sliceAngle, posX = Math.cos(curAngle + Math.PI) * radius, posY = halfHeight, posZ = Math.sin(curAngle + Math.PI) * radius, vertices[vc++] = 0, vertices[vc + 8 * (slices + 1) - 1] = posX, vertices[vc++] = posY, vertices[vc + 8 * (slices + 1) - 1] = -posY, vertices[vc++] = 0, vertices[vc + 8 * (slices + 1) - 1] = posZ, normal.x = posX, normal.y = 0, normal.z = posZ, downPoint.x = posX, downPoint.y = -posY, downPoint.z = posZ, Vector3.subtract(downPoint, upPoint, v3), Vector3.normalize(v3, v3), rotateRadius = Math.acos(Vector3.dot(downV3, v3)), Vector3.cross(downV3, v3, rotateAxis), Vector3.normalize(rotateAxis, rotateAxis), Quaternion.createFromAxisAngle(rotateAxis, rotateRadius, q4), Vector3.normalize(normal, normal), Vector3.transformQuat(normal, q4, normal), Vector3.normalize(normal, normal), vertices[vc++] = normal.x, vertices[vc + 8 * (slices + 1) - 1] = normal.x, vertices[vc++] = normal.y, vertices[vc + 8 * (slices + 1) - 1] = normal.y, vertices[vc++] = normal.z, vertices[vc + 8 * (slices + 1) - 1] = normal.z, vertices[vc++] = 1 - 1 * rv / slices, vertices[vc + 8 * (slices + 1) - 1] = 1 - 1 * rv / slices, vertices[vc++] = 0, vertices[vc + 8 * (slices + 1) - 1] = 1;
                vc += 8 * (slices + 1);
                for (var ri = 0; ri < slices; ri++) indices[ic++] = ri + verticeCount + (slices + 1), indices[ic++] = ri + verticeCount + 1, indices[ic++] = ri + verticeCount, indices[ic++] = ri + verticeCount + (slices + 1), indices[ic++] = ri + verticeCount + (slices + 1) + 1, indices[ic++] = ri + verticeCount + 1;
                verticeCount += 2 * (slices + 1);
                for (var bv = 0; bv <= slices; bv++) 0 === bv && (vertices[vc++] = 0, vertices[vc++] = -halfHeight, vertices[vc++] = 0, vertices[vc++] = 0, vertices[vc++] = -1, vertices[vc++] = 0, vertices[vc++] = .5, vertices[vc++] = .5), curAngle = bv * sliceAngle, posX = Math.cos(curAngle + Math.PI) * radius, posY = -halfHeight, posZ = Math.sin(curAngle + Math.PI) * radius, vertices[vc++] = posX, vertices[vc++] = posY, vertices[vc++] = posZ, vertices[vc++] = 0, vertices[vc++] = -1, vertices[vc++] = 0, vertices[vc++] = .5 + .5 * Math.cos(curAngle), vertices[vc++] = .5 + .5 * Math.sin(curAngle);
                for (var bi = 0; bi < slices; bi++) indices[ic++] = 0 + verticeCount, indices[ic++] = bi + 2 + verticeCount, indices[ic++] = bi + 1 + verticeCount;
                return verticeCount += slices + 1 + 1, PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices)
            }

            static createCylinder(radius = .5, height = 2, slices = 32) {
                for (var vertexCount = slices + 1 + 1 + 2 * (slices + 1) + (slices + 1 + 1), indexCount = 3 * slices + 6 * slices + 3 * slices, vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV"), vertexFloatStride = vertexDeclaration.vertexStride / 4, vertices = new Float32Array(vertexCount * vertexFloatStride), indices = new Uint16Array(indexCount), sliceAngle = 2 * Math.PI / slices, halfHeight = height / 2, curAngle = 0, verticeCount = 0, posX = 0, posY = 0, posZ = 0, vc = 0, ic = 0, tv = 0; tv <= slices; tv++) 0 === tv && (vertices[vc++] = 0, vertices[vc++] = halfHeight, vertices[vc++] = 0, vertices[vc++] = 0, vertices[vc++] = 1, vertices[vc++] = 0, vertices[vc++] = .5, vertices[vc++] = .5), curAngle = tv * sliceAngle, posX = Math.cos(curAngle) * radius, posY = halfHeight, posZ = Math.sin(curAngle) * radius, vertices[vc++] = posX, vertices[vc++] = posY, vertices[vc++] = posZ, vertices[vc++] = 0, vertices[vc++] = 1, vertices[vc++] = 0, vertices[vc++] = .5 + .5 * Math.cos(curAngle), vertices[vc++] = .5 + .5 * Math.sin(curAngle);
                for (var ti = 0; ti < slices; ti++) indices[ic++] = 0, indices[ic++] = ti + 1, indices[ic++] = ti + 2;
                verticeCount += slices + 1 + 1;
                for (var rv = 0; rv <= slices; rv++) curAngle = rv * sliceAngle, posX = Math.cos(curAngle + Math.PI) * radius, posY = halfHeight, posZ = Math.sin(curAngle + Math.PI) * radius, vertices[vc++] = posX, vertices[vc + 8 * (slices + 1) - 1] = posX, vertices[vc++] = posY, vertices[vc + 8 * (slices + 1) - 1] = -posY, vertices[vc++] = posZ, vertices[vc + 8 * (slices + 1) - 1] = posZ, vertices[vc++] = posX, vertices[vc + 8 * (slices + 1) - 1] = posX, vertices[vc++] = 0, vertices[vc + 8 * (slices + 1) - 1] = 0, vertices[vc++] = posZ, vertices[vc + 8 * (slices + 1) - 1] = posZ, vertices[vc++] = 1 - 1 * rv / slices, vertices[vc + 8 * (slices + 1) - 1] = 1 - 1 * rv / slices, vertices[vc++] = 0, vertices[vc + 8 * (slices + 1) - 1] = 1;
                vc += 8 * (slices + 1);
                for (var ri = 0; ri < slices; ri++) indices[ic++] = ri + verticeCount + (slices + 1), indices[ic++] = ri + verticeCount + 1, indices[ic++] = ri + verticeCount, indices[ic++] = ri + verticeCount + (slices + 1), indices[ic++] = ri + verticeCount + (slices + 1) + 1, indices[ic++] = ri + verticeCount + 1;
                verticeCount += 2 * (slices + 1);
                for (var bv = 0; bv <= slices; bv++) 0 === bv && (vertices[vc++] = 0, vertices[vc++] = -halfHeight, vertices[vc++] = 0, vertices[vc++] = 0, vertices[vc++] = -1, vertices[vc++] = 0, vertices[vc++] = .5, vertices[vc++] = .5), curAngle = bv * sliceAngle, posX = Math.cos(curAngle + Math.PI) * radius, posY = -halfHeight, posZ = Math.sin(curAngle + Math.PI) * radius, vertices[vc++] = posX, vertices[vc++] = posY, vertices[vc++] = posZ, vertices[vc++] = 0, vertices[vc++] = -1, vertices[vc++] = 0, vertices[vc++] = .5 + .5 * Math.cos(curAngle), vertices[vc++] = .5 + .5 * Math.sin(curAngle);
                for (var bi = 0; bi < slices; bi++) indices[ic++] = 0 + verticeCount, indices[ic++] = bi + 2 + verticeCount, indices[ic++] = bi + 1 + verticeCount;
                return verticeCount += slices + 1 + 1, PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices)
            }

            static createPlane(long = 10, width = 10, stacks = 10, slices = 10) {
                for (var vertexCount = (stacks + 1) * (slices + 1), indices = new Uint16Array(stacks * slices * 2 * 3), vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV"), vertexFloatStride = vertexDeclaration.vertexStride / 4, vertices = new Float32Array(vertexCount * vertexFloatStride), halfLong = long / 2, halfWidth = width / 2, stacksLong = long / stacks, slicesWidth = width / slices, verticeCount = 0, i = 0; i <= slices; i++) for (var j = 0; j <= stacks; j++) vertices[verticeCount++] = j * stacksLong - halfLong, vertices[verticeCount++] = 0, vertices[verticeCount++] = i * slicesWidth - halfWidth, vertices[verticeCount++] = 0, vertices[verticeCount++] = 1, vertices[verticeCount++] = 0, vertices[verticeCount++] = 1 * j / stacks, vertices[verticeCount++] = 1 * i / slices;
                var indiceIndex = 0;
                for (i = 0; i < slices; i++) for (j = 0; j < stacks; j++) indices[indiceIndex++] = (i + 1) * (stacks + 1) + j, indices[indiceIndex++] = i * (stacks + 1) + j, indices[indiceIndex++] = (i + 1) * (stacks + 1) + j + 1, indices[indiceIndex++] = i * (stacks + 1) + j, indices[indiceIndex++] = i * (stacks + 1) + j + 1, indices[indiceIndex++] = (i + 1) * (stacks + 1) + j + 1;
                return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices)
            }

            static createQuad(long = 1, width = 1) {
                var vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV"),
                    halfLong = (vertexDeclaration.vertexStride, long / 2), halfWidth = width / 2,
                    vertices = new Float32Array([halfLong, halfWidth, 0, 0, 0, 1, 0, 0, halfLong, halfWidth, 0, 0, 0, 1, 1, 0, -halfLong, -halfWidth, 0, 0, 0, 1, 0, 1, halfLong, -halfWidth, 0, 0, 0, 1, 1, 1]),
                    indices = new Uint16Array([0, 1, 2, 3, 2, 1]);
                return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices)
            }

            static createSphere(radius = .5, stacks = 32, slices = 32) {
                var vertexCount = (stacks + 1) * (slices + 1), indexCount = 3 * stacks * (slices + 1) * 2,
                    indices = new Uint16Array(indexCount),
                    vertexDeclaration = VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV"),
                    vertexFloatStride = vertexDeclaration.vertexStride / 4,
                    vertices = new Float32Array(vertexCount * vertexFloatStride), stackAngle = Math.PI / stacks,
                    sliceAngle = 2 * Math.PI / slices, vertexIndex = 0;
                vertexCount = 0, indexCount = 0;
                for (var stack = 0; stack < stacks + 1; stack++) for (var r = Math.sin(stack * stackAngle), y = Math.cos(stack * stackAngle), slice = 0; slice < slices + 1; slice++) {
                    var x = r * Math.sin(slice * sliceAngle + 1 * Math.PI / 2),
                        z = r * Math.cos(slice * sliceAngle + 1 * Math.PI / 2);
                    vertices[vertexCount + 0] = x * radius, vertices[vertexCount + 1] = y * radius, vertices[vertexCount + 2] = z * radius, vertices[vertexCount + 3] = x, vertices[vertexCount + 4] = y, vertices[vertexCount + 5] = z, vertices[vertexCount + 6] = slice / slices, vertices[vertexCount + 7] = stack / stacks, vertexCount += vertexFloatStride, stack != stacks - 1 && (indices[indexCount++] = vertexIndex + (slices + 1), indices[indexCount++] = vertexIndex, indices[indexCount++] = vertexIndex + 1, indices[indexCount++] = vertexIndex + slices, indices[indexCount++] = vertexIndex, indices[indexCount++] = vertexIndex + (slices + 1), vertexIndex++)
                }
                return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices)
            }
        }

        class VertexPositionTerrain {
            constructor(position, normal, textureCoord0, textureCoord1) {
                this._position = position, this._normal = normal, this._textureCoord0 = textureCoord0, this._textureCoord1 = textureCoord1
            }

            static __init__() {
                VertexPositionTerrain._vertexDeclaration = new VertexDeclaration(40, [new VertexElement(0, VertexElementFormat.Vector3, VertexPositionTerrain.TERRAIN_POSITION0), new VertexElement(12, VertexElementFormat.Vector3, VertexPositionTerrain.TERRAIN_NORMAL0), new VertexElement(24, VertexElementFormat.Vector2, VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE0), new VertexElement(32, VertexElementFormat.Vector2, VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE1)])
            }

            static get vertexDeclaration() {
                return VertexPositionTerrain._vertexDeclaration
            }

            get position() {
                return this._position
            }

            get normal() {
                return this._normal
            }

            get textureCoord0() {
                return this._textureCoord0
            }

            get textureCoord1() {
                return this._textureCoord1
            }

            get vertexDeclaration() {
                return VertexPositionTerrain._vertexDeclaration
            }
        }

        VertexPositionTerrain.TERRAIN_POSITION0 = 0, VertexPositionTerrain.TERRAIN_NORMAL0 = 1, VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE0 = 2, VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE1 = 3;

        class Laya3D {
            constructor() {
            }

            static get enbalePhysics() {
                return Physics3D._enbalePhysics
            }

            static _cancelLoadByUrl(url) {
                Laya.Laya.loader.cancelLoadByUrl(url), Laya3D._innerFirstLevelLoaderManager.cancelLoadByUrl(url), Laya3D._innerSecondLevelLoaderManager.cancelLoadByUrl(url), Laya3D._innerThirdLevelLoaderManager.cancelLoadByUrl(url), Laya3D._innerFourthLevelLoaderManager.cancelLoadByUrl(url)
            }

            static _changeWebGLSize(width, height) {
                Laya.WebGL.onStageResize(width, height), RenderContext3D.clientWidth = width, RenderContext3D.clientHeight = height
            }

            static __init__(width, height, config) {
                if (Laya.Config.isAntialias = config.isAntialias, Laya.Config.isAlpha = config.isAlpha, Laya.Config.premultipliedAlpha = config.premultipliedAlpha, Laya.Config.isStencil = config.isStencil, Laya.WebGL.enable()) {
                    Laya.RunDriver.changeWebGLSize = Laya3D._changeWebGLSize, Laya.Render.is3DMode = !0, Laya.Laya.init(width, height), Laya.Render.supportWebGLPlusRendering || (Laya.LayaGL.instance = Laya.WebGLContext.mainContext, Laya.LayaGL.instance.createCommandEncoder = function (reserveSize = 128, adjustSize = 64, isSyncToRenderThread = !1) {
                        return new Laya.CommandEncoder(this, reserveSize, adjustSize, isSyncToRenderThread)
                    }), ILaya3D.Scene3D = Scene3D, ILaya3D.MeshRenderStaticBatchManager = MeshRenderStaticBatchManager, ILaya3D.MeshRenderDynamicBatchManager = MeshRenderDynamicBatchManager, ILaya3D.SubMeshDynamicBatch = SubMeshDynamicBatch, ILaya3D.Laya3D = Laya3D, ILaya3D.Matrix4x4 = Matrix4x4, Laya3D.enableNative3D(), VertexElementFormat.__init__(), VertexMesh.__init__(), VertexShurikenParticleBillboard.__init__(), VertexShurikenParticleMesh.__init__(), VertexPositionTexture0.__init__(), VertexTrail.__init__(), VertexPositionTerrain.__init__(), PixelLineVertex.__init__(), SubMeshInstanceBatch.__init__(), SubMeshDynamicBatch.__init__(), Physics3D._physics3D = window.Physics3D, Physics3D._physics3D && (StaticPlaneColliderShape.__init__(), ColliderShape.__init__(), CompoundColliderShape.__init__(), PhysicsComponent.__init__(), PhysicsSimulation.__init__(), BoxColliderShape.__init__(), CylinderColliderShape.__init__(), CharacterController.__init__(), Rigidbody3D.__init__()), Mesh.__init__(), PrimitiveMesh.__init__(), Sprite3D.__init__(), RenderableSprite3D.__init__(), MeshSprite3D.__init__(), SkinnedMeshSprite3D.__init__(), ShuriKenParticle3D.__init__(), TrailSprite3D.__init__(), PostProcess.__init__(), Scene3D.__init__(), MeshRenderStaticBatchManager.__init__(), BaseMaterial.__initDefine__(), BlinnPhongMaterial.__initDefine__(), PBRStandardMaterial.__initDefine__(), PBRSpecularMaterial.__initDefine__(), SkyProceduralMaterial.__initDefine__(), UnlitMaterial.__initDefine__(), TrailMaterial.__initDefine__(), EffectMaterial.__initDefine__(), WaterPrimaryMaterial.__initDefine__(), ShurikenParticleMaterial.__initDefine__(), ExtendTerrainMaterial.__initDefine__(), PixelLineMaterial.__initDefine__(), SkyBoxMaterial.__initDefine__(), ShaderInit3D.__init__(), Command.__init__(), Laya.ClassUtils.regClass("Laya.EffectMaterial", EffectMaterial), Laya.ClassUtils.regClass("Laya.UnlitMaterial", UnlitMaterial), Laya.ClassUtils.regClass("Laya.BlinnPhongMaterial", BlinnPhongMaterial), Laya.ClassUtils.regClass("Laya.SkyProceduralMaterial", SkyProceduralMaterial), Laya.ClassUtils.regClass("Laya.PBRStandardMaterial", PBRStandardMaterial), Laya.ClassUtils.regClass("Laya.PBRSpecularMaterial", PBRSpecularMaterial), Laya.ClassUtils.regClass("Laya.SkyBoxMaterial", SkyBoxMaterial), Laya.ClassUtils.regClass("Laya.WaterPrimaryMaterial", WaterPrimaryMaterial), Laya.ClassUtils.regClass("Laya.ExtendTerrainMaterial", ExtendTerrainMaterial), Laya.ClassUtils.regClass("Laya.ShurikenParticleMaterial", ShurikenParticleMaterial), Laya.ClassUtils.regClass("Laya.TrailMaterial", TrailMaterial), Laya.ClassUtils.regClass("Laya.PhysicsCollider", PhysicsCollider), Laya.ClassUtils.regClass("Laya.Rigidbody3D", Rigidbody3D), Laya.ClassUtils.regClass("Laya.CharacterController", CharacterController), Laya.ClassUtils.regClass("Laya.Animator", Animator), Laya.ClassUtils.regClass("PhysicsCollider", PhysicsCollider), Laya.ClassUtils.regClass("CharacterController", CharacterController), Laya.ClassUtils.regClass("Animator", Animator), Laya.ClassUtils.regClass("Rigidbody3D", Rigidbody3D), PixelLineMaterial.defaultMaterial = new PixelLineMaterial, BlinnPhongMaterial.defaultMaterial = new BlinnPhongMaterial, EffectMaterial.defaultMaterial = new EffectMaterial, PBRStandardMaterial.defaultMaterial = new PBRStandardMaterial, PBRSpecularMaterial.defaultMaterial = new PBRSpecularMaterial, UnlitMaterial.defaultMaterial = new UnlitMaterial, ShurikenParticleMaterial.defaultMaterial = new ShurikenParticleMaterial, TrailMaterial.defaultMaterial = new TrailMaterial, SkyProceduralMaterial.defaultMaterial = new SkyProceduralMaterial, SkyBoxMaterial.defaultMaterial = new SkyBoxMaterial, WaterPrimaryMaterial.defaultMaterial = new WaterPrimaryMaterial, PixelLineMaterial.defaultMaterial.lock = !0, BlinnPhongMaterial.defaultMaterial.lock = !0, EffectMaterial.defaultMaterial.lock = !0, PBRStandardMaterial.defaultMaterial.lock = !0, PBRSpecularMaterial.defaultMaterial.lock = !0, UnlitMaterial.defaultMaterial.lock = !0, ShurikenParticleMaterial.defaultMaterial.lock = !0, TrailMaterial.defaultMaterial.lock = !0, SkyProceduralMaterial.defaultMaterial.lock = !0, SkyBoxMaterial.defaultMaterial.lock = !0, WaterPrimaryMaterial.defaultMaterial.lock = !0, Laya.Texture2D.__init__(), TextureCube.__init__(), SkyBox.__init__(), SkyDome.__init__(), ScreenQuad.__init__(), ScreenTriangle.__init__(), FrustumCulling.__init__(), HalfFloatUtils.__init__();
                    var createMap = Laya.LoaderManager.createMap;
                    createMap.lh = [Laya3D.HIERARCHY, Scene3DUtils._parse], createMap.ls = [Laya3D.HIERARCHY, Scene3DUtils._parseScene], createMap.lm = [Laya3D.MESH, Mesh._parse], createMap.lmat = [Laya3D.MATERIAL, BaseMaterial._parse], createMap.ltc = [Laya3D.TEXTURECUBE, TextureCube._parse], createMap.jpg = [Laya3D.TEXTURE2D, Laya.Texture2D._parse], createMap.jpeg = [Laya3D.TEXTURE2D, Laya.Texture2D._parse], createMap.bmp = [Laya3D.TEXTURE2D, Laya.Texture2D._parse], createMap.gif = [Laya3D.TEXTURE2D, Laya.Texture2D._parse], createMap.png = [Laya3D.TEXTURE2D, Laya.Texture2D._parse], createMap.dds = [Laya3D.TEXTURE2D, Laya.Texture2D._parse], createMap.ktx = [Laya3D.TEXTURE2D, Laya.Texture2D._parse], createMap.pvr = [Laya3D.TEXTURE2D, Laya.Texture2D._parse], createMap.lani = [Laya3D.ANIMATIONCLIP, AnimationClip._parse], createMap.lav = [Laya3D.AVATAR, Avatar._parse];
                    var parserMap = Laya.Loader.parserMap;
                    parserMap[Laya3D.HIERARCHY] = Laya3D._loadHierarchy, parserMap[Laya3D.MESH] = Laya3D._loadMesh, parserMap[Laya3D.MATERIAL] = Laya3D._loadMaterial, parserMap[Laya3D.TEXTURECUBE] = Laya3D._loadTextureCube, parserMap[Laya3D.TEXTURE2D] = Laya3D._loadTexture2D, parserMap[Laya3D.ANIMATIONCLIP] = Laya3D._loadAnimationClip, parserMap[Laya3D.AVATAR] = Laya3D._loadAvatar, Laya3D._innerFirstLevelLoaderManager.on(Laya.Event.ERROR, null, Laya3D._eventLoadManagerError), Laya3D._innerSecondLevelLoaderManager.on(Laya.Event.ERROR, null, Laya3D._eventLoadManagerError), Laya3D._innerThirdLevelLoaderManager.on(Laya.Event.ERROR, null, Laya3D._eventLoadManagerError), Laya3D._innerFourthLevelLoaderManager.on(Laya.Event.ERROR, null, Laya3D._eventLoadManagerError)
                } else alert("Laya3D init error,must support webGL!")
            }

            static enableNative3D() {
                if (Laya.Render.isConchApp) {
                    var shaderData = ShaderData, shader3D = ShaderInstance, skinnedMeshRender = SkinnedMeshRenderer,
                        avatar = Avatar, frustumCulling = FrustumCulling;
                    if (Laya.Render.supportWebGLPlusRendering && (shaderData.prototype._initData = shaderData.prototype._initDataForNative, shaderData.prototype.setBool = shaderData.prototype.setBoolForNative, shaderData.prototype.getBool = shaderData.prototype.getBoolForNative, shaderData.prototype.setInt = shaderData.prototype.setIntForNative, shaderData.prototype.getInt = shaderData.prototype.getIntForNative, shaderData.prototype.setNumber = shaderData.prototype.setNumberForNative, shaderData.prototype.getNumber = shaderData.prototype.getNumberForNative, shaderData.prototype.setVector = shaderData.prototype.setVectorForNative, shaderData.prototype.getVector = shaderData.prototype.getVectorForNative, shaderData.prototype.setVector2 = shaderData.prototype.setVector2ForNative, shaderData.prototype.getVector2 = shaderData.prototype.getVector2ForNative, shaderData.prototype.setVector3 = shaderData.prototype.setVector3ForNative, shaderData.prototype.getVector3 = shaderData.prototype.getVector3ForNative, shaderData.prototype.setQuaternion = shaderData.prototype.setQuaternionForNative, shaderData.prototype.getQuaternion = shaderData.prototype.getQuaternionForNative, shaderData.prototype.setMatrix4x4 = shaderData.prototype.setMatrix4x4ForNative, shaderData.prototype.getMatrix4x4 = shaderData.prototype.getMatrix4x4ForNative, shaderData.prototype.setBuffer = shaderData.prototype.setBufferForNative, shaderData.prototype.getBuffer = shaderData.prototype.getBufferForNative, shaderData.prototype.setTexture = shaderData.prototype.setTextureForNative, shaderData.prototype.getTexture = shaderData.prototype.getTextureForNative, shaderData.prototype.setAttribute = shaderData.prototype.setAttributeForNative, shaderData.prototype.getAttribute = shaderData.prototype.getAttributeForNative, shaderData.prototype.cloneTo = shaderData.prototype.cloneToForNative, shaderData.prototype.getData = shaderData.prototype.getDataForNative, shader3D.prototype._uniformMatrix2fv = shader3D.prototype._uniformMatrix2fvForNative, shader3D.prototype._uniformMatrix3fv = shader3D.prototype._uniformMatrix3fvForNative, shader3D.prototype._uniformMatrix4fv = shader3D.prototype._uniformMatrix4fvForNative), Laya.Render.supportWebGLPlusCulling && (frustumCulling.renderObjectCulling = FrustumCulling.renderObjectCullingNative), Laya.Render.supportWebGLPlusAnimation) {
                        avatar.prototype._cloneDatasToAnimator = avatar.prototype._cloneDatasToAnimatorNative;
                        var animationClip = AnimationClip;
                        animationClip.prototype._evaluateClipDatasRealTime = animationClip.prototype._evaluateClipDatasRealTimeForNative, skinnedMeshRender.prototype._computeSkinnedData = skinnedMeshRender.prototype._computeSkinnedDataForNative
                    }
                }
                Laya.WebGL.shaderHighPrecision = !1;
                var gl = Laya.LayaGL.instance;
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision ? Laya.WebGL.shaderHighPrecision = !0 : Laya.WebGL.shaderHighPrecision = !1
            }

            static formatRelativePath(base, value) {
                var path;
                if (path = base + value, "." === value.charAt(0)) {
                    for (var parts = path.split("/"), i = 0, len = parts.length; i < len; i++) if (".." == parts[i]) {
                        var index = i - 1;
                        index > 0 && ".." !== parts[index] && (parts.splice(index, 2), i -= 2)
                    }
                    path = parts.join("/")
                }
                return path
            }

            static _endLoad(loader, content = null, subResous = null) {
                if (subResous) for (var i = 0, n = subResous.length; i < n; i++) {
                    var resou = Laya.Loader.getRes(subResous[i]);
                    resou && resou._removeReference()
                }
                loader.endLoad(content)
            }

            static _eventLoadManagerError(msg) {
                Laya.Laya.loader.event(Laya.Event.ERROR, msg)
            }

            static _addHierarchyInnerUrls(urls, urlMap, urlVersion, hierarchyBasePath, path, type, constructParams = null, propertyParams = null) {
                var formatUrl = Laya3D.formatRelativePath(hierarchyBasePath, path);
                return urlVersion && (formatUrl += urlVersion), urls.push({
                    url: formatUrl,
                    type: type,
                    constructParams: constructParams,
                    propertyParams: propertyParams
                }), urlMap.push(formatUrl), formatUrl
            }

            static _getSprite3DHierarchyInnerUrls(node, firstLevelUrls, secondLevelUrls, thirdLevelUrls, fourthLelUrls, subUrls, urlVersion, hierarchyBasePath) {
                var i, n, props = node.props;
                switch (node.type) {
                    case"Scene3D":
                        var lightmaps = props.lightmaps;
                        for (i = 0, n = lightmaps.length; i < n; i++) {
                            var lightMap = lightmaps[i];
                            lightMap.path = Laya3D._addHierarchyInnerUrls(fourthLelUrls, subUrls, urlVersion, hierarchyBasePath, lightMap.path, Laya3D.TEXTURE2D, lightMap.constructParams, lightMap.propertyParams)
                        }
                        var reflectionTextureData = props.reflectionTexture;
                        if (reflectionTextureData && (props.reflectionTexture = Laya3D._addHierarchyInnerUrls(thirdLevelUrls, subUrls, urlVersion, hierarchyBasePath, reflectionTextureData, Laya3D.TEXTURECUBE)), props.sky) {
                            var skyboxMaterial = props.sky.material;
                            skyboxMaterial && (skyboxMaterial.path = Laya3D._addHierarchyInnerUrls(secondLevelUrls, subUrls, urlVersion, hierarchyBasePath, skyboxMaterial.path, Laya3D.MATERIAL))
                        }
                        break;
                    case"Camera":
                        var skyboxMatData = props.skyboxMaterial;
                        skyboxMatData && (skyboxMatData.path = Laya3D._addHierarchyInnerUrls(secondLevelUrls, subUrls, urlVersion, hierarchyBasePath, skyboxMatData.path, Laya3D.MATERIAL));
                        break;
                    case"TrailSprite3D":
                    case"MeshSprite3D":
                    case"SkinnedMeshSprite3D":
                        var meshPath = props.meshPath;
                        meshPath && (props.meshPath = Laya3D._addHierarchyInnerUrls(firstLevelUrls, subUrls, urlVersion, hierarchyBasePath, meshPath, Laya3D.MESH));
                        var materials = props.materials;
                        if (materials) for (i = 0, n = materials.length; i < n; i++) materials[i].path = Laya3D._addHierarchyInnerUrls(secondLevelUrls, subUrls, urlVersion, hierarchyBasePath, materials[i].path, Laya3D.MATERIAL);
                        break;
                    case"ShuriKenParticle3D":
                        var parMeshPath = props.meshPath;
                        parMeshPath && (props.meshPath = Laya3D._addHierarchyInnerUrls(firstLevelUrls, subUrls, urlVersion, hierarchyBasePath, parMeshPath, Laya3D.MESH)), props.material.path = Laya3D._addHierarchyInnerUrls(secondLevelUrls, subUrls, urlVersion, hierarchyBasePath, props.material.path, Laya3D.MATERIAL);
                        break;
                    case"Terrain":
                        Laya3D._addHierarchyInnerUrls(fourthLelUrls, subUrls, urlVersion, hierarchyBasePath, props.dataPath, Laya3D.TERRAINRES)
                }
                var components = node.components;
                if (components) for (var k = 0, p = components.length; k < p; k++) {
                    var component = components[k];
                    switch (component.type) {
                        case"Animator":
                            component.avatarPath;
                            var avatarData = component.avatar;
                            avatarData && (avatarData.path = Laya3D._addHierarchyInnerUrls(fourthLelUrls, subUrls, urlVersion, hierarchyBasePath, avatarData.path, Laya3D.AVATAR));
                            var clipPaths = component.clipPaths;
                            if (clipPaths) for (i = 0, n = clipPaths.length; i < n; i++) clipPaths[i] = Laya3D._addHierarchyInnerUrls(fourthLelUrls, subUrls, urlVersion, hierarchyBasePath, clipPaths[i], Laya3D.ANIMATIONCLIP); else {
                                var layersData = component.layers;
                                for (i = 0; i < layersData.length; i++) for (var states = layersData[i].states, j = 0, m = states.length; j < m; j++) {
                                    var clipPath = states[j].clipPath;
                                    clipPath && (states[j].clipPath = Laya3D._addHierarchyInnerUrls(fourthLelUrls, subUrls, urlVersion, hierarchyBasePath, clipPath, Laya3D.ANIMATIONCLIP))
                                }
                            }
                            break;
                        case"PhysicsCollider":
                        case"Rigidbody3D":
                        case"CharacterController":
                            var shapes = component.shapes;
                            for (i = 0; i < shapes.length; i++) {
                                var shape = shapes[i];
                                if ("MeshColliderShape" === shape.type) {
                                    var mesh = shape.mesh;
                                    mesh && (shape.mesh = Laya3D._addHierarchyInnerUrls(firstLevelUrls, subUrls, urlVersion, hierarchyBasePath, mesh, Laya3D.MESH))
                                }
                            }
                    }
                }
                var children = node.child;
                for (i = 0, n = children.length; i < n; i++) Laya3D._getSprite3DHierarchyInnerUrls(children[i], firstLevelUrls, secondLevelUrls, thirdLevelUrls, fourthLelUrls, subUrls, urlVersion, hierarchyBasePath)
            }

            static _loadHierarchy(loader) {
                loader.on(Laya.Event.LOADED, null, Laya3D._onHierarchylhLoaded, [loader]), loader.load(loader.url, Laya.Loader.JSON, !1, null, !0)
            }

            static _onHierarchylhLoaded(loader, lhData) {
                var url = loader.url, urlVersion = Utils3D.getURLVerion(url), hierarchyBasePath = Laya.URL.getPath(url),
                    firstLevUrls = [], secondLevUrls = [], thirdLevUrls = [], forthLevUrls = [], subUrls = [];
                Laya3D._getSprite3DHierarchyInnerUrls(lhData.data, firstLevUrls, secondLevUrls, thirdLevUrls, forthLevUrls, subUrls, urlVersion, hierarchyBasePath);
                var urlCount = firstLevUrls.length + secondLevUrls.length + forthLevUrls.length,
                    totalProcessCount = urlCount + 1, weight = 1 / totalProcessCount;
                if (Laya3D._onProcessChange(loader, 0, weight, 1), forthLevUrls.length > 0) {
                    var processCeil = urlCount / totalProcessCount,
                        processHandler = Laya.Handler.create(null, Laya3D._onProcessChange, [loader, weight, processCeil], !1);
                    Laya3D._innerFourthLevelLoaderManager._create(forthLevUrls, !1, Laya.Handler.create(null, Laya3D._onHierarchyInnerForthLevResouLoaded, [loader, processHandler, lhData, subUrls, firstLevUrls, secondLevUrls, thirdLevUrls, weight + processCeil * forthLevUrls.length, processCeil]), processHandler, null, null, null, 1, !0)
                } else Laya3D._onHierarchyInnerForthLevResouLoaded(loader, null, lhData, subUrls, firstLevUrls, secondLevUrls, thirdLevUrls, weight, processCeil)
            }

            static _onHierarchyInnerForthLevResouLoaded(loader, processHandler, lhData, subUrls, firstLevUrls, secondLevUrls, thirdLevUrls, processOffset, processCeil) {
                if (processHandler && processHandler.recover(), thirdLevUrls.length > 0) {
                    var process = Laya.Handler.create(null, Laya3D._onProcessChange, [loader, processOffset, processCeil], !1);
                    Laya3D._innerThirdLevelLoaderManager._create(thirdLevUrls, !1, Laya.Handler.create(null, Laya3D._onHierarchyInnerThirdLevResouLoaded, [loader, process, lhData, subUrls, firstLevUrls, secondLevUrls, processOffset + processCeil * secondLevUrls.length, processCeil]), processHandler, null, null, null, 1, !0)
                } else Laya3D._onHierarchyInnerThirdLevResouLoaded(loader, null, lhData, subUrls, firstLevUrls, secondLevUrls, processOffset, processCeil)
            }

            static _onHierarchyInnerThirdLevResouLoaded(loader, processHandler, lhData, subUrls, firstLevUrls, secondLevUrls, processOffset, processCeil) {
                if (processHandler && processHandler.recover(), secondLevUrls.length > 0) {
                    var process = Laya.Handler.create(null, Laya3D._onProcessChange, [loader, processOffset, processCeil], !1);
                    Laya3D._innerSecondLevelLoaderManager._create(secondLevUrls, !1, Laya.Handler.create(null, Laya3D._onHierarchyInnerSecondLevResouLoaded, [loader, process, lhData, subUrls, firstLevUrls, processOffset + processCeil * secondLevUrls.length, processCeil]), processHandler, null, null, null, 1, !0)
                } else Laya3D._onHierarchyInnerSecondLevResouLoaded(loader, null, lhData, subUrls, firstLevUrls, processOffset, processCeil)
            }

            static _onHierarchyInnerSecondLevResouLoaded(loader, processHandler, lhData, subUrls, firstLevUrls, processOffset, processCeil) {
                if (processHandler && processHandler.recover(), firstLevUrls.length > 0) {
                    var process = Laya.Handler.create(null, Laya3D._onProcessChange, [loader, processOffset, processCeil], !1);
                    Laya3D._innerFirstLevelLoaderManager._create(firstLevUrls, !1, Laya.Handler.create(null, Laya3D._onHierarchyInnerFirstLevResouLoaded, [loader, process, lhData, subUrls]), processHandler, null, null, null, 1, !0)
                } else Laya3D._onHierarchyInnerFirstLevResouLoaded(loader, null, lhData, subUrls)
            }

            static _onHierarchyInnerFirstLevResouLoaded(loader, processHandler, lhData, subUrls) {
                processHandler && processHandler.recover(), loader._cache = loader._createCache;
                var item = "Scene3D" === lhData.data.type ? Scene3DUtils._parseScene(lhData, loader._propertyParams, loader._constructParams) : Scene3DUtils._parse(lhData, loader._propertyParams, loader._constructParams);
                Laya3D._endLoad(loader, item, subUrls)
            }

            static _loadMesh(loader) {
                loader.on(Laya.Event.LOADED, null, Laya3D._onMeshLmLoaded, [loader]), loader.load(loader.url, Laya.Loader.BUFFER, !1, null, !0)
            }

            static _onMeshLmLoaded(loader, lmData) {
                loader._cache = loader._createCache;
                var mesh = Mesh._parse(lmData, loader._propertyParams, loader._constructParams);
                Laya3D._endLoad(loader, mesh)
            }

            static _loadMaterial(loader) {
                loader.on(Laya.Event.LOADED, null, Laya3D._onMaterilLmatLoaded, [loader]), loader.load(loader.url, Laya.Loader.JSON, !1, null, !0)
            }

            static _onMaterilLmatLoaded(loader, lmatData) {
                var formatSubUrl, url = loader.url, urlVersion = Utils3D.getURLVerion(url),
                    materialBasePath = Laya.URL.getPath(url), urls = [], subUrls = [];
                lmatData.customProps;
                switch (lmatData.version) {
                    case"LAYAMATERIAL:01":
                    case"LAYAMATERIAL:02":
                        var i, n, textures = lmatData.props.textures;
                        if (textures) for (i = 0, n = textures.length; i < n; i++) {
                            var tex2D = textures[i], tex2DPath = tex2D.path;
                            tex2DPath && (formatSubUrl = Laya3D.formatRelativePath(materialBasePath, tex2DPath), urlVersion && (formatSubUrl += urlVersion), urls.push({
                                url: formatSubUrl,
                                constructParams: tex2D.constructParams,
                                propertyParams: tex2D.propertyParams
                            }), subUrls.push(formatSubUrl), tex2D.path = formatSubUrl)
                        }
                        break;
                    default:
                        throw new Error("Laya3D:unkonwn version.")
                }
                var urlCount = urls.length, totalProcessCount = urlCount + 1, lmatWeight = 1 / totalProcessCount;
                if (Laya3D._onProcessChange(loader, 0, lmatWeight, 1), urlCount > 0) {
                    var processHandler = Laya.Handler.create(null, Laya3D._onProcessChange, [loader, lmatWeight, urlCount / totalProcessCount], !1);
                    Laya3D._innerFourthLevelLoaderManager._create(urls, !1, Laya.Handler.create(null, Laya3D._onMateialTexturesLoaded, [loader, processHandler, lmatData, subUrls]), processHandler, null, null, null, 1, !0)
                } else Laya3D._onMateialTexturesLoaded(loader, null, lmatData, null)
            }

            static _onMateialTexturesLoaded(loader, processHandler, lmatData, subUrls) {
                loader._cache = loader._createCache;
                var mat = BaseMaterial._parse(lmatData, loader._propertyParams, loader._constructParams);
                Laya3D._endLoad(loader, mat, subUrls), processHandler && processHandler.recover()
            }

            static _loadAvatar(loader) {
                loader.on(Laya.Event.LOADED, null, function (data) {
                    loader._cache = loader._createCache;
                    var avatar = Avatar._parse(data, loader._propertyParams, loader._constructParams);
                    Laya3D._endLoad(loader, avatar)
                }), loader.load(loader.url, Laya.Loader.JSON, !1, null, !0)
            }

            static _loadAnimationClip(loader) {
                loader.on(Laya.Event.LOADED, null, function (data) {
                    loader._cache = loader._createCache;
                    var clip = AnimationClip._parse(data, loader._propertyParams, loader._constructParams);
                    Laya3D._endLoad(loader, clip)
                }), loader.load(loader.url, Laya.Loader.BUFFER, !1, null, !0)
            }

            static _loadTexture2D(loader) {
                var type, url = loader.url, index = url.lastIndexOf(".") + 1, verIndex = url.indexOf("?"),
                    endIndex = -1 == verIndex ? url.length : verIndex;
                switch (url.substr(index, endIndex - index)) {
                    case"jpg":
                    case"jpeg":
                    case"bmp":
                    case"gif":
                    case"png":
                        type = "nativeimage";
                        break;
                    case"dds":
                    case"ktx":
                    case"pvr":
                        type = Laya.Loader.BUFFER
                }
                loader.on(Laya.Event.LOADED, null, function (image) {
                    loader._cache = loader._createCache;
                    var tex = Laya.Texture2D._parse(image, loader._propertyParams, loader._constructParams);
                    Laya3D._endLoad(loader, tex)
                }), loader.load(loader.url, type, !1, null, !0)
            }

            static _loadTextureCube(loader) {
                loader.on(Laya.Event.LOADED, null, Laya3D._onTextureCubeLtcLoaded, [loader]), loader.load(loader.url, Laya.Loader.JSON, !1, null, !0)
            }

            static _onTextureCubeLtcLoaded(loader, ltcData) {
                var ltcBasePath = Laya.URL.getPath(loader.url),
                    urls = [Laya3D.formatRelativePath(ltcBasePath, ltcData.front), Laya3D.formatRelativePath(ltcBasePath, ltcData.back), Laya3D.formatRelativePath(ltcBasePath, ltcData.left), Laya3D.formatRelativePath(ltcBasePath, ltcData.right), Laya3D.formatRelativePath(ltcBasePath, ltcData.up), Laya3D.formatRelativePath(ltcBasePath, ltcData.down)];
                Laya3D._onProcessChange(loader, 0, 1 / 7, 1);
                var processHandler = Laya.Handler.create(null, Laya3D._onProcessChange, [loader, 1 / 7, 6 / 7], !1);
                Laya3D._innerFourthLevelLoaderManager.load(urls, Laya.Handler.create(null, Laya3D._onTextureCubeImagesLoaded, [loader, urls, processHandler]), processHandler, "nativeimage")
            }

            static _onTextureCubeImagesLoaded(loader, urls, processHandler) {
                for (var images = new Array(6), i = 0; i < 6; i++) images[i] = Laya.Loader.getRes(urls[i]);
                loader._cache = loader._createCache;
                var tex = TextureCube._parse(images, loader._propertyParams, loader._constructParams);
                for (processHandler.recover(), i = 0; i < 6; i++) Laya.Loader.clearRes(urls[i]);
                Laya3D._endLoad(loader, tex)
            }

            static _onProcessChange(loader, offset, weight, process) {
                (process = offset + process * weight) < 1 && loader.event(Laya.Event.PROGRESS, process)
            }

            static init(width, height, config = null, compolete = null) {
                if (!Laya3D._isInit) {
                    Laya3D._isInit = !0, (config = config || Config3D._default).cloneTo(Laya3D._config), FrustumCulling.debugFrustumCulling = config.debugFrustumCulling, Laya3D._editerEnvironment = Laya3D._config._editerEnvironment, Scene3D.octreeCulling = config.octreeCulling, Scene3D.octreeInitialSize = config.octreeInitialSize, Scene3D.octreeInitialCenter = config.octreeInitialCenter, Scene3D.octreeMinNodeSize = config.octreeMinNodeSize, Scene3D.octreeLooseness = config.octreeLooseness;
                    var physics3D = window.Physics3D;
                    null == physics3D ? (Physics3D._enbalePhysics = !1, Laya3D.__init__(width, height, Laya3D._config), compolete && compolete.run()) : (Physics3D._enbalePhysics = !0, physics3D(1024 * Laya3D._config.defaultPhysicsMemory * 1024).then(function () {
                        Laya3D.__init__(width, height, Laya3D._config), compolete && compolete.run()
                    }))
                }
            }
        }

        Laya3D.HIERARCHY = "HIERARCHY", Laya3D.MESH = "MESH", Laya3D.MATERIAL = "MATERIAL", Laya3D.TEXTURE2D = "TEXTURE2D", Laya3D.TEXTURECUBE = "TEXTURECUBE", Laya3D.ANIMATIONCLIP = "ANIMATIONCLIP", Laya3D.AVATAR = "AVATAR", Laya3D.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA", Laya3D.TERRAINRES = "TERRAIN", Laya3D._innerFirstLevelLoaderManager = new Laya.LoaderManager, Laya3D._innerSecondLevelLoaderManager = new Laya.LoaderManager, Laya3D._innerThirdLevelLoaderManager = new Laya.LoaderManager, Laya3D._innerFourthLevelLoaderManager = new Laya.LoaderManager, Laya3D._isInit = !1, Laya3D._editerEnvironment = !1, Laya3D._config = new Config3D, Laya3D.physicsSettings = new PhysicsSettings, window.Laya3D = Laya3D;

        class Script3D extends Laya.Component {
            constructor() {
                super(...arguments), this._indexInPool = -1
            }

            get isSingleton() {
                return !1
            }

            _checkProcessTriggers() {
                var prototype = Script3D.prototype;
                return this.onTriggerEnter !== prototype.onTriggerEnter || (this.onTriggerStay !== prototype.onTriggerStay || this.onTriggerExit !== prototype.onTriggerExit)
            }

            _checkProcessCollisions() {
                var prototype = Script3D.prototype;
                return this.onCollisionEnter !== prototype.onCollisionEnter || (this.onCollisionStay !== prototype.onCollisionStay || this.onCollisionExit !== prototype.onCollisionExit)
            }

            _onAwake() {
                this.onAwake(), this.onStart !== Script3D.prototype.onStart && Laya.Laya.startTimer.callLater(this, this.onStart)
            }

            _onEnable() {
                this.owner._scene._addScript(this);
                var proto = Script3D.prototype;
                this.onKeyDown !== proto.onKeyDown && Laya.Laya.stage.on(Laya.Event.KEY_DOWN, this, this.onKeyDown), this.onKeyPress !== proto.onKeyPress && Laya.Laya.stage.on(Laya.Event.KEY_PRESS, this, this.onKeyUp), this.onKeyUp !== proto.onKeyUp && Laya.Laya.stage.on(Laya.Event.KEY_UP, this, this.onKeyUp)
            }

            _onDisable() {
                this.owner._scene._removeScript(this), this.owner.offAllCaller(this), Laya.Laya.stage.offAllCaller(this)
            }

            _isScript() {
                return !0
            }

            _onAdded() {
                var sprite = this.owner, scripts = sprite._scripts;
                scripts || (sprite._scripts = scripts = []), scripts.push(this), sprite._needProcessCollisions || (sprite._needProcessCollisions = this._checkProcessCollisions()), sprite._needProcessTriggers || (sprite._needProcessTriggers = this._checkProcessTriggers())
            }

            _onDestroy() {
                var scripts = this.owner._scripts;
                scripts.splice(scripts.indexOf(this), 1);
                var sprite = this.owner;
                sprite._needProcessTriggers = !1;
                for (var i = 0, n = scripts.length; i < n; i++) if (scripts[i]._checkProcessTriggers()) {
                    sprite._needProcessTriggers = !0;
                    break
                }
                for (sprite._needProcessCollisions = !1, i = 0, n = scripts.length; i < n; i++) if (scripts[i]._checkProcessCollisions()) {
                    sprite._needProcessCollisions = !0;
                    break
                }
                this.onDestroy()
            }

            onAwake() {
            }

            onEnable() {
            }

            onStart() {
            }

            onTriggerEnter(other) {
            }

            onTriggerStay(other) {
            }

            onTriggerExit(other) {
            }

            onCollisionEnter(collision) {
            }

            onCollisionStay(collision) {
            }

            onCollisionExit(collision) {
            }

            onMouseDown() {
            }

            onMouseDrag() {
            }

            onMouseClick() {
            }

            onMouseUp() {
            }

            onMouseEnter() {
            }

            onMouseOver() {
            }

            onMouseOut() {
            }

            onKeyDown(e) {
            }

            onKeyPress(e) {
            }

            onKeyUp(e) {
            }

            onUpdate() {
            }

            onLateUpdate() {
            }

            onPreRender() {
            }

            onPostRender() {
            }

            onDisable() {
            }

            onDestroy() {
            }
        }

        class HeightMap {
            constructor(width, height, minHeight, maxHeight) {
                this._datas = [], this._w = width, this._h = height, this._minHeight = minHeight, this._maxHeight = maxHeight
            }

            static creatFromMesh(mesh, width, height, outCellSize) {
                for (var vertices = [], indexs = [], submesheCount = mesh.subMeshCount, i = 0; i < submesheCount; i++) {
                    for (var subMesh = mesh.getSubMesh(i), vertexBuffer = subMesh._vertexBuffer, verts = vertexBuffer.getFloat32Data(), subMeshVertices = [], j = 0; j < verts.length; j += vertexBuffer.vertexDeclaration.vertexStride / 4) {
                        var position = new Vector3(verts[j + 0], verts[j + 1], verts[j + 2]);
                        subMeshVertices.push(position)
                    }
                    vertices.push(subMeshVertices);
                    var ib = subMesh._indexBuffer;
                    indexs.push(ib.getData())
                }
                var bounds = mesh.bounds, minX = bounds.getMin().x, minZ = bounds.getMin().z, maxX = bounds.getMax().x,
                    maxZ = bounds.getMax().z, minY = bounds.getMin().y, maxY = bounds.getMax().y,
                    widthSize = maxX - minX, heightSize = maxZ - minZ,
                    cellWidth = outCellSize.x = widthSize / (width - 1),
                    cellHeight = outCellSize.y = heightSize / (height - 1),
                    heightMap = new HeightMap(width, height, minY, maxY), ray = HeightMap._tempRay,
                    rayDir = ray.direction;
                rayDir.x = 0, rayDir.y = -1, rayDir.z = 0;
                var rayY = maxY + .1;
                ray.origin.y = rayY;
                for (var h = 0; h < height; h++) {
                    var posZ = minZ + h * cellHeight;
                    heightMap._datas[h] = [];
                    for (var w = 0; w < width; w++) {
                        var posX = minX + w * cellWidth, rayOri = ray.origin;
                        rayOri.x = posX, rayOri.z = posZ;
                        var closestIntersection = HeightMap._getPosition(ray, vertices, indexs);
                        heightMap._datas[h][w] = closestIntersection === Number.MAX_VALUE ? NaN : rayY - closestIntersection
                    }
                }
                return heightMap
            }

            static createFromImage(texture, minHeight, maxHeight) {
                for (var textureWidth = texture.width, textureHeight = texture.height, heightMap = new HeightMap(textureWidth, textureHeight, minHeight, maxHeight), compressionRatio = (maxHeight - minHeight) / 254, pixelsInfo = texture.getPixels(), index = 0, h = 0; h < textureHeight; h++) for (var colDatas = heightMap._datas[h] = [], w = 0; w < textureWidth; w++) {
                    var r = pixelsInfo[index++], g = pixelsInfo[index++], b = pixelsInfo[index++],
                        a = pixelsInfo[index++];
                    colDatas[w] = 255 == r && 255 == g && 255 == b && 255 == a ? NaN : (r + g + b) / 3 * compressionRatio + minHeight
                }
                return heightMap
            }

            static _getPosition(ray, vertices, indexs) {
                for (var closestIntersection = Number.MAX_VALUE, i = 0; i < vertices.length; i++) for (var subMeshVertices = vertices[i], subMeshIndexes = indexs[i], j = 0; j < subMeshIndexes.length; j += 3) {
                    var vertex1 = subMeshVertices[subMeshIndexes[j + 0]],
                        vertex2 = subMeshVertices[subMeshIndexes[j + 1]],
                        vertex3 = subMeshVertices[subMeshIndexes[j + 2]],
                        intersection = Picker.rayIntersectsTriangle(ray, vertex1, vertex2, vertex3);
                    !isNaN(intersection) && intersection < closestIntersection && (closestIntersection = intersection)
                }
                return closestIntersection
            }

            get width() {
                return this._w
            }

            get height() {
                return this._h
            }

            get maxHeight() {
                return this._maxHeight
            }

            get minHeight() {
                return this._minHeight
            }

            _inBounds(row, col) {
                return row >= 0 && row < this._h && col >= 0 && col < this._w
            }

            getHeight(row, col) {
                return this._inBounds(row, col) ? this._datas[row][col] : NaN
            }
        }

        HeightMap._tempRay = new Ray(new Vector3, new Vector3);

        class MeshTerrainSprite3D extends MeshSprite3D {
            constructor(mesh, heightMap, name = null) {
                super(mesh, name), this._heightMap = heightMap, this._cellSize = new Vector2
            }

            static createFromMesh(mesh, heightMapWidth, heightMapHeight, name = null) {
                var meshTerrainSprite3D = new MeshTerrainSprite3D(mesh, null, name);
                return meshTerrainSprite3D._initCreateFromMesh(heightMapWidth, heightMapHeight), meshTerrainSprite3D
            }

            static createFromMeshAndHeightMap(mesh, texture, minHeight, maxHeight, name = null) {
                var meshTerrainSprite3D = new MeshTerrainSprite3D(mesh, null, name);
                return meshTerrainSprite3D._initCreateFromMeshHeightMap(texture, minHeight, maxHeight), meshTerrainSprite3D
            }

            get minX() {
                var worldMatE = this.transform.worldMatrix.elements;
                return this._minX * this._getScaleX() + worldMatE[12]
            }

            get minZ() {
                var worldMatE = this.transform.worldMatrix.elements;
                return this._minZ * this._getScaleZ() + worldMatE[14]
            }

            get width() {
                return (this._heightMap.width - 1) * this._cellSize.x * this._getScaleX()
            }

            get depth() {
                return (this._heightMap.height - 1) * this._cellSize.y * this._getScaleZ()
            }

            _disableRotation() {
                var rotation = this.transform.rotation;
                rotation.x = 0, rotation.y = 0, rotation.z = 0, rotation.w = 1, this.transform.rotation = rotation
            }

            _getScaleX() {
                var worldMatE = this.transform.worldMatrix.elements, m11 = worldMatE[0], m12 = worldMatE[1],
                    m13 = worldMatE[2];
                return Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13)
            }

            _getScaleZ() {
                var worldMatE = this.transform.worldMatrix.elements, m31 = worldMatE[8], m32 = worldMatE[9],
                    m33 = worldMatE[10];
                return Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33)
            }

            _initCreateFromMesh(heightMapWidth, heightMapHeight) {
                this._heightMap = HeightMap.creatFromMesh(this.meshFilter.sharedMesh, heightMapWidth, heightMapHeight, this._cellSize);
                var boundingBox = this.meshFilter.sharedMesh.bounds, min = boundingBox.getMin();
                boundingBox.getMax();
                this._minX = min.x, this._minZ = min.z
            }

            _initCreateFromMeshHeightMap(texture, minHeight, maxHeight) {
                var boundingBox = this.meshFilter.sharedMesh.bounds;
                this._heightMap = HeightMap.createFromImage(texture, minHeight, maxHeight), this._computeCellSize(boundingBox);
                var min = boundingBox.getMin();
                boundingBox.getMax();
                this._minX = min.x, this._minZ = min.z
            }

            _computeCellSize(boundingBox) {
                var min = boundingBox.getMin(), max = boundingBox.getMax(), minX = min.x, minZ = min.z,
                    widthSize = max.x - minX, heightSize = max.z - minZ;
                this._cellSize.x = widthSize / (this._heightMap.width - 1), this._cellSize.y = heightSize / (this._heightMap.height - 1)
            }

            _update(state) {
                this._disableRotation()
            }

            getHeight(x, z) {
                MeshTerrainSprite3D._tempVector3.x = x, MeshTerrainSprite3D._tempVector3.y = 0, MeshTerrainSprite3D._tempVector3.z = z, this._disableRotation();
                var worldMat = this.transform.worldMatrix;
                worldMat.invert(MeshTerrainSprite3D._tempMatrix4x4), Vector3.transformCoordinate(MeshTerrainSprite3D._tempVector3, MeshTerrainSprite3D._tempMatrix4x4, MeshTerrainSprite3D._tempVector3), x = MeshTerrainSprite3D._tempVector3.x, z = MeshTerrainSprite3D._tempVector3.z;
                var c = (x - this._minX) / this._cellSize.x, d = (z - this._minZ) / this._cellSize.y,
                    row = Math.floor(d), col = Math.floor(c), s = c - col, t = d - row, worldMatE = worldMat.elements,
                    m21 = worldMatE[4], m22 = worldMatE[5], m23 = worldMatE[6],
                    scaleY = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23), translateY = worldMatE[13],
                    h01 = this._heightMap.getHeight(row, col + 1), h10 = this._heightMap.getHeight(row + 1, col);
                if (isNaN(h01) || isNaN(h10)) return NaN;
                if (s + t <= 1) {
                    var h00 = this._heightMap.getHeight(row, col);
                    return isNaN(h00) ? NaN : (h00 + s * (h01 - h00) + t * (h10 - h00)) * scaleY + translateY
                }
                var h11 = this._heightMap.getHeight(row + 1, col + 1);
                return isNaN(h11) ? NaN : (h11 + (1 - s) * (h10 - h11) + (1 - t) * (h01 - h11)) * scaleY + translateY
            }
        }

        MeshTerrainSprite3D._tempVector3 = new Vector3, MeshTerrainSprite3D._tempMatrix4x4 = new Matrix4x4;

        class GradientDataVector2 {
            constructor() {
                this._currentLength = 0, this._elements = new Float32Array(12)
            }

            get gradientCount() {
                return this._currentLength / 3
            }

            add(key, value) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== key && (key = 1, console.log("GradientDataVector2 warning:the forth key is  be force set to 1.")), this._elements[this._currentLength++] = key, this._elements[this._currentLength++] = value.x, this._elements[this._currentLength++] = value.y) : console.log("GradientDataVector2 warning:data count must lessEqual than 4")
            }

            cloneTo(destObject) {
                var destGradientDataVector2 = destObject;
                destGradientDataVector2._currentLength = this._currentLength;
                for (var destElements = destGradientDataVector2._elements, i = 0, n = this._elements.length; i < n; i++) destElements[i] = this._elements[i]
            }

            clone() {
                var destGradientDataVector2 = new GradientDataVector2;
                return this.cloneTo(destGradientDataVector2), destGradientDataVector2
            }
        }

        class PostProcessEffect {
            constructor() {
            }

            render(context) {
            }
        }

        class BloomEffect extends PostProcessEffect {
            constructor() {
                super(), this._shader = null, this._shaderData = new ShaderData, this._linearColor = new Color, this._bloomTextureTexelSize = new Vector4, this._shaderThreshold = new Vector4, this._shaderParams = new Vector4, this._pyramid = null, this._intensity = 0, this._threshold = 1, this._softKnee = .5, this._diffusion = 7, this._anamorphicRatio = 0, this._dirtIntensity = 0, this._shaderSetting = new Vector4, this._dirtTileOffset = new Vector4, this.clamp = 65472, this.color = new Color(1, 1, 1, 1), this.fastMode = !1, this.dirtTexture = null, this._shader = Shader3D.find("PostProcessBloom"), this._pyramid = new Array(2 * BloomEffect.MAXPYRAMIDSIZE)
            }

            get intensity() {
                return this._intensity
            }

            set intensity(value) {
                this._intensity = Math.max(value, 0)
            }

            get threshold() {
                return this._threshold
            }

            set threshold(value) {
                this._threshold = Math.max(value, 0)
            }

            get softKnee() {
                return this._softKnee
            }

            set softKnee(value) {
                this._softKnee = Math.min(Math.max(value, 0), 1)
            }

            get diffusion() {
                return this._diffusion
            }

            set diffusion(value) {
                this._diffusion = Math.min(Math.max(value, 1), 10)
            }

            get anamorphicRatio() {
                return this._anamorphicRatio
            }

            set anamorphicRatio(value) {
                this._anamorphicRatio = Math.min(Math.max(value, -1), 1)
            }

            get dirtIntensity() {
                return this._dirtIntensity
            }

            set dirtIntensity(value) {
                this._dirtIntensity = Math.max(value, 0)
            }

            render(context) {
                var cmd = context.command, viewport = context.camera.viewport;
                this._shaderData.setTexture(BloomEffect.SHADERVALUE_AUTOEXPOSURETEX, Laya.Texture2D.whiteTexture);
                var logs, ratio = this._anamorphicRatio, rw = ratio < 0 ? -ratio : 0, rh = ratio > 0 ? ratio : 0,
                    tw = Math.floor(viewport.width / (2 - rw)), th = Math.floor(viewport.height / (2 - rh)),
                    s = Math.max(tw, th);
                logs = Math.log2(s) + this._diffusion - 10;
                var logsInt = Math.floor(logs), iterations = Math.min(Math.max(logsInt, 1), BloomEffect.MAXPYRAMIDSIZE),
                    sampleScale = .5 + logs - logsInt;
                this._shaderData.setNumber(BloomEffect.SHADERVALUE_SAMPLESCALE, sampleScale);
                var lthresh = Color.gammaToLinearSpace(this.threshold), knee = lthresh * this._softKnee + 1e-5;
                this._shaderThreshold.setValue(lthresh, lthresh - knee, 2 * knee, .25 / knee), this._shaderData.setVector(BloomEffect.SHADERVALUE_THRESHOLD, this._shaderThreshold);
                var lclamp = Color.gammaToLinearSpace(this.clamp);
                this._shaderParams.setValue(lclamp, 0, 0, 0), this._shaderData.setVector(BloomEffect.SHADERVALUE_PARAMS, this._shaderParams);
                for (var qualityOffset = this.fastMode ? 1 : 0, lastDownTexture = context.source, i = 0; i < iterations; i++) {
                    var downIndex = 2 * i, upIndex = downIndex + 1,
                        subShader = 0 == i ? BloomEffect.SUBSHADER_PREFILTER13 + qualityOffset : BloomEffect.SUBSHADER_DOWNSAMPLE13 + qualityOffset,
                        mipDownTexture = RenderTexture.createFromPool(tw, th, Laya.BaseTexture.FORMAT_R8G8B8, Laya.BaseTexture.FORMAT_DEPTHSTENCIL_NONE, Laya.BaseTexture.FILTERMODE_BILINEAR);
                    if (this._pyramid[downIndex] = mipDownTexture, i !== iterations - 1) {
                        var mipUpTexture = RenderTexture.createFromPool(tw, th, Laya.BaseTexture.FORMAT_R8G8B8, Laya.BaseTexture.FORMAT_DEPTHSTENCIL_NONE, Laya.BaseTexture.FILTERMODE_BILINEAR);
                        this._pyramid[upIndex] = mipUpTexture
                    }
                    cmd.blitScreenTriangle(lastDownTexture, mipDownTexture, this._shader, this._shaderData, subShader), lastDownTexture = mipDownTexture, tw = Math.max(Math.floor(tw / 2), 1), th = Math.max(Math.floor(th / 2), 1)
                }
                var lastUpTexture = this._pyramid[2 * (iterations - 1)];
                for (i = iterations - 2; i >= 0; i--) upIndex = (downIndex = 2 * i) + 1, mipDownTexture = this._pyramid[downIndex], mipUpTexture = this._pyramid[upIndex], cmd.setShaderDataTexture(this._shaderData, BloomEffect.SHADERVALUE_BLOOMTEX, mipDownTexture), cmd.blitScreenTriangle(lastUpTexture, mipUpTexture, this._shader, this._shaderData, BloomEffect.SUBSHADER_UPSAMPLETENT + qualityOffset), lastUpTexture = mipUpTexture;
                var linearColor = this._linearColor;
                this.color.toLinear(linearColor);
                var intensity = Math.pow(2, this._intensity / 10) - 1, shaderSettings = this._shaderSetting;
                this._shaderSetting.setValue(sampleScale, intensity, this._dirtIntensity, iterations);
                var dirtTexture = this.dirtTexture ? this.dirtTexture : Laya.Texture2D.blackTexture,
                    dirtRatio = dirtTexture.width / dirtTexture.height, screenRatio = viewport.width / viewport.height,
                    dirtTileOffset = this._dirtTileOffset;
                dirtRatio > screenRatio ? dirtTileOffset.setValue(screenRatio / dirtRatio, 1, .5 * (1 - dirtTileOffset.x), 0) : dirtRatio < screenRatio && dirtTileOffset.setValue(1, dirtRatio / screenRatio, 0, .5 * (1 - dirtTileOffset.y));
                var compositeShaderData = context.compositeShaderData;
                for (this.fastMode ? compositeShaderData.addDefine(PostProcess.SHADERDEFINE_BLOOM_LOW) : compositeShaderData.addDefine(PostProcess.SHADERDEFINE_BLOOM), this._bloomTextureTexelSize.setValue(1 / lastUpTexture.width, 1 / lastUpTexture.height, lastUpTexture.width, lastUpTexture.height), compositeShaderData.setVector(PostProcess.SHADERVALUE_BLOOM_DIRTTILEOFFSET, dirtTileOffset), compositeShaderData.setVector(PostProcess.SHADERVALUE_BLOOM_SETTINGS, shaderSettings), compositeShaderData.setVector(PostProcess.SHADERVALUE_BLOOM_COLOR, new Vector4(linearColor.r, linearColor.g, linearColor.b, linearColor.a)), compositeShaderData.setTexture(PostProcess.SHADERVALUE_BLOOM_DIRTTEX, dirtTexture), compositeShaderData.setTexture(PostProcess.SHADERVALUE_BLOOMTEX, lastUpTexture), compositeShaderData.setVector(PostProcess.SHADERVALUE_BLOOMTEX_TEXELSIZE, this._bloomTextureTexelSize), i = 0; i < iterations; i++) upIndex = (downIndex = 2 * i) + 1, RenderTexture.recoverToPool(this._pyramid[downIndex]), 0 !== i && i !== iterations - 1 && RenderTexture.recoverToPool(this._pyramid[upIndex]);
                context.deferredReleaseTextures.push(lastUpTexture)
            }
        }

        BloomEffect.SHADERVALUE_MAINTEX = Shader3D.propertyNameToID("u_MainTex"), BloomEffect.SHADERVALUE_AUTOEXPOSURETEX = Shader3D.propertyNameToID("u_AutoExposureTex"), BloomEffect.SHADERVALUE_SAMPLESCALE = Shader3D.propertyNameToID("u_SampleScale"), BloomEffect.SHADERVALUE_THRESHOLD = Shader3D.propertyNameToID("u_Threshold"), BloomEffect.SHADERVALUE_PARAMS = Shader3D.propertyNameToID("u_Params"), BloomEffect.SHADERVALUE_BLOOMTEX = Shader3D.propertyNameToID("u_BloomTex"), BloomEffect.SUBSHADER_PREFILTER13 = 0, BloomEffect.SUBSHADER_PREFILTER4 = 1, BloomEffect.SUBSHADER_DOWNSAMPLE13 = 2, BloomEffect.SUBSHADER_DOWNSAMPLE4 = 3, BloomEffect.SUBSHADER_UPSAMPLETENT = 4, BloomEffect.SUBSHADER_UPSAMPLEBOX = 5, BloomEffect.MAXPYRAMIDSIZE = 16;

        class RandX {
            constructor(seed) {
                if (!(seed instanceof Array) || 4 !== seed.length) throw new Error("Rand:Seed must be an array with 4 numbers");
                this._state0U = 0 | seed[0], this._state0L = 0 | seed[1], this._state1U = 0 | seed[2], this._state1L = 0 | seed[3]
            }

            randomint() {
                var s1U = this._state0U, s1L = this._state0L, s0U = this._state1U, s0L = this._state1L,
                    sumL = (s0L >>> 0) + (s1L >>> 0), resU = s0U + s1U + (sumL / 2 >>> 31) >>> 0, resL = sumL >>> 0;
                this._state0U = s0U, this._state0L = s0L;
                var t1U = 0, t1L = 0;
                t1U = (s1U ^= t1U = s1U << 23 | (-512 & s1L) >>> 9) ^ s0U, t1L = (s1L ^= t1L = s1L << 23) ^ s0L;
                t1U ^= s1U >>> 18, t1L ^= s1L >>> 18 | (262143 & s1U) << 14;
                return t1U ^= s0U >>> 5, t1L ^= s0L >>> 5 | (31 & s0U) << 27, this._state1U = t1U, this._state1L = t1L, [resU, resL]
            }

            random() {
                var t2 = this.randomint(), t2U = t2[0], xU = 1023 << 20 | t2U >>> 12,
                    xL = 0 | (t2[1] >>> 12 | (4095 & t2U) << 20);
                return RandX._CONVERTION_BUFFER.setUint32(0, xU, !1), RandX._CONVERTION_BUFFER.setUint32(4, xL, !1), RandX._CONVERTION_BUFFER.getFloat64(0, !1) - 1
            }
        }

        RandX._CONVERTION_BUFFER = new DataView(new ArrayBuffer(8)), RandX.defaultRand = new RandX([0, Date.now() / 65536, 0, Date.now() % 65536]);

        class Size {
            constructor(width, height) {
                this._width = 0, this._height = 0, this._width = width, this._height = height
            }

            static get fullScreen() {
                return new Size(-1, -1)
            }

            get width() {
                return -1 === this._width ? RenderContext3D.clientWidth : this._width
            }

            get height() {
                return -1 === this._height ? RenderContext3D.clientHeight : this._height
            }
        }

        exports.AnimationClip = AnimationClip, exports.AnimationClipParser03 = AnimationClipParser03, exports.AnimationClipParser04 = AnimationClipParser04, exports.AnimationEvent = AnimationEvent, exports.AnimationNode = AnimationNode, exports.AnimationTransform3D = AnimationTransform3D, exports.Animator = Animator, exports.AnimatorControllerLayer = AnimatorControllerLayer, exports.AnimatorPlayState = AnimatorPlayState, exports.AnimatorState = AnimatorState, exports.AnimatorStateScript = class {
            constructor() {
            }

            onStateEnter() {
            }

            onStateUpdate() {
            }

            onStateExit() {
            }
        }, exports.Avatar = Avatar, exports.BaseCamera = BaseCamera, exports.BaseMaterial = BaseMaterial, exports.BaseRender = BaseRender, exports.BaseShape = BaseShape, exports.BatchMark = BatchMark, exports.BlinnPhongMaterial = BlinnPhongMaterial, exports.BlitScreenQuadCMD = BlitScreenQuadCMD, exports.BloomEffect = BloomEffect, exports.BoundBox = BoundBox, exports.BoundFrustum = BoundFrustum, exports.BoundSphere = BoundSphere, exports.Bounds = Bounds, exports.BoundsOctree = BoundsOctree, exports.BoundsOctreeNode = BoundsOctreeNode, exports.BoxColliderShape = BoxColliderShape, exports.BoxShape = BoxShape, exports.BufferState = BufferState, exports.Burst = Burst, exports.Camera = Camera, exports.CapsuleColliderShape = CapsuleColliderShape, exports.CastShadowList = CastShadowList, exports.CharacterController = CharacterController, exports.CircleShape = CircleShape, exports.ColliderShape = ColliderShape, exports.Collision = Collision, exports.CollisionTool = CollisionTool, exports.CollisionUtils = CollisionUtils, exports.Color = Color, exports.ColorOverLifetime = ColorOverLifetime, exports.Command = Command, exports.CommandBuffer = CommandBuffer, exports.CompoundColliderShape = CompoundColliderShape, exports.ConchQuaternion = ConchQuaternion, exports.ConchVector3 = ConchVector3, exports.ConchVector4 = ConchVector4, exports.ConeColliderShape = ConeColliderShape, exports.ConeShape = ConeShape, exports.Config3D = Config3D, exports.Constraint3D = class {
            constructor() {
            }
        }, exports.ConstraintComponent = class extends Laya.Component {
            constructor() {
                super(), this._feedbackEnabled = !1
            }

            get enabled() {
                return super.enabled
            }

            set enabled(value) {
                this._nativeConstraint.IsEnabled = value, super.enabled = value
            }

            get breakingImpulseThreshold() {
                return this._breakingImpulseThreshold
            }

            set breakingImpulseThreshold(value) {
                this._nativeConstraint.BreakingImpulseThreshold = value, this._breakingImpulseThreshold = value
            }

            get appliedImpulse() {
                return this._feedbackEnabled || (this._nativeConstraint.EnableFeedback(!0), this._feedbackEnabled = !0), this._nativeConstraint.AppliedImpulse
            }

            get connectedBody() {
                return this._connectedBody
            }

            set connectedBody(value) {
                this._connectedBody = value
            }

            _onDestroy() {
                Physics3D._physics3D.destroy(this._nativeConstraint), this._nativeConstraint = null
            }
        }, exports.ContactPoint = ContactPoint, exports.ContainmentType = ContainmentType, exports.CylinderColliderShape = CylinderColliderShape, exports.DefineDatas = DefineDatas, exports.DirectionLight = DirectionLight, exports.DynamicBatchManager = DynamicBatchManager, exports.EffectMaterial = EffectMaterial, exports.Emission = Emission, exports.ExtendTerrainMaterial = ExtendTerrainMaterial, exports.FloatKeyframe = FloatKeyframe, exports.FrameOverTime = FrameOverTime, exports.FrustumCulling = FrustumCulling, exports.GeometryElement = GeometryElement, exports.Gradient = Gradient, exports.GradientAngularVelocity = GradientAngularVelocity, exports.GradientColor = GradientColor, exports.GradientDataInt = GradientDataInt, exports.GradientDataNumber = GradientDataNumber, exports.GradientDataVector2 = GradientDataVector2, exports.GradientMode = GradientMode, exports.GradientSize = GradientSize, exports.GradientVelocity = GradientVelocity, exports.HalfFloatUtils = HalfFloatUtils, exports.HeightMap = HeightMap, exports.HeightfieldColliderShape = class {
            constructor() {
            }
        }, exports.HemisphereShape = HemisphereShape, exports.HitResult = HitResult, exports.ILaya3D = ILaya3D, exports.IndexBuffer3D = IndexBuffer3D, exports.Input3D = Input3D, exports.Keyframe = Keyframe, exports.KeyframeNode = KeyframeNode, exports.KeyframeNodeList = KeyframeNodeList, exports.KeyframeNodeOwner = KeyframeNodeOwner, exports.Laya3D = Laya3D, exports.LightSprite = LightSprite, exports.LoadModelV04 = LoadModelV04, exports.LoadModelV05 = LoadModelV05, exports.MathUtils3D = MathUtils3D, exports.Matrix3x3 = Matrix3x3, exports.Matrix4x4 = Matrix4x4, exports.Mesh = Mesh, exports.MeshColliderShape = MeshColliderShape, exports.MeshFilter = MeshFilter, exports.MeshReader = MeshReader, exports.MeshRenderDynamicBatchManager = MeshRenderDynamicBatchManager, exports.MeshRenderStaticBatchManager = MeshRenderStaticBatchManager, exports.MeshRenderer = MeshRenderer, exports.MeshSprite3D = MeshSprite3D,exports.MeshSprite3DShaderDeclaration = MeshSprite3DShaderDeclaration,exports.MeshTerrainSprite3D = MeshTerrainSprite3D,exports.MouseTouch = MouseTouch,exports.OctreeMotionList = OctreeMotionList,exports.PBRSpecularMaterial = PBRSpecularMaterial,exports.PBRStandardMaterial = PBRStandardMaterial,exports.ParallelSplitShadowMap = ParallelSplitShadowMap,exports.Physics3D = Physics3D,exports.Physics3DUtils = Physics3DUtils,exports.PhysicsCollider = PhysicsCollider,exports.PhysicsComponent = PhysicsComponent,exports.PhysicsSettings = PhysicsSettings,exports.PhysicsSimulation = PhysicsSimulation,exports.PhysicsTriggerComponent = PhysicsTriggerComponent,exports.PhysicsUpdateList = PhysicsUpdateList,exports.Picker = Picker,exports.PixelLineData = class {
            constructor() {
                this.startPosition = new Vector3, this.endPosition = new Vector3, this.startColor = new Color, this.endColor = new Color
            }

            cloneTo(destObject) {
                this.startPosition.cloneTo(destObject.startPosition), this.endPosition.cloneTo(destObject.endPosition), this.startColor.cloneTo(destObject.startColor), this.endColor.cloneTo(destObject.endColor)
            }
        },exports.PixelLineFilter = PixelLineFilter,exports.PixelLineMaterial = PixelLineMaterial,exports.PixelLineRenderer = PixelLineRenderer,exports.PixelLineSprite3D = PixelLineSprite3D,exports.PixelLineVertex = PixelLineVertex,exports.Plane = Plane,exports.Point2PointConstraint = class {
            constructor() {
                this._pivotInA = new Vector3, this._pivotInB = new Vector3
            }

            get pivotInA() {
                return this._pivotInA
            }

            set pivotInA(value) {
                this._pivotInA = value
            }

            get pivotInB() {
                return this._pivotInB
            }

            set pivotInB(value) {
                this._pivotInB = value
            }

            get damping() {
                return this._damping
            }

            set damping(value) {
                this._damping = value
            }

            get impulseClamp() {
                return this._impulseClamp
            }

            set impulseClamp(value) {
                this._impulseClamp = value
            }

            get tau() {
                return this._tau
            }

            set tau(value) {
                this._tau = value
            }
        },exports.PointLight = PointLight,exports.PostProcess = PostProcess,exports.PostProcessEffect = PostProcessEffect,exports.PostProcessRenderContext = PostProcessRenderContext,exports.PrimitiveMesh = PrimitiveMesh,exports.Quaternion = Quaternion,exports.QuaternionKeyframe = QuaternionKeyframe,exports.Rand = Rand,exports.RandX = RandX,exports.Ray = Ray,exports.RenderContext3D = RenderContext3D,exports.RenderElement = RenderElement,exports.RenderQueue = RenderQueue,exports.RenderState = RenderState,exports.RenderTexture = RenderTexture,exports.RenderableSprite3D = RenderableSprite3D,exports.Rigidbody3D = Rigidbody3D,exports.RotationOverLifetime = RotationOverLifetime,exports.Scene3D = Scene3D,exports.Scene3DShaderDeclaration = Scene3DShaderDeclaration,exports.Scene3DUtils = Scene3DUtils,exports.SceneManager = class {
            constructor() {
            }
        },exports.ScreenQuad = ScreenQuad,exports.ScreenTriangle = ScreenTriangle,exports.Script3D = Script3D,exports.SetRenderTargetCMD = SetRenderTargetCMD,exports.SetShaderDataTextureCMD = SetShaderDataTextureCMD,exports.Shader3D = Shader3D,exports.ShaderData = ShaderData,exports.ShaderDefines = ShaderDefines,exports.ShaderInit3D = ShaderInit3D,exports.ShaderInstance = ShaderInstance,exports.ShaderPass = ShaderPass,exports.ShaderVariable = ShaderVariable,exports.ShapeUtils = ShapeUtils,exports.ShuriKenParticle3D = ShuriKenParticle3D,exports.ShuriKenParticle3DShaderDeclaration = ShuriKenParticle3DShaderDeclaration,exports.ShurikenParticleData = ShurikenParticleData,exports.ShurikenParticleMaterial = ShurikenParticleMaterial,exports.ShurikenParticleRenderer = ShurikenParticleRenderer,exports.ShurikenParticleSystem = ShurikenParticleSystem,exports.SimpleSingletonList = SimpleSingletonList,exports.SingletonList = SingletonList,exports.Size = Size,exports.SizeOverLifetime = SizeOverLifetime,exports.SkinnedMeshRenderer = SkinnedMeshRenderer,exports.SkinnedMeshSprite3D = SkinnedMeshSprite3D,exports.SkinnedMeshSprite3DShaderDeclaration = SkinnedMeshSprite3DShaderDeclaration,exports.SkyBox = SkyBox,exports.SkyBoxMaterial = SkyBoxMaterial,exports.SkyDome = SkyDome,exports.SkyMesh = SkyMesh,exports.SkyProceduralMaterial = SkyProceduralMaterial,exports.SkyRenderer = SkyRenderer,exports.SphereColliderShape = SphereColliderShape,exports.SphereShape = SphereShape,exports.SpotLight = SpotLight,exports.Sprite3D = Sprite3D,exports.StartFrame = StartFrame,exports.StaticBatchManager = StaticBatchManager,exports.StaticPlaneColliderShape = StaticPlaneColliderShape,exports.SubMesh = SubMesh,exports.SubMeshDynamicBatch = SubMeshDynamicBatch,exports.SubMeshInstanceBatch = SubMeshInstanceBatch,exports.SubMeshRenderElement = SubMeshRenderElement,exports.SubMeshStaticBatch = SubMeshStaticBatch,exports.SubShader = SubShader,exports.TextMesh = class {
            get text() {
                return this._text
            }

            set text(value) {
                this._text = value
            }

            get fontSize() {
                return this._fontSize
            }

            set fontSize(value) {
                this._fontSize = value
            }

            get color() {
                return this._color
            }

            set color(value) {
                this._color = value
            }

            constructor() {
            }

            _createVertexBuffer(charCount) {
            }

            _resizeVertexBuffer(charCount) {
            }

            _addChar() {
            }
        },exports.TextureCube = TextureCube,exports.TextureGenerator = TextureGenerator,exports.TextureMode = TextureMode,exports.TextureSheetAnimation = TextureSheetAnimation,exports.Touch = Touch,exports.TrailFilter = TrailFilter,exports.TrailGeometry = TrailGeometry,exports.TrailMaterial = TrailMaterial,exports.TrailRenderer = TrailRenderer,exports.TrailSprite3D = TrailSprite3D,exports.Transform3D = Transform3D,exports.UnlitMaterial = UnlitMaterial,exports.Utils3D = Utils3D,exports.Vector2 = Vector2,exports.Vector3 = Vector3,exports.Vector3Keyframe = Vector3Keyframe,exports.Vector4 = Vector4,exports.VelocityOverLifetime = VelocityOverLifetime,exports.VertexBuffer3D = VertexBuffer3D,exports.VertexDeclaration = VertexDeclaration,exports.VertexElement = VertexElement,exports.VertexElementFormat = VertexElementFormat,exports.VertexMesh = VertexMesh,exports.VertexPositionTerrain = VertexPositionTerrain,exports.VertexPositionTexture0 = VertexPositionTexture0,exports.VertexShuriKenParticle = VertexShuriKenParticle,exports.VertexShurikenParticleBillboard = VertexShurikenParticleBillboard,exports.VertexShurikenParticleMesh = VertexShurikenParticleMesh,exports.VertexTrail = VertexTrail,exports.Viewport = Viewport,exports.WaterPrimaryMaterial = WaterPrimaryMaterial
    }(window.Laya = window.Laya || {}, Laya);
});
define("libs/laya.ui.js", function (require, module, exports) {
    !function (exports, Laya) {
        "use strict";

        class UIConfig {
        }

        UIConfig.touchScrollEnable = !0, UIConfig.mouseWheelEnable = !0, UIConfig.showButtons = !0, UIConfig.popupBgColor = "#000000", UIConfig.popupBgAlpha = .5, UIConfig.closeDialogOnSide = !0, window.UIConfig = UIConfig;

        class Styles {
        }

        Styles.defaultSizeGrid = [4, 4, 4, 4, 0], Styles.labelColor = "#000000", Styles.labelPadding = [2, 2, 2, 2], Styles.inputLabelPadding = [1, 1, 1, 3], Styles.buttonStateNum = 3, Styles.buttonLabelColors = ["#32556b", "#32cc6b", "#ff0000", "#C0C0C0"], Styles.comboBoxItemColors = ["#5e95b6", "#ffffff", "#000000", "#8fa4b1", "#ffffff"], Styles.scrollBarMinNum = 15, Styles.scrollBarDelayTime = 500;

        class AutoBitmap extends Laya.Graphics {
            constructor() {
                super(...arguments), this.autoCacheCmd = !0, this._width = 0, this._height = 0, this.uv = null
            }

            destroy() {
                super.destroy(), this._source = null, this._sizeGrid = null, this._offset = null
            }

            get sizeGrid() {
                return this._sizeGrid
            }

            set sizeGrid(value) {
                this._sizeGrid = value.map(v => +v), this._setChanged()
            }

            get width() {
                return this._width ? this._width : this._source ? this._source.sourceWidth : 0
            }

            set width(value) {
                this._width != value && (this._width = value, this._setChanged())
            }

            get height() {
                return this._height ? this._height : this._source ? this._source.sourceHeight : 0
            }

            set height(value) {
                this._height != value && (this._height = value, this._setChanged())
            }

            get source() {
                return this._source
            }

            set source(value) {
                value ? (this._source = value, this._setChanged()) : (this._source = null, this.clear())
            }

            _setChanged() {
                this._isChanged || (this._isChanged = !0, Laya.ILaya.timer.callLater(this, this.changeSource))
            }

            changeSource() {
                this._isChanged = !1;
                var source = this._source;
                if (source && source.bitmap) {
                    var width = this.width, height = this.height, sizeGrid = this._sizeGrid, sw = source.sourceWidth,
                        sh = source.sourceHeight;
                    if (sizeGrid && (sw !== width || sh !== height)) return this.clear(), this.draw9Grid(source, 0, 0, width, height, sizeGrid), void this._repaint();
                    this.clear(), this.drawTexture(source, this._offset ? this._offset[0] : 0, this._offset ? this._offset[1] : 0, width, height, null, 1, null, null, this.uv), this._repaint()
                }
            }

            drawBitmap(repeat, tex, x, y, width = 0, height = 0) {
                width < .1 || height < .1 || (!repeat || tex.width == width && tex.height == height ? this.drawImage(tex, x, y, width, height) : this.fillTexture(tex, x, y, width, height))
            }

            static getTexture(tex, x, y, width, height) {
                var texture;
                return width <= 0 && (width = 1), height <= 0 && (height = 1), tex.$_GID || (tex.$_GID = Laya.Utils.getGID()), texture && texture._getSource() || (texture = Laya.Texture.createFromTexture(tex, x, y, width, height)), texture
            }
        }

        Laya.ClassUtils.regClass("laya.ui.AutoBitmap", AutoBitmap), Laya.ClassUtils.regClass("Laya.AutoBitmap", AutoBitmap);

        class Widget extends Laya.Component {
            constructor() {
                super(...arguments), this._top = NaN, this._bottom = NaN, this._left = NaN, this._right = NaN, this._centerX = NaN, this._centerY = NaN
            }

            onReset() {
                this._top = this._bottom = this._left = this._right = this._centerX = this._centerY = NaN
            }

            _onEnable() {
                this.owner.parent ? this._onAdded() : this.owner.once(Laya.Event.ADDED, this, this._onAdded)
            }

            _onDisable() {
                this.owner.off(Laya.Event.ADDED, this, this._onAdded), this.owner.parent && this.owner.parent.off(Laya.Event.RESIZE, this, this._onParentResize)
            }

            _onAdded() {
                this.owner.parent && this.owner.parent.on(Laya.Event.RESIZE, this, this._onParentResize), this.resetLayoutX(), this.resetLayoutY()
            }

            _onParentResize() {
                (this.resetLayoutX() || this.resetLayoutY()) && this.owner.event(Laya.Event.RESIZE)
            }

            resetLayoutX() {
                var owner = this.owner;
                if (!owner) return !1;
                var parent = owner.parent;
                if (parent) if (isNaN(this.centerX)) {
                    if (isNaN(this.left)) isNaN(this.right) || (owner.x = Math.round(parent.width - owner.displayWidth - this.right + owner.pivotX * owner.scaleX)); else if (owner.x = Math.round(this.left + owner.pivotX * owner.scaleX), !isNaN(this.right)) {
                        var temp = (parent._width - this.left - this.right) / (owner.scaleX || .01);
                        if (temp != owner.width) return owner.width = temp, !0
                    }
                } else owner.x = Math.round(.5 * (parent.width - owner.displayWidth) + this.centerX + owner.pivotX * owner.scaleX);
                return !1
            }

            resetLayoutY() {
                var owner = this.owner;
                if (!owner) return !1;
                var parent = owner.parent;
                if (parent) if (isNaN(this.centerY)) {
                    if (isNaN(this.top)) isNaN(this.bottom) || (owner.y = Math.round(parent.height - owner.displayHeight - this.bottom + owner.pivotY * owner.scaleY)); else if (owner.y = Math.round(this.top + owner.pivotY * owner.scaleY), !isNaN(this.bottom)) {
                        var temp = (parent._height - this.top - this.bottom) / (owner.scaleY || .01);
                        if (temp != owner.height) return owner.height = temp, !0
                    }
                } else owner.y = Math.round(.5 * (parent.height - owner.displayHeight) + this.centerY + owner.pivotY * owner.scaleY);
                return !1
            }

            resetLayout() {
                this.owner && (this.resetLayoutX(), this.resetLayoutY())
            }

            get top() {
                return this._top
            }

            set top(value) {
                this._top != value && (this._top = value, this.resetLayoutY())
            }

            get bottom() {
                return this._bottom
            }

            set bottom(value) {
                this._bottom != value && (this._bottom = value, this.resetLayoutY())
            }

            get left() {
                return this._left
            }

            set left(value) {
                this._left != value && (this._left = value, this.resetLayoutX())
            }

            get right() {
                return this._right
            }

            set right(value) {
                this._right != value && (this._right = value, this.resetLayoutX())
            }

            get centerX() {
                return this._centerX
            }

            set centerX(value) {
                this._centerX != value && (this._centerX = value, this.resetLayoutX())
            }

            get centerY() {
                return this._centerY
            }

            set centerY(value) {
                this._centerY != value && (this._centerY = value, this.resetLayoutY())
            }
        }

        Widget.EMPTY = null, Laya.ILaya.regClass(Widget), Widget.EMPTY = new Widget, Laya.ClassUtils.regClass("laya.ui.Widget", Widget), Laya.ClassUtils.regClass("Laya.Widget", Widget);

        class UIEvent extends Laya.Event {
        }

        UIEvent.SHOW_TIP = "showtip", UIEvent.HIDE_TIP = "hidetip", Laya.ILaya.regClass(UIEvent), Laya.ClassUtils.regClass("laya.ui.UIEvent", UIEvent), Laya.ClassUtils.regClass("Laya.UIEvent", UIEvent);

        class UIUtils {
            static fillArray(arr, str, type = null) {
                var temp = arr.concat();
                if (str) for (var a = str.split(","), i = 0, n = Math.min(temp.length, a.length); i < n; i++) {
                    var value = a[i];
                    temp[i] = "true" == value || "false" != value && value, null != type && (temp[i] = type(value))
                }
                return temp
            }

            static toColor(color) {
                return Laya.Utils.toHexColor(color)
            }

            static gray(traget, isGray = !0) {
                isGray ? UIUtils.addFilter(traget, UIUtils.grayFilter) : UIUtils.clearFilter(traget, Laya.ColorFilter)
            }

            static addFilter(target, filter) {
                var filters = target.filters || [];
                filters.push(filter), target.filters = filters
            }

            static clearFilter(target, filterType) {
                var filters = target.filters;
                if (null != filters && filters.length > 0) {
                    for (var i = filters.length - 1; i > -1; i--) {
                        filters[i] instanceof filterType && filters.splice(i, 1)
                    }
                    target.filters = filters
                }
            }

            static _getReplaceStr(word) {
                return UIUtils.escapeSequence[word]
            }

            static adptString(str) {
                return str.replace(/\\(\w)/g, UIUtils._getReplaceStr)
            }

            static getBindFun(value) {
                UIUtils._funMap || (UIUtils._funMap = new Laya.WeakObject);
                var fun = UIUtils._funMap.get(value);
                if (null == fun) {
                    var temp = '"' + value + '"',
                        str = "(function(data){if(data==null)return;with(data){try{\nreturn " + (temp = temp.replace(/^"\${|}"$/g, "").replace(/\${/g, '"+').replace(/}/g, '+"')) + "\n}catch(e){}}})";
                    fun = window.Laya._runScript(str), UIUtils._funMap.set(value, fun)
                }
                return fun
            }
        }

        UIUtils.grayFilter = new Laya.ColorFilter([.3086, .6094, .082, 0, 0, .3086, .6094, .082, 0, 0, .3086, .6094, .082, 0, 0, 0, 0, 0, 1, 0]), UIUtils.escapeSequence = {
            "\\n": "\n",
            "\\t": "\t"
        }, UIUtils._funMap = null, Laya.ClassUtils.regClass("laya.ui.UIUtils", UIUtils), Laya.ClassUtils.regClass("Laya.UIUtils", UIUtils);

        class UIComponent extends Laya.Sprite {
            constructor(createChildren = !0) {
                super(), this._anchorX = NaN, this._anchorY = NaN, this._widget = Widget.EMPTY, createChildren && (this.preinitialize(), this.createChildren(), this.initialize())
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._dataSource = null, this._tag = null, this._toolTip = null
            }

            preinitialize() {
            }

            createChildren() {
            }

            initialize() {
            }

            get width() {
                return this.get_width()
            }

            get_width() {
                return this._width ? this._width : this.measureWidth()
            }

            measureWidth() {
                var max = 0;
                this.commitMeasure();
                for (var i = this.numChildren - 1; i > -1; i--) {
                    var comp = this.getChildAt(i);
                    comp._visible && (max = Math.max(comp._x + comp.width * comp.scaleX, max))
                }
                return max
            }

            commitMeasure() {
            }

            get height() {
                return this.get_height()
            }

            get_height() {
                return this._height ? this._height : this.measureHeight()
            }

            measureHeight() {
                var max = 0;
                this.commitMeasure();
                for (var i = this.numChildren - 1; i > -1; i--) {
                    var comp = this.getChildAt(i);
                    comp._visible && (max = Math.max(comp._y + comp.height * comp.scaleY, max))
                }
                return max
            }

            get dataSource() {
                return this.get_dataSource()
            }

            get_dataSource() {
                return this._dataSource
            }

            set dataSource(value) {
                this.set_dataSource(value)
            }

            set_dataSource(value) {
                for (var prop in this._dataSource = value, this._dataSource) prop in this && "function" != typeof this[prop] && (this[prop] = this._dataSource[prop])
            }

            get top() {
                return this.get_top()
            }

            get_top() {
                return this._widget.top
            }

            set top(value) {
                this.set_top(value)
            }

            set_top(value) {
                value != this._widget.top && (this._getWidget().top = value)
            }

            get bottom() {
                return this.get_bottom()
            }

            get_bottom() {
                return this._widget.bottom
            }

            set bottom(value) {
                this.set_bottom(value)
            }

            set_bottom(value) {
                value != this._widget.bottom && (this._getWidget().bottom = value)
            }

            get left() {
                return this._widget.left
            }

            set left(value) {
                value != this._widget.left && (this._getWidget().left = value)
            }

            get right() {
                return this._widget.right
            }

            set right(value) {
                value != this._widget.right && (this._getWidget().right = value)
            }

            get centerX() {
                return this._widget.centerX
            }

            set centerX(value) {
                value != this._widget.centerX && (this._getWidget().centerX = value)
            }

            get centerY() {
                return this._widget.centerY
            }

            set centerY(value) {
                value != this._widget.centerY && (this._getWidget().centerY = value)
            }

            _sizeChanged() {
                isNaN(this._anchorX) || (this.pivotX = this.anchorX * this.width), isNaN(this._anchorY) || (this.pivotY = this.anchorY * this.height), this.event(Laya.Event.RESIZE), this._widget !== Widget.EMPTY && this._widget.resetLayout()
            }

            get tag() {
                return this._tag
            }

            set tag(value) {
                this._tag = value
            }

            get toolTip() {
                return this._toolTip
            }

            set toolTip(value) {
                this._toolTip != value && (this._toolTip = value, null != value ? (this.on(Laya.Event.MOUSE_OVER, this, this.onMouseOver), this.on(Laya.Event.MOUSE_OUT, this, this.onMouseOut)) : (this.off(Laya.Event.MOUSE_OVER, this, this.onMouseOver), this.off(Laya.Event.MOUSE_OUT, this, this.onMouseOut)))
            }

            onMouseOver(e) {
                Laya.ILaya.stage.event(UIEvent.SHOW_TIP, this._toolTip)
            }

            onMouseOut(e) {
                Laya.ILaya.stage.event(UIEvent.HIDE_TIP, this._toolTip)
            }

            get gray() {
                return this._gray
            }

            set gray(value) {
                value !== this._gray && (this._gray = value, UIUtils.gray(this, value))
            }

            get disabled() {
                return this._disabled
            }

            set disabled(value) {
                value !== this._disabled && (this.gray = this._disabled = value, this.mouseEnabled = !value)
            }

            _getWidget() {
                return this._widget === Widget.EMPTY && (this._widget = this.addComponent(Widget)), this._widget
            }

            set scaleX(value) {
                this.set_scaleX(value)
            }

            set_scaleX(value) {
                super.get_scaleX() != value && (super.set_scaleX(value), this.event(Laya.Event.RESIZE))
            }

            get scaleX() {
                return super.scaleX
            }

            set scaleY(value) {
                this.set_scaleY(value)
            }

            set_scaleY(value) {
                super.get_scaleY() != value && (super.set_scaleY(value), this.event(Laya.Event.RESIZE))
            }

            get scaleY() {
                return super.scaleY
            }

            onCompResize() {
                this._sizeChanged()
            }

            set width(value) {
                this.set_width(value)
            }

            set_width(value) {
                super.get_width() != value && (super.set_width(value), this.callLater(this._sizeChanged))
            }

            set height(value) {
                this.set_height(value)
            }

            set_height(value) {
                super.get_height() != value && (super.set_height(value), this.callLater(this._sizeChanged))
            }

            get anchorX() {
                return this.get_anchorX()
            }

            get_anchorX() {
                return this._anchorX
            }

            set anchorX(value) {
                this.set_anchorX(value)
            }

            set_anchorX(value) {
                this._anchorX != value && (this._anchorX = value, this.callLater(this._sizeChanged))
            }

            get anchorY() {
                return this.get_anchorY()
            }

            get_anchorY() {
                return this._anchorY
            }

            set anchorY(value) {
                this.set_anchorY(value)
            }

            set_anchorY(value) {
                this._anchorY != value && (this._anchorY = value, this.callLater(this._sizeChanged))
            }

            _childChanged(child = null) {
                this.callLater(this._sizeChanged), super._childChanged(child)
            }
        }

        Laya.ILaya.regClass(UIComponent), Laya.ClassUtils.regClass("laya.ui.UIComponent", UIComponent), Laya.ClassUtils.regClass("Laya.UIComponent", UIComponent);

        class Image extends UIComponent {
            constructor(skin = null) {
                super(), this.skin = skin
            }

            destroy(destroyChild = !0) {
                super.destroy(!0), this._bitmap && this._bitmap.destroy(), this._bitmap = null
            }

            dispose() {
                this.destroy(!0), Laya.ILaya.loader.clearRes(this._skin)
            }

            createChildren() {
                this.graphics = this._bitmap = new AutoBitmap, this._bitmap.autoCacheCmd = !1
            }

            get skin() {
                return this._skin
            }

            set skin(value) {
                if (this._skin != value) if (this._skin = value, value) {
                    var source = Laya.Loader.getRes(value);
                    source ? (this.source = source, this.onCompResize()) : Laya.ILaya.loader.load(this._skin, Laya.Handler.create(this, this.setSource, [this._skin]), null, Laya.Loader.IMAGE, 1, !0, this._group)
                } else this.source = null
            }

            get source() {
                return this._bitmap.source
            }

            set source(value) {
                this._bitmap && (this._bitmap.source = value, this.event(Laya.Event.LOADED), this.repaint())
            }

            get group() {
                return this._group
            }

            set group(value) {
                value && this._skin && Laya.Loader.setGroup(this._skin, value), this._group = value
            }

            setSource(url, img = null) {
                url === this._skin && img && (this.source = img, this.onCompResize())
            }

            measureWidth() {
                return this._bitmap.width
            }

            measureHeight() {
                return this._bitmap.height
            }

            set width(value) {
                super.width = value, this._bitmap.width = 0 == value ? 1e-7 : value
            }

            get width() {
                return super.width
            }

            set height(value) {
                super.height = value, this._bitmap.height = 0 == value ? 1e-7 : value
            }

            get height() {
                return super.height
            }

            get sizeGrid() {
                return this._bitmap.sizeGrid ? this._bitmap.sizeGrid.join(",") : null
            }

            set sizeGrid(value) {
                this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number)
            }

            set dataSource(value) {
                this._dataSource = value, "string" == typeof value ? this.skin = value : super.dataSource = value
            }

            get dataSource() {
                return super.dataSource
            }
        }

        Laya.ILaya.regClass(Image), Laya.ClassUtils.regClass("laya.ui.Image", Image), Laya.ClassUtils.regClass("Laya.Image", Image);

        class AdvImage extends Image {
            constructor(skin = null) {
                super(), this.advsListArr = [], this.resUrl = "https://unioncdn.layabox.com/config/iconlist.json", this._http = new Laya.Browser.window.XMLHttpRequest, this._data = [], this._resquestTime = 36e4, this._playIndex = 0, this._lunboTime = 5e3, this.skin = skin, this.setLoadUrl(), this.init(), this.size(120, 120)
            }

            setLoadUrl() {
            }

            init() {
                this.isSupportJump() ? ((Laya.Browser.onMiniGame || Laya.Browser.onBDMiniGame) && Laya.ILaya.timer.loop(this._resquestTime, this, this.onGetAdvsListData), this.onGetAdvsListData(), this.initEvent()) : this.visible = !1
            }

            initEvent() {
                this.on(Laya.Event.CLICK, this, this.onAdvsImgClick)
            }

            onAdvsImgClick() {
                this.getCurrentAppidObj() && this.jumptoGame()
            }

            revertAdvsData() {
                this.advsListArr[this._playIndex] && (this.visible = !0, this.skin = this.advsListArr[this._playIndex])
            }

            isSupportJump() {
                return Laya.Browser.onMiniGame ? window.wx.navigateToMiniProgram instanceof Function : !!Laya.Browser.onBDMiniGame
            }

            jumptoGame() {
                var advsObj = this.advsListArr[this._playIndex];
                parseInt(advsObj.gameid), advsObj.extendInfo, advsObj.path;
                Laya.Browser.onMiniGame ? this.isSupportJump() && window.wx.navigateToMiniProgram({
                    appId: this._appid,
                    path: "",
                    extraData: "",
                    envVersion: "release",
                    success: function () {
                        console.log("-------------跳转成功--------------")
                    },
                    fail: function () {
                        console.log("-------------跳转失败--------------")
                    },
                    complete: function () {
                        console.log("-------------跳转接口调用成功--------------"), this.updateAdvsInfo()
                    }.bind(this)
                }) : Laya.Browser.onBDMiniGame || (this.visible = !1)
            }

            updateAdvsInfo() {
                this.visible = !1, this.onLunbo(), Laya.ILaya.timer.loop(this._lunboTime, this, this.onLunbo)
            }

            onLunbo() {
                this._playIndex >= this.advsListArr.length - 1 ? this._playIndex = 0 : this._playIndex += 1, this.visible = !0, this.revertAdvsData()
            }

            getCurrentAppidObj() {
                return this.advsListArr[this._playIndex]
            }

            onGetAdvsListData() {
                var _this = this, random = AdvImage.randRange(1e4, 1e6), url = this.resUrl + "?" + random;
                this._http.open("get", url, !0), this._http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), this._http.responseType = "text", this._http.onerror = function (e) {
                    _this._onError(e)
                }, this._http.onload = function (e) {
                    _this._onLoad(e)
                }, this._http.send(null)
            }

            static randRange(minNum, maxNum) {
                return Math.floor(Math.random() * (maxNum - minNum + 1)) + minNum
            }

            _onError(e) {
                this.error("Request failed Status:" + this._http.status + " text:" + this._http.statusText)
            }

            _onLoad(e) {
                var http = this._http, status = void 0 !== http.status ? http.status : 200;
                200 === status || 204 === status || 0 === status ? this.complete() : this.error("[" + http.status + "]" + http.statusText + ":" + http.responseURL)
            }

            error(message) {
                this.event(Laya.Event.ERROR, message)
            }

            complete() {
                try {
                    this._data = this._http.response || this._http.responseText, this._data = JSON.parse(this._data), this.advsListArr = this._data.list, this._appid = this._data.appid, this.updateAdvsInfo(), this.revertAdvsData()
                } catch (e) {
                    this.error(e.message)
                }
            }

            getAdvsQArr(data) {
                var tempArr = [], gameAdvsObj = Laya.LocalStorage.getJSON("gameObj");
                for (var key in data) {
                    var tempObj = data[key];
                    gameAdvsObj && gameAdvsObj[tempObj.gameid] && !tempObj.isQiangZhi || tempArr.push(tempObj)
                }
                return tempArr
            }

            clear() {
                var http = this._http;
                http.onerror = http.onabort = http.onprogress = http.onload = null
            }

            destroy(destroyChild = !0) {
                Laya.ILaya.timer.clear(this, this.onLunbo), super.destroy(!0), this.clear(), Laya.ILaya.timer.clear(this, this.onGetAdvsListData)
            }
        }

        Laya.ClassUtils.regClass("laya.ui.AdvImage", AdvImage), Laya.ClassUtils.regClass("Laya.AdvImage", AdvImage);

        class Box extends UIComponent {
            set dataSource(value) {
                for (var name in this._dataSource = value, value) {
                    var comp = this.getChildByName(name);
                    comp ? comp.dataSource = value[name] : name in this && !(this[name] instanceof Function) && (this[name] = value[name])
                }
            }

            get dataSource() {
                return super.dataSource
            }

            get bgColor() {
                return this._bgColor
            }

            set bgColor(value) {
                this._bgColor = value, value ? (this._onResize(null), this.on(Laya.Event.RESIZE, this, this._onResize)) : (this.graphics.clear(), this.off(Laya.Event.RESIZE, this, this._onResize))
            }

            _onResize(e) {
                this.graphics.clear(), this.graphics.drawRect(0, 0, this.width, this.height, this._bgColor)
            }
        }

        Laya.ILaya.regClass(Box), Laya.ClassUtils.regClass("laya.ui.Box", Box), Laya.ClassUtils.regClass("Laya.Box", Box);

        class Button extends UIComponent {
            constructor(skin = null, label = "") {
                super(), this._labelColors = Styles.buttonLabelColors, this._state = 0, this._autoSize = !0, this._stateNum = Styles.buttonStateNum, this._stateChanged = !1, this.skin = skin, this.label = label
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._bitmap && this._bitmap.destroy(), this._text && this._text.destroy(destroyChild), this._bitmap = null, this._text = null, this._clickHandler = null, this._labelColors = this._sources = this._strokeColors = null
            }

            createChildren() {
                this.graphics = this._bitmap = new AutoBitmap
            }

            createText() {
                this._text || (this._text = new Laya.Text, this._text.overflow = Laya.Text.HIDDEN, this._text.align = "center", this._text.valign = "middle", this._text.width = this._width, this._text.height = this._height)
            }

            initialize() {
                1 !== this._mouseState && (this.mouseEnabled = !0, this._setBit(Laya.Const.HAS_MOUSE, !0)), this._createListener(Laya.Event.MOUSE_OVER, this, this.onMouse, null, !1, !1), this._createListener(Laya.Event.MOUSE_OUT, this, this.onMouse, null, !1, !1), this._createListener(Laya.Event.MOUSE_DOWN, this, this.onMouse, null, !1, !1), this._createListener(Laya.Event.MOUSE_UP, this, this.onMouse, null, !1, !1), this._createListener(Laya.Event.CLICK, this, this.onMouse, null, !1, !1)
            }

            onMouse(e) {
                if (!1 !== this.toggle || !this._selected) return e.type === Laya.Event.CLICK ? (this.toggle && (this.selected = !this._selected), void (this._clickHandler && this._clickHandler.run())) : void (!this._selected && (this.state = Button.stateMap[e.type]))
            }

            get skin() {
                return this._skin
            }

            set skin(value) {
                this._skin != value && (this._skin = value, value ? Laya.Loader.getRes(value) ? this._skinLoaded() : Laya.ILaya.loader.load(this._skin, Laya.Handler.create(this, this._skinLoaded), null, Laya.Loader.IMAGE, 1) : this._skinLoaded())
            }

            _skinLoaded() {
                this.callLater(this.changeClips), this._setStateChanged(), this._sizeChanged(), this.event(Laya.Event.LOADED)
            }

            get stateNum() {
                return this._stateNum
            }

            set stateNum(value) {
                "string" == typeof value && (value = parseInt(value)), this._stateNum != value && (this._stateNum = value < 1 ? 1 : value > 3 ? 3 : value, this.callLater(this.changeClips))
            }

            changeClips() {
                var img = Laya.Loader.getRes(this._skin);
                if (img) {
                    var width = img.sourceWidth, height = img.sourceHeight / this._stateNum;
                    img.$_GID || (img.$_GID = Laya.Utils.getGID());
                    var key = img.$_GID + "-" + this._stateNum, clips = Laya.WeakObject.I.get(key);
                    if (Laya.Utils.isOkTextureList(clips) || (clips = null), clips) this._sources = clips; else {
                        if (this._sources = [], 1 === this._stateNum) this._sources.push(img); else for (var i = 0; i < this._stateNum; i++) this._sources.push(Laya.Texture.createFromTexture(img, 0, height * i, width, height));
                        Laya.WeakObject.I.set(key, this._sources)
                    }
                    this._autoSize ? (this._bitmap.width = this._width || width, this._bitmap.height = this._height || height, this._text && (this._text.width = this._bitmap.width, this._text.height = this._bitmap.height)) : this._text && (this._text.x = width)
                } else console.log("lose skin", this._skin)
            }

            measureWidth() {
                return this.runCallLater(this.changeClips), this._autoSize ? this._bitmap.width : (this.runCallLater(this.changeState), this._bitmap.width + (this._text ? this._text.width : 0))
            }

            measureHeight() {
                return this.runCallLater(this.changeClips), this._text ? Math.max(this._bitmap.height, this._text.height) : this._bitmap.height
            }

            get label() {
                return this._text ? this._text.text : null
            }

            set label(value) {
                (this._text || value) && (this.createText(), this._text.text != value && (value && !this._text.parent && this.addChild(this._text), this._text.text = (value + "").replace(/\\n/g, "\n"), this._setStateChanged()))
            }

            get selected() {
                return this._selected
            }

            set selected(value) {
                this._selected != value && (this._selected = value, this.state = this._selected ? 2 : 0, this.event(Laya.Event.CHANGE))
            }

            get state() {
                return this._state
            }

            set state(value) {
                this._state != value && (this._state = value, this._setStateChanged())
            }

            changeState() {
                this._stateChanged = !1, this.runCallLater(this.changeClips);
                var index = this._state < this._stateNum ? this._state : this._stateNum - 1;
                this._sources && (this._bitmap.source = this._sources[index]), this.label && (this._text.color = this._labelColors[index], this._strokeColors && (this._text.strokeColor = this._strokeColors[index]))
            }

            get labelColors() {
                return this._labelColors.join(",")
            }

            set labelColors(value) {
                this._labelColors = UIUtils.fillArray(Styles.buttonLabelColors, value, String), this._setStateChanged()
            }

            get strokeColors() {
                return this._strokeColors ? this._strokeColors.join(",") : ""
            }

            set strokeColors(value) {
                this._strokeColors = UIUtils.fillArray(Styles.buttonLabelColors, value, String), this._setStateChanged()
            }

            get labelPadding() {
                return this.createText(), this._text.padding.join(",")
            }

            set labelPadding(value) {
                this.createText(), this._text.padding = UIUtils.fillArray(Styles.labelPadding, value, Number)
            }

            get labelSize() {
                return this.createText(), this._text.fontSize
            }

            set labelSize(value) {
                this.createText(), this._text.fontSize = value
            }

            get labelStroke() {
                return this.createText(), this._text.stroke
            }

            set labelStroke(value) {
                this.createText(), this._text.stroke = value
            }

            get labelStrokeColor() {
                return this.createText(), this._text.strokeColor
            }

            set labelStrokeColor(value) {
                this.createText(), this._text.strokeColor = value
            }

            get labelBold() {
                return this.createText(), this._text.bold
            }

            set labelBold(value) {
                this.createText(), this._text.bold = value
            }

            get labelFont() {
                return this.createText(), this._text.font
            }

            set labelFont(value) {
                this.createText(), this._text.font = value
            }

            get labelAlign() {
                return this.createText(), this._text.align
            }

            set labelAlign(value) {
                this.createText(), this._text.align = value
            }

            get clickHandler() {
                return this._clickHandler
            }

            set clickHandler(value) {
                this._clickHandler = value
            }

            get text() {
                return this.createText(), this._text
            }

            get sizeGrid() {
                return this._bitmap.sizeGrid ? this._bitmap.sizeGrid.join(",") : null
            }

            set sizeGrid(value) {
                this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number)
            }

            set width(value) {
                super.set_width(value), this._autoSize && (this._bitmap.width = value, this._text && (this._text.width = value))
            }

            get width() {
                return super.get_width()
            }

            set height(value) {
                super.set_height(value), this._autoSize && (this._bitmap.height = value, this._text && (this._text.height = value))
            }

            get height() {
                return super.get_height()
            }

            set dataSource(value) {
                this._dataSource = value, "number" == typeof value || "string" == typeof value ? this.label = value + "" : super.set_dataSource(value)
            }

            get dataSource() {
                return super.get_dataSource()
            }

            get iconOffset() {
                return this._bitmap._offset ? this._bitmap._offset.join(",") : null
            }

            set iconOffset(value) {
                this._bitmap._offset = value ? UIUtils.fillArray([1, 1], value, Number) : []
            }

            _setStateChanged() {
                this._stateChanged || (this._stateChanged = !0, this.callLater(this.changeState))
            }
        }

        Button.stateMap = {
            mouseup: 0,
            mouseover: 1,
            mousedown: 2,
            mouseout: 0
        }, Laya.ILaya.regClass(Button), Laya.ClassUtils.regClass("laya.ui.Button", Button), Laya.ClassUtils.regClass("Laya.Button", Button);

        class CheckBox extends Button {
            constructor(skin = null, label = "") {
                super(skin, label), this.toggle = !0, this._autoSize = !1
            }

            preinitialize() {
                super.preinitialize(), this.toggle = !0, this._autoSize = !1
            }

            initialize() {
                super.initialize(), this.createText(), this._text.align = "left", this._text.valign = "top", this._text.width = 0
            }

            set dataSource(value) {
                this._dataSource = value, value instanceof Boolean ? this.selected = value : "string" == typeof value ? this.selected = "true" === value : super.dataSource = value
            }

            get dataSource() {
                return super.dataSource
            }
        }

        Laya.ILaya.regClass(CheckBox), Laya.ClassUtils.regClass("laya.ui.CheckBox", CheckBox), Laya.ClassUtils.regClass("Laya.CheckBox", CheckBox);

        class Clip extends UIComponent {
            constructor(url = null, clipX = 1, clipY = 1) {
                super(), this._clipX = 1, this._clipY = 1, this._clipWidth = 0, this._clipHeight = 0, this._interval = 50, this._index = 0, this._toIndex = -1, this._clipX = clipX, this._clipY = clipY, this.skin = url
            }

            destroy(destroyChild = !0) {
                super.destroy(!0), this._bitmap && this._bitmap.destroy(), this._bitmap = null, this._sources = null
            }

            dispose() {
                this.destroy(!0), Laya.ILaya.loader.clearRes(this._skin)
            }

            createChildren() {
                this.graphics = this._bitmap = new AutoBitmap
            }

            _onDisplay(e) {
                this._isPlaying ? this._getBit(Laya.Const.DISPLAYED_INSTAGE) ? this.play() : this.stop() : this._autoPlay && this.play()
            }

            get skin() {
                return this._skin
            }

            set skin(value) {
                this._skin != value && (this._skin = value, value ? Laya.Loader.getRes(value) ? this._skinLoaded() : Laya.ILaya.loader.load(this._skin, Laya.Handler.create(this, this._skinLoaded), null, Laya.Loader.IMAGE, 1) : this._bitmap.source = null)
            }

            _skinLoaded() {
                this._setClipChanged(), this._sizeChanged(), this.event(Laya.Event.LOADED)
            }

            get clipX() {
                return this._clipX
            }

            set clipX(value) {
                this._clipX = value || 1, this._setClipChanged()
            }

            get clipY() {
                return this._clipY
            }

            set clipY(value) {
                this._clipY = value || 1, this._setClipChanged()
            }

            get clipWidth() {
                return this._clipWidth
            }

            set clipWidth(value) {
                this._clipWidth = value, this._setClipChanged()
            }

            get clipHeight() {
                return this._clipHeight
            }

            set clipHeight(value) {
                this._clipHeight = value, this._setClipChanged()
            }

            changeClip() {
                if (this._clipChanged = !1, this._skin) {
                    var img = Laya.Loader.getRes(this._skin);
                    img ? this.loadComplete(this._skin, img) : Laya.ILaya.loader.load(this._skin, Laya.Handler.create(this, this.loadComplete, [this._skin]))
                }
            }

            loadComplete(url, img) {
                if (url === this._skin && img) {
                    var w = this._clipWidth || Math.ceil(img.sourceWidth / this._clipX),
                        h = this._clipHeight || Math.ceil(img.sourceHeight / this._clipY), key = this._skin + w + h,
                        clips = Laya.WeakObject.I.get(key);
                    if (Laya.Utils.isOkTextureList(clips) || (clips = null), clips) this._sources = clips; else {
                        this._sources = [];
                        for (var i = 0; i < this._clipY; i++) for (var j = 0; j < this._clipX; j++) this._sources.push(Laya.Texture.createFromTexture(img, w * j, h * i, w, h));
                        Laya.WeakObject.I.set(key, this._sources)
                    }
                    this.index = this._index, this.event(Laya.Event.LOADED), this.onCompResize()
                }
            }

            get sources() {
                return this._sources
            }

            set sources(value) {
                this._sources = value, this.index = this._index, this.event(Laya.Event.LOADED)
            }

            get group() {
                return this._group
            }

            set group(value) {
                value && this._skin && Laya.Loader.setGroup(this._skin, value), this._group = value
            }

            set width(value) {
                super.width = value, this._bitmap.width = value
            }

            get width() {
                return super.width
            }

            set height(value) {
                super.height = value, this._bitmap.height = value
            }

            get height() {
                return super.height
            }

            measureWidth() {
                return this.runCallLater(this.changeClip), this._bitmap.width
            }

            measureHeight() {
                return this.runCallLater(this.changeClip), this._bitmap.height
            }

            get sizeGrid() {
                return this._bitmap.sizeGrid ? this._bitmap.sizeGrid.join(",") : null
            }

            set sizeGrid(value) {
                this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number)
            }

            get index() {
                return this._index
            }

            set index(value) {
                this._index = value, this._bitmap && this._sources && (this._bitmap.source = this._sources[value]), this.event(Laya.Event.CHANGE)
            }

            get total() {
                return this.runCallLater(this.changeClip), this._sources ? this._sources.length : 0
            }

            get autoPlay() {
                return this._autoPlay
            }

            set autoPlay(value) {
                this._autoPlay != value && (this._autoPlay = value, value ? this.play() : this.stop())
            }

            get interval() {
                return this._interval
            }

            set interval(value) {
                this._interval != value && (this._interval = value, this._isPlaying && this.play())
            }

            get isPlaying() {
                return this._isPlaying
            }

            set isPlaying(value) {
                this._isPlaying = value
            }

            play(from = 0, to = -1) {
                this._isPlaying = !0, this.index = from, this._toIndex = to, this._index++, Laya.ILaya.timer.loop(this.interval, this, this._loop), this.on(Laya.Event.DISPLAY, this, this._onDisplay), this.on(Laya.Event.UNDISPLAY, this, this._onDisplay)
            }

            _loop() {
                this._visible && this._sources && (this._index++, this._toIndex > -1 && this._index >= this._toIndex ? this.stop() : this._index >= this._sources.length && (this._index = 0), this.index = this._index)
            }

            stop() {
                this._isPlaying = !1, Laya.ILaya.timer.clear(this, this._loop), this.event(Laya.Event.COMPLETE)
            }

            set dataSource(value) {
                this._dataSource = value, "number" == typeof value || "string" == typeof value ? this.index = parseInt(value) : super.dataSource = value
            }

            get dataSource() {
                return super.dataSource
            }

            get bitmap() {
                return this._bitmap
            }

            _setClipChanged() {
                this._clipChanged || (this._clipChanged = !0, this.callLater(this.changeClip))
            }
        }

        Laya.ILaya.regClass(Clip), Laya.ClassUtils.regClass("laya.ui.Clip", Clip), Laya.ClassUtils.regClass("Laya.Clip", Clip);

        class ColorPicker extends UIComponent {
            constructor() {
                super(...arguments), this._gridSize = 11, this._bgColor = "#ffffff", this._borderColor = "#000000", this._inputColor = "#000000", this._inputBgColor = "#efefef", this._colors = [], this._selectedColor = "#000000"
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._colorPanel && this._colorPanel.destroy(destroyChild), this._colorButton && this._colorButton.destroy(destroyChild), this._colorPanel = null, this._colorTiles = null, this._colorBlock = null, this._colorInput = null, this._colorButton = null, this._colors = null, this.changeHandler = null
            }

            createChildren() {
                this.addChild(this._colorButton = new Button), this._colorPanel = new Box, this._colorPanel.size(230, 166), this._colorPanel.addChild(this._colorTiles = new Laya.Sprite), this._colorPanel.addChild(this._colorBlock = new Laya.Sprite), this._colorPanel.addChild(this._colorInput = new Laya.Input)
            }

            initialize() {
                this._colorButton.on(Laya.Event.CLICK, this, this.onColorButtonClick), this._colorBlock.pos(5, 5), this._colorInput.pos(60, 5), this._colorInput.size(60, 20), this._colorInput.on(Laya.Event.CHANGE, this, this.onColorInputChange), this._colorInput.on(Laya.Event.KEY_DOWN, this, this.onColorFieldKeyDown), this._colorTiles.pos(5, 30), this._colorTiles.on(Laya.Event.MOUSE_MOVE, this, this.onColorTilesMouseMove), this._colorTiles.on(Laya.Event.CLICK, this, this.onColorTilesClick), this._colorTiles.size(20 * this._gridSize, 12 * this._gridSize), this._colorPanel.on(Laya.Event.MOUSE_DOWN, this, this.onPanelMouseDown), this.bgColor = this._bgColor
            }

            onPanelMouseDown(e) {
                e.stopPropagation()
            }

            changePanel() {
                this._panelChanged = !1;
                var g = this._colorPanel.graphics;
                g.clear(!0), g.drawRect(0, 0, 230, 166, this._bgColor, this._borderColor), this.drawBlock(this._selectedColor), this._colorInput.borderColor = this._borderColor, this._colorInput.bgColor = this._inputBgColor, this._colorInput.color = this._inputColor, (g = this._colorTiles.graphics).clear(!0);
                for (var mainColors = [0, 3355443, 6710886, 10066329, 13421772, 16777215, 16711680, 65280, 255, 16776960, 65535, 16711935], i = 0; i < 12; i++) for (var j = 0; j < 20; j++) {
                    var color;
                    color = 0 === j ? mainColors[i] : 1 === j ? 0 : 51 * (((3 * i + j / 6) % 3 << 0) + 3 * (i / 6 << 0)) << 16 | j % 6 * 51 << 8 | (i << 0) % 6 * 51;
                    var strColor = UIUtils.toColor(color);
                    this._colors.push(strColor);
                    var x = j * this._gridSize, y = i * this._gridSize;
                    g.drawRect(x, y, this._gridSize, this._gridSize, strColor, "#000000")
                }
            }

            onColorButtonClick(e) {
                this._colorPanel.parent ? this.close() : this.open()
            }

            open() {
                let stage = Laya.ILaya.stage;
                var p = this.localToGlobal(new Laya.Point),
                    px = p.x + this._colorPanel.width <= stage.width ? p.x : stage.width - this._colorPanel.width,
                    py = p.y + this._colorButton.height;
                py = py + this._colorPanel.height <= stage.height ? py : p.y - this._colorPanel.height, this._colorPanel.pos(px, py), this._colorPanel.zOrder = 1001, stage.addChild(this._colorPanel), stage.on(Laya.Event.MOUSE_DOWN, this, this.removeColorBox)
            }

            close() {
                Laya.ILaya.stage.off(Laya.Event.MOUSE_DOWN, this, this.removeColorBox), this._colorPanel.removeSelf()
            }

            removeColorBox(e = null) {
                this.close()
            }

            onColorFieldKeyDown(e) {
                13 == e.keyCode && (this._colorInput.text ? this.selectedColor = this._colorInput.text : this.selectedColor = null, this.close(), e.stopPropagation())
            }

            onColorInputChange(e = null) {
                this._colorInput.text ? this.drawBlock(this._colorInput.text) : this.drawBlock("#FFFFFF")
            }

            onColorTilesClick(e) {
                this.selectedColor = this.getColorByMouse(), this.close()
            }

            onColorTilesMouseMove(e) {
                this._colorInput.focus = !1;
                var color = this.getColorByMouse();
                this._colorInput.text = color, this.drawBlock(color)
            }

            getColorByMouse() {
                var point = this._colorTiles.getMousePoint(), x = Math.floor(point.x / this._gridSize),
                    y = Math.floor(point.y / this._gridSize);
                return this._colors[20 * y + x]
            }

            drawBlock(color) {
                var g = this._colorBlock.graphics;
                g.clear(!0);
                var showColor = color || "#ffffff";
                g.drawRect(0, 0, 50, 20, showColor, this._borderColor), color || g.drawLine(0, 0, 50, 20, "#ff0000")
            }

            get selectedColor() {
                return this._selectedColor
            }

            set selectedColor(value) {
                this._selectedColor != value && (this._selectedColor = this._colorInput.text = value, this.drawBlock(value), this.changeColor(), this.changeHandler && this.changeHandler.runWith(this._selectedColor), this.event(Laya.Event.CHANGE, Laya.Event.EMPTY.setTo(Laya.Event.CHANGE, this, this)))
            }

            get skin() {
                return this._colorButton.skin
            }

            set skin(value) {
                this._colorButton.once(Laya.Event.LOADED, this, this.changeColor), this._colorButton.skin = value
            }

            changeColor() {
                var g = this.graphics;
                g.clear(!0);
                var showColor = this._selectedColor || "#000000";
                g.drawRect(0, 0, this._colorButton.width, this._colorButton.height, showColor)
            }

            get bgColor() {
                return this._bgColor
            }

            set bgColor(value) {
                this._bgColor = value, this._setPanelChanged()
            }

            get borderColor() {
                return this._borderColor
            }

            set borderColor(value) {
                this._borderColor = value, this._setPanelChanged()
            }

            get inputColor() {
                return this._inputColor
            }

            set inputColor(value) {
                this._inputColor = value, this._setPanelChanged()
            }

            get inputBgColor() {
                return this._inputBgColor
            }

            set inputBgColor(value) {
                this._inputBgColor = value, this._setPanelChanged()
            }

            _setPanelChanged() {
                this._panelChanged || (this._panelChanged = !0, this.callLater(this.changePanel))
            }
        }

        Laya.ILaya.regClass(ColorPicker), Laya.ClassUtils.regClass("laya.ui.ColorPicker", ColorPicker), Laya.ClassUtils.regClass("Laya.ColorPicker", ColorPicker);

        class Label extends UIComponent {
            constructor(text = "") {
                super(), this.text = text
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._tf = null
            }

            createChildren() {
                this.addChild(this._tf = new Laya.Text)
            }

            get text() {
                return this._tf.text
            }

            set text(value) {
                this._tf.text != value && (value && (value = UIUtils.adptString(value + "")), this._tf.text = value, this.event(Laya.Event.CHANGE), this._width && this._height || this.onCompResize())
            }

            changeText(text) {
                this._tf.changeText(text)
            }

            get wordWrap() {
                return this._tf.wordWrap
            }

            set wordWrap(value) {
                this._tf.wordWrap = value
            }

            get color() {
                return this._tf.color
            }

            set color(value) {
                this._tf.color = value
            }

            get font() {
                return this._tf.font
            }

            set font(value) {
                this._tf.font = value
            }

            get align() {
                return this._tf.align
            }

            set align(value) {
                this._tf.align = value
            }

            get valign() {
                return this._tf.valign
            }

            set valign(value) {
                this._tf.valign = value
            }

            get bold() {
                return this._tf.bold
            }

            set bold(value) {
                this._tf.bold = value
            }

            get italic() {
                return this._tf.italic
            }

            set italic(value) {
                this._tf.italic = value
            }

            get leading() {
                return this._tf.leading
            }

            set leading(value) {
                this._tf.leading = value
            }

            get fontSize() {
                return this._tf.fontSize
            }

            set fontSize(value) {
                this._tf.fontSize = value
            }

            get padding() {
                return this._tf.padding.join(",")
            }

            set padding(value) {
                this._tf.padding = UIUtils.fillArray(Styles.labelPadding, value, Number)
            }

            get bgColor() {
                return this._tf.bgColor
            }

            set bgColor(value) {
                this._tf.bgColor = value
            }

            get borderColor() {
                return this._tf.borderColor
            }

            set borderColor(value) {
                this._tf.borderColor = value
            }

            get stroke() {
                return this._tf.stroke
            }

            set stroke(value) {
                this._tf.stroke = value
            }

            get strokeColor() {
                return this._tf.strokeColor
            }

            set strokeColor(value) {
                this._tf.strokeColor = value
            }

            get textField() {
                return this._tf
            }

            measureWidth() {
                return this._tf.width
            }

            measureHeight() {
                return this._tf.height
            }

            get width() {
                return this._width || this._tf.text ? super.width : 0
            }

            set width(value) {
                super.width = value, this._tf.width = value
            }

            get height() {
                return this._height || this._tf.text ? super.height : 0
            }

            set height(value) {
                super.height = value, this._tf.height = value
            }

            set dataSource(value) {
                this._dataSource = value, "number" == typeof value || "string" == typeof value ? this.text = value + "" : super.dataSource = value
            }

            get dataSource() {
                return super.dataSource
            }

            get overflow() {
                return this._tf.overflow
            }

            set overflow(value) {
                this._tf.overflow = value
            }

            get underline() {
                return this._tf.underline
            }

            set underline(value) {
                this._tf.underline = value
            }

            get underlineColor() {
                return this._tf.underlineColor
            }

            set underlineColor(value) {
                this._tf.underlineColor = value
            }
        }

        Laya.ILaya.regClass(Label), Laya.ClassUtils.regClass("laya.ui.Label", Label), Laya.ClassUtils.regClass("Laya.Label", Label);

        class Slider extends UIComponent {
            constructor(skin = null) {
                super(), this.isVertical = !0, this.showLabel = !0, this._max = 100, this._min = 0, this._tick = 1, this._value = 0, Slider.label || (Slider.label = new Label), this.skin = skin
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._bg && this._bg.destroy(destroyChild), this._bar && this._bar.destroy(destroyChild), this._progress && this._progress.destroy(destroyChild), this._bg = null, this._bar = null, this._progress = null, this.changeHandler = null
            }

            createChildren() {
                this.addChild(this._bg = new Image), this.addChild(this._bar = new Button)
            }

            initialize() {
                this._bar.on(Laya.Event.MOUSE_DOWN, this, this.onBarMouseDown), this._bg.sizeGrid = this._bar.sizeGrid = "4,4,4,4,0", this._progress && (this._progress.sizeGrid = this._bar.sizeGrid), this.allowClickBack = !0
            }

            onBarMouseDown(e) {
                var Laya$1 = Laya.ILaya;
                this._globalSacle || (this._globalSacle = new Laya.Point), this._globalSacle.setTo(this.globalScaleX || .01, this.globalScaleY || .01), this._maxMove = this.isVertical ? this.height - this._bar.height : this.width - this._bar.width, this._tx = Laya$1.stage.mouseX, this._ty = Laya$1.stage.mouseY, Laya$1.stage.on(Laya.Event.MOUSE_MOVE, this, this.mouseMove), Laya$1.stage.once(Laya.Event.MOUSE_UP, this, this.mouseUp), Laya$1.stage.once(Laya.Event.MOUSE_OUT, this, this.mouseUp), this.showValueText()
            }

            showValueText() {
                if (this.showLabel) {
                    var label = Slider.label;
                    this.addChild(label), label.textField.changeText(this._value + ""), this.isVertical ? (label.x = this._bar._x + 20, label.y = .5 * (this._bar.height - label.height) + this._bar._y) : (label.y = this._bar._y - 20, label.x = .5 * (this._bar.width - label.width) + this._bar._x)
                }
            }

            hideValueText() {
                Slider.label && Slider.label.removeSelf()
            }

            mouseUp(e) {
                let stage = Laya.ILaya.stage;
                stage.off(Laya.Event.MOUSE_MOVE, this, this.mouseMove), stage.off(Laya.Event.MOUSE_UP, this, this.mouseUp), stage.off(Laya.Event.MOUSE_OUT, this, this.mouseUp), this.sendChangeEvent(Laya.Event.CHANGED), this.hideValueText()
            }

            mouseMove(e) {
                let stage = Laya.ILaya.stage;
                var oldValue = this._value;
                if (this.isVertical ? (this._bar.y += (stage.mouseY - this._ty) / this._globalSacle.y, this._bar._y > this._maxMove ? this._bar.y = this._maxMove : this._bar._y < 0 && (this._bar.y = 0), this._value = this._bar._y / this._maxMove * (this._max - this._min) + this._min, this._progress && (this._progress.height = this._bar._y + .5 * this._bar.height)) : (this._bar.x += (stage.mouseX - this._tx) / this._globalSacle.x, this._bar._x > this._maxMove ? this._bar.x = this._maxMove : this._bar._x < 0 && (this._bar.x = 0), this._value = this._bar._x / this._maxMove * (this._max - this._min) + this._min, this._progress && (this._progress.width = this._bar._x + .5 * this._bar.width)), this._tx = stage.mouseX, this._ty = stage.mouseY, 0 != this._tick) {
                    var pow = Math.pow(10, (this._tick + "").length - 1);
                    this._value = Math.round(Math.round(this._value / this._tick) * this._tick * pow) / pow
                }
                this._value != oldValue && this.sendChangeEvent(), this.showValueText()
            }

            sendChangeEvent(type = Laya.Event.CHANGE) {
                this.event(type), this.changeHandler && this.changeHandler.runWith(this._value)
            }

            get skin() {
                return this._skin
            }

            set skin(value) {
                this._skin != value && (this._skin = value, this._skin && !Laya.Loader.getRes(this._skin) ? Laya.ILaya.loader.load([this._skin, this._skin.replace(".png", "$bar.png")], Laya.Handler.create(this, this._skinLoaded)) : this._skinLoaded())
            }

            _skinLoaded() {
                this._bg.skin = this._skin, this._bar.skin = this._skin.replace(".png", "$bar.png");
                var progressSkin = this._skin.replace(".png", "$progress.png");
                Laya.Loader.getRes(progressSkin) && (this._progress || (this.addChild(this._progress = new Image), this._progress.sizeGrid = this._bar.sizeGrid, this.setChildIndex(this._progress, 1)), this._progress.skin = progressSkin), this.setBarPoint(), this.callLater(this.changeValue), this._sizeChanged(), this.event(Laya.Event.LOADED)
            }

            setBarPoint() {
                this.isVertical ? this._bar.x = Math.round(.5 * (this._bg.width - this._bar.width)) : this._bar.y = Math.round(.5 * (this._bg.height - this._bar.height))
            }

            measureWidth() {
                return Math.max(this._bg.width, this._bar.width)
            }

            measureHeight() {
                return Math.max(this._bg.height, this._bar.height)
            }

            _sizeChanged() {
                super._sizeChanged(), this.isVertical ? this._bg.height = this.height : this._bg.width = this.width, this.setBarPoint(), this.changeValue()
            }

            get sizeGrid() {
                return this._bg.sizeGrid
            }

            set sizeGrid(value) {
                this._bg.sizeGrid = value, this._bar.sizeGrid = value, this._progress && (this._progress.sizeGrid = this._bar.sizeGrid)
            }

            setSlider(min, max, value) {
                this._value = -1, this._min = min, this._max = max > min ? max : min, this.value = value < min ? min : value > max ? max : value
            }

            get tick() {
                return this._tick
            }

            set tick(value) {
                this._tick != value && (this._tick = value, this.callLater(this.changeValue))
            }

            changeValue() {
                if (0 != this.tick) {
                    var pow = Math.pow(10, (this._tick + "").length - 1);
                    this._value = Math.round(Math.round(this._value / this._tick) * this._tick * pow) / pow
                }
                this._value = this._value > this._max ? this._max : this._value < this._min ? this._min : this._value;
                var num = this._max - this._min;
                0 === num && (num = 1), this.isVertical ? (this._bar.y = (this._value - this._min) / num * (this.height - this._bar.height), this._progress && (this._progress.height = this._bar._y + .5 * this._bar.height)) : (this._bar.x = (this._value - this._min) / num * (this.width - this._bar.width), this._progress && (this._progress.width = this._bar._x + .5 * this._bar.width))
            }

            get max() {
                return this._max
            }

            set max(value) {
                this._max != value && (this._max = value, this.callLater(this.changeValue))
            }

            get min() {
                return this._min
            }

            set min(value) {
                this._min != value && (this._min = value, this.callLater(this.changeValue))
            }

            get value() {
                return this._value
            }

            set value(num) {
                if (this._value != num) {
                    var oldValue = this._value;
                    this._value = num, this.changeValue(), this._value != oldValue && this.sendChangeEvent()
                }
            }

            get allowClickBack() {
                return this._allowClickBack
            }

            set allowClickBack(value) {
                this._allowClickBack != value && (this._allowClickBack = value, value ? this._bg.on(Laya.Event.MOUSE_DOWN, this, this.onBgMouseDown) : this._bg.off(Laya.Event.MOUSE_DOWN, this, this.onBgMouseDown))
            }

            onBgMouseDown(e) {
                var point = this._bg.getMousePoint();
                this.isVertical ? this.value = point.y / (this.height - this._bar.height) * (this._max - this._min) + this._min : this.value = point.x / (this.width - this._bar.width) * (this._max - this._min) + this._min
            }

            set dataSource(value) {
                this._dataSource = value, "number" == typeof value || "string" == typeof value ? this.value = Number(value) : super.dataSource = value
            }

            get dataSource() {
                return super.dataSource
            }

            get bar() {
                return this._bar
            }
        }

        Slider.label = null, Laya.ILaya.regClass(Slider), Laya.ClassUtils.regClass("laya.ui.Slider", Slider), Laya.ClassUtils.regClass("Laya.Slider", Slider);

        class ScrollBar extends UIComponent {
            constructor(skin = null) {
                super(), this.rollRatio = .97, this.scaleBar = !0, this.autoHide = !1, this.elasticDistance = 0, this.elasticBackTime = 500, this._showButtons = UIConfig.showButtons, this._scrollSize = 1, this._thumbPercent = 1, this._lastOffset = 0, this._checkElastic = !1, this._isElastic = !1, this._hide = !1, this._clickOnly = !0, this._touchScrollEnable = UIConfig.touchScrollEnable, this._mouseWheelEnable = UIConfig.mouseWheelEnable, this.skin = skin, this.max = 1
            }

            destroy(destroyChild = !0) {
                this.stopScroll(), this.target = null, super.destroy(destroyChild), this.upButton && this.upButton.destroy(destroyChild), this.downButton && this.downButton.destroy(destroyChild), this.slider && this.slider.destroy(destroyChild), this.upButton = this.downButton = null, this.slider = null, this.changeHandler = null, this._offsets = null
            }

            createChildren() {
                this.addChild(this.slider = new Slider), this.addChild(this.upButton = new Button), this.addChild(this.downButton = new Button)
            }

            initialize() {
                this.slider.showLabel = !1, this.slider.tick = 0, this.slider.on(Laya.Event.CHANGE, this, this.onSliderChange), this.slider.setSlider(0, 0, 0), this.upButton.on(Laya.Event.MOUSE_DOWN, this, this.onButtonMouseDown), this.downButton.on(Laya.Event.MOUSE_DOWN, this, this.onButtonMouseDown)
            }

            onSliderChange() {
                this._value != this.slider.value && (this.value = this.slider.value)
            }

            onButtonMouseDown(e) {
                var isUp = e.currentTarget === this.upButton;
                this.slide(isUp), Laya.ILaya.timer.once(Styles.scrollBarDelayTime, this, this.startLoop, [isUp]), Laya.ILaya.stage.once(Laya.Event.MOUSE_UP, this, this.onStageMouseUp)
            }

            startLoop(isUp) {
                Laya.ILaya.timer.frameLoop(1, this, this.slide, [isUp])
            }

            slide(isUp) {
                isUp ? this.value -= this._scrollSize : this.value += this._scrollSize
            }

            onStageMouseUp(e) {
                Laya.ILaya.timer.clear(this, this.startLoop), Laya.ILaya.timer.clear(this, this.slide)
            }

            get skin() {
                return this._skin
            }

            set skin(value) {
                " " != value && this._skin != value && (this._skin = value, this._skin && !Laya.Loader.getRes(this._skin) ? Laya.ILaya.loader.load([this._skin, this._skin.replace(".png", "$up.png"), this._skin.replace(".png", "$down.png"), this._skin.replace(".png", "$bar.png")], Laya.Handler.create(this, this._skinLoaded)) : this._skinLoaded())
            }

            _skinLoaded() {
                this.slider.skin = this._skin, this.callLater(this.changeScrollBar), this._sizeChanged(), this.event(Laya.Event.LOADED)
            }

            changeScrollBar() {
                this.upButton.visible = this._showButtons, this.downButton.visible = this._showButtons, this._showButtons && (this.upButton.skin = this._skin.replace(".png", "$up.png"), this.downButton.skin = this._skin.replace(".png", "$down.png")), this.slider.isVertical ? this.slider.y = this._showButtons ? this.upButton.height : 0 : this.slider.x = this._showButtons ? this.upButton.width : 0, this.resetPositions(), this.repaint()
            }

            _sizeChanged() {
                super._sizeChanged(), this.repaint(), this.resetPositions(), this.event(Laya.Event.CHANGE), this.changeHandler && this.changeHandler.runWith(this.value)
            }

            resetPositions() {
                this.slider.isVertical ? this.slider.height = this.height - (this._showButtons ? this.upButton.height + this.downButton.height : 0) : this.slider.width = this.width - (this._showButtons ? this.upButton.width + this.downButton.width : 0), this.resetButtonPosition()
            }

            resetButtonPosition() {
                this.slider.isVertical ? this.downButton.y = this.slider._y + this.slider.height : this.downButton.x = this.slider._x + this.slider.width
            }

            measureWidth() {
                return this.slider.isVertical ? this.slider.width : 100
            }

            measureHeight() {
                return this.slider.isVertical ? 100 : this.slider.height
            }

            setScroll(min, max, value) {
                this.runCallLater(this._sizeChanged), this.slider.setSlider(min, max, value), this.slider.bar.visible = max > 0, !this._hide && this.autoHide && (this.visible = !1)
            }

            get max() {
                return this.slider.max
            }

            set max(value) {
                this.slider.max = value
            }

            get min() {
                return this.slider.min
            }

            set min(value) {
                this.slider.min = value
            }

            get value() {
                return this._value
            }

            set value(v) {
                v !== this._value && (this._value = v, this._isElastic || (this.slider._value != v && (this.slider._value = v, this.slider.changeValue()), this._value = this.slider._value), this.event(Laya.Event.CHANGE), this.changeHandler && this.changeHandler.runWith(this._value))
            }

            get isVertical() {
                return this.slider.isVertical
            }

            set isVertical(value) {
                this.slider.isVertical = value
            }

            get sizeGrid() {
                return this.slider.sizeGrid
            }

            set sizeGrid(value) {
                this.slider.sizeGrid = value
            }

            get scrollSize() {
                return this._scrollSize
            }

            set scrollSize(value) {
                this._scrollSize = value
            }

            set dataSource(value) {
                this._dataSource = value, "number" == typeof value || "string" == typeof value ? this.value = Number(value) : super.dataSource = value
            }

            get dataSource() {
                return super.dataSource
            }

            get thumbPercent() {
                return this._thumbPercent
            }

            set thumbPercent(value) {
                this.runCallLater(this.changeScrollBar), this.runCallLater(this._sizeChanged), value = value >= 1 ? .99 : value, this._thumbPercent = value, this.scaleBar && (this.slider.isVertical ? this.slider.bar.height = Math.max(this.slider.height * value, Styles.scrollBarMinNum) : this.slider.bar.width = Math.max(this.slider.width * value, Styles.scrollBarMinNum))
            }

            get target() {
                return this._target
            }

            set target(value) {
                this._target && (this._target.off(Laya.Event.MOUSE_WHEEL, this, this.onTargetMouseWheel), this._target.off(Laya.Event.MOUSE_DOWN, this, this.onTargetMouseDown)), this._target = value, value && (this._mouseWheelEnable && this._target.on(Laya.Event.MOUSE_WHEEL, this, this.onTargetMouseWheel), this._touchScrollEnable && this._target.on(Laya.Event.MOUSE_DOWN, this, this.onTargetMouseDown))
            }

            get hide() {
                return this._hide
            }

            set hide(value) {
                this._hide = value, this.visible = !value
            }

            get showButtons() {
                return this._showButtons
            }

            set showButtons(value) {
                this._showButtons = value, this.callLater(this.changeScrollBar)
            }

            get touchScrollEnable() {
                return this._touchScrollEnable
            }

            set touchScrollEnable(value) {
                this._touchScrollEnable = value, this.target = this._target
            }

            get mouseWheelEnable() {
                return this._mouseWheelEnable
            }

            set mouseWheelEnable(value) {
                this._mouseWheelEnable = value, this.target = this._target
            }

            onTargetMouseWheel(e) {
                this.value -= e.delta * this._scrollSize, this.target = this._target
            }

            onTargetMouseDown(e) {
                this.isLockedFun && !this.isLockedFun(e) || (this.event(Laya.Event.END), this._clickOnly = !0, this._lastOffset = 0, this._checkElastic = !1, this._lastPoint || (this._lastPoint = new Laya.Point), this._lastPoint.setTo(Laya.ILaya.stage.mouseX, Laya.ILaya.stage.mouseY), Laya.ILaya.timer.clear(this, this.tweenMove), Laya.Tween.clearTween(this), Laya.ILaya.stage.once(Laya.Event.MOUSE_UP, this, this.onStageMouseUp2), Laya.ILaya.stage.once(Laya.Event.MOUSE_OUT, this, this.onStageMouseUp2), Laya.ILaya.timer.frameLoop(1, this, this.loop))
            }

            startDragForce() {
                this._clickOnly = !0, this._lastOffset = 0, this._checkElastic = !1, this._lastPoint || (this._lastPoint = new Laya.Point), this._lastPoint.setTo(Laya.ILaya.stage.mouseX, Laya.ILaya.stage.mouseY), Laya.ILaya.timer.clear(this, this.tweenMove), Laya.Tween.clearTween(this), Laya.ILaya.stage.once(Laya.Event.MOUSE_UP, this, this.onStageMouseUp2), Laya.ILaya.stage.once(Laya.Event.MOUSE_OUT, this, this.onStageMouseUp2), Laya.ILaya.timer.frameLoop(1, this, this.loop)
            }

            cancelDragOp() {
                Laya.ILaya.stage.off(Laya.Event.MOUSE_UP, this, this.onStageMouseUp2), Laya.ILaya.stage.off(Laya.Event.MOUSE_OUT, this, this.onStageMouseUp2), Laya.ILaya.timer.clear(this, this.tweenMove), Laya.ILaya.timer.clear(this, this.loop), this._target.mouseEnabled = !0
            }

            checkTriggers(isTweenMove = !1) {
                return this.value >= 0 && this.value - this._lastOffset <= 0 && this.triggerDownDragLimit && this.triggerDownDragLimit(isTweenMove) ? (this.cancelDragOp(), this.value = 0, !0) : !!(this.value <= this.max && this.value - this._lastOffset >= this.max && this.triggerUpDragLimit && this.triggerUpDragLimit(isTweenMove)) && (this.cancelDragOp(), this.value = this.max, !0)
            }

            get lastOffset() {
                return this._lastOffset
            }

            startTweenMoveForce(lastOffset) {
                this._lastOffset = lastOffset, Laya.ILaya.timer.frameLoop(1, this, this.tweenMove, [200])
            }

            loop() {
                var mouseY = Laya.ILaya.stage.mouseY, mouseX = Laya.ILaya.stage.mouseX;
                if (this._lastOffset = this.isVertical ? mouseY - this._lastPoint.y : mouseX - this._lastPoint.x, this._clickOnly) {
                    if (!(Math.abs(this._lastOffset * (this.isVertical ? Laya.ILaya.stage._canvasTransform.getScaleY() : Laya.ILaya.stage._canvasTransform.getScaleX())) > 1)) return;
                    if (this._clickOnly = !1, this.checkTriggers()) return;
                    this._offsets || (this._offsets = []), this._offsets.length = 0, this._target.mouseEnabled = !1, !this.hide && this.autoHide && (this.alpha = 1, this.visible = !0), this.event(Laya.Event.START)
                } else if (this.checkTriggers()) return;
                this._offsets.push(this._lastOffset), this._lastPoint.x = mouseX, this._lastPoint.y = mouseY, 0 !== this._lastOffset && (this._checkElastic || (this.elasticDistance > 0 ? this._checkElastic || 0 == this._lastOffset || (this._lastOffset > 0 && this._value <= this.min || this._lastOffset < 0 && this._value >= this.max ? (this._isElastic = !0, this._checkElastic = !0) : this._isElastic = !1) : this._checkElastic = !0), this._isElastic ? this._value <= this.min ? this._lastOffset > 0 ? this.value -= this._lastOffset * Math.max(0, 1 - (this.min - this._value) / this.elasticDistance) : (this.value -= .5 * this._lastOffset, this._value >= this.min && (this._checkElastic = !1)) : this._value >= this.max && (this._lastOffset < 0 ? this.value -= this._lastOffset * Math.max(0, 1 - (this._value - this.max) / this.elasticDistance) : (this.value -= .5 * this._lastOffset, this._value <= this.max && (this._checkElastic = !1))) : this.value -= this._lastOffset)
            }

            onStageMouseUp2(e) {
                if (Laya.ILaya.stage.off(Laya.Event.MOUSE_UP, this, this.onStageMouseUp2), Laya.ILaya.stage.off(Laya.Event.MOUSE_OUT, this, this.onStageMouseUp2), Laya.ILaya.timer.clear(this, this.loop), !(this._clickOnly && this._value >= this.min && this._value <= this.max)) if (this._target.mouseEnabled = !0, this._isElastic) this._value < this.min ? Laya.Tween.to(this, {value: this.min}, this.elasticBackTime, Laya.Ease.sineOut, Laya.Handler.create(this, this.elasticOver)) : this._value > this.max && Laya.Tween.to(this, {value: this.max}, this.elasticBackTime, Laya.Ease.sineOut, Laya.Handler.create(this, this.elasticOver)); else {
                    if (!this._offsets) return;
                    this._offsets.length < 1 && (this._offsets[0] = this.isVertical ? Laya.ILaya.stage.mouseY - this._lastPoint.y : Laya.ILaya.stage.mouseX - this._lastPoint.x);
                    for (var offset = 0, n = Math.min(this._offsets.length, 3), i = 0; i < n; i++) offset += this._offsets[this._offsets.length - 1 - i];
                    if (this._lastOffset = offset / n, (offset = Math.abs(this._lastOffset)) < 2) return void this.event(Laya.Event.END);
                    offset > 250 && (this._lastOffset = this._lastOffset > 0 ? 250 : -250);
                    var dis = Math.round(Math.abs(this.elasticDistance * (this._lastOffset / 150)));
                    Laya.ILaya.timer.frameLoop(1, this, this.tweenMove, [dis])
                }
            }

            elasticOver() {
                this._isElastic = !1, !this.hide && this.autoHide && Laya.Tween.to(this, {alpha: 0}, 500), this.event(Laya.Event.END)
            }

            tweenMove(maxDistance) {
                var tarSpeed;
                if ((this._lastOffset *= this.rollRatio, !this.checkTriggers(!0)) && (maxDistance > 0 && (this._lastOffset > 0 && this.value <= this.min ? (this._isElastic = !0, tarSpeed = .5 * -(this.min - maxDistance - this.value), this._lastOffset > tarSpeed && (this._lastOffset = tarSpeed)) : this._lastOffset < 0 && this.value >= this.max && (this._isElastic = !0, tarSpeed = .5 * -(this.max + maxDistance - this.value), this._lastOffset < tarSpeed && (this._lastOffset = tarSpeed))), this.value -= this._lastOffset, Math.abs(this._lastOffset) < .1)) {
                    if (Laya.ILaya.timer.clear(this, this.tweenMove), this._isElastic) return void (this._value < this.min ? Laya.Tween.to(this, {value: this.min}, this.elasticBackTime, Laya.Ease.sineOut, Laya.Handler.create(this, this.elasticOver)) : this._value > this.max ? Laya.Tween.to(this, {value: this.max}, this.elasticBackTime, Laya.Ease.sineOut, Laya.Handler.create(this, this.elasticOver)) : this.elasticOver());
                    this.event(Laya.Event.END), !this.hide && this.autoHide && Laya.Tween.to(this, {alpha: 0}, 500)
                }
            }

            stopScroll() {
                this.onStageMouseUp2(null), Laya.ILaya.timer.clear(this, this.tweenMove), Laya.Tween.clearTween(this)
            }

            get tick() {
                return this.slider.tick
            }

            set tick(value) {
                this.slider.tick = value
            }
        }

        Laya.ILaya.regClass(ScrollBar), Laya.ClassUtils.regClass("laya.ui.ScrollBar", ScrollBar), Laya.ClassUtils.regClass("Laya.ScrollBar", ScrollBar);

        class VScrollBar extends ScrollBar {
        }

        Laya.ILaya.regClass(VScrollBar), Laya.ClassUtils.regClass("laya.ui.VScrollBar", VScrollBar), Laya.ClassUtils.regClass("Laya.VScrollBar", VScrollBar);

        class HScrollBar extends ScrollBar {
            initialize() {
                super.initialize(), this.slider.isVertical = !1
            }
        }

        Laya.ILaya.regClass(HScrollBar), Laya.ClassUtils.regClass("laya.ui.HScrollBar", HScrollBar), Laya.ClassUtils.regClass("Laya.HScrollBar", HScrollBar);

        class List extends Box {
            constructor() {
                super(...arguments), this.selectEnable = !1, this.totalPage = 0, this._$componentType = "List", this._repeatX = 0, this._repeatY = 0, this._repeatX2 = 0, this._repeatY2 = 0, this._spaceX = 0, this._spaceY = 0, this._cells = [], this._startIndex = 0, this._selectedIndex = -1, this._page = 0, this._isVertical = !0, this._cellSize = 20, this._cellOffset = 0, this._createdLine = 0, this._offset = new Laya.Point, this._usedCache = null, this._elasticEnabled = !1, this._preLen = 0
            }

            destroy(destroyChild = !0) {
                this._content && this._content.destroy(destroyChild), this._scrollBar && this._scrollBar.destroy(destroyChild), super.destroy(destroyChild), this._content = null, this._scrollBar = null, this._itemRender = null, this._cells = null, this._array = null, this.selectHandler = this.renderHandler = this.mouseHandler = null
            }

            createChildren() {
                this.addChild(this._content = new Box)
            }

            set cacheAs(value) {
                super.cacheAs = value, this._scrollBar && (this._usedCache = null, "none" !== value ? this._scrollBar.on(Laya.Event.START, this, this.onScrollStart) : this._scrollBar.off(Laya.Event.START, this, this.onScrollStart))
            }

            get cacheAs() {
                return super.cacheAs
            }

            onScrollStart() {
                this._usedCache || (this._usedCache = super.cacheAs), super.cacheAs = "none", this._scrollBar.once(Laya.Event.END, this, this.onScrollEnd)
            }

            onScrollEnd() {
                super.cacheAs = this._usedCache
            }

            get content() {
                return this._content
            }

            get vScrollBarSkin() {
                return this._scrollBar ? this._scrollBar.skin : null
            }

            set vScrollBarSkin(value) {
                this._removePreScrollBar();
                var scrollBar = new VScrollBar;
                scrollBar.name = "scrollBar", scrollBar.right = 0, scrollBar.skin = value, scrollBar.elasticDistance = this._elasticEnabled ? 200 : 0, this.scrollBar = scrollBar, this.addChild(scrollBar), this._setCellChanged()
            }

            _removePreScrollBar() {
                var preNode = this.removeChildByName("scrollBar");
                preNode && preNode.destroy(!0)
            }

            get hScrollBarSkin() {
                return this._scrollBar ? this._scrollBar.skin : null
            }

            set hScrollBarSkin(value) {
                this._removePreScrollBar();
                var scrollBar = new HScrollBar;
                scrollBar.name = "scrollBar", scrollBar.bottom = 0, scrollBar.skin = value, scrollBar.elasticDistance = this._elasticEnabled ? 200 : 0, this.scrollBar = scrollBar, this.addChild(scrollBar), this._setCellChanged()
            }

            get scrollBar() {
                return this._scrollBar
            }

            set scrollBar(value) {
                this._scrollBar != value && (this._scrollBar = value, value && (this._isVertical = this._scrollBar.isVertical, this.addChild(this._scrollBar), this._scrollBar.on(Laya.Event.CHANGE, this, this.onScrollBarChange)))
            }

            get itemRender() {
                return this._itemRender
            }

            set itemRender(value) {
                if (this._itemRender != value) {
                    this._itemRender = value;
                    for (var i = this._cells.length - 1; i > -1; i--) this._cells[i].destroy();
                    this._cells.length = 0, this._setCellChanged()
                }
            }

            set width(value) {
                value != this._width && (super.width = value, this._setCellChanged())
            }

            get width() {
                return super.width
            }

            set height(value) {
                value != this._height && (super.height = value, this._setCellChanged())
            }

            get height() {
                return super.height
            }

            get repeatX() {
                return this._repeatX > 0 ? this._repeatX : this._repeatX2 > 0 ? this._repeatX2 : 1
            }

            set repeatX(value) {
                this._repeatX = value, this._setCellChanged()
            }

            get repeatY() {
                return this._repeatY > 0 ? this._repeatY : this._repeatY2 > 0 ? this._repeatY2 : 1
            }

            set repeatY(value) {
                this._repeatY = value, this._setCellChanged()
            }

            get spaceX() {
                return this._spaceX
            }

            set spaceX(value) {
                this._spaceX = value, this._setCellChanged()
            }

            get spaceY() {
                return this._spaceY
            }

            set spaceY(value) {
                this._spaceY = value, this._setCellChanged()
            }

            changeCells() {
                if (this._cellChanged = !1, this._itemRender) {
                    this.scrollBar = this.getChildByName("scrollBar");
                    var cell = this._getOneCell(), cellWidth = cell.width + this._spaceX || 1,
                        cellHeight = cell.height + this._spaceY || 1;
                    this._width > 0 && (this._repeatX2 = this._isVertical ? Math.round(this._width / cellWidth) : Math.ceil(this._width / cellWidth)), this._height > 0 && (this._repeatY2 = this._isVertical ? Math.ceil(this._height / cellHeight) : Math.round(this._height / cellHeight));
                    var listWidth = this._width ? this._width : cellWidth * this.repeatX - this._spaceX,
                        listHeight = this._height ? this._height : cellHeight * this.repeatY - this._spaceY;
                    this._cellSize = this._isVertical ? cellHeight : cellWidth, this._cellOffset = this._isVertical ? cellHeight * Math.max(this._repeatY2, this._repeatY) - listHeight - this._spaceY : cellWidth * Math.max(this._repeatX2, this._repeatX) - listWidth - this._spaceX, this._isVertical && this.vScrollBarSkin ? this._scrollBar.height = listHeight : !this._isVertical && this.hScrollBarSkin && (this._scrollBar.width = listWidth), this.setContentSize(listWidth, listHeight);
                    var numX = this._isVertical ? this.repeatX : this.repeatY,
                        numY = (this._isVertical ? this.repeatY : this.repeatX) + (this._scrollBar ? 1 : 0);
                    this._createItems(0, numX, numY), this._createdLine = numY, this._array && (this.array = this._array, this.runCallLater(this.renderItems))
                }
            }

            _getOneCell() {
                if (0 === this._cells.length) {
                    var item = this.createItem();
                    if (this._offset.setTo(item._x, item._y), this.cacheContent) return item;
                    this._cells.push(item)
                }
                return this._cells[0]
            }

            _createItems(startY, numX, numY) {
                var box = this._content, cell = this._getOneCell(), cellWidth = cell.width + this._spaceX,
                    cellHeight = cell.height + this._spaceY;
                if (this.cacheContent) {
                    var cacheBox = new Box;
                    cacheBox.cacheAs = "normal", cacheBox.pos((this._isVertical ? 0 : startY) * cellWidth, (this._isVertical ? startY : 0) * cellHeight), this._content.addChild(cacheBox), box = cacheBox
                } else {
                    for (var arr = [], i = this._cells.length - 1; i > -1; i--) {
                        var item = this._cells[i];
                        item.removeSelf(), arr.push(item)
                    }
                    this._cells.length = 0
                }
                for (var k = startY; k < numY; k++) for (var l = 0; l < numX; l++) (cell = arr && arr.length ? arr.pop() : this.createItem()).x = (this._isVertical ? l : k) * cellWidth - box._x, cell.y = (this._isVertical ? k : l) * cellHeight - box._y, cell.name = "item" + (k * numX + l), box.addChild(cell), this.addCell(cell)
            }

            createItem() {
                var arr = [];
                if ("function" == typeof this._itemRender) var box = new this._itemRender; else box = Laya.SceneUtils.createComp(this._itemRender, null, null, arr);
                if (0 == arr.length && box._watchMap) {
                    var watchMap = box._watchMap;
                    for (var name in watchMap) for (var a = watchMap[name], i = 0; i < a.length; i++) {
                        var watcher = a[i];
                        arr.push(watcher.comp, watcher.prop, watcher.value)
                    }
                }
                return arr.length && (box._$bindData = arr), box
            }

            addCell(cell) {
                cell.on(Laya.Event.CLICK, this, this.onCellMouse), cell.on(Laya.Event.RIGHT_CLICK, this, this.onCellMouse), cell.on(Laya.Event.MOUSE_OVER, this, this.onCellMouse), cell.on(Laya.Event.MOUSE_OUT, this, this.onCellMouse), cell.on(Laya.Event.MOUSE_DOWN, this, this.onCellMouse), cell.on(Laya.Event.MOUSE_UP, this, this.onCellMouse), this._cells.push(cell)
            }

            _afterInited() {
                this.initItems()
            }

            initItems() {
                if (!this._itemRender && null != this.getChildByName("item0")) {
                    var count;
                    this.repeatX = 1, count = 0;
                    for (var i = 0; i < 1e4; i++) {
                        var cell = this.getChildByName("item" + i);
                        if (!cell) break;
                        this.addCell(cell), count++
                    }
                    this.repeatY = count
                }
            }

            setContentSize(width, height) {
                this._content.width = width, this._content.height = height, (this._scrollBar || 0 != this._offset.x || 0 != this._offset.y) && (this._content._style.scrollRect || (this._content.scrollRect = Laya.Rectangle.create()), this._content._style.scrollRect.setTo(-this._offset.x, -this._offset.y, width, height), this._content.scrollRect = this._content.scrollRect), this.event(Laya.Event.RESIZE)
            }

            onCellMouse(e) {
                e.type === Laya.Event.MOUSE_DOWN && (this._isMoved = !1);
                var cell = e.currentTarget, index = this._startIndex + this._cells.indexOf(cell);
                index < 0 || (e.type === Laya.Event.CLICK || e.type === Laya.Event.RIGHT_CLICK ? this.selectEnable && !this._isMoved ? this.selectedIndex = index : this.changeCellState(cell, !0, 0) : e.type !== Laya.Event.MOUSE_OVER && e.type !== Laya.Event.MOUSE_OUT || this._selectedIndex === index || this.changeCellState(cell, e.type === Laya.Event.MOUSE_OVER, 0), this.mouseHandler && this.mouseHandler.runWith([e, index]))
            }

            changeCellState(cell, visible, index) {
                var selectBox = cell.getChildByName("selectBox");
                selectBox && (this.selectEnable = !0, selectBox.visible = visible, selectBox.index = index)
            }

            _sizeChanged() {
                super._sizeChanged(), this.setContentSize(this.width, this.height), this._scrollBar && this.callLater(this.onScrollBarChange)
            }

            onScrollBarChange(e = null) {
                this.runCallLater(this.changeCells);
                var scrollValue = this._scrollBar.value, lineX = this._isVertical ? this.repeatX : this.repeatY,
                    lineY = this._isVertical ? this.repeatY : this.repeatX,
                    scrollLine = Math.floor(scrollValue / this._cellSize);
                if (this.cacheContent) num = lineY + 1, this._createdLine - scrollLine < num && (this._createItems(this._createdLine, lineX, this._createdLine + num), this.renderItems(this._createdLine * lineX, 0), this._createdLine += num); else {
                    var index = scrollLine * lineX, num = 0;
                    if (index > this._startIndex) {
                        num = index - this._startIndex;
                        var down = !0, toIndex = this._startIndex + lineX * (lineY + 1);
                        this._isMoved = !0
                    } else index < this._startIndex && (num = this._startIndex - index, down = !1, toIndex = this._startIndex - 1, this._isMoved = !0);
                    for (var i = 0; i < num; i++) {
                        if (down) {
                            var cell = this._cells.shift();
                            this._cells[this._cells.length] = cell;
                            var cellIndex = toIndex + i
                        } else cell = this._cells.pop(), this._cells.unshift(cell), cellIndex = toIndex - i;
                        var pos = Math.floor(cellIndex / lineX) * this._cellSize;
                        this._isVertical ? cell.y = pos : cell.x = pos, this.renderItem(cell, cellIndex)
                    }
                    this._startIndex = index, this.changeSelectStatus()
                }
                var r = this._content._style.scrollRect;
                this._isVertical ? (r.y = scrollValue - this._offset.y, r.x = -this._offset.x) : (r.y = -this._offset.y, r.x = scrollValue - this._offset.x), this._content.scrollRect = r
            }

            posCell(cell, cellIndex) {
                if (this._scrollBar) {
                    var lineX = this._isVertical ? this.repeatX : this.repeatY,
                        pos = (this._isVertical ? this.repeatY : this.repeatX, Math.floor(cellIndex / lineX) * this._cellSize);
                    this._isVertical ? cell._y = pos : cell.x = pos
                }
            }

            get selectedIndex() {
                return this._selectedIndex
            }

            set selectedIndex(value) {
                this._selectedIndex != value && (this._selectedIndex = value, this.changeSelectStatus(), this.event(Laya.Event.CHANGE), this.selectHandler && this.selectHandler.runWith(value), this.startIndex = this._startIndex)
            }

            changeSelectStatus() {
                for (var i = 0, n = this._cells.length; i < n; i++) this.changeCellState(this._cells[i], this._selectedIndex === this._startIndex + i, 1)
            }

            get selectedItem() {
                return -1 != this._selectedIndex ? this._array[this._selectedIndex] : null
            }

            set selectedItem(value) {
                this.selectedIndex = this._array.indexOf(value)
            }

            get selection() {
                return this.getCell(this._selectedIndex)
            }

            set selection(value) {
                this.selectedIndex = this._startIndex + this._cells.indexOf(value)
            }

            get startIndex() {
                return this._startIndex
            }

            set startIndex(value) {
                this._startIndex = value > 0 ? value : 0, this.callLater(this.renderItems)
            }

            renderItems(from = 0, to = 0) {
                for (var i = from, n = to || this._cells.length; i < n; i++) this.renderItem(this._cells[i], this._startIndex + i);
                this.changeSelectStatus()
            }

            renderItem(cell, index) {
                this._array && index >= 0 && index < this._array.length ? (cell.visible = !0, cell._$bindData ? (cell._dataSource = this._array[index], this._bindData(cell, this._array[index])) : cell.dataSource = this._array[index], this.cacheContent || this.posCell(cell, index), this.hasListener(Laya.Event.RENDER) && this.event(Laya.Event.RENDER, [cell, index]), this.renderHandler && this.renderHandler.runWith([cell, index])) : (cell.visible = !1, cell.dataSource = null)
            }

            _bindData(cell, data) {
                for (var arr = cell._$bindData, i = 0, n = arr.length; i < n; i++) {
                    var ele = arr[i++], prop = arr[i++], value = arr[i], fun = UIUtils.getBindFun(value);
                    ele[prop] = fun.call(this, data)
                }
            }

            get array() {
                return this._array
            }

            set array(value) {
                this.runCallLater(this.changeCells), this._array = value || [], this._preLen = this._array.length;
                var length = this._array.length;
                if (this.totalPage = Math.ceil(length / (this.repeatX * this.repeatY)), this._selectedIndex = this._selectedIndex < length ? this._selectedIndex : length - 1, this.startIndex = this._startIndex, this._scrollBar) {
                    this._scrollBar.stopScroll();
                    var numX = this._isVertical ? this.repeatX : this.repeatY,
                        numY = this._isVertical ? this.repeatY : this.repeatX, lineCount = Math.ceil(length / numX);
                    (this._cellOffset > 0 ? this.totalPage + 1 : this.totalPage) > 1 && lineCount >= numY ? (this._scrollBar.scrollSize = this._cellSize, this._scrollBar.thumbPercent = numY / lineCount, this._scrollBar.setScroll(0, (lineCount - numY) * this._cellSize + this._cellOffset, this._scrollBar.value), this._scrollBar.target = this._content) : (this._scrollBar.setScroll(0, 0, 0), this._scrollBar.target = this._content)
                }
            }

            updateArray(array) {
                var freshStart;
                if (this._array = array, this._array && ((freshStart = this._preLen - this._startIndex) >= 0 && this.renderItems(freshStart), this._preLen = this._array.length), this._scrollBar) {
                    var length = array.length, numX = this._isVertical ? this.repeatX : this.repeatY,
                        numY = this._isVertical ? this.repeatY : this.repeatX, lineCount = Math.ceil(length / numX);
                    lineCount >= numY && (this._scrollBar.thumbPercent = numY / lineCount, this._scrollBar.slider._max = (lineCount - numY) * this._cellSize + this._cellOffset)
                }
            }

            get page() {
                return this._page
            }

            set page(value) {
                this._page = value, this._array && (this._page = value > 0 ? value : 0, this._page = this._page < this.totalPage ? this._page : this.totalPage - 1, this.startIndex = this._page * this.repeatX * this.repeatY)
            }

            get length() {
                return this._array ? this._array.length : 0
            }

            set dataSource(value) {
                this._dataSource = value, "number" == typeof value || "string" == typeof value ? this.selectedIndex = parseInt(value) : value instanceof Array ? this.array = value : super.dataSource = value
            }

            get dataSource() {
                return super.dataSource
            }

            get cells() {
                return this.runCallLater(this.changeCells), this._cells
            }

            get elasticEnabled() {
                return this._elasticEnabled
            }

            set elasticEnabled(value) {
                this._elasticEnabled = value, this._scrollBar && (this._scrollBar.elasticDistance = value ? 200 : 0)
            }

            refresh() {
                this.array = this._array
            }

            getItem(index) {
                return index > -1 && index < this._array.length ? this._array[index] : null
            }

            changeItem(index, source) {
                index > -1 && index < this._array.length && (this._array[index] = source, index >= this._startIndex && index < this._startIndex + this._cells.length && this.renderItem(this.getCell(index), index))
            }

            setItem(index, source) {
                this.changeItem(index, source)
            }

            addItem(souce) {
                this._array.push(souce), this.array = this._array
            }

            addItemAt(souce, index) {
                this._array.splice(index, 0, souce), this.array = this._array
            }

            deleteItem(index) {
                this._array.splice(index, 1), this.array = this._array
            }

            getCell(index) {
                return this.runCallLater(this.changeCells), index > -1 && this._cells ? this._cells[(index - this._startIndex) % this._cells.length] : null
            }

            scrollTo(index) {
                if (this._scrollBar) {
                    var numX = this._isVertical ? this.repeatX : this.repeatY;
                    this._scrollBar.value = Math.floor(index / numX) * this._cellSize
                } else this.startIndex = index
            }

            tweenTo(index, time = 200, complete = null) {
                if (this._scrollBar) {
                    this._scrollBar.stopScroll();
                    var numX = this._isVertical ? this.repeatX : this.repeatY;
                    Laya.Tween.to(this._scrollBar, {value: Math.floor(index / numX) * this._cellSize}, time, null, complete, 0, !0)
                } else this.startIndex = index, complete && complete.run()
            }

            _setCellChanged() {
                this._cellChanged || (this._cellChanged = !0, this.callLater(this.changeCells))
            }

            commitMeasure() {
                this.runCallLater(this.changeCells)
            }
        }

        Laya.ILaya.regClass(List), Laya.ClassUtils.regClass("laya.ui.List", List), Laya.ClassUtils.regClass("Laya.List", List);

        class ComboBox extends UIComponent {
            constructor(skin = null, labels = null) {
                super(), this._visibleNum = 6, this._itemColors = Styles.comboBoxItemColors, this._itemSize = 12, this._labels = [], this._selectedIndex = -1, this.itemRender = null, this.skin = skin, this.labels = labels
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._button && this._button.destroy(destroyChild), this._list && this._list.destroy(destroyChild), this._button = null, this._list = null, this._itemColors = null, this._labels = null, this._selectHandler = null
            }

            createChildren() {
                this.addChild(this._button = new Button), this._button.text.align = "left", this._button.labelPadding = "0,0,0,5", this._button.on(Laya.Event.MOUSE_DOWN, this, this.onButtonMouseDown)
            }

            _createList() {
                this._list = new List, this._scrollBarSkin && (this._list.vScrollBarSkin = this._scrollBarSkin), this._setListEvent(this._list)
            }

            _setListEvent(list) {
                this._list.selectEnable = !0, this._list.on(Laya.Event.MOUSE_DOWN, this, this.onListDown), this._list.mouseHandler = Laya.Handler.create(this, this.onlistItemMouse, null, !1), this._list.scrollBar && this._list.scrollBar.on(Laya.Event.MOUSE_DOWN, this, this.onScrollBarDown)
            }

            onListDown(e) {
                e.stopPropagation()
            }

            onScrollBarDown(e) {
                e.stopPropagation()
            }

            onButtonMouseDown(e) {
                this.callLater(this.switchTo, [!this._isOpen])
            }

            get skin() {
                return this._button.skin
            }

            set skin(value) {
                this._button.skin != value && (this._button.skin = value, this._listChanged = !0)
            }

            measureWidth() {
                return this._button.width
            }

            measureHeight() {
                return this._button.height
            }

            changeList() {
                this._listChanged = !1;
                var labelWidth = this.width - 2, labelColor = this._itemColors[2];
                this._itemHeight = this._itemSize + 6, this._list.itemRender = this.itemRender || {
                    type: "Box",
                    child: [{
                        type: "Label",
                        props: {
                            name: "label",
                            x: 1,
                            padding: "3,3,3,3",
                            width: labelWidth,
                            height: this._itemHeight,
                            fontSize: this._itemSize,
                            color: labelColor
                        }
                    }]
                }, this._list.repeatY = this._visibleNum, this._list.refresh()
            }

            onlistItemMouse(e, index) {
                var type = e.type;
                if (type === Laya.Event.MOUSE_OVER || type === Laya.Event.MOUSE_OUT) {
                    if (this._isCustomList) return;
                    var box = this._list.getCell(index);
                    if (!box) return;
                    var label = box.getChildByName("label");
                    label && (type === Laya.Event.ROLL_OVER ? (label.bgColor = this._itemColors[0], label.color = this._itemColors[1]) : (label.bgColor = null, label.color = this._itemColors[2]))
                } else type === Laya.Event.CLICK && (this.selectedIndex = index, this.isOpen = !1)
            }

            switchTo(value) {
                this.isOpen = value
            }

            changeOpen() {
                this.isOpen = !this._isOpen
            }

            set width(value) {
                super.width = value, this._button.width = this._width, this._itemChanged = !0, this._listChanged = !0
            }

            get width() {
                return super.width
            }

            set height(value) {
                super.height = value, this._button.height = this._height
            }

            get height() {
                return super.height
            }

            get labels() {
                return this._labels.join(",")
            }

            set labels(value) {
                this._labels.length > 0 && (this.selectedIndex = -1), value ? this._labels = value.split(",") : this._labels.length = 0, this._itemChanged = !0
            }

            changeItem() {
                if (this._itemChanged = !1, this._listHeight = this._labels.length > 0 ? Math.min(this._visibleNum, this._labels.length) * this._itemHeight : this._itemHeight, !this._isCustomList) {
                    var g = this._list.graphics;
                    g.clear(!0), g.drawRect(0, 0, this.width - 1, this._listHeight, this._itemColors[4], this._itemColors[3])
                }
                var a = this._list.array || [];
                a.length = 0;
                for (var i = 0, n = this._labels.length; i < n; i++) a.push({label: this._labels[i]});
                this._list.height = this._listHeight, this._list.array = a
            }

            get selectedIndex() {
                return this._selectedIndex
            }

            set selectedIndex(value) {
                this._selectedIndex != value && (this._selectedIndex = value, this._labels.length > 0 ? this.changeSelected() : this.callLater(this.changeSelected), this.event(Laya.Event.CHANGE, [Laya.Event.EMPTY.setTo(Laya.Event.CHANGE, this, this)]), this._selectHandler && this._selectHandler.runWith(this._selectedIndex))
            }

            changeSelected() {
                this._button.label = this.selectedLabel
            }

            get selectHandler() {
                return this._selectHandler
            }

            set selectHandler(value) {
                this._selectHandler = value
            }

            get selectedLabel() {
                return this._selectedIndex > -1 && this._selectedIndex < this._labels.length ? this._labels[this._selectedIndex] : null
            }

            set selectedLabel(value) {
                this.selectedIndex = this._labels.indexOf(value)
            }

            get visibleNum() {
                return this._visibleNum
            }

            set visibleNum(value) {
                this._visibleNum = value, this._listChanged = !0
            }

            get itemColors() {
                return String(this._itemColors)
            }

            set itemColors(value) {
                this._itemColors = UIUtils.fillArray(this._itemColors, value, String), this._listChanged = !0
            }

            get itemSize() {
                return this._itemSize
            }

            set itemSize(value) {
                this._itemSize = value, this._listChanged = !0
            }

            get isOpen() {
                return this._isOpen
            }

            set isOpen(value) {
                if (this._isOpen != value) if (this._isOpen = value, this._button.selected = this._isOpen, this._isOpen) {
                    this._list || this._createList(), this._listChanged && !this._isCustomList && this.changeList(), this._itemChanged && this.changeItem();
                    var p = this.localToGlobal(Laya.Point.TEMP.setTo(0, 0)), py = p.y + this._button.height;
                    py = py + this._listHeight <= Laya.ILaya.stage.height ? py : p.y - this._listHeight, this._list.pos(p.x, py), this._list.zOrder = 1001, Laya.ILaya.stage.addChild(this._list), Laya.ILaya.stage.once(Laya.Event.MOUSE_DOWN, this, this.removeList), Laya.ILaya.stage.on(Laya.Event.MOUSE_WHEEL, this, this._onStageMouseWheel), this._list.selectedIndex = this._selectedIndex
                } else this._list && this._list.removeSelf()
            }

            _onStageMouseWheel(e) {
                this._list && !this._list.contains(e.target) && this.removeList(null)
            }

            removeList(e) {
                Laya.ILaya.stage.off(Laya.Event.MOUSE_DOWN, this, this.removeList), Laya.ILaya.stage.off(Laya.Event.MOUSE_WHEEL, this, this._onStageMouseWheel), this.isOpen = !1
            }

            get scrollBarSkin() {
                return this._scrollBarSkin
            }

            set scrollBarSkin(value) {
                this._scrollBarSkin = value
            }

            get sizeGrid() {
                return this._button.sizeGrid
            }

            set sizeGrid(value) {
                this._button.sizeGrid = value
            }

            get scrollBar() {
                return this.list.scrollBar
            }

            get button() {
                return this._button
            }

            get list() {
                return this._list || this._createList(), this._list
            }

            set list(value) {
                value && (value.removeSelf(), this._isCustomList = !0, this._list = value, this._setListEvent(value), this._itemHeight = value.getCell(0).height + value.spaceY)
            }

            set dataSource(value) {
                this._dataSource = value, "number" == typeof value || "string" == typeof value ? this.selectedIndex = parseInt(value) : value instanceof Array ? this.labels = value.join(",") : super.dataSource = value
            }

            get dataSource() {
                return super.dataSource
            }

            get labelColors() {
                return this._button.labelColors
            }

            set labelColors(value) {
                this._button.labelColors != value && (this._button.labelColors = value)
            }

            get labelPadding() {
                return this._button.text.padding.join(",")
            }

            set labelPadding(value) {
                this._button.text.padding = UIUtils.fillArray(Styles.labelPadding, value, Number)
            }

            get labelSize() {
                return this._button.text.fontSize
            }

            set labelSize(value) {
                this._button.text.fontSize = value
            }

            get labelBold() {
                return this._button.text.bold
            }

            set labelBold(value) {
                this._button.text.bold = value
            }

            get labelFont() {
                return this._button.text.font
            }

            set labelFont(value) {
                this._button.text.font = value
            }

            get stateNum() {
                return this._button.stateNum
            }

            set stateNum(value) {
                this._button.stateNum = value
            }
        }

        Laya.ILaya.regClass(ComboBox), Laya.ClassUtils.regClass("laya.ui.ComboBox", ComboBox), Laya.ClassUtils.regClass("Laya.ComboBox", ComboBox);

        class ProgressBar extends UIComponent {
            constructor(skin = null) {
                super(), this._value = .5, this.skin = skin
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._bg && this._bg.destroy(destroyChild), this._bar && this._bar.destroy(destroyChild), this._bg = this._bar = null, this.changeHandler = null
            }

            createChildren() {
                this.addChild(this._bg = new Image), this.addChild(this._bar = new Image), this._bar._bitmap.autoCacheCmd = !1
            }

            get skin() {
                return this._skin
            }

            set skin(value) {
                this._skin != value && (this._skin = value, this._skin && !Laya.Loader.getRes(this._skin) ? Laya.ILaya.loader.load(this._skin, Laya.Handler.create(this, this._skinLoaded), null, Laya.Loader.IMAGE, 1) : this._skinLoaded())
            }

            _skinLoaded() {
                this._bg.skin = this._skin, this._bar.skin = this._skin.replace(".png", "$bar.png"), this.callLater(this.changeValue), this._sizeChanged(), this.event(Laya.Event.LOADED)
            }

            measureWidth() {
                return this._bg.width
            }

            measureHeight() {
                return this._bg.height
            }

            get value() {
                return this._value
            }

            set value(num) {
                this._value != num && (num = num > 1 ? 1 : num < 0 ? 0 : num, this._value = num, this.callLater(this.changeValue), this.event(Laya.Event.CHANGE), this.changeHandler && this.changeHandler.runWith(num))
            }

            changeValue() {
                if (this.sizeGrid) {
                    var grid = this.sizeGrid.split(","), left = Number(grid[3]), right = Number(grid[1]),
                        sw = (this.width - left - right) * this._value;
                    this._bar.width = left + right + sw, this._bar.visible = this._bar.width > left + right
                } else this._bar.width = this.width * this._value
            }

            get bar() {
                return this._bar
            }

            get bg() {
                return this._bg
            }

            get sizeGrid() {
                return this._bg.sizeGrid
            }

            set sizeGrid(value) {
                this._bg.sizeGrid = this._bar.sizeGrid = value
            }

            set width(value) {
                super.width = value, this._bg.width = this._width, this.callLater(this.changeValue)
            }

            get width() {
                return super.width
            }

            set height(value) {
                super.height = value, this._bg.height = this._height, this._bar.height = this._height
            }

            get height() {
                return super.height
            }

            set dataSource(value) {
                this._dataSource = value, "number" == typeof value || "string" == typeof value ? this.value = Number(value) : super.dataSource = value
            }

            get dataSource() {
                return super.dataSource
            }
        }

        Laya.ILaya.regClass(ProgressBar), Laya.ClassUtils.regClass("laya.ui.ProgressBar", ProgressBar), Laya.ClassUtils.regClass("Laya.ProgressBar", ProgressBar);

        class Radio extends Button {
            constructor(skin = null, label = "") {
                super(skin, label), this.toggle = !1, this._autoSize = !1
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._value = null
            }

            preinitialize() {
                super.preinitialize(), this.toggle = !1, this._autoSize = !1
            }

            initialize() {
                super.initialize(), this.createText(), this._text.align = "left", this._text.valign = "top", this._text.width = 0, this.on(Laya.Event.CLICK, this, this.onClick)
            }

            onClick(e) {
                this.selected = !0
            }

            get value() {
                return null != this._value ? this._value : this.label
            }

            set value(obj) {
                this._value = obj
            }
        }

        Laya.ILaya.regClass(Radio), Laya.ClassUtils.regClass("laya.ui.Radio", Radio), Laya.ClassUtils.regClass("Laya.Radio", Radio);

        class UIGroup extends Box {
            constructor(labels = null, skin = null) {
                super(), this._selectedIndex = -1, this._direction = "horizontal", this._space = 0, this.skin = skin, this.labels = labels
            }

            preinitialize() {
                this.mouseEnabled = !0
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._items && (this._items.length = 0), this._items = null, this.selectHandler = null
            }

            addItem(item, autoLayOut = !0) {
                var display = item, index = this._items.length;
                if (display.name = "item" + index, this.addChild(display), this.initItems(), autoLayOut && index > 0) {
                    var preItem = this._items[index - 1];
                    "horizontal" == this._direction ? display.x = preItem._x + preItem.width + this._space : display.y = preItem._y + preItem.height + this._space
                } else autoLayOut && (display.x = 0, display.y = 0);
                return index
            }

            delItem(item, autoLayOut = !0) {
                var index = this._items.indexOf(item);
                if (-1 != index) {
                    var newIndex, display = item;
                    this.removeChild(display);
                    for (var i = index + 1, n = this._items.length; i < n; i++) {
                        var child = this._items[i];
                        child.name = "item" + (i - 1), autoLayOut && ("horizontal" == this._direction ? child.x -= display.width + this._space : child.y -= display.height + this._space)
                    }
                    if (this.initItems(), this._selectedIndex > -1) newIndex = this._selectedIndex < this._items.length ? this._selectedIndex : this._selectedIndex - 1, this._selectedIndex = -1, this.selectedIndex = newIndex
                }
            }

            _afterInited() {
                this.initItems()
            }

            initItems() {
                this._items || (this._items = []), this._items.length = 0;
                for (var i = 0; i < 1e4; i++) {
                    var item = this.getChildByName("item" + i);
                    if (null == item) break;
                    this._items.push(item), item.selected = i === this._selectedIndex, item.clickHandler = Laya.Handler.create(this, this.itemClick, [i], !1)
                }
            }

            itemClick(index) {
                this.selectedIndex = index
            }

            get selectedIndex() {
                return this._selectedIndex
            }

            set selectedIndex(value) {
                this._selectedIndex != value && (this.setSelect(this._selectedIndex, !1), this._selectedIndex = value, this.setSelect(value, !0), this.event(Laya.Event.CHANGE), this.selectHandler && this.selectHandler.runWith(this._selectedIndex))
            }

            setSelect(index, selected) {
                this._items && index > -1 && index < this._items.length && (this._items[index].selected = selected)
            }

            get skin() {
                return this._skin
            }

            set skin(value) {
                this._skin != value && (this._skin = value, this._skin && !Laya.Loader.getRes(this._skin) ? Laya.ILaya.loader.load(this._skin, Laya.Handler.create(this, this._skinLoaded), null, Laya.Loader.IMAGE, 1) : this._skinLoaded())
            }

            _skinLoaded() {
                this._setLabelChanged(), this.event(Laya.Event.LOADED)
            }

            get labels() {
                return this._labels
            }

            set labels(value) {
                if (this._labels != value) {
                    if (this._labels = value, this.removeChildren(), this._setLabelChanged(), this._labels) for (var a = this._labels.split(","), i = 0, n = a.length; i < n; i++) {
                        var item = this.createItem(this._skin, a[i]);
                        item.name = "item" + i, this.addChild(item)
                    }
                    this.initItems()
                }
            }

            createItem(skin, label) {
                return null
            }

            get labelColors() {
                return this._labelColors
            }

            set labelColors(value) {
                this._labelColors != value && (this._labelColors = value, this._setLabelChanged())
            }

            get labelStroke() {
                return this._labelStroke
            }

            set labelStroke(value) {
                this._labelStroke != value && (this._labelStroke = value, this._setLabelChanged())
            }

            get labelStrokeColor() {
                return this._labelStrokeColor
            }

            set labelStrokeColor(value) {
                this._labelStrokeColor != value && (this._labelStrokeColor = value, this._setLabelChanged())
            }

            get strokeColors() {
                return this._strokeColors
            }

            set strokeColors(value) {
                this._strokeColors != value && (this._strokeColors = value, this._setLabelChanged())
            }

            get labelSize() {
                return this._labelSize
            }

            set labelSize(value) {
                this._labelSize != value && (this._labelSize = value, this._setLabelChanged())
            }

            get stateNum() {
                return this._stateNum
            }

            set stateNum(value) {
                this._stateNum != value && (this._stateNum = value, this._setLabelChanged())
            }

            get labelBold() {
                return this._labelBold
            }

            set labelBold(value) {
                this._labelBold != value && (this._labelBold = value, this._setLabelChanged())
            }

            get labelFont() {
                return this._labelFont
            }

            set labelFont(value) {
                this._labelFont != value && (this._labelFont = value, this._setLabelChanged())
            }

            get labelPadding() {
                return this._labelPadding
            }

            set labelPadding(value) {
                this._labelPadding != value && (this._labelPadding = value, this._setLabelChanged())
            }

            get direction() {
                return this._direction
            }

            set direction(value) {
                this._direction = value, this._setLabelChanged()
            }

            get space() {
                return this._space
            }

            set space(value) {
                this._space = value, this._setLabelChanged()
            }

            changeLabels() {
                if (this._labelChanged = !1, this._items) for (var left = 0, i = 0, n = this._items.length; i < n; i++) {
                    var btn = this._items[i];
                    this._skin && (btn.skin = this._skin), this._labelColors && (btn.labelColors = this._labelColors), this._labelSize && (btn.labelSize = this._labelSize), this._labelStroke && (btn.labelStroke = this._labelStroke), this._labelStrokeColor && (btn.labelStrokeColor = this._labelStrokeColor), this._strokeColors && (btn.strokeColors = this._strokeColors), this._labelBold && (btn.labelBold = this._labelBold), this._labelPadding && (btn.labelPadding = this._labelPadding), this._labelAlign && (btn.labelAlign = this._labelAlign), this._stateNum && (btn.stateNum = this._stateNum), this._labelFont && (btn.labelFont = this._labelFont), "horizontal" === this._direction ? (btn.y = 0, btn.x = left, left += btn.width + this._space) : (btn.x = 0, btn.y = left, left += btn.height + this._space)
                }
                this._sizeChanged()
            }

            commitMeasure() {
                this.runCallLater(this.changeLabels)
            }

            get items() {
                return this._items
            }

            get selection() {
                return this._selectedIndex > -1 && this._selectedIndex < this._items.length ? this._items[this._selectedIndex] : null
            }

            set selection(value) {
                this.selectedIndex = this._items.indexOf(value)
            }

            set dataSource(value) {
                this._dataSource = value, "number" == typeof value || "string" == typeof value ? this.selectedIndex = parseInt(value) : value instanceof Array ? this.labels = value.join(",") : super.dataSource = value
            }

            get dataSource() {
                return super.dataSource
            }

            _setLabelChanged() {
                this._labelChanged || (this._labelChanged = !0, this.callLater(this.changeLabels))
            }
        }

        Laya.ILaya.regClass(UIGroup), Laya.ClassUtils.regClass("laya.ui.UIGroup", UIGroup), Laya.ClassUtils.regClass("Laya.UIGroup", UIGroup);

        class RadioGroup extends UIGroup {
            createItem(skin, label) {
                return new Radio(skin, label)
            }
        }

        Laya.ILaya.regClass(RadioGroup), Laya.ClassUtils.regClass("laya.ui.RadioGroup", RadioGroup), Laya.ClassUtils.regClass("Laya.RadioGroup", RadioGroup);

        class Tab extends UIGroup {
            createItem(skin, label) {
                return new Button(skin, label)
            }
        }

        Laya.ILaya.regClass(Tab), Laya.ClassUtils.regClass("laya.ui.Tab", Tab), Laya.ClassUtils.regClass("Laya.Tab", Tab);

        class ViewStack extends Box {
            constructor() {
                super(...arguments), this._setIndexHandler = Laya.Handler.create(this, this.setIndex, null, !1)
            }

            setItems(views) {
                this.removeChildren();
                for (var index = 0, i = 0, n = views.length; i < n; i++) {
                    var item = views[i];
                    item && (item.name = "item" + index, this.addChild(item), index++)
                }
                this.initItems()
            }

            addItem(view) {
                view.name = "item" + this._items.length, this.addChild(view), this.initItems()
            }

            _afterInited() {
                this.initItems()
            }

            initItems() {
                this._items = [];
                for (var i = 0; i < 1e4; i++) {
                    var item = this.getChildByName("item" + i);
                    if (null == item) break;
                    this._items.push(item), item.visible = i == this._selectedIndex
                }
            }

            get selectedIndex() {
                return this._selectedIndex
            }

            set selectedIndex(value) {
                this._selectedIndex != value && (this.setSelect(this._selectedIndex, !1), this._selectedIndex = value, this.setSelect(this._selectedIndex, !0))
            }

            setSelect(index, selected) {
                this._items && index > -1 && index < this._items.length && (this._items[index].visible = selected)
            }

            get selection() {
                return this._selectedIndex > -1 && this._selectedIndex < this._items.length ? this._items[this._selectedIndex] : null
            }

            set selection(value) {
                this.selectedIndex = this._items.indexOf(value)
            }

            get setIndexHandler() {
                return this._setIndexHandler
            }

            set setIndexHandler(value) {
                this._setIndexHandler = value
            }

            setIndex(index) {
                this.selectedIndex = index
            }

            get items() {
                return this._items
            }

            set dataSource(value) {
                if (this._dataSource = value, "number" == typeof value || "string" == typeof value) this.selectedIndex = parseInt(value); else for (var prop in this._dataSource) prop in this && (this[prop] = this._dataSource[prop])
            }

            get dataSource() {
                return super.dataSource
            }
        }

        Laya.ILaya.regClass(ViewStack), Laya.ClassUtils.regClass("laya.ui.ViewStack", ViewStack), Laya.ClassUtils.regClass("Laya.ViewStack", ViewStack);

        class TextInput extends Label {
            constructor(text = "") {
                super(), this.text = text, this.skin = this.skin
            }

            preinitialize() {
                this.mouseEnabled = !0
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._bg && this._bg.destroy(), this._bg = null
            }

            createChildren() {
                this.addChild(this._tf = new Laya.Input), this._tf.padding = Styles.inputLabelPadding, this._tf.on(Laya.Event.INPUT, this, this._onInput), this._tf.on(Laya.Event.ENTER, this, this._onEnter), this._tf.on(Laya.Event.BLUR, this, this._onBlur), this._tf.on(Laya.Event.FOCUS, this, this._onFocus)
            }

            _onFocus() {
                this.event(Laya.Event.FOCUS, this)
            }

            _onBlur() {
                this.event(Laya.Event.BLUR, this)
            }

            _onInput() {
                this.event(Laya.Event.INPUT, this)
            }

            _onEnter() {
                this.event(Laya.Event.ENTER, this)
            }

            initialize() {
                this.width = 128, this.height = 22
            }

            get bg() {
                return this._bg
            }

            set bg(value) {
                this.graphics = this._bg = value
            }

            get skin() {
                return this._skin
            }

            set skin(value) {
                this._skin != value && (this._skin = value, this._skin && !Laya.Loader.getRes(this._skin) ? Laya.ILaya.loader.load(this._skin, Laya.Handler.create(this, this._skinLoaded), null, Laya.Loader.IMAGE, 1) : this._skinLoaded())
            }

            _skinLoaded() {
                this._bg || (this.graphics = this._bg = new AutoBitmap), this._bg.source = Laya.Loader.getRes(this._skin), this._width && (this._bg.width = this._width), this._height && (this._bg.height = this._height), this._sizeChanged(), this.event(Laya.Event.LOADED)
            }

            get sizeGrid() {
                return this._bg && this._bg.sizeGrid ? this._bg.sizeGrid.join(",") : null
            }

            set sizeGrid(value) {
                this._bg || (this.graphics = this._bg = new AutoBitmap), this._bg.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number)
            }

            set text(value) {
                this._tf.text != value && (value += "", this._tf.text = value, this.event(Laya.Event.CHANGE))
            }

            get text() {
                return super.text
            }

            set width(value) {
                super.width = value, this._bg && (this._bg.width = value)
            }

            get width() {
                return super.width
            }

            set height(value) {
                super.height = value, this._bg && (this._bg.height = value)
            }

            get height() {
                return super.height
            }

            get multiline() {
                return this._tf.multiline
            }

            set multiline(value) {
                this._tf.multiline = value
            }

            set editable(value) {
                this._tf.editable = value
            }

            get editable() {
                return this._tf.editable
            }

            select() {
                this._tf.select()
            }

            get restrict() {
                return this._tf.restrict
            }

            set restrict(pattern) {
                this._tf.restrict = pattern
            }

            get prompt() {
                return this._tf.prompt
            }

            set prompt(value) {
                this._tf.prompt = value
            }

            get promptColor() {
                return this._tf.promptColor
            }

            set promptColor(value) {
                this._tf.promptColor = value
            }

            get maxChars() {
                return this._tf.maxChars
            }

            set maxChars(value) {
                this._tf.maxChars = value
            }

            get focus() {
                return this._tf.focus
            }

            set focus(value) {
                this._tf.focus = value
            }

            get type() {
                return this._tf.type
            }

            set type(value) {
                this._tf.type = value
            }

            setSelection(startIndex, endIndex) {
                this._tf.setSelection(startIndex, endIndex)
            }
        }

        Laya.ILaya.regClass(TextInput), Laya.ClassUtils.regClass("laya.ui.TextInput", TextInput), Laya.ClassUtils.regClass("Laya.TextInput", TextInput);

        class TextArea extends TextInput {
            constructor(text = "") {
                super(text), this.on(Laya.Event.CHANGE, this, this._onTextChange)
            }

            _onTextChange() {
                this.callLater(this.changeScroll)
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._vScrollBar && this._vScrollBar.destroy(), this._hScrollBar && this._hScrollBar.destroy(), this._vScrollBar = null, this._hScrollBar = null
            }

            initialize() {
                this.width = 180, this.height = 150, this._tf.wordWrap = !0, this.multiline = !0
            }

            set width(value) {
                super.width = value, this.callLater(this.changeScroll)
            }

            get width() {
                return super.width
            }

            set height(value) {
                super.height = value, this.callLater(this.changeScroll)
            }

            get height() {
                return super.height
            }

            get vScrollBarSkin() {
                return this._vScrollBar ? this._vScrollBar.skin : null
            }

            set vScrollBarSkin(value) {
                null == this._vScrollBar && (this.addChild(this._vScrollBar = new VScrollBar), this._vScrollBar.on(Laya.Event.CHANGE, this, this.onVBarChanged), this._vScrollBar.target = this._tf, this.callLater(this.changeScroll)), this._vScrollBar.skin = value
            }

            get hScrollBarSkin() {
                return this._hScrollBar ? this._hScrollBar.skin : null
            }

            set hScrollBarSkin(value) {
                null == this._hScrollBar && (this.addChild(this._hScrollBar = new HScrollBar), this._hScrollBar.on(Laya.Event.CHANGE, this, this.onHBarChanged), this._hScrollBar.mouseWheelEnable = !1, this._hScrollBar.target = this._tf, this.callLater(this.changeScroll)), this._hScrollBar.skin = value
            }

            onVBarChanged(e) {
                this._tf.scrollY != this._vScrollBar.value && (this._tf.scrollY = this._vScrollBar.value)
            }

            onHBarChanged(e) {
                this._tf.scrollX != this._hScrollBar.value && (this._tf.scrollX = this._hScrollBar.value)
            }

            get vScrollBar() {
                return this._vScrollBar
            }

            get hScrollBar() {
                return this._hScrollBar
            }

            get maxScrollY() {
                return this._tf.maxScrollY
            }

            get scrollY() {
                return this._tf.scrollY
            }

            get maxScrollX() {
                return this._tf.maxScrollX
            }

            get scrollX() {
                return this._tf.scrollX
            }

            changeScroll() {
                var vShow = this._vScrollBar && this._tf.maxScrollY > 0,
                    hShow = this._hScrollBar && this._tf.maxScrollX > 0,
                    showWidth = vShow ? this._width - this._vScrollBar.width : this._width,
                    showHeight = hShow ? this._height - this._hScrollBar.height : this._height,
                    padding = this._tf.padding || Styles.labelPadding;
                this._tf.width = showWidth, this._tf.height = showHeight, this._vScrollBar && (this._vScrollBar.x = this._width - this._vScrollBar.width - padding[2], this._vScrollBar.y = padding[1], this._vScrollBar.height = this._height - (hShow ? this._hScrollBar.height : 0) - padding[1] - padding[3], this._vScrollBar.scrollSize = 1, this._vScrollBar.thumbPercent = showHeight / Math.max(this._tf.textHeight, showHeight), this._vScrollBar.setScroll(1, this._tf.maxScrollY, this._tf.scrollY), this._vScrollBar.visible = vShow), this._hScrollBar && (this._hScrollBar.x = padding[0], this._hScrollBar.y = this._height - this._hScrollBar.height - padding[3], this._hScrollBar.width = this._width - (vShow ? this._vScrollBar.width : 0) - padding[0] - padding[2], this._hScrollBar.scrollSize = Math.max(.033 * showWidth, 1), this._hScrollBar.thumbPercent = showWidth / Math.max(this._tf.textWidth, showWidth), this._hScrollBar.setScroll(0, this.maxScrollX, this.scrollX), this._hScrollBar.visible = hShow)
            }

            scrollTo(y) {
                this.commitMeasure(), this._tf.scrollY = y
            }
        }

        Laya.ILaya.regClass(TextArea), Laya.ClassUtils.regClass("laya.ui.TextArea", TextArea), Laya.ClassUtils.regClass("Laya.TextArea", TextArea);

        class ScaleBox extends Box {
            constructor() {
                super(...arguments), this._oldW = 0, this._oldH = 0
            }

            onEnable() {
                Laya.ILaya.stage.on("resize", this, this.onResize), this.onResize()
            }

            onDisable() {
                Laya.ILaya.stage.off("resize", this, this.onResize)
            }

            onResize() {
                let stage = Laya.ILaya.stage;
                if (this.width > 0 && this.height > 0) {
                    var scale = Math.min(stage.width / this._oldW, stage.height / this._oldH);
                    super.width = stage.width, super.height = stage.height, this.scale(scale, scale)
                }
            }

            set width(value) {
                super.width = value, this._oldW = value
            }

            get width() {
                return super.width
            }

            set height(value) {
                super.height = value, this._oldH = value
            }

            get height() {
                return super.height
            }
        }

        Laya.ILaya.regClass(ScaleBox), Laya.ClassUtils.regClass("laya.ui.ScaleBox", ScaleBox), Laya.ClassUtils.regClass("Laya.ScaleBox", ScaleBox);

        class HSlider extends Slider {
            constructor(skin = null) {
                super(skin), this.isVertical = !1
            }
        }

        Laya.ILaya.regClass(HSlider), Laya.ClassUtils.regClass("laya.ui.HSlider", HSlider), Laya.ClassUtils.regClass("Laya.HSlider", HSlider);

        class Panel extends Box {
            constructor() {
                super(), this._usedCache = null, this._elasticEnabled = !1, this.width = this.height = 100
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._content && this._content.destroy(destroyChild), this._vScrollBar && this._vScrollBar.destroy(destroyChild), this._hScrollBar && this._hScrollBar.destroy(destroyChild), this._vScrollBar = null, this._hScrollBar = null, this._content = null
            }

            destroyChildren() {
                this._content.destroyChildren()
            }

            createChildren() {
                super.addChild(this._content = new Box)
            }

            addChild(child) {
                return child.on(Laya.Event.RESIZE, this, this.onResize), this._setScrollChanged(), this._content.addChild(child)
            }

            onResize() {
                this._setScrollChanged()
            }

            addChildAt(child, index) {
                return child.on(Laya.Event.RESIZE, this, this.onResize), this._setScrollChanged(), this._content.addChildAt(child, index)
            }

            removeChild(child) {
                return child.off(Laya.Event.RESIZE, this, this.onResize), this._setScrollChanged(), this._content.removeChild(child)
            }

            removeChildAt(index) {
                return this.getChildAt(index).off(Laya.Event.RESIZE, this, this.onResize), this._setScrollChanged(), this._content.removeChildAt(index)
            }

            removeChildren(beginIndex = 0, endIndex = 2147483647) {
                return this._content.removeChildren(beginIndex, endIndex), this._setScrollChanged(), this
            }

            getChildAt(index) {
                return this._content.getChildAt(index)
            }

            getChildByName(name) {
                return this._content.getChildByName(name)
            }

            getChildIndex(child) {
                return this._content.getChildIndex(child)
            }

            get numChildren() {
                return this._content.numChildren
            }

            changeScroll() {
                this._scrollChanged = !1;
                var contentW = this.contentWidth || 1, contentH = this.contentHeight || 1, vscroll = this._vScrollBar,
                    hscroll = this._hScrollBar, vShow = vscroll && contentH > this._height,
                    hShow = hscroll && contentW > this._width,
                    showWidth = vShow ? this._width - vscroll.width : this._width,
                    showHeight = hShow ? this._height - hscroll.height : this._height;
                vscroll && (vscroll.x = this._width - vscroll.width, vscroll.y = 0, vscroll.height = this._height - (hShow ? hscroll.height : 0), vscroll.scrollSize = Math.max(.033 * this._height, 1), vscroll.thumbPercent = showHeight / contentH, vscroll.setScroll(0, contentH - showHeight, vscroll.value)), hscroll && (hscroll.x = 0, hscroll.y = this._height - hscroll.height, hscroll.width = this._width - (vShow ? vscroll.width : 0), hscroll.scrollSize = Math.max(.033 * this._width, 1), hscroll.thumbPercent = showWidth / contentW, hscroll.setScroll(0, contentW - showWidth, hscroll.value))
            }

            _sizeChanged() {
                super._sizeChanged(), this.setContentSize(this._width, this._height)
            }

            get contentWidth() {
                for (var max = 0, i = this._content.numChildren - 1; i > -1; i--) {
                    var comp = this._content.getChildAt(i);
                    max = Math.max(comp._x + comp.width * comp.scaleX - comp.pivotX, max)
                }
                return max
            }

            get contentHeight() {
                for (var max = 0, i = this._content.numChildren - 1; i > -1; i--) {
                    var comp = this._content.getChildAt(i);
                    max = Math.max(comp._y + comp.height * comp.scaleY - comp.pivotY, max)
                }
                return max
            }

            setContentSize(width, height) {
                var content = this._content;
                content.width = width, content.height = height, content._style.scrollRect || (content.scrollRect = Laya.Rectangle.create()), content._style.scrollRect.setTo(0, 0, width, height), content.scrollRect = content.scrollRect
            }

            set width(value) {
                super.width = value, this._setScrollChanged()
            }

            get width() {
                return super.width
            }

            set height(value) {
                super.height = value, this._setScrollChanged()
            }

            get height() {
                return super.height
            }

            get vScrollBarSkin() {
                return this._vScrollBar ? this._vScrollBar.skin : null
            }

            set vScrollBarSkin(value) {
                null == this._vScrollBar && (super.addChild(this._vScrollBar = new VScrollBar), this._vScrollBar.on(Laya.Event.CHANGE, this, this.onScrollBarChange, [this._vScrollBar]), this._vScrollBar.target = this._content, this._vScrollBar.elasticDistance = this._elasticEnabled ? 200 : 0, this._setScrollChanged()), this._vScrollBar.skin = value
            }

            get hScrollBarSkin() {
                return this._hScrollBar ? this._hScrollBar.skin : null
            }

            set hScrollBarSkin(value) {
                null == this._hScrollBar && (super.addChild(this._hScrollBar = new HScrollBar), this._hScrollBar.on(Laya.Event.CHANGE, this, this.onScrollBarChange, [this._hScrollBar]), this._hScrollBar.target = this._content, this._hScrollBar.elasticDistance = this._elasticEnabled ? 200 : 0, this._setScrollChanged()), this._hScrollBar.skin = value
            }

            get vScrollBar() {
                return this._vScrollBar
            }

            get hScrollBar() {
                return this._hScrollBar
            }

            get content() {
                return this._content
            }

            onScrollBarChange(scrollBar) {
                var rect = this._content._style.scrollRect;
                if (rect) {
                    var start = Math.round(scrollBar.value);
                    scrollBar.isVertical ? rect.y = start : rect.x = start, this._content.scrollRect = rect
                }
            }

            scrollTo(x = 0, y = 0) {
                this.vScrollBar && (this.vScrollBar.value = y), this.hScrollBar && (this.hScrollBar.value = x)
            }

            refresh() {
                this.changeScroll()
            }

            set cacheAs(value) {
                super.cacheAs = value, this._usedCache = null, "none" !== value ? (this._hScrollBar && this._hScrollBar.on(Laya.Event.START, this, this.onScrollStart), this._vScrollBar && this._vScrollBar.on(Laya.Event.START, this, this.onScrollStart)) : (this._hScrollBar && this._hScrollBar.off(Laya.Event.START, this, this.onScrollStart), this._vScrollBar && this._vScrollBar.off(Laya.Event.START, this, this.onScrollStart))
            }

            get cacheAs() {
                return super.cacheAs
            }

            get elasticEnabled() {
                return this._elasticEnabled
            }

            set elasticEnabled(value) {
                this._elasticEnabled = value, this._vScrollBar && (this._vScrollBar.elasticDistance = value ? 200 : 0), this._hScrollBar && (this._hScrollBar.elasticDistance = value ? 200 : 0)
            }

            onScrollStart() {
                this._usedCache || (this._usedCache = super.cacheAs), super.cacheAs = "none", this._hScrollBar && this._hScrollBar.once(Laya.Event.END, this, this.onScrollEnd), this._vScrollBar && this._vScrollBar.once(Laya.Event.END, this, this.onScrollEnd)
            }

            onScrollEnd() {
                super.cacheAs = this._usedCache
            }

            _setScrollChanged() {
                this._scrollChanged || (this._scrollChanged = !0, this.callLater(this.changeScroll))
            }
        }

        Laya.ILaya.regClass(Panel), Laya.ClassUtils.regClass("laya.ui.Panel", Panel), Laya.ClassUtils.regClass("Laya.Panel", Panel);

        class VSlider extends Slider {
        }

        Laya.ILaya.regClass(VSlider), Laya.ClassUtils.regClass("laya.ui.VSlider", VSlider), Laya.ClassUtils.regClass("Laya.VSlider", VSlider);

        class Tree extends Box {
            constructor() {
                super(), this._spaceLeft = 10, this._spaceBottom = 0, this._keepStatus = !0, this.width = this.height = 200
            }

            destroy(destroyChild = !0) {
                super.destroy(destroyChild), this._list && this._list.destroy(destroyChild), this._list = null, this._source = null, this._renderHandler = null
            }

            createChildren() {
                this.addChild(this._list = new List), this._list.renderHandler = Laya.Handler.create(this, this.renderItem, null, !1), this._list.repeatX = 1, this._list.on(Laya.Event.CHANGE, this, this.onListChange)
            }

            onListChange(e = null) {
                this.event(Laya.Event.CHANGE)
            }

            get keepStatus() {
                return this._keepStatus
            }

            set keepStatus(value) {
                this._keepStatus = value
            }

            get array() {
                return this._list.array
            }

            set array(value) {
                this._keepStatus && this._list.array && value && this.parseOpenStatus(this._list.array, value), this._source = value, this._list.array = this.getArray()
            }

            get source() {
                return this._source
            }

            get list() {
                return this._list
            }

            get itemRender() {
                return this._list.itemRender
            }

            set itemRender(value) {
                this._list.itemRender = value
            }

            get scrollBarSkin() {
                return this._list.vScrollBarSkin
            }

            set scrollBarSkin(value) {
                this._list.vScrollBarSkin = value
            }

            get scrollBar() {
                return this._list.scrollBar
            }

            get mouseHandler() {
                return this._list.mouseHandler
            }

            set mouseHandler(value) {
                this._list.mouseHandler = value
            }

            get renderHandler() {
                return this._renderHandler
            }

            set renderHandler(value) {
                this._renderHandler = value
            }

            get spaceLeft() {
                return this._spaceLeft
            }

            set spaceLeft(value) {
                this._spaceLeft = value
            }

            get spaceBottom() {
                return this._list.spaceY
            }

            set spaceBottom(value) {
                this._list.spaceY = value
            }

            get selectedIndex() {
                return this._list.selectedIndex
            }

            set selectedIndex(value) {
                this._list.selectedIndex = value
            }

            get selectedItem() {
                return this._list.selectedItem
            }

            set selectedItem(value) {
                this._list.selectedItem = value
            }

            set width(value) {
                super.width = value, this._list.width = value
            }

            get width() {
                return super.width
            }

            set height(value) {
                super.height = value, this._list.height = value
            }

            get height() {
                return super.height
            }

            getArray() {
                var arr = [];
                for (let item of this._source) this.getParentOpenStatus(item) && (item.x = this._spaceLeft * this.getDepth(item), arr.push(item));
                return arr
            }

            getDepth(item, num = 0) {
                return null == item.nodeParent ? num : this.getDepth(item.nodeParent, num + 1)
            }

            getParentOpenStatus(item) {
                var parent = item.nodeParent;
                return null == parent || !!parent.isOpen && (null == parent.nodeParent || this.getParentOpenStatus(parent))
            }

            renderItem(cell, index) {
                var item = cell.dataSource;
                if (item) {
                    cell.left = item.x;
                    var arrow = cell.getChildByName("arrow");
                    arrow && (item.hasChild ? (arrow.visible = !0, arrow.index = item.isOpen ? 1 : 0, arrow.tag = index, arrow.off(Laya.Event.CLICK, this, this.onArrowClick), arrow.on(Laya.Event.CLICK, this, this.onArrowClick)) : arrow.visible = !1);
                    var folder = cell.getChildByName("folder");
                    folder && (2 == folder.clipY ? folder.index = item.isDirectory ? 0 : 1 : folder.index = item.isDirectory ? item.isOpen ? 1 : 0 : 2), this._renderHandler && this._renderHandler.runWith([cell, index])
                }
            }

            onArrowClick(e) {
                var index = e.currentTarget.tag;
                this._list.array[index].isOpen = !this._list.array[index].isOpen, this.event(Laya.Event.OPEN), this._list.array = this.getArray()
            }

            setItemState(index, isOpen) {
                this._list.array[index] && (this._list.array[index].isOpen = isOpen, this._list.array = this.getArray())
            }

            fresh() {
                this._list.array = this.getArray(), this.repaint()
            }

            set dataSource(value) {
                this._dataSource = value, super.dataSource = value
            }

            get dataSource() {
                return super.dataSource
            }

            set xml(value) {
                var arr = [];
                this.parseXml(value.childNodes[0], arr, null, !0), this.array = arr
            }

            parseXml(xml, source, nodeParent, isRoot) {
                var obj, list = xml.childNodes, childCount = list.length;
                if (!isRoot) {
                    obj = {};
                    var list2 = xml.attributes;
                    for (let attrs of list2) {
                        var prop = attrs.nodeName, value = attrs.nodeValue;
                        obj[prop] = "true" == value || "false" != value && value
                    }
                    obj.nodeParent = nodeParent, childCount > 0 && (obj.isDirectory = !0), obj.hasChild = childCount > 0, source.push(obj)
                }
                for (var i = 0; i < childCount; i++) {
                    var node = list[i];
                    this.parseXml(node, source, obj, !1)
                }
            }

            parseOpenStatus(oldSource, newSource) {
                for (var i = 0, n = newSource.length; i < n; i++) {
                    var newItem = newSource[i];
                    if (newItem.isDirectory) for (var j = 0, m = oldSource.length; j < m; j++) {
                        var oldItem = oldSource[j];
                        if (oldItem.isDirectory && this.isSameParent(oldItem, newItem) && newItem.label == oldItem.label) {
                            newItem.isOpen = oldItem.isOpen;
                            break
                        }
                    }
                }
            }

            isSameParent(item1, item2) {
                return null == item1.nodeParent && null == item2.nodeParent || null != item1.nodeParent && null != item2.nodeParent && (item1.nodeParent.label == item2.nodeParent.label && this.isSameParent(item1.nodeParent, item2.nodeParent))
            }

            get selectedPath() {
                return this._list.selectedItem ? this._list.selectedItem.path : null
            }

            filter(key) {
                if (Boolean(key)) {
                    var result = [];
                    this.getFilterSource(this._source, result, key), this._list.array = result
                } else this._list.array = this.getArray()
            }

            getFilterSource(array, result, key) {
                key = key.toLocaleLowerCase();
                for (let item of array) !item.isDirectory && String(item.label).toLowerCase().indexOf(key) > -1 && (item.x = 0, result.push(item)), item.child && item.child.length > 0 && this.getFilterSource(item.child, result, key)
            }
        }

        Laya.ILaya.regClass(Tree), Laya.ClassUtils.regClass("laya.ui.Tree", Tree), Laya.ClassUtils.regClass("Laya.Tree", Tree);

        class LayoutBox extends Box {
            constructor() {
                super(...arguments), this._space = 0, this._align = "none", this._itemChanged = !1
            }

            addChild(child) {
                return child.on(Laya.Event.RESIZE, this, this.onResize), this._setItemChanged(), super.addChild(child)
            }

            onResize(e) {
                this._setItemChanged()
            }

            addChildAt(child, index) {
                return child.on(Laya.Event.RESIZE, this, this.onResize), this._setItemChanged(), super.addChildAt(child, index)
            }

            removeChildAt(index) {
                return this.getChildAt(index).off(Laya.Event.RESIZE, this, this.onResize), this._setItemChanged(), super.removeChildAt(index)
            }

            refresh() {
                this._setItemChanged()
            }

            changeItems() {
                this._itemChanged = !1
            }

            get space() {
                return this._space
            }

            set space(value) {
                this._space = value, this._setItemChanged()
            }

            get align() {
                return this._align
            }

            set align(value) {
                this._align = value, this._setItemChanged()
            }

            sortItem(items) {
                items && items.sort(function (a, b) {
                    return a.y - b.y
                })
            }

            _setItemChanged() {
                this._itemChanged || (this._itemChanged = !0, this.callLater(this.changeItems))
            }
        }

        Laya.ILaya.regClass(LayoutBox), Laya.ClassUtils.regClass("laya.ui.LayoutBox", LayoutBox), Laya.ClassUtils.regClass("Laya.LayoutBox", LayoutBox);

        class HBox extends LayoutBox {
            sortItem(items) {
                items && items.sort(function (a, b) {
                    return a.x - b.x
                })
            }

            set height(value) {
                this._height != value && (super.height = value, this.callLater(this.changeItems))
            }

            get height() {
                return super.height
            }

            changeItems() {
                this._itemChanged = !1;
                for (var items = [], maxHeight = 0, i = 0, n = this.numChildren; i < n; i++) {
                    var item = this.getChildAt(i);
                    item && (items.push(item), maxHeight = this._height ? this._height : Math.max(maxHeight, item.height * item.scaleY))
                }
                this.sortItem(items);
                var left = 0;
                for (i = 0, n = items.length; i < n; i++) (item = items[i]).x = left, left += item.width * item.scaleX + this._space, this._align == HBox.TOP ? item.y = 0 : this._align == HBox.MIDDLE ? item.y = .5 * (maxHeight - item.height * item.scaleY) : this._align == HBox.BOTTOM && (item.y = maxHeight - item.height * item.scaleY);
                this._sizeChanged()
            }
        }

        HBox.NONE = "none", HBox.TOP = "top", HBox.MIDDLE = "middle", HBox.BOTTOM = "bottom", Laya.ILaya.regClass(HBox), Laya.ClassUtils.regClass("laya.ui.HBox", HBox), Laya.ClassUtils.regClass("Laya.HBox", HBox);

        class VBox extends LayoutBox {
            set width(value) {
                this._width != value && (super.width = value, this.callLater(this.changeItems))
            }

            get width() {
                return super.width
            }

            changeItems() {
                this._itemChanged = !1;
                for (var items = [], maxWidth = 0, i = 0, n = this.numChildren; i < n; i++) {
                    var item = this.getChildAt(i);
                    item && (items.push(item), maxWidth = this._width ? this._width : Math.max(maxWidth, item.width * item.scaleX))
                }
                this.sortItem(items);
                var top = 0;
                for (i = 0, n = items.length; i < n; i++) (item = items[i]).y = top, top += item.height * item.scaleY + this._space, this._align == VBox.LEFT ? item.x = 0 : this._align == VBox.CENTER ? item.x = .5 * (maxWidth - item.width * item.scaleX) : this._align == VBox.RIGHT && (item.x = maxWidth - item.width * item.scaleX);
                this._sizeChanged()
            }
        }

        VBox.NONE = "none", VBox.LEFT = "left", VBox.CENTER = "center", VBox.RIGHT = "right", Laya.ILaya.regClass(VBox), Laya.ClassUtils.regClass("laya.ui.VBox", VBox), Laya.ClassUtils.regClass("Laya.VBox", VBox);

        class FontClip extends Clip {
            constructor(skin = null, sheet = null) {
                super(), this._valueArr = "", this._indexMap = null, this._sheet = null, this._direction = "horizontal", this._spaceX = 0, this._spaceY = 0, this._align = "left", this._wordsW = 0, this._wordsH = 0, skin && (this.skin = skin), sheet && (this.sheet = sheet)
            }

            createChildren() {
                this._bitmap = new AutoBitmap, this.on(Laya.Event.LOADED, this, this._onClipLoaded)
            }

            _onClipLoaded() {
                this.callLater(this.changeValue)
            }

            get sheet() {
                return this._sheet
            }

            set sheet(value) {
                value += "", this._sheet = value;
                var arr = value.split(" ");
                this._clipX = String(arr[0]).length, this.clipY = arr.length, this._indexMap = {};
                for (var i = 0; i < this._clipY; i++) for (var line = arr[i].split(""), j = 0, n = line.length; j < n; j++) this._indexMap[line[j]] = i * this._clipX + j
            }

            get value() {
                return this._valueArr ? this._valueArr : ""
            }

            set value(value) {
                value += "", this._valueArr = value, this.callLater(this.changeValue)
            }

            get direction() {
                return this._direction
            }

            set direction(value) {
                this._direction = value, this.callLater(this.changeValue)
            }

            get spaceX() {
                return this._spaceX
            }

            set spaceX(value) {
                this._spaceX = value, "horizontal" === this._direction && this.callLater(this.changeValue)
            }

            get spaceY() {
                return this._spaceY
            }

            set spaceY(value) {
                this._spaceY = value, "horizontal" !== this._direction && this.callLater(this.changeValue)
            }

            set align(v) {
                this._align = v, this.callLater(this.changeValue)
            }

            get align() {
                return this._align
            }

            changeValue() {
                var texture;
                if (this._sources && (this._valueArr && (this.graphics.clear(!0), texture = this._sources[0]))) {
                    var isHorizontal = "horizontal" === this._direction;
                    isHorizontal ? (this._wordsW = this._valueArr.length * (texture.sourceWidth + this.spaceX), this._wordsH = texture.sourceHeight) : (this._wordsW = texture.sourceWidth, this._wordsH = (texture.sourceHeight + this.spaceY) * this._valueArr.length);
                    var dX = 0;
                    if (this._width) switch (this._align) {
                        case"center":
                            dX = .5 * (this._width - this._wordsW);
                            break;
                        case"right":
                            dX = this._width - this._wordsW;
                            break;
                        default:
                            dX = 0
                    }
                    for (var i = 0, sz = this._valueArr.length; i < sz; i++) {
                        var index = this._indexMap[this._valueArr.charAt(i)];
                        this.sources[index] && (texture = this.sources[index], isHorizontal ? this.graphics.drawImage(texture, dX + i * (texture.sourceWidth + this.spaceX), 0, texture.sourceWidth, texture.sourceHeight) : this.graphics.drawImage(texture, 0 + dX, i * (texture.sourceHeight + this.spaceY), texture.sourceWidth, texture.sourceHeight))
                    }
                    this._width || (this._widget.resetLayoutX(), this.callLater(this._sizeChanged)), this._height || (this._widget.resetLayoutY(), this.callLater(this._sizeChanged))
                }
            }

            set width(value) {
                super.width = value, this.callLater(this.changeValue)
            }

            get width() {
                return super.width
            }

            set height(value) {
                super.height = value, this.callLater(this.changeValue)
            }

            get height() {
                return super.height
            }

            measureWidth() {
                return this._wordsW
            }

            measureHeight() {
                return this._wordsH
            }

            destroy(destroyChild = !0) {
                this._valueArr = null, this._indexMap = null, this.graphics.clear(!0), this.removeSelf(), this.off(Laya.Event.LOADED, this, this._onClipLoaded), super.destroy(destroyChild)
            }
        }

        Laya.ILaya.regClass(FontClip), Laya.ClassUtils.regClass("laya.ui.FontClip", FontClip), Laya.ClassUtils.regClass("Laya.FontClip", FontClip);

        class View extends Laya.Scene {
            constructor() {
                super(!1), this._watchMap = {}, this._anchorX = NaN, this._anchorY = NaN, this._widget = Widget.EMPTY, this.createChildren()
            }

            static __init__() {
                Laya.ILaya.ClassUtils.regShortClassName([ViewStack, Button, TextArea, ColorPicker, Box, ScaleBox, CheckBox, Clip, ComboBox, UIComponent, HScrollBar, HSlider, Image, Label, List, Panel, ProgressBar, Radio, RadioGroup, ScrollBar, Slider, Tab, TextInput, View, VScrollBar, VSlider, Tree, HBox, VBox, Laya.Animation, Laya.Text, FontClip])
            }

            static regComponent(key, compClass) {
                Laya.ILaya.ClassUtils.regClass(key, compClass)
            }

            static regViewRuntime(key, compClass) {
                Laya.ILaya.ClassUtils.regClass(key, compClass)
            }

            static regUI(url, json) {
                Laya.ILaya.loader.cacheRes(url, json)
            }

            destroy(destroyChild = !0) {
                this._watchMap = null, super.destroy(destroyChild)
            }

            changeData(key) {
                var arr = this._watchMap[key];
                if (arr) for (var i = 0, n = arr.length; i < n; i++) {
                    arr[i].exe(this)
                }
            }

            get top() {
                return this._widget.top
            }

            set top(value) {
                value != this._widget.top && (this._getWidget().top = value)
            }

            get bottom() {
                return this._widget.bottom
            }

            set bottom(value) {
                value != this._widget.bottom && (this._getWidget().bottom = value)
            }

            get left() {
                return this._widget.left
            }

            set left(value) {
                value != this._widget.left && (this._getWidget().left = value)
            }

            get right() {
                return this._widget.right
            }

            set right(value) {
                value != this._widget.right && (this._getWidget().right = value)
            }

            get centerX() {
                return this._widget.centerX
            }

            set centerX(value) {
                value != this._widget.centerX && (this._getWidget().centerX = value)
            }

            get centerY() {
                return this._widget.centerY
            }

            set centerY(value) {
                value != this._widget.centerY && (this._getWidget().centerY = value)
            }

            get anchorX() {
                return this._anchorX
            }

            set anchorX(value) {
                this._anchorX != value && (this._anchorX = value, this.callLater(this._sizeChanged))
            }

            get anchorY() {
                return this._anchorY
            }

            set anchorY(value) {
                this._anchorY != value && (this._anchorY = value, this.callLater(this._sizeChanged))
            }

            _sizeChanged() {
                isNaN(this._anchorX) || (this.pivotX = this.anchorX * this.width), isNaN(this._anchorY) || (this.pivotY = this.anchorY * this.height), this.event(Laya.Event.RESIZE)
            }

            _getWidget() {
                return this._widget === Widget.EMPTY && (this._widget = this.addComponent(Widget)), this._widget
            }

            loadUI(path) {
                var uiView = View.uiMap[path];
                View.uiMap && this.createView(uiView)
            }

            get dataSource() {
                return this._dataSource
            }

            set dataSource(value) {
                for (var name in this._dataSource = value, value) {
                    var comp = this.getChildByName(name);
                    comp instanceof UIComponent ? comp.dataSource = value[name] : name in this && !(this[name] instanceof Function) && (this[name] = value[name])
                }
            }
        }

        View.uiMap = {}, Laya.ILaya.regClass(View), Laya.ClassUtils.regClass("laya.ui.View", View), Laya.ClassUtils.regClass("Laya.View", View);

        class IUI {
        }

        IUI.Dialog = null;

        class DialogManager extends Laya.Sprite {
            constructor() {
                super(), this.maskLayer = new Laya.Sprite, this.popupEffect = function (dialog) {
                    dialog.scale(1, 1), dialog._effectTween = Laya.Tween.from(dialog, {
                        x: Laya.ILaya.stage.width / 2,
                        y: Laya.ILaya.stage.height / 2,
                        scaleX: 0,
                        scaleY: 0
                    }, 300, Laya.Ease.backOut, Laya.Handler.create(this, this.doOpen, [dialog]), 0, !1, !1)
                }, this.closeEffect = function (dialog) {
                    dialog._effectTween = Laya.Tween.to(dialog, {
                        x: Laya.ILaya.stage.width / 2,
                        y: Laya.ILaya.stage.height / 2,
                        scaleX: 0,
                        scaleY: 0
                    }, 300, Laya.Ease.strongOut, Laya.Handler.create(this, this.doClose, [dialog]), 0, !1, !1)
                }, this.popupEffectHandler = new Laya.Handler(this, this.popupEffect), this.closeEffectHandler = new Laya.Handler(this, this.closeEffect), this.mouseEnabled = this.maskLayer.mouseEnabled = !0, this.zOrder = 1e3, Laya.ILaya.stage.addChild(this), Laya.ILaya.stage.on(Laya.Event.RESIZE, this, this._onResize), UIConfig.closeDialogOnSide && this.maskLayer.on("click", this, this._closeOnSide), this._onResize(null)
            }

            _closeOnSide() {
                var dialog = this.getChildAt(this.numChildren - 1);
                dialog instanceof IUI.Dialog && dialog.close()
            }

            setLockView(value) {
                this.lockLayer || (this.lockLayer = new Box, this.lockLayer.mouseEnabled = !0, this.lockLayer.size(Laya.ILaya.stage.width, Laya.ILaya.stage.height)), this.lockLayer.removeChildren(), value && (value.centerX = value.centerY = 0, this.lockLayer.addChild(value))
            }

            _onResize(e = null) {
                var width = this.maskLayer.width = Laya.ILaya.stage.width,
                    height = this.maskLayer.height = Laya.ILaya.stage.height;
                this.lockLayer && this.lockLayer.size(width, height), this.maskLayer.graphics.clear(!0), this.maskLayer.graphics.drawRect(0, 0, width, height, UIConfig.popupBgColor), this.maskLayer.alpha = UIConfig.popupBgAlpha;
                for (var i = this.numChildren - 1; i > -1; i--) {
                    var item = this.getChildAt(i);
                    item.isPopupCenter && this._centerDialog(item)
                }
            }

            _centerDialog(dialog) {
                dialog.x = Math.round((Laya.ILaya.stage.width - dialog.width >> 1) + dialog.pivotX), dialog.y = Math.round((Laya.ILaya.stage.height - dialog.height >> 1) + dialog.pivotY)
            }

            open(dialog, closeOther = !1, showEffect = !1) {
                closeOther && this._closeAll(), this._clearDialogEffect(dialog), dialog.isPopupCenter && this._centerDialog(dialog), this.addChild(dialog), (dialog.isModal || this._getBit(Laya.Const.HAS_ZORDER)) && Laya.ILaya.timer.callLater(this, this._checkMask), showEffect && null != dialog.popupEffect ? dialog.popupEffect.runWith(dialog) : this.doOpen(dialog), this.event(Laya.Event.OPEN)
            }

            _clearDialogEffect(dialog) {
                dialog._effectTween && (Laya.Tween.clear(dialog._effectTween), dialog._effectTween = null)
            }

            doOpen(dialog) {
                dialog.onOpened(dialog._param)
            }

            lock(value) {
                this.lockLayer && (value ? this.addChild(this.lockLayer) : this.lockLayer.removeSelf())
            }

            close(dialog) {
                this._clearDialogEffect(dialog), dialog.isShowEffect && null != dialog.closeEffect ? dialog.closeEffect.runWith([dialog]) : this.doClose(dialog), this.event(Laya.Event.CLOSE)
            }

            doClose(dialog) {
                dialog.removeSelf(), dialog.isModal && this._checkMask(), dialog.closeHandler && dialog.closeHandler.runWith(dialog.closeType), dialog.onClosed(dialog.closeType), dialog.autoDestroyAtClosed && dialog.destroy()
            }

            closeAll() {
                this._closeAll(), this.event(Laya.Event.CLOSE)
            }

            _closeAll() {
                for (var i = this.numChildren - 1; i > -1; i--) {
                    var item = this.getChildAt(i);
                    item && null != item.close && this.doClose(item)
                }
            }

            getDialogsByGroup(group) {
                for (var arr = [], i = this.numChildren - 1; i > -1; i--) {
                    var item = this.getChildAt(i);
                    item && item.group === group && arr.push(item)
                }
                return arr
            }

            closeByGroup(group) {
                for (var arr = [], i = this.numChildren - 1; i > -1; i--) {
                    var item = this.getChildAt(i);
                    item && item.group === group && (item.close(), arr.push(item))
                }
                return arr
            }

            _checkMask() {
                this.maskLayer.removeSelf();
                for (var i = this.numChildren - 1; i > -1; i--) {
                    var dialog = this.getChildAt(i);
                    if (dialog && dialog.isModal) return void this.addChildAt(this.maskLayer, i)
                }
            }
        }

        Laya.ClassUtils.regClass("laya.ui.DialogManager", DialogManager), Laya.ClassUtils.regClass("Laya.DialogManager", DialogManager);

        class Dialog extends View {
            constructor() {
                super(), this.isShowEffect = !0, this.isPopupCenter = !0, this.popupEffect = Dialog.manager.popupEffectHandler, this.closeEffect = Dialog.manager.closeEffectHandler, this._dealDragArea(), this.on(Laya.Event.CLICK, this, this._onClick)
            }

            static get manager() {
                return Dialog._manager = Dialog._manager || new DialogManager
            }

            static set manager(value) {
                Dialog._manager = value
            }

            _dealDragArea() {
                var dragTarget = this.getChildByName("drag");
                dragTarget && (this.dragArea = dragTarget._x + "," + dragTarget._y + "," + dragTarget.width + "," + dragTarget.height, dragTarget.removeSelf())
            }

            get dragArea() {
                return this._dragArea ? this._dragArea.toString() : null
            }

            set dragArea(value) {
                if (value) {
                    var a = UIUtils.fillArray([0, 0, 0, 0], value, Number);
                    this._dragArea = new Laya.Rectangle(a[0], a[1], a[2], a[3]), this.on(Laya.Event.MOUSE_DOWN, this, this._onMouseDown)
                } else this._dragArea = null, this.off(Laya.Event.MOUSE_DOWN, this, this._onMouseDown)
            }

            _onMouseDown(e) {
                var point = this.getMousePoint();
                this._dragArea.contains(point.x, point.y) ? this.startDrag() : this.stopDrag()
            }

            _onClick(e) {
                var btn = e.target;
                if (btn) switch (btn.name) {
                    case Dialog.CLOSE:
                    case Dialog.CANCEL:
                    case Dialog.SURE:
                    case Dialog.NO:
                    case Dialog.OK:
                    case Dialog.YES:
                        return void this.close(btn.name)
                }
            }

            open(closeOther = !0, param = null) {
                this._dealDragArea(), this._param = param, Dialog.manager.open(this, closeOther, this.isShowEffect), Dialog.manager.lock(!1)
            }

            close(type = null) {
                this.closeType = type, Dialog.manager.close(this)
            }

            destroy(destroyChild = !0) {
                this.closeHandler = null, this.popupEffect = null, this.closeEffect = null, this._dragArea = null, super.destroy(destroyChild)
            }

            show(closeOther = !1, showEffect = !0) {
                this._open(!1, closeOther, showEffect)
            }

            popup(closeOther = !1, showEffect = !0) {
                this._open(!0, closeOther, showEffect)
            }

            _open(modal, closeOther, showEffect) {
                this.isModal = modal, this.isShowEffect = showEffect, Dialog.manager.lock(!0), this.open(closeOther)
            }

            get isPopup() {
                return null != this.parent
            }

            set zOrder(value) {
                super.zOrder = value, Dialog.manager._checkMask()
            }

            get zOrder() {
                return super.zOrder
            }

            static setLockView(view) {
                Dialog.manager.setLockView(view)
            }

            static lock(value) {
                Dialog.manager.lock(value)
            }

            static closeAll() {
                Dialog.manager.closeAll()
            }

            static getDialogsByGroup(group) {
                return Dialog.manager.getDialogsByGroup(group)
            }

            static closeByGroup(group) {
                return Dialog.manager.closeByGroup(group)
            }
        }

        Dialog.CLOSE = "close", Dialog.CANCEL = "cancel", Dialog.SURE = "sure", Dialog.NO = "no", Dialog.YES = "yes", Dialog.OK = "ok", IUI.Dialog = Dialog, Laya.ILaya.regClass(Dialog), Laya.ClassUtils.regClass("laya.ui.Dialog", Dialog), Laya.ClassUtils.regClass("Laya.Dialog", Dialog);

        class TipManager extends UIComponent {
            constructor() {
                super(), this._tipBox = new UIComponent, this._tipBox.addChild(this._tipText = new Laya.Text), this._tipText.x = this._tipText.y = 5, this._tipText.color = TipManager.tipTextColor, this._defaultTipHandler = this._showDefaultTip, Laya.ILaya.stage.on(UIEvent.SHOW_TIP, this, this._onStageShowTip), Laya.ILaya.stage.on(UIEvent.HIDE_TIP, this, this._onStageHideTip), this.zOrder = 1100
            }

            _onStageHideTip(e) {
                Laya.ILaya.timer.clear(this, this._showTip), this.closeAll(), this.removeSelf()
            }

            _onStageShowTip(data) {
                Laya.ILaya.timer.once(TipManager.tipDelay, this, this._showTip, [data], !0)
            }

            _showTip(tip) {
                if ("string" == typeof tip) {
                    var text = String(tip);
                    Boolean(text) && this._defaultTipHandler(text)
                } else tip instanceof Laya.Handler ? tip.run() : tip instanceof Function && tip.apply();
                Laya.ILaya.stage.on(Laya.Event.MOUSE_MOVE, this, this._onStageMouseMove), Laya.ILaya.stage.on(Laya.Event.MOUSE_DOWN, this, this._onStageMouseDown), this._onStageMouseMove(null)
            }

            _onStageMouseDown(e) {
                this.closeAll()
            }

            _onStageMouseMove(e) {
                this._showToStage(this, TipManager.offsetX, TipManager.offsetY)
            }

            _showToStage(dis, offX = 0, offY = 0) {
                var rec = dis.getBounds();
                dis.x = Laya.ILaya.stage.mouseX + offX, dis.y = Laya.ILaya.stage.mouseY + offY, dis._x + rec.width > Laya.ILaya.stage.width && (dis.x -= rec.width + offX), dis._y + rec.height > Laya.ILaya.stage.height && (dis.y -= rec.height + offY)
            }

            closeAll() {
                Laya.ILaya.timer.clear(this, this._showTip), Laya.ILaya.stage.off(Laya.Event.MOUSE_MOVE, this, this._onStageMouseMove), Laya.ILaya.stage.off(Laya.Event.MOUSE_DOWN, this, this._onStageMouseDown), this.removeChildren()
            }

            showDislayTip(tip) {
                this.addChild(tip), this._showToStage(this), Laya.ILaya.stage.addChild(this)
            }

            _showDefaultTip(text) {
                this._tipText.text = text;
                var g = this._tipBox.graphics;
                g.clear(!0), g.drawRect(0, 0, this._tipText.width + 10, this._tipText.height + 10, TipManager.tipBackColor), this.addChild(this._tipBox), this._showToStage(this), Laya.ILaya.stage.addChild(this)
            }

            get defaultTipHandler() {
                return this._defaultTipHandler
            }

            set defaultTipHandler(value) {
                this._defaultTipHandler = value
            }
        }

        TipManager.offsetX = 10, TipManager.offsetY = 15, TipManager.tipTextColor = "#ffffff", TipManager.tipBackColor = "#111111", TipManager.tipDelay = 200, Laya.ILaya.regClass(TipManager), Laya.ClassUtils.regClass("laya.ui.TipManager", TipManager), Laya.ClassUtils.regClass("Laya.TipManager", TipManager);

        class WXOpenDataViewer extends UIComponent {
            constructor() {
                super(), this._width = this._height = 200;
                var tex = new Laya.Texture;
                tex.bitmap = new Laya.Texture2D, this.texture = tex
            }

            onEnable() {
                this.postMsg({
                    type: "display",
                    rate: Laya.Laya.stage.frameRate
                }), window.wx && window.sharedCanvas && Laya.Laya.timer.frameLoop(1, this, this._onLoop)
            }

            onDisable() {
                this.postMsg({type: "undisplay"}), Laya.Laya.timer.clear(this, this._onLoop)
            }

            _onLoop() {
                this.texture.bitmap.loadImageSource(window.sharedCanvas)
            }

            set width(value) {
                super.width = value, window.sharedCanvas && (window.sharedCanvas.width = value), this.callLater(this._postMsg)
            }

            get width() {
                return super.width
            }

            set height(value) {
                super.height = value, window.sharedCanvas && (window.sharedCanvas.height = value), this.callLater(this._postMsg)
            }

            get height() {
                return super.width
            }

            set x(value) {
                super.x = value, this.callLater(this._postMsg)
            }

            get x() {
                return super.x
            }

            set y(value) {
                super.y = value, this.callLater(this._postMsg)
            }

            get y() {
                return super.y
            }

            _postMsg() {
                var mat = new Laya.Matrix;
                mat.translate(this.x, this.y);
                var stage = Laya.Laya.stage;
                mat.scale(stage._canvasTransform.getScaleX() * this.globalScaleX * stage.transform.getScaleX(), stage._canvasTransform.getScaleY() * this.globalScaleY * stage.transform.getScaleY()), this.postMsg({
                    type: "changeMatrix",
                    a: mat.a,
                    b: mat.b,
                    c: mat.c,
                    d: mat.d,
                    tx: mat.tx,
                    ty: mat.ty,
                    w: this.width,
                    h: this.height
                })
            }

            postMsg(msg) {
                window.wx && window.wx.getOpenDataContext && window.wx.getOpenDataContext().postMessage(msg)
            }
        }

        Laya.ILaya.regClass(WXOpenDataViewer), Laya.ClassUtils.regClass("laya.ui.WXOpenDataViewer", WXOpenDataViewer), Laya.ClassUtils.regClass("Laya.WXOpenDataViewer", WXOpenDataViewer), exports.AdvImage = AdvImage, exports.AutoBitmap = AutoBitmap, exports.Box = Box, exports.Button = Button, exports.CheckBox = CheckBox, exports.Clip = Clip, exports.ColorPicker = ColorPicker, exports.ComboBox = ComboBox, exports.Dialog = Dialog, exports.DialogManager = DialogManager, exports.FontClip = FontClip, exports.HBox = HBox, exports.HScrollBar = HScrollBar, exports.HSlider = HSlider, exports.IUI = IUI, exports.Image = Image, exports.Label = Label, exports.LayoutBox = LayoutBox, exports.List = List, exports.Panel = Panel, exports.ProgressBar = ProgressBar, exports.Radio = Radio, exports.RadioGroup = RadioGroup, exports.ScaleBox = ScaleBox, exports.ScrollBar = ScrollBar, exports.Slider = Slider, exports.Styles = Styles, exports.Tab = Tab, exports.TextArea = TextArea, exports.TextInput = TextInput, exports.TipManager = TipManager, exports.Tree = Tree, exports.UIComponent = UIComponent, exports.UIConfig = UIConfig, exports.UIEvent = UIEvent, exports.UIGroup = UIGroup, exports.UILib = class {
            static __init__() {
            }
        }, exports.UIUtils = UIUtils, exports.VBox = VBox, exports.VScrollBar = VScrollBar, exports.VSlider = VSlider, exports.View = View, exports.ViewStack = ViewStack, exports.WXOpenDataViewer = WXOpenDataViewer, exports.Widget = Widget
    }(window.Laya = window.Laya || {}, Laya);
});
define("libs/laya.wxmini.js", function (require, module, exports) {
    window.wxMiniGame = function (exports, Laya) {
        "use strict";

        class MiniFileMgr {
            static isLocalNativeFile(url) {
                for (var i = 0, sz = MiniAdpter.nativefiles.length; i < sz; i++) if (-1 != url.indexOf(MiniAdpter.nativefiles[i])) return !0;
                return !1
            }

            static getFileInfo(fileUrl) {
                var fileNativePath = fileUrl, fileObj = MiniFileMgr.fakeObj[fileNativePath];
                return null == fileObj ? null : fileObj
            }

            static read(filePath, encoding = "utf8", callBack = null, readyUrl = "", isSaveFile = !1, fileType = "") {
                var fileUrl;
                fileUrl = "" == readyUrl || -1 == readyUrl.indexOf("http://") && -1 == readyUrl.indexOf("https://") ? filePath : MiniFileMgr.getFileNativePath(filePath), fileUrl = Laya.URL.getAdptedFilePath(fileUrl), MiniFileMgr.fs.readFile({
                    filePath: fileUrl,
                    encoding: encoding,
                    success: function (data) {
                        null != callBack && callBack.runWith([0, data])
                    },
                    fail: function (data) {
                        data && "" != readyUrl ? MiniFileMgr.downFiles(readyUrl, encoding, callBack, readyUrl, isSaveFile, fileType) : null != callBack && callBack.runWith([1])
                    }
                })
            }

            static downFiles(fileUrl, encoding = "utf8", callBack = null, readyUrl = "", isSaveFile = !1, fileType = "", isAutoClear = !0) {
                MiniFileMgr.wxdown({
                    url: fileUrl, success: function (data) {
                        200 === data.statusCode ? MiniFileMgr.readFile(data.tempFilePath, encoding, callBack, readyUrl, isSaveFile, fileType, isAutoClear) : 403 === data.statusCode ? null != callBack && callBack.runWith([0, fileUrl]) : null != callBack && callBack.runWith([1, data])
                    }, fail: function (data) {
                        null != callBack && callBack.runWith([1, data])
                    }
                }).onProgressUpdate(function (data) {
                    null != callBack && callBack.runWith([2, data.progress])
                })
            }

            static readFile(filePath, encoding = "utf8", callBack = null, readyUrl = "", isSaveFile = !1, fileType = "", isAutoClear = !0) {
                filePath = Laya.URL.getAdptedFilePath(filePath), MiniFileMgr.fs.readFile({
                    filePath: filePath,
                    encoding: encoding,
                    success: function (data) {
                        (-1 != filePath.indexOf("http://") || -1 != filePath.indexOf("https://")) && (MiniAdpter.autoCacheFile || isSaveFile) ? (null != callBack && callBack.runWith([0, data]), MiniFileMgr.copyFile(filePath, readyUrl, null, encoding, isAutoClear)) : null != callBack && callBack.runWith([0, data])
                    },
                    fail: function (data) {
                        data && null != callBack && callBack.runWith([1, data])
                    }
                })
            }

            static downOtherFiles(fileUrl, callBack = null, readyUrl = "", isSaveFile = !1, isAutoClear = !0) {
                MiniFileMgr.wxdown({
                    url: fileUrl, success: function (data) {
                        200 === data.statusCode ? (MiniAdpter.autoCacheFile || isSaveFile) && -1 == readyUrl.indexOf("qlogo.cn") && -1 == readyUrl.indexOf(".php") ? (null != callBack && callBack.runWith([0, data.tempFilePath]), MiniFileMgr.copyFile(data.tempFilePath, readyUrl, null, "", isAutoClear)) : null != callBack && callBack.runWith([0, data.tempFilePath]) : null != callBack && callBack.runWith([1, data])
                    }, fail: function (data) {
                        null != callBack && callBack.runWith([1, data])
                    }
                })
            }

            static downLoadFile(fileUrl, fileType = "", callBack = null, encoding = "utf8") {
                window.navigator.userAgent.indexOf("MiniGame") < 0 ? Laya.Laya.loader.load(fileUrl, callBack) : fileType == Laya.Loader.IMAGE || fileType == Laya.Loader.SOUND ? MiniFileMgr.downOtherFiles(fileUrl, callBack, fileUrl, !0, !1) : MiniFileMgr.downFiles(fileUrl, encoding, callBack, fileUrl, !0, fileType, !1)
            }

            static copyFile(tempFilePath, readyUrl, callBack, encoding = "", isAutoClear = !0) {
                var temp = tempFilePath.split("/"), tempFileName = temp[temp.length - 1], fileurlkey = readyUrl,
                    fileObj = MiniFileMgr.getFileInfo(readyUrl),
                    saveFilePath = MiniFileMgr.getFileNativePath(tempFileName);
                MiniFileMgr.fakeObj[fileurlkey] = {
                    md5: tempFileName,
                    readyUrl: readyUrl,
                    size: 0,
                    times: Laya.Browser.now(),
                    encoding: encoding
                };
                var fileUseSize = MiniFileMgr.getCacheUseSize();
                fileObj ? fileObj.readyUrl != readyUrl ? MiniFileMgr.fs.getFileInfo({
                    filePath: tempFilePath,
                    success: function (data) {
                        isAutoClear && fileUseSize + 4194304 + data.size >= 52428800 && (data.size > MiniAdpter.minClearSize && (MiniAdpter.minClearSize = data.size), MiniFileMgr.onClearCacheRes()), MiniFileMgr.deleteFile(tempFileName, readyUrl, callBack, encoding, data.size)
                    },
                    fail: function (data) {
                        null != callBack && callBack.runWith([1, data])
                    }
                }) : null != callBack && callBack.runWith([0]) : MiniFileMgr.fs.getFileInfo({
                    filePath: tempFilePath,
                    success: function (data) {
                        isAutoClear && fileUseSize + 4194304 + data.size >= 52428800 && (data.size > MiniAdpter.minClearSize && (MiniAdpter.minClearSize = data.size), MiniFileMgr.onClearCacheRes()), MiniFileMgr.fs.copyFile({
                            srcPath: tempFilePath,
                            destPath: saveFilePath,
                            success: function (data2) {
                                MiniFileMgr.onSaveFile(readyUrl, tempFileName, !0, encoding, callBack, data.size)
                            },
                            fail: function (data) {
                                null != callBack && callBack.runWith([1, data])
                            }
                        })
                    },
                    fail: function (data) {
                        null != callBack && callBack.runWith([1, data])
                    }
                })
            }

            static onClearCacheRes() {
                var memSize = MiniAdpter.minClearSize, tempFileListArr = [];
                for (var key in MiniFileMgr.filesListObj) "fileUsedSize" != key && tempFileListArr.push(MiniFileMgr.filesListObj[key]);
                MiniFileMgr.sortOn(tempFileListArr, "times", MiniFileMgr.NUMERIC);
                for (var clearSize = 0, i = 1, sz = tempFileListArr.length; i < sz; i++) {
                    var fileObj = tempFileListArr[i];
                    if (clearSize >= memSize) break;
                    clearSize += fileObj.size, MiniFileMgr.deleteFile("", fileObj.readyUrl)
                }
            }

            static sortOn(array, name, options = 0) {
                return options == MiniFileMgr.NUMERIC ? array.sort(function (a, b) {
                    return a[name] - b[name]
                }) : options == (MiniFileMgr.NUMERIC | MiniFileMgr.DESCENDING) ? array.sort(function (a, b) {
                    return b[name] - a[name]
                }) : array.sort(function (a, b) {
                    return a[name] - b[name]
                })
            }

            static getFileNativePath(fileName) {
                return MiniFileMgr.fileNativeDir + "/" + fileName
            }

            static deleteFile(tempFileName, readyUrl = "", callBack = null, encoding = "", fileSize = 0) {
                var fileObj = MiniFileMgr.getFileInfo(readyUrl),
                    deleteFileUrl = MiniFileMgr.getFileNativePath(fileObj.md5), isAdd = "" != tempFileName;
                MiniFileMgr.onSaveFile(readyUrl, tempFileName, isAdd, encoding, callBack, fileSize), MiniFileMgr.fs.unlink({
                    filePath: deleteFileUrl,
                    success: function (data) {
                        if ("" != tempFileName) {
                            var saveFilePath = MiniFileMgr.getFileNativePath(tempFileName);
                            MiniFileMgr.fs.copyFile({
                                srcPath: tempFileName,
                                destPath: saveFilePath,
                                success: function (data) {
                                },
                                fail: function (data) {
                                    null != callBack && callBack.runWith([1, data])
                                }
                            })
                        }
                    },
                    fail: function (data) {
                    }
                })
            }

            static deleteAll() {
                var tempFileListArr = [];
                for (var key in MiniFileMgr.filesListObj) "fileUsedSize" != key && tempFileListArr.push(MiniFileMgr.filesListObj[key]);
                for (var i = 1, sz = tempFileListArr.length; i < sz; i++) {
                    var fileObj = tempFileListArr[i];
                    MiniFileMgr.deleteFile("", fileObj.readyUrl)
                }
                MiniFileMgr.filesListObj && MiniFileMgr.filesListObj.fileUsedSize && (MiniFileMgr.filesListObj.fileUsedSize = 0), MiniFileMgr.writeFilesList("", JSON.stringify({}), !1)
            }

            static onSaveFile(readyUrl, md5Name, isAdd = !0, encoding = "", callBack = null, fileSize = 0) {
                var fileurlkey = readyUrl;
                if (null == MiniFileMgr.filesListObj.fileUsedSize && (MiniFileMgr.filesListObj.fileUsedSize = 0), isAdd) {
                    MiniFileMgr.getFileNativePath(md5Name);
                    MiniFileMgr.filesListObj[fileurlkey] = {
                        md5: md5Name,
                        readyUrl: readyUrl,
                        size: fileSize,
                        times: Laya.Browser.now(),
                        encoding: encoding
                    }, MiniFileMgr.filesListObj.fileUsedSize = parseInt(MiniFileMgr.filesListObj.fileUsedSize) + fileSize, MiniFileMgr.writeFilesList(fileurlkey, JSON.stringify(MiniFileMgr.filesListObj), !0), null != callBack && callBack.runWith([0])
                } else if (MiniFileMgr.filesListObj[fileurlkey]) {
                    var deletefileSize = parseInt(MiniFileMgr.filesListObj[fileurlkey].size);
                    MiniFileMgr.filesListObj.fileUsedSize = parseInt(MiniFileMgr.filesListObj.fileUsedSize) - deletefileSize, delete MiniFileMgr.filesListObj[fileurlkey], MiniFileMgr.writeFilesList(fileurlkey, JSON.stringify(MiniFileMgr.filesListObj), !1), null != callBack && callBack.runWith([0])
                }
            }

            static writeFilesList(fileurlkey, filesListStr, isAdd) {
                var listFilesPath = MiniFileMgr.fileNativeDir + "/" + MiniFileMgr.fileListName;
                MiniFileMgr.fs.writeFile({
                    filePath: listFilesPath,
                    encoding: "utf8",
                    data: filesListStr,
                    success: function (data) {
                    },
                    fail: function (data) {
                    }
                }), !MiniAdpter.isZiYu && MiniAdpter.isPosMsgYu && MiniAdpter.window.wx.postMessage({
                    url: fileurlkey,
                    data: MiniFileMgr.filesListObj[fileurlkey],
                    isLoad: "filenative",
                    isAdd: isAdd
                })
            }

            static getCacheUseSize() {
                return MiniFileMgr.filesListObj && MiniFileMgr.filesListObj.fileUsedSize ? MiniFileMgr.filesListObj.fileUsedSize : 0
            }

            static existDir(dirPath, callBack) {
                MiniFileMgr.fs.mkdir({
                    dirPath: dirPath, success: function (data) {
                        null != callBack && callBack.runWith([0, {data: JSON.stringify({})}])
                    }, fail: function (data) {
                        -1 != data.errMsg.indexOf("file already exists") ? MiniFileMgr.readSync(MiniFileMgr.fileListName, "utf8", callBack) : null != callBack && callBack.runWith([1, data])
                    }
                })
            }

            static readSync(filePath, encoding = "utf8", callBack = null, readyUrl = "") {
                var filesListStr, fileUrl = MiniFileMgr.getFileNativePath(filePath);
                try {
                    filesListStr = MiniFileMgr.fs.readFileSync(fileUrl, encoding), null != callBack && callBack.runWith([0, {data: filesListStr}])
                } catch (error) {
                    null != callBack && callBack.runWith([1])
                }
            }

            static setNativeFileDir(value) {
                MiniFileMgr.fileNativeDir = MiniAdpter.window.wx.env.USER_DATA_PATH + value
            }
        }

        MiniFileMgr.fs = window.wx.getFileSystemManager(), MiniFileMgr.wxdown = window.wx.downloadFile, MiniFileMgr.filesListObj = {}, MiniFileMgr.fakeObj = {}, MiniFileMgr.fileListName = "layaairfiles.txt", MiniFileMgr.ziyuFileData = {}, MiniFileMgr.ziyuFileTextureData = {}, MiniFileMgr.loadPath = "", MiniFileMgr.DESCENDING = 2, MiniFileMgr.NUMERIC = 16;

        class MiniSoundChannel extends Laya.SoundChannel {
            constructor(audio, miniSound) {
                super(), this._audio = audio, this._miniSound = miniSound, this._onEnd = MiniSoundChannel.bindToThis(this.__onEnd, this), audio.onEnded(this._onEnd)
            }

            static bindToThis(fun, scope) {
                return fun.bind(scope)
            }

            __onEnd() {
                if (1 == this.loops) return this.completeHandler && (Laya.Laya.systemTimer.once(10, this, this.__runComplete, [this.completeHandler], !1), this.completeHandler = null), this.stop(), void this.event(Laya.Event.COMPLETE);
                this.loops > 0 && this.loops--, this.startTime = 0, this.play()
            }

            play() {
                this.isStopped = !1, Laya.SoundManager.addChannel(this), this._audio.play()
            }

            set startTime(time) {
                this._audio && (this._audio.startTime = time)
            }

            set autoplay(value) {
                this._audio.autoplay = value
            }

            get autoplay() {
                return this._audio.autoplay
            }

            get position() {
                return this._audio ? this._audio.currentTime : 0
            }

            get duration() {
                return this._audio ? this._audio.duration : 0
            }

            stop() {
                this.isStopped = !0, Laya.SoundManager.removeChannel(this), this.completeHandler = null, this._audio && (this._audio.stop(), this.loop || (this._audio.offEnded(null), this._miniSound.dispose(), this._audio = null, this._miniSound = null, this._onEnd = null))
            }

            pause() {
                this.isStopped = !0, this._audio.pause()
            }

            get loop() {
                return this._audio.loop
            }

            set loop(value) {
                this._audio.loop = value
            }

            resume() {
                this._audio && (this.isStopped = !1, Laya.SoundManager.addChannel(this), this._audio.play())
            }

            set volume(v) {
                this._audio && (this._audio.volume = v)
            }

            get volume() {
                return this._audio ? this._audio.volume : 1
            }
        }

        class MiniSound extends Laya.EventDispatcher {
            constructor() {
                super(), this.loaded = !1
            }

            static _createSound() {
                return MiniSound._id++, MiniAdpter.window.wx.createInnerAudioContext()
            }

            load(url) {
                if (MiniFileMgr.isLocalNativeFile(url)) {
                    if (-1 != url.indexOf("http://") || -1 != url.indexOf("https://")) if ("" != MiniFileMgr.loadPath) url = url.split(MiniFileMgr.loadPath)[1]; else {
                        var tempStr = "" != Laya.URL.rootPath ? Laya.URL.rootPath : Laya.URL._basePath;
                        "" != tempStr && (url = url.split(tempStr)[1])
                    }
                } else url = Laya.URL.formatURL(url);
                if (this.url = url, this.readyUrl = url, MiniSound._audioCache[this.readyUrl]) this.event(Laya.Event.COMPLETE); else if (MiniAdpter.autoCacheFile && MiniFileMgr.getFileInfo(url)) this.onDownLoadCallBack(url, 0); else if (MiniAdpter.autoCacheFile) if (MiniFileMgr.isLocalNativeFile(url)) {
                    var tempUrl = url;
                    if ("" != (tempStr = "" != Laya.URL.rootPath ? Laya.URL.rootPath : Laya.URL._basePath) && (url = url.split(tempStr)[1]), url || (url = tempUrl), MiniAdpter.subNativeFiles && 0 == MiniAdpter.subNativeheads.length) for (var key in MiniAdpter.subNativeFiles) {
                        var tempArr = MiniAdpter.subNativeFiles[key];
                        MiniAdpter.subNativeheads = MiniAdpter.subNativeheads.concat(tempArr);
                        for (var aa = 0; aa < tempArr.length; aa++) MiniAdpter.subMaps[tempArr[aa]] = key + "/" + tempArr[aa]
                    }
                    if (MiniAdpter.subNativeFiles && -1 != url.indexOf("/")) {
                        var curfileHead = url.split("/")[0] + "/";
                        if (curfileHead && -1 != MiniAdpter.subNativeheads.indexOf(curfileHead)) {
                            var newfileHead = MiniAdpter.subMaps[curfileHead];
                            url = url.replace(curfileHead, newfileHead)
                        }
                    }
                    this.onDownLoadCallBack(url, 0)
                } else !MiniFileMgr.isLocalNativeFile(url) && -1 == url.indexOf("http://") && -1 == url.indexOf("https://") || -1 != url.indexOf("http://usr/") ? this.onDownLoadCallBack(url, 0) : MiniFileMgr.downOtherFiles(url, Laya.Handler.create(this, this.onDownLoadCallBack, [url]), url); else this.onDownLoadCallBack(url, 0)
            }

            onDownLoadCallBack(sourceUrl, errorCode, tempFilePath = null) {
                if (errorCode) this.event(Laya.Event.ERROR); else {
                    var fileNativeUrl;
                    if (MiniAdpter.autoCacheFile) {
                        if (tempFilePath) fileNativeUrl = tempFilePath; else if (MiniFileMgr.isLocalNativeFile(sourceUrl)) {
                            var tempStr = "" != Laya.URL.rootPath ? Laya.URL.rootPath : Laya.URL._basePath,
                                tempUrl = sourceUrl;
                            "" == tempStr || -1 == sourceUrl.indexOf("http://") && -1 == sourceUrl.indexOf("https://") || (fileNativeUrl = sourceUrl.split(tempStr)[1]), fileNativeUrl || (fileNativeUrl = tempUrl)
                        } else {
                            var fileObj = MiniFileMgr.getFileInfo(sourceUrl);
                            if (fileObj && fileObj.md5) {
                                var fileMd5Name = fileObj.md5;
                                fileNativeUrl = MiniFileMgr.getFileNativePath(fileMd5Name)
                            } else fileNativeUrl = sourceUrl
                        }
                        this._sound = MiniSound._createSound(), this._sound.src = this.url = fileNativeUrl
                    } else this._sound = MiniSound._createSound(), this._sound.src = this.url = sourceUrl;
                    this._sound.onCanplay(MiniSound.bindToThis(this.onCanPlay, this)), this._sound.onError(MiniSound.bindToThis(this.onError, this))
                }
            }

            onError(error) {
                try {
                    console.log("-----1---------------minisound-----id:" + MiniSound._id), console.log(error)
                } catch (error) {
                    console.log("-----2---------------minisound-----id:" + MiniSound._id), console.log(error)
                }
                this.event(Laya.Event.ERROR), this._sound.offError(null)
            }

            onCanPlay() {
                this.loaded = !0, this.event(Laya.Event.COMPLETE), this._sound.offCanplay(null)
            }

            static bindToThis(fun, scope) {
                return fun.bind(scope)
            }

            play(startTime = 0, loops = 0) {
                var tSound;
                if (this.url == Laya.SoundManager._bgMusic ? (MiniSound._musicAudio || (MiniSound._musicAudio = MiniSound._createSound()), tSound = MiniSound._musicAudio) : tSound = MiniSound._audioCache[this.readyUrl] ? MiniSound._audioCache[this.readyUrl]._sound : MiniSound._createSound(), !tSound) return null;
                if (MiniAdpter.autoCacheFile && MiniFileMgr.getFileInfo(this.url)) {
                    var fileMd5Name = MiniFileMgr.getFileInfo(this.url).md5;
                    tSound.src = this.url = MiniFileMgr.getFileNativePath(fileMd5Name)
                } else tSound.src = this.url;
                var channel = new MiniSoundChannel(tSound, this);
                return channel.url = this.url, channel.loops = loops, channel.loop = 0 === loops, channel.startTime = startTime, channel.play(), Laya.SoundManager.addChannel(channel), channel
            }

            get duration() {
                return this._sound.duration
            }

            dispose() {
                var ad = MiniSound._audioCache[this.readyUrl];
                ad && (ad.src = "", ad._sound && (ad._sound.destroy(), ad._sound = null, ad = null), delete MiniSound._audioCache[this.readyUrl]), this._sound && (this._sound.destroy(), this._sound = null, this.readyUrl = this.url = null)
            }
        }

        MiniSound._id = 0, MiniSound._audioCache = {};

        class MiniInput {
            constructor() {
            }

            static _createInputElement() {
                Laya.Input._initInput(Laya.Input.area = Laya.Browser.createElement("textarea")), Laya.Input._initInput(Laya.Input.input = Laya.Browser.createElement("input")), Laya.Input.inputContainer = Laya.Browser.createElement("div"), Laya.Input.inputContainer.style.position = "absolute", Laya.Input.inputContainer.style.zIndex = 1e5, Laya.Browser.container.appendChild(Laya.Input.inputContainer), Laya.Laya.stage.on("resize", null, MiniInput._onStageResize), MiniAdpter.window.wx.onWindowResize && MiniAdpter.window.wx.onWindowResize(function (res) {
                }), Laya.SoundManager._soundClass = MiniSound, Laya.SoundManager._musicClass = MiniSound;
                var model = MiniAdpter.systemInfo.model, system = MiniAdpter.systemInfo.system;
                -1 != model.indexOf("iPhone") && (Laya.Browser.onIPhone = !0, Laya.Browser.onIOS = !0, Laya.Browser.onIPad = !0, Laya.Browser.onAndroid = !1), -1 == system.indexOf("Android") && -1 == system.indexOf("Adr") || (Laya.Browser.onAndroid = !0, Laya.Browser.onIPhone = !1, Laya.Browser.onIOS = !1, Laya.Browser.onIPad = !1)
            }

            static _onStageResize() {
                Laya.Laya.stage._canvasTransform.identity().scale(Laya.Browser.width / Laya.Render.canvas.width / Laya.Browser.pixelRatio, Laya.Browser.height / Laya.Render.canvas.height / Laya.Browser.pixelRatio)
            }

            static wxinputFocus(e) {
                var _inputTarget = Laya.Input.inputElement.target;
                _inputTarget && !_inputTarget.editable || (MiniAdpter.window.wx.offKeyboardConfirm(), MiniAdpter.window.wx.offKeyboardInput(), MiniAdpter.window.wx.showKeyboard({
                    defaultValue: _inputTarget.text,
                    maxLength: _inputTarget.maxChars,
                    multiple: _inputTarget.multiline,
                    confirmHold: !0,
                    confirmType: _inputTarget.confirmType || "done",
                    success: function (res) {
                    },
                    fail: function (res) {
                    }
                }), MiniAdpter.window.wx.onKeyboardConfirm(function (res) {
                    var str = res ? res.value : "";
                    _inputTarget._restrictPattern && (str = str.replace(/\u2006|\x27/g, ""), _inputTarget._restrictPattern.test(str) && (str = str.replace(_inputTarget._restrictPattern, ""))), _inputTarget.text = str, _inputTarget.event(Laya.Event.INPUT), MiniInput.inputEnter(), _inputTarget.event("confirm")
                }), MiniAdpter.window.wx.onKeyboardInput(function (res) {
                    var str = res ? res.value : "";
                    _inputTarget.multiline || -1 == str.indexOf("\n") ? (_inputTarget._restrictPattern && (str = str.replace(/\u2006|\x27/g, ""), _inputTarget._restrictPattern.test(str) && (str = str.replace(_inputTarget._restrictPattern, ""))), _inputTarget.text = str, _inputTarget.event(Laya.Event.INPUT)) : MiniInput.inputEnter()
                }))
            }

            static inputEnter() {
                Laya.Input.inputElement.target.focus = !1
            }

            static wxinputblur() {
                MiniInput.hideKeyboard()
            }

            static hideKeyboard() {
                MiniAdpter.window.wx.offKeyboardConfirm(), MiniAdpter.window.wx.offKeyboardInput(), MiniAdpter.window.wx.hideKeyboard({
                    success: function (res) {
                        console.log("隐藏键盘")
                    }, fail: function (res) {
                        console.log("隐藏键盘出错:" + (res ? res.errMsg : ""))
                    }
                })
            }
        }

        class MiniLoader extends Laya.EventDispatcher {
            constructor() {
                super()
            }

            _loadResourceFilter(type, url) {
                if (-1 == url.indexOf(MiniAdpter.window.wx.env.USER_DATA_PATH) && (-1 != url.indexOf("http://") || -1 != url.indexOf("https://"))) if ("" != MiniFileMgr.loadPath) url = url.split(MiniFileMgr.loadPath)[1]; else {
                    var tempStr = "" != Laya.URL.rootPath ? Laya.URL.rootPath : Laya.URL._basePath, tempUrl = url;
                    "" != tempStr && (url = url.split(tempStr)[1]), url || (url = tempUrl)
                }
                if (MiniAdpter.subNativeFiles && 0 == MiniAdpter.subNativeheads.length) for (var key in MiniAdpter.subNativeFiles) {
                    var tempArr = MiniAdpter.subNativeFiles[key];
                    MiniAdpter.subNativeheads = MiniAdpter.subNativeheads.concat(tempArr);
                    for (var aa = 0; aa < tempArr.length; aa++) MiniAdpter.subMaps[tempArr[aa]] = key + "/" + tempArr[aa]
                }
                if (MiniAdpter.subNativeFiles && -1 != url.indexOf("/")) {
                    var curfileHead = url.split("/")[0] + "/";
                    if (curfileHead && -1 != MiniAdpter.subNativeheads.indexOf(curfileHead)) {
                        var newfileHead = MiniAdpter.subMaps[curfileHead];
                        url = url.replace(curfileHead, newfileHead)
                    }
                }
                switch (type) {
                    case Laya.Loader.IMAGE:
                    case"htmlimage":
                    case"nativeimage":
                        MiniLoader._transformImgUrl(url, type, this);
                        break;
                    case Laya.Loader.SOUND:
                        this._loadSound(url);
                        break;
                    default:
                        this._loadResource(type, url)
                }
            }

            _loadSound(url) {
                var fileNativeUrl;
                if (MiniFileMgr.isLocalNativeFile(url)) {
                    var tempStr = "" != Laya.URL.rootPath ? Laya.URL.rootPath : Laya.URL._basePath, tempUrl = url;
                    "" == tempStr || -1 == url.indexOf("http://") && -1 == url.indexOf("https://") || (fileNativeUrl = url.split(tempStr)[1]), fileNativeUrl || (fileNativeUrl = tempUrl), MiniLoader.onDownLoadCallBack(url, this, 0)
                } else {
                    var tempurl = Laya.URL.formatURL(url);
                    !MiniFileMgr.isLocalNativeFile(url) && -1 == tempurl.indexOf("http://") && -1 == tempurl.indexOf("https://") || -1 != tempurl.indexOf(MiniAdpter.window.wx.env.USER_DATA_PATH) ? MiniLoader.onDownLoadCallBack(url, this, 0) : MiniFileMgr.downOtherFiles(encodeURI(tempurl), Laya.Handler.create(MiniLoader, MiniLoader.onDownLoadCallBack, [tempurl, this]), tempurl)
                }
            }

            static onDownLoadCallBack(sourceUrl, thisLoader, errorCode, tempFilePath = null) {
                if (errorCode) thisLoader.event(Laya.Event.ERROR, "Load sound failed"); else {
                    var fileNativeUrl;
                    if (MiniAdpter.autoCacheFile) if (tempFilePath) fileNativeUrl = tempFilePath; else if (MiniFileMgr.isLocalNativeFile(sourceUrl)) {
                        var tempStr = "" != Laya.URL.rootPath ? Laya.URL.rootPath : Laya.URL._basePath,
                            tempUrl = sourceUrl;
                        "" == tempStr || -1 == sourceUrl.indexOf("http://") && -1 == sourceUrl.indexOf("https://") || (fileNativeUrl = sourceUrl.split(tempStr)[1]), fileNativeUrl || (fileNativeUrl = tempUrl)
                    } else {
                        var fileObj = MiniFileMgr.getFileInfo(sourceUrl);
                        if (fileObj && fileObj.md5) {
                            var fileMd5Name = fileObj.md5;
                            fileNativeUrl = MiniFileMgr.getFileNativePath(fileMd5Name)
                        } else fileNativeUrl = sourceUrl
                    }
                    sourceUrl = fileNativeUrl;
                    var sound = new Laya.SoundManager._soundClass;
                    sound.load(sourceUrl), thisLoader.onLoaded(sound)
                }
            }

            static bindToThis(fun, scope) {
                return fun.bind(scope)
            }

            _loadHttpRequestWhat(url, contentType) {
                var encoding = MiniAdpter.getUrlEncode(url, contentType);
                if (Laya.Loader.preLoadedMap[url]) this.onLoaded(Laya.Loader.preLoadedMap[url]); else {
                    var tempurl = Laya.URL.formatURL(url);
                    if (-1 != url.indexOf(MiniAdpter.window.wx.env.USER_DATA_PATH) || -1 == tempurl.indexOf("http://") && -1 == tempurl.indexOf("https://") || MiniAdpter.AutoCacheDownFile) {
                        var fileObj = MiniFileMgr.getFileInfo(Laya.URL.formatURL(url));
                        fileObj ? (fileObj.encoding = null == fileObj.encoding ? "utf8" : fileObj.encoding, MiniFileMgr.readFile(fileObj.url, encoding, new Laya.Handler(MiniLoader, MiniLoader.onReadNativeCallBack, [url, contentType, this]), url)) : "image" == this.type || "htmlimage" == this.type ? this._transformUrl(url, contentType) : contentType != Laya.Loader.IMAGE && (-1 == tempurl.indexOf("http://") && -1 == tempurl.indexOf("https://") || MiniFileMgr.isLocalNativeFile(url)) ? MiniFileMgr.readFile(url, encoding, new Laya.Handler(MiniLoader, MiniLoader.onReadNativeCallBack, [url, contentType, this]), url) : MiniFileMgr.downFiles(tempurl, encoding, new Laya.Handler(MiniLoader, MiniLoader.onReadNativeCallBack, [url, contentType, this]), tempurl, !0)
                    } else this._loadHttpRequest(tempurl, contentType, this, this.onLoaded, this, this.onProgress, this, this.onError)
                }
            }

            static onReadNativeCallBack(url, type = null, thisLoader = null, errorCode = 0, data = null) {
                var tempData;
                errorCode ? 1 == errorCode && thisLoader._loadHttpRequest(url, type, thisLoader, thisLoader.onLoaded, thisLoader, thisLoader.onProgress, thisLoader, thisLoader.onError) : (tempData = type == Laya.Loader.JSON || type == Laya.Loader.ATLAS || type == Laya.Loader.PREFAB || type == Laya.Loader.PLF ? MiniAdpter.getJson(data.data) : type == Laya.Loader.XML ? Laya.Utils.parseXMLFromString(data.data) : data.data, !MiniAdpter.isZiYu && MiniAdpter.isPosMsgYu && type != Laya.Loader.BUFFER && MiniAdpter.window.wx.postMessage({
                    url: url,
                    data: tempData,
                    isLoad: "filedata"
                }), thisLoader.onLoaded(tempData))
            }

            static _transformImgUrl(url, type, thisLoader) {
                if (MiniAdpter.isZiYu) thisLoader._loadImage(url); else if (MiniFileMgr.getFileInfo(url)) thisLoader._loadImage(url); else {
                    var tempUrl = Laya.URL.formatURL(url);
                    -1 != url.indexOf(MiniAdpter.window.wx.env.USER_DATA_PATH) || -1 == tempUrl.indexOf("http://") && -1 == tempUrl.indexOf("https://") ? thisLoader._loadImage(url) : MiniAdpter.isZiYu ? thisLoader._loadImage(url) : MiniFileMgr.downOtherFiles(tempUrl, new Laya.Handler(MiniLoader, MiniLoader.onDownImgCallBack, [url, thisLoader]), tempUrl)
                }
            }

            static onDownImgCallBack(sourceUrl, thisLoader, errorCode, tempFilePath = "") {
                errorCode ? thisLoader.onError(null) : MiniLoader.onCreateImage(sourceUrl, thisLoader, !1, tempFilePath)
            }

            static onCreateImage(sourceUrl, thisLoader, isLocal = !1, tempFilePath = "") {
                var fileNativeUrl;
                if (MiniAdpter.autoCacheFile) if (isLocal) if (MiniAdpter.isZiYu) {
                    var tempUrl = Laya.URL.formatURL(sourceUrl);
                    fileNativeUrl = MiniFileMgr.ziyuFileTextureData[tempUrl] ? MiniFileMgr.ziyuFileTextureData[tempUrl] : sourceUrl
                } else fileNativeUrl = sourceUrl; else if ("" != tempFilePath) fileNativeUrl = tempFilePath; else {
                    var fileMd5Name = MiniFileMgr.getFileInfo(sourceUrl).md5;
                    fileNativeUrl = MiniFileMgr.getFileNativePath(fileMd5Name)
                } else fileNativeUrl = isLocal ? sourceUrl : tempFilePath;
                thisLoader._loadImage(fileNativeUrl)
            }
        }

        class MiniLocalStorage {
            constructor() {
            }

            static __init__() {
                MiniLocalStorage.items = MiniLocalStorage
            }

            static setItem(key, value) {
                try {
                    MiniAdpter.window.wx.setStorageSync(key, value)
                } catch (error) {
                    MiniAdpter.window.wx.setStorage({key: key, data: value})
                }
            }

            static getItem(key) {
                return MiniAdpter.window.wx.getStorageSync(key)
            }

            static setJSON(key, value) {
                MiniLocalStorage.setItem(key, value)
            }

            static getJSON(key) {
                return MiniLocalStorage.getItem(key)
            }

            static removeItem(key) {
                MiniAdpter.window.wx.removeStorageSync(key)
            }

            static clear() {
                MiniAdpter.window.wx.clearStorageSync()
            }

            static getStorageInfoSync() {
                try {
                    var res = MiniAdpter.window.wx.getStorageInfoSync();
                    return console.log(res.keys), console.log(res.currentSize), console.log(res.limitSize), res
                } catch (e) {
                }
                return null
            }
        }

        MiniLocalStorage.support = !0;

        class MiniAdpter {
            static getJson(data) {
                return JSON.parse(data)
            }

            static enable() {
                MiniAdpter.init(Laya.Laya.isWXPosMsg, Laya.Laya.isWXOpenDataContext)
            }

            static init(isPosMsg = !1, isSon = !1) {
                MiniAdpter._inited || (MiniAdpter._inited = !0, MiniAdpter.window = window, MiniAdpter.window.hasOwnProperty("wx") && (MiniAdpter.window.navigator.userAgent.indexOf("MiniGame") < 0 || (MiniAdpter.isZiYu = isSon, MiniAdpter.isPosMsgYu = isPosMsg, MiniAdpter.EnvConfig = {}, MiniAdpter.isZiYu || (MiniFileMgr.setNativeFileDir("/layaairGame"), MiniFileMgr.existDir(MiniFileMgr.fileNativeDir, Laya.Handler.create(MiniAdpter, MiniAdpter.onMkdirCallBack))), MiniAdpter.systemInfo = MiniAdpter.window.wx.getSystemInfoSync(), MiniAdpter.window.focus = function () {
                }, Laya.Laya._getUrlPath = function () {
                    return ""
                }, MiniAdpter.window.logtime = function (str) {
                }, MiniAdpter.window.alertTimeLog = function (str) {
                }, MiniAdpter.window.resetShareInfo = function () {
                }, MiniAdpter.window.CanvasRenderingContext2D = function () {
                }, MiniAdpter.window.CanvasRenderingContext2D.prototype = MiniAdpter.window.wx.createCanvas().getContext("2d").__proto__, MiniAdpter.window.document.body.appendChild = function () {
                }, MiniAdpter.EnvConfig.pixelRatioInt = 0, Laya.Browser._pixelRatio = MiniAdpter.pixelRatio(), MiniAdpter._preCreateElement = Laya.Browser.createElement, Laya.Browser.createElement = MiniAdpter.createElement, Laya.RunDriver.createShaderCondition = MiniAdpter.createShaderCondition, Laya.Utils.parseXMLFromString = MiniAdpter.parseXMLFromString, Laya.Input._createInputElement = MiniInput._createInputElement, Laya.Loader.prototype._loadResourceFilter = MiniLoader.prototype._loadResourceFilter, Laya.Loader.prototype._loadSound = MiniLoader.prototype._loadSound, Laya.Loader.prototype._loadHttpRequestWhat = MiniLoader.prototype._loadHttpRequestWhat, Laya.LocalStorage._baseClass = MiniLocalStorage, MiniLocalStorage.__init__(), MiniAdpter.window.wx.onMessage && MiniAdpter.window.wx.onMessage(MiniAdpter._onMessage))))
            }

            static _onMessage(data) {
                switch (data.type) {
                    case"changeMatrix":
                        Laya.Laya.stage.transform.identity(), Laya.Laya.stage._width = data.w, Laya.Laya.stage._height = data.h, Laya.Laya.stage._canvasTransform = new Laya.Matrix(data.a, data.b, data.c, data.d, data.tx, data.ty);
                        break;
                    case"display":
                        Laya.Laya.stage.frameRate = data.rate || Laya.Stage.FRAME_FAST;
                        break;
                    case"undisplay":
                        Laya.Laya.stage.frameRate = Laya.Stage.FRAME_SLEEP
                }
                "opendatacontext" == data.isLoad ? data.url && (MiniFileMgr.ziyuFileData[data.url] = data.atlasdata, MiniFileMgr.ziyuFileTextureData[data.imgReadyUrl] = data.imgNativeUrl) : "openJsondatacontext" == data.isLoad ? data.url && (MiniFileMgr.ziyuFileData[data.url] = data.atlasdata) : "openJsondatacontextPic" == data.isLoad && (MiniFileMgr.ziyuFileTextureData[data.imgReadyUrl] = data.imgNativeUrl)
            }

            static getUrlEncode(url, type) {
                return "arraybuffer" == type ? "" : "utf8"
            }

            static downLoadFile(fileUrl, fileType = "", callBack = null, encoding = "utf8") {
                MiniFileMgr.getFileInfo(fileUrl) ? null != callBack && callBack.runWith([0]) : MiniFileMgr.downLoadFile(fileUrl, fileType, callBack, encoding)
            }

            static remove(fileUrl, callBack = null) {
                MiniFileMgr.deleteFile("", fileUrl, callBack, "", 0)
            }

            static removeAll() {
                MiniFileMgr.deleteAll()
            }

            static hasNativeFile(fileUrl) {
                return MiniFileMgr.isLocalNativeFile(fileUrl)
            }

            static getFileInfo(fileUrl) {
                return MiniFileMgr.getFileInfo(fileUrl)
            }

            static getFileList() {
                return MiniFileMgr.filesListObj
            }

            static exitMiniProgram() {
                MiniAdpter.window.wx.exitMiniProgram()
            }

            static onMkdirCallBack(errorCode, data) {
                errorCode || (MiniFileMgr.filesListObj = JSON.parse(data.data)), MiniFileMgr.fakeObj = MiniFileMgr.filesListObj
            }

            static pixelRatio() {
                if (!MiniAdpter.EnvConfig.pixelRatioInt) try {
                    return MiniAdpter.EnvConfig.pixelRatioInt = MiniAdpter.systemInfo.pixelRatio, MiniAdpter.systemInfo.pixelRatio
                } catch (error) {
                }
                return MiniAdpter.EnvConfig.pixelRatioInt
            }

            static createElement(type) {
                var _source;
                if ("canvas" == type) return 1 == MiniAdpter.idx ? MiniAdpter.isZiYu ? (_source = MiniAdpter.window.sharedCanvas).style = {} : _source = MiniAdpter.window.canvas : _source = MiniAdpter.window.wx.createCanvas(), MiniAdpter.idx++, _source;
                if ("textarea" == type || "input" == type) return MiniAdpter.onCreateInput(type);
                if ("div" == type) {
                    var node = MiniAdpter._preCreateElement(type);
                    return node.contains = function (value) {
                        return null
                    }, node.removeChild = function (value) {
                    }, node
                }
                return MiniAdpter._preCreateElement(type)
            }

            static onCreateInput(type) {
                var node = MiniAdpter._preCreateElement(type);
                return node.focus = MiniInput.wxinputFocus, node.blur = MiniInput.wxinputblur, node.style = {}, node.value = 0, node.parentElement = {}, node.placeholder = {}, node.type = {}, node.setColor = function (value) {
                }, node.setType = function (value) {
                }, node.setFontFace = function (value) {
                }, node.addEventListener = function (value) {
                }, node.contains = function (value) {
                    return null
                }, node.removeChild = function (value) {
                }, node
            }

            static createShaderCondition(conditionScript) {
                return function () {
                    return this[conditionScript.replace("this.", "")]
                }
            }

            static sendAtlasToOpenDataContext(url) {
                if (!MiniAdpter.isZiYu) {
                    var atlasJson = Laya.Loader.getRes(Laya.URL.formatURL(url));
                    if (!atlasJson) throw"传递的url没有获取到对应的图集数据信息，请确保图集已经过！";
                    atlasJson.meta.image.split(",");
                    if (atlasJson.meta && atlasJson.meta.image) for (var toloadPics = atlasJson.meta.image.split(","), split = url.indexOf("/") >= 0 ? "/" : "\\", idx = url.lastIndexOf(split), folderPath = idx >= 0 ? url.substr(0, idx + 1) : "", i = 0, len = toloadPics.length; i < len; i++) toloadPics[i] = folderPath + toloadPics[i]; else toloadPics = [url.replace(".json", ".png")];
                    for (i = 0; i < toloadPics.length; i++) {
                        var tempAtlasPngUrl = toloadPics[i];
                        MiniAdpter.postInfoToContext(url, tempAtlasPngUrl, atlasJson)
                    }
                }
            }

            static postInfoToContext(url, atlaspngUrl, atlasJson) {
                var postData = {frames: atlasJson.frames, meta: atlasJson.meta}, textureUrl = atlaspngUrl,
                    fileObj = MiniFileMgr.getFileInfo(Laya.URL.formatURL(atlaspngUrl));
                if (fileObj) var fileMd5Name = fileObj.md5,
                    fileNativeUrl = MiniFileMgr.getFileNativePath(fileMd5Name); else fileNativeUrl = textureUrl;
                if (!fileNativeUrl) throw"获取图集的磁盘url路径不存在！";
                MiniAdpter.window.wx.postMessage({
                    url: Laya.URL.formatURL(url),
                    atlasdata: postData,
                    imgNativeUrl: fileNativeUrl,
                    imgReadyUrl: textureUrl,
                    isLoad: "opendatacontext"
                })
            }

            static sendSinglePicToOpenDataContext(url) {
                var tempTextureUrl = Laya.URL.formatURL(url), fileObj = MiniFileMgr.getFileInfo(tempTextureUrl);
                if (fileObj) {
                    var fileMd5Name = fileObj.md5, fileNativeUrl = MiniFileMgr.getFileNativePath(fileMd5Name);
                    url = tempTextureUrl
                } else fileNativeUrl = url;
                if (!fileNativeUrl) throw"获取图集的磁盘url路径不存在！";
                MiniAdpter.window.wx.postMessage({
                    url: url,
                    imgNativeUrl: fileNativeUrl,
                    imgReadyUrl: url,
                    isLoad: "openJsondatacontextPic"
                })
            }

            static sendJsonDataToDataContext(url) {
                if (!MiniAdpter.isZiYu) {
                    var atlasJson = Laya.Loader.getRes(url);
                    if (!atlasJson) throw"传递的url没有获取到对应的图集数据信息，请确保图集已经过！";
                    MiniAdpter.window.wx.postMessage({url: url, atlasdata: atlasJson, isLoad: "openJsondatacontext"})
                }
            }
        }

        MiniAdpter._inited = !1, MiniAdpter.autoCacheFile = !0, MiniAdpter.minClearSize = 5242880, MiniAdpter.nativefiles = ["layaNativeDir", "wxlocal"], MiniAdpter.subNativeFiles = [], MiniAdpter.subNativeheads = [], MiniAdpter.subMaps = [], MiniAdpter.AutoCacheDownFile = !1, MiniAdpter.parseXMLFromString = function (value) {
            var rst;
            value = value.replace(/>\s+</g, "><");
            try {
                rst = (new MiniAdpter.window.Parser.DOMParser).parseFromString(value, "text/xml")
            } catch (error) {
                throw"需要引入xml解析库文件"
            }
            return rst
        }, MiniAdpter.idx = 1;

        class MiniAccelerator extends Laya.EventDispatcher {
            constructor() {
                super()
            }

            static __init__() {
                try {
                    var Acc;
                    if (!(Acc = Laya.Accelerator)) return;
                    Acc.prototype.on = MiniAccelerator.prototype.on, Acc.prototype.off = MiniAccelerator.prototype.off
                } catch (e) {
                }
            }

            static startListen(callBack) {
                if (MiniAccelerator._callBack = callBack, !MiniAccelerator._isListening) {
                    MiniAccelerator._isListening = !0;
                    try {
                        MiniAdpter.window.wx.onAccelerometerChange(MiniAccelerator.onAccelerometerChange)
                    } catch (e) {
                    }
                }
            }

            static stopListen() {
                MiniAccelerator._isListening = !1;
                try {
                    MiniAdpter.window.wx.stopAccelerometer({})
                } catch (e) {
                }
            }

            static onAccelerometerChange(res) {
                var e;
                (e = {}).acceleration = res, e.accelerationIncludingGravity = res, e.rotationRate = {}, null != MiniAccelerator._callBack && MiniAccelerator._callBack(e)
            }

            on(type, caller, listener, args = null) {
                return super.on(type, caller, listener, args), MiniAccelerator.startListen(this.onDeviceOrientationChange), this
            }

            off(type, caller, listener, onceOnly = !1) {
                return this.hasListener(type) || MiniAccelerator.stopListen(), super.off(type, caller, listener, onceOnly)
            }
        }

        MiniAccelerator._isListening = !1;

        class MiniImage {
            _loadImage(url) {
                if (MiniAdpter.isZiYu) MiniImage.onCreateImage(url, this, !0); else {
                    var isTransformUrl;
                    if (MiniFileMgr.isLocalNativeFile(url)) {
                        if (-1 == url.indexOf(MiniAdpter.window.wx.env.USER_DATA_PATH) && (-1 != url.indexOf("http://") || -1 != url.indexOf("https://"))) if ("" != MiniFileMgr.loadPath) url = url.split(MiniFileMgr.loadPath)[1]; else {
                            var tempStr = "" != Laya.URL.rootPath ? Laya.URL.rootPath : Laya.URL._basePath,
                                tempUrl = url;
                            "" != tempStr && (url = url.split(tempStr)[1]), url || (url = tempUrl)
                        }
                        if (MiniAdpter.subNativeFiles && 0 == MiniAdpter.subNativeheads.length) for (var key in MiniAdpter.subNativeFiles) {
                            var tempArr = MiniAdpter.subNativeFiles[key];
                            MiniAdpter.subNativeheads = MiniAdpter.subNativeheads.concat(tempArr);
                            for (var aa = 0; aa < tempArr.length; aa++) MiniAdpter.subMaps[tempArr[aa]] = key + "/" + tempArr[aa]
                        }
                        if (MiniAdpter.subNativeFiles && -1 != url.indexOf("/")) {
                            var curfileHead = url.split("/")[0] + "/";
                            if (curfileHead && -1 != MiniAdpter.subNativeheads.indexOf(curfileHead)) {
                                var newfileHead = MiniAdpter.subMaps[curfileHead];
                                url = url.replace(curfileHead, newfileHead)
                            }
                        }
                    } else isTransformUrl = !0, url = Laya.URL.formatURL(url);
                    MiniFileMgr.getFileInfo(url) ? MiniImage.onCreateImage(url, this, !isTransformUrl) : -1 != url.indexOf(MiniAdpter.window.wx.env.USER_DATA_PATH) || -1 == url.indexOf("http://") && -1 == url.indexOf("https://") ? MiniImage.onCreateImage(url, this, !0) : MiniAdpter.isZiYu ? MiniImage.onCreateImage(url, this, !0) : MiniFileMgr.downOtherFiles(url, new Laya.Handler(MiniImage, MiniImage.onDownImgCallBack, [url, this]), url)
                }
            }

            static onDownImgCallBack(sourceUrl, thisLoader, errorCode, tempFilePath = "") {
                errorCode ? thisLoader.onError(null) : MiniImage.onCreateImage(sourceUrl, thisLoader, !1, tempFilePath)
            }

            static onCreateImage(sourceUrl, thisLoader, isLocal = !1, tempFilePath = "") {
                var fileNativeUrl, image;
                if (MiniAdpter.autoCacheFile) if (isLocal) if (MiniAdpter.isZiYu) {
                    var tempUrl = Laya.URL.formatURL(sourceUrl);
                    fileNativeUrl = MiniFileMgr.ziyuFileTextureData[tempUrl] ? MiniFileMgr.ziyuFileTextureData[tempUrl] : sourceUrl
                } else fileNativeUrl = sourceUrl; else if ("" != tempFilePath) fileNativeUrl = tempFilePath; else {
                    var fileMd5Name = MiniFileMgr.getFileInfo(sourceUrl).md5;
                    fileNativeUrl = MiniFileMgr.getFileNativePath(fileMd5Name)
                } else fileNativeUrl = isLocal ? sourceUrl : tempFilePath;

                function clear() {
                    var img = thisLoader._imgCache[fileNativeUrl];
                    img && (img.onload = null, img.onerror = null, delete thisLoader._imgCache[fileNativeUrl])
                }

                null == thisLoader._imgCache && (thisLoader._imgCache = {});
                var onerror = function () {
                    clear(), delete MiniFileMgr.fakeObj[sourceUrl], delete MiniFileMgr.filesListObj[sourceUrl], thisLoader.event(Laya.Event.ERROR, "Load image failed")
                };
                if ("nativeimage" == thisLoader._type) {
                    var onload = function () {
                        clear(), thisLoader.onLoaded(image)
                    };
                    (image = new Laya.Browser.window.Image).crossOrigin = "", image.onload = onload, image.onerror = onerror, image.src = fileNativeUrl, thisLoader._imgCache[fileNativeUrl] = image
                } else {
                    var imageSource = new Laya.Browser.window.Image;
                    onload = function () {
                        (image = Laya.HTMLImage.create(imageSource.width, imageSource.height)).loadImageSource(imageSource, !0), image._setCreateURL(fileNativeUrl), clear(), thisLoader.onLoaded(image)
                    }, imageSource.crossOrigin = "", imageSource.onload = onload, imageSource.onerror = onerror, imageSource.src = fileNativeUrl, thisLoader._imgCache[fileNativeUrl] = imageSource
                }
            }
        }

        class MiniLocation {
            constructor() {
            }

            static __init__() {
                MiniAdpter.window.navigator.geolocation.getCurrentPosition = MiniLocation.getCurrentPosition, MiniAdpter.window.navigator.geolocation.watchPosition = MiniLocation.watchPosition, MiniAdpter.window.navigator.geolocation.clearWatch = MiniLocation.clearWatch
            }

            static getCurrentPosition(success = null, error = null, options = null) {
                var paramO;
                (paramO = {}).success = function (res) {
                    null != success && success(res)
                }, paramO.fail = error, MiniAdpter.window.wx.getLocation(paramO)
            }

            static watchPosition(success = null, error = null, options = null) {
                var curWatchO;
                return MiniLocation._curID++, (curWatchO = {}).success = success, curWatchO.error = error, MiniLocation._watchDic[MiniLocation._curID] = curWatchO, Laya.Laya.systemTimer.loop(1e3, null, MiniLocation._myLoop), MiniLocation._curID
            }

            static clearWatch(id) {
                delete MiniLocation._watchDic[id], MiniLocation._hasWatch() || Laya.Laya.systemTimer.clear(null, MiniLocation._myLoop)
            }

            static _hasWatch() {
                var key;
                for (key in MiniLocation._watchDic) if (MiniLocation._watchDic[key]) return !0;
                return !1
            }

            static _myLoop() {
                MiniLocation.getCurrentPosition(MiniLocation._mySuccess, MiniLocation._myError)
            }

            static _mySuccess(res) {
                var key, rst = {};
                for (key in rst.coords = res, rst.timestamp = Laya.Browser.now(), MiniLocation._watchDic) MiniLocation._watchDic[key].success && MiniLocation._watchDic[key].success(rst)
            }

            static _myError(res) {
                var key;
                for (key in MiniLocation._watchDic) MiniLocation._watchDic[key].error && MiniLocation._watchDic[key].error(res)
            }
        }

        MiniLocation._watchDic = {}, MiniLocation._curID = 0;
        exports.MiniAccelerator = MiniAccelerator, exports.MiniAdpter = MiniAdpter, exports.MiniFileMgr = MiniFileMgr, exports.MiniImage = MiniImage, exports.MiniInput = MiniInput, exports.MiniLoader = MiniLoader, exports.MiniLocalStorage = MiniLocalStorage, exports.MiniLocation = MiniLocation, exports.MiniSound = MiniSound, exports.MiniSoundChannel = MiniSoundChannel, exports.MiniVideo = class {
            constructor(width = 320, height = 240) {
                this.videoend = !1, this.videourl = "", this.videoElement = MiniAdpter.window.wx.createVideo({
                    width: width,
                    height: height,
                    autoplay: !0
                })
            }

            static __init__() {
            }

            on(eventType, ths, callBack) {
                "loadedmetadata" == eventType ? (this.onPlayFunc = callBack.bind(ths), this.videoElement.onPlay = this.onPlayFunction.bind(this)) : "ended" == eventType && (this.onEndedFunC = callBack.bind(ths), this.videoElement.onEnded = this.onEndedFunction.bind(this)), this.videoElement.onTimeUpdate = this.onTimeUpdateFunc.bind(this)
            }

            onTimeUpdateFunc(data) {
                this.position = data.position, this._duration = data.duration
            }

            get duration() {
                return this._duration
            }

            onPlayFunction() {
                this.videoElement && (this.videoElement.readyState = 200), console.log("=====视频加载完成========"), null != this.onPlayFunc && this.onPlayFunc()
            }

            onEndedFunction() {
                this.videoElement && (this.videoend = !0, console.log("=====视频播放完毕========"), null != this.onEndedFunC && this.onEndedFunC())
            }

            off(eventType, ths, callBack) {
                "loadedmetadata" == eventType ? (this.onPlayFunc = callBack.bind(ths), this.videoElement.offPlay = this.onPlayFunction.bind(this)) : "ended" == eventType && (this.onEndedFunC = callBack.bind(ths), this.videoElement.offEnded = this.onEndedFunction.bind(this))
            }

            load(url) {
                this.videoElement && (this.videoElement.src = url)
            }

            play() {
                this.videoElement && (this.videoend = !1, this.videoElement.play())
            }

            pause() {
                this.videoElement && (this.videoend = !0, this.videoElement.pause())
            }

            get currentTime() {
                return this.videoElement ? this.videoElement.initialTime : 0
            }

            set currentTime(value) {
                this.videoElement && (this.videoElement.initialTime = value)
            }

            get videoWidth() {
                return this.videoElement ? this.videoElement.width : 0
            }

            get videoHeight() {
                return this.videoElement ? this.videoElement.height : 0
            }

            get ended() {
                return this.videoend
            }

            get loop() {
                return !!this.videoElement && this.videoElement.loop
            }

            set loop(value) {
                this.videoElement && (this.videoElement.loop = value)
            }

            get playbackRate() {
                return this.videoElement ? this.videoElement.playbackRate : 0
            }

            set playbackRate(value) {
                this.videoElement && (this.videoElement.playbackRate = value)
            }

            get muted() {
                return !!this.videoElement && this.videoElement.muted
            }

            set muted(value) {
                this.videoElement && (this.videoElement.muted = value)
            }

            get paused() {
                return !!this.videoElement && this.videoElement.paused
            }

            size(width, height) {
                this.videoElement && (this.videoElement.width = width, this.videoElement.height = height)
            }

            get x() {
                return this.videoElement ? this.videoElement.x : 0
            }

            set x(value) {
                this.videoElement && (this.videoElement.x = value)
            }

            get y() {
                return this.videoElement ? this.videoElement.y : 0
            }

            set y(value) {
                this.videoElement && (this.videoElement.y = value)
            }

            get currentSrc() {
                return this.videoElement.src
            }

            destroy() {
                this.videoElement && this.videoElement.destroy(), this.videoElement = null, this.onEndedFunC = null, this.onPlayFunc = null, this.videoend = !1, this.videourl = null
            }

            reload() {
                this.videoElement && (this.videoElement.src = this.videourl)
            }
        }
    };
});
define("weapp-adapter.js", function (require, module, exports) {
    !function (modules) {
        var installedModules = {};

        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {exports: {}, id: moduleId, loaded: !1};
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.loaded = !0, module.exports
        }

        __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.p = "", __webpack_require__(0)
    }([function (module, exports, __webpack_require__) {
        "use strict";
        var obj, _window = function (obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                return newObj.default = obj, newObj
            }(__webpack_require__(1)), _HTMLElement = __webpack_require__(4),
            _HTMLElement2 = (obj = _HTMLElement) && obj.__esModule ? obj : {default: obj};
        var global = GameGlobal;
        GameGlobal.__isAdapterInjected || (GameGlobal.__isAdapterInjected = !0, function () {
            _window.addEventListener = function (type, listener) {
                _window.document.addEventListener(type, listener)
            }, _window.removeEventListener = function (type, listener) {
                _window.document.removeEventListener(type, listener)
            }, _window.canvas && (_window.canvas.addEventListener = _window.addEventListener, _window.canvas.removeEventListener = _window.removeEventListener), global.sharedCanvas && (sharedCanvas.__proto__.__proto__ = new _HTMLElement2.default("canvas"), sharedCanvas.addEventListener = _window.addEventListener, sharedCanvas.removeEventListener = _window.removeEventListener);
            var platform = wx.getSystemInfoSync().platform;
            if ("undefined" == typeof __devtoolssubcontext && "devtools" === platform) {
                for (var key in _window) {
                    var descriptor = Object.getOwnPropertyDescriptor(global, key);
                    descriptor && !0 !== descriptor.configurable || Object.defineProperty(window, key, {value: _window[key]})
                }
                for (var _key in _window.document) {
                    var _descriptor = Object.getOwnPropertyDescriptor(global.document, _key);
                    _descriptor && !0 !== _descriptor.configurable || Object.defineProperty(global.document, _key, {value: _window.document[_key]})
                }
                window.parent = window
            } else {
                for (var _key2 in _window) global[_key2] = _window[_key2];
                global.window = _window, window = global, window.top = window.parent = window
            }
        }())
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0}), exports.cancelAnimationFrame = exports.requestAnimationFrame = exports.clearInterval = exports.clearTimeout = exports.setInterval = exports.setTimeout = exports.canvas = exports.location = exports.localStorage = exports.HTMLElement = exports.FileReader = exports.Audio = exports.Image = exports.WebSocket = exports.XMLHttpRequest = exports.navigator = exports.document = void 0;
        var _WindowProperties = __webpack_require__(2);
        Object.keys(_WindowProperties).forEach(function (key) {
            "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                enumerable: !0,
                get: function () {
                    return _WindowProperties[key]
                }
            })
        });
        var _constructor = __webpack_require__(3);
        Object.keys(_constructor).forEach(function (key) {
            "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                enumerable: !0,
                get: function () {
                    return _constructor[key]
                }
            })
        });
        var _Canvas2 = _interopRequireDefault(__webpack_require__(9)), _Util = __webpack_require__(17),
            _document3 = _interopRequireDefault(__webpack_require__(10)),
            _navigator3 = _interopRequireDefault(__webpack_require__(18)),
            _XMLHttpRequest3 = _interopRequireDefault(__webpack_require__(19)),
            _WebSocket3 = _interopRequireDefault(__webpack_require__(20)),
            _Image3 = _interopRequireDefault(__webpack_require__(11)),
            _Audio3 = _interopRequireDefault(__webpack_require__(12)),
            _FileReader3 = _interopRequireDefault(__webpack_require__(21)),
            _HTMLElement3 = _interopRequireDefault(__webpack_require__(4)),
            _localStorage3 = _interopRequireDefault(__webpack_require__(22)),
            _location3 = _interopRequireDefault(__webpack_require__(23));

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {default: obj}
        }

        exports.document = _document3.default, exports.navigator = _navigator3.default, exports.XMLHttpRequest = _XMLHttpRequest3.default, exports.WebSocket = _WebSocket3.default, exports.Image = _Image3.default, exports.Audio = _Audio3.default, exports.FileReader = _FileReader3.default, exports.HTMLElement = _HTMLElement3.default, exports.localStorage = _localStorage3.default, exports.location = _location3.default;
        var canvas = (0, _Util.isSubContext)() ? void 0 : new _Canvas2.default;
        exports.canvas = canvas, exports.setTimeout = setTimeout, exports.setInterval = setInterval, exports.clearTimeout = clearTimeout, exports.clearInterval = clearInterval, exports.requestAnimationFrame = requestAnimationFrame, exports.cancelAnimationFrame = cancelAnimationFrame
    }, function (module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var _wx$getSystemInfoSync = wx.getSystemInfoSync(), screenWidth = _wx$getSystemInfoSync.screenWidth,
            screenHeight = _wx$getSystemInfoSync.screenHeight,
            devicePixelRatio = _wx$getSystemInfoSync.devicePixelRatio, innerWidth = exports.innerWidth = screenWidth,
            innerHeight = exports.innerHeight = screenHeight;
        exports.devicePixelRatio = devicePixelRatio;
        exports.screen = {availWidth: innerWidth, availHeight: innerHeight}, exports.performance = {
            now: function () {
                return Date.now() / 1e3
            }
        }, exports.ontouchstart = null, exports.ontouchmove = null, exports.ontouchend = null
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0}), exports.HTMLCanvasElement = exports.HTMLImageElement = void 0;
        var obj, _HTMLElement3 = __webpack_require__(4),
            _HTMLElement4 = (obj = _HTMLElement3) && obj.__esModule ? obj : {default: obj};

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call
        }

        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass)
        }

        exports.HTMLImageElement = function (_HTMLElement) {
            function HTMLImageElement() {
                return _classCallCheck(this, HTMLImageElement), _possibleConstructorReturn(this, (HTMLImageElement.__proto__ || Object.getPrototypeOf(HTMLImageElement)).call(this, "img"))
            }

            return _inherits(HTMLImageElement, _HTMLElement4.default), HTMLImageElement
        }(), exports.HTMLCanvasElement = function (_HTMLElement2) {
            function HTMLCanvasElement() {
                return _classCallCheck(this, HTMLCanvasElement), _possibleConstructorReturn(this, (HTMLCanvasElement.__proto__ || Object.getPrototypeOf(HTMLCanvasElement)).call(this, "canvas"))
            }

            return _inherits(HTMLCanvasElement, _HTMLElement4.default), HTMLCanvasElement
        }()
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var obj, _createClass = function () {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                    }
                }

                return function (Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
                }
            }(), _Element2 = __webpack_require__(5), _Element3 = (obj = _Element2) && obj.__esModule ? obj : {default: obj},
            _util = __webpack_require__(8), _WindowProperties = __webpack_require__(2);
        var HTMLElement = function (_Element) {
            function HTMLElement() {
                var tagName = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                !function (instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                }(this, HTMLElement);
                var _this = function (self, call) {
                    if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !call || "object" != typeof call && "function" != typeof call ? self : call
                }(this, (HTMLElement.__proto__ || Object.getPrototypeOf(HTMLElement)).call(this));
                return _this.className = "", _this.childern = [], _this.style = {
                    width: _WindowProperties.innerWidth + "px",
                    height: _WindowProperties.innerHeight + "px"
                }, _this.insertBefore = _util.noop, _this.innerHTML = "", _this.tagName = tagName.toUpperCase(), _this
            }

            return function (subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass)
            }(HTMLElement, _Element3.default), _createClass(HTMLElement, [{
                key: "setAttribute",
                value: function (name, value) {
                    this[name] = value
                }
            }, {
                key: "getAttribute", value: function (name) {
                    return this[name]
                }
            }, {
                key: "getBoundingClientRect", value: function () {
                    return {top: 0, left: 0, width: _WindowProperties.innerWidth, height: _WindowProperties.innerHeight}
                }
            }, {
                key: "focus", value: function () {
                }
            }, {
                key: "clientWidth", get: function () {
                    var ret = parseInt(this.style.fontSize, 10) * this.innerHTML.length;
                    return Number.isNaN(ret) ? 0 : ret
                }
            }, {
                key: "clientHeight", get: function () {
                    var ret = parseInt(this.style.fontSize, 10);
                    return Number.isNaN(ret) ? 0 : ret
                }
            }]), HTMLElement
        }();
        exports.default = HTMLElement
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var obj, _Node2 = __webpack_require__(6), _Node3 = (obj = _Node2) && obj.__esModule ? obj : {default: obj};
        var ELement = function (_Node) {
            function ELement() {
                !function (instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                }(this, ELement);
                var _this = function (self, call) {
                    if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !call || "object" != typeof call && "function" != typeof call ? self : call
                }(this, (ELement.__proto__ || Object.getPrototypeOf(ELement)).call(this));
                return _this.className = "", _this.children = [], _this
            }

            return function (subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass)
            }(ELement, _Node3.default), ELement
        }();
        exports.default = ELement
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var obj, _createClass = function () {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                    }
                }

                return function (Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
                }
            }(), _EventTarget2 = __webpack_require__(7),
            _EventTarget3 = (obj = _EventTarget2) && obj.__esModule ? obj : {default: obj};
        var Node = function (_EventTarget) {
            function Node() {
                !function (instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                }(this, Node);
                var _this = function (self, call) {
                    if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !call || "object" != typeof call && "function" != typeof call ? self : call
                }(this, (Node.__proto__ || Object.getPrototypeOf(Node)).call(this));
                return _this.childNodes = [], _this
            }

            return function (subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass)
            }(Node, _EventTarget3.default), _createClass(Node, [{
                key: "appendChild", value: function (node) {
                    if (!(node instanceof Node)) throw new TypeError("Failed to executed 'appendChild' on 'Node': parameter 1 is not of type 'Node'.");
                    this.childNodes.push(node)
                }
            }, {
                key: "cloneNode", value: function () {
                    var copyNode = Object.create(this);
                    return Object.assign(copyNode, this), copyNode
                }
            }, {
                key: "removeChild", value: function (node) {
                    var index = this.childNodes.findIndex(function (child) {
                        return child === node
                    });
                    return index > -1 ? this.childNodes.splice(index, 1) : null
                }
            }]), Node
        }();
        exports.default = Node
    }, function (module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var _createClass = function () {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                }
            }

            return function (Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
            }
        }();
        var _events = new WeakMap, EventTarget = function () {
            function EventTarget() {
                !function (instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                }(this, EventTarget), _events.set(this, {})
            }

            return _createClass(EventTarget, [{
                key: "addEventListener", value: function (type, listener) {
                    var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                        events = _events.get(this);
                    events || (events = {}, _events.set(this, events)), events[type] || (events[type] = []), events[type].push(listener), options.capture && console.warn("EventTarget.addEventListener: options.capture is not implemented."), options.once && console.warn("EventTarget.addEventListener: options.once is not implemented."), options.passive && console.warn("EventTarget.addEventListener: options.passive is not implemented.")
                }
            }, {
                key: "removeEventListener", value: function (type, listener) {
                    var listeners = _events.get(this)[type];
                    if (listeners && listeners.length > 0) for (var i = listeners.length; i--; i > 0) if (listeners[i] === listener) {
                        listeners.splice(i, 1);
                        break
                    }
                }
            }, {
                key: "dispatchEvent", value: function () {
                    var event = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        listeners = _events.get(this)[event.type];
                    if (listeners) for (var i = 0; i < listeners.length; i++) listeners[i](event)
                }
            }]), EventTarget
        }();
        exports.default = EventTarget
    }, function (module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0}), exports.noop = function () {
        }, exports.isSubContext = function () {
            return "undefined" != typeof GameGlobal && !0 === GameGlobal.__isSubContext
        }
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0}), exports.default = function () {
            var canvas = wx.createCanvas();
            canvas.type = "canvas", canvas.__proto__.__proto__ = new _HTMLElement2.default("canvas");
            canvas.getContext;
            return canvas.getBoundingClientRect = function () {
                return {top: 0, left: 0, width: window.innerWidth, height: window.innerHeight}
            }, canvas
        };
        __webpack_require__(3);
        var _HTMLElement2 = _interopRequireDefault(__webpack_require__(4));
        _interopRequireDefault(__webpack_require__(10));

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {default: obj}
        }
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var window = function (obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                return newObj.default = obj, newObj
            }(__webpack_require__(1)), _HTMLElement2 = _interopRequireDefault(__webpack_require__(4)),
            _Image2 = _interopRequireDefault(__webpack_require__(11)),
            _Audio2 = _interopRequireDefault(__webpack_require__(12)),
            _Canvas2 = _interopRequireDefault(__webpack_require__(9));

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {default: obj}
        }

        __webpack_require__(15);
        var events = {}, document = {
            readyState: "complete",
            visibilityState: "visible",
            documentElement: window,
            hidden: !1,
            style: {},
            location: window.location,
            ontouchstart: null,
            ontouchmove: null,
            ontouchend: null,
            head: new _HTMLElement2.default("head"),
            body: new _HTMLElement2.default("body"),
            createElement: function (tagName) {
                return "canvas" === tagName ? new _Canvas2.default : "audio" === tagName ? new _Audio2.default : "img" === tagName ? new _Image2.default : new _HTMLElement2.default(tagName)
            },
            getElementById: function (id) {
                return id === window.canvas.id ? window.canvas : null
            },
            getElementsByTagName: function (tagName) {
                return "head" === tagName ? [document.head] : "body" === tagName ? [document.body] : "canvas" === tagName ? [window.canvas] : []
            },
            querySelector: function (query) {
                return "head" === query ? document.head : "body" === query ? document.body : "canvas" === query ? window.canvas : query === "#" + window.canvas.id ? window.canvas : null
            },
            querySelectorAll: function (query) {
                return "head" === query ? [document.head] : "body" === query ? [document.body] : "canvas" === query ? [window.canvas] : []
            },
            addEventListener: function (type, listener) {
                events[type] || (events[type] = []), events[type].push(listener)
            },
            removeEventListener: function (type, listener) {
                var listeners = events[type];
                if (listeners && listeners.length > 0) for (var i = listeners.length; i--; i > 0) if (listeners[i] === listener) {
                    listeners.splice(i, 1);
                    break
                }
            },
            dispatchEvent: function (event) {
                var listeners = events[event.type];
                if (listeners) for (var i = 0; i < listeners.length; i++) listeners[i](event)
            }
        };
        exports.default = document
    }, function (module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0}), exports.default = function () {
            return wx.createImage()
        }
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var obj, _createClass = function () {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                    }
                }

                return function (Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
                }
            }(), _HTMLAudioElement2 = __webpack_require__(13),
            _HTMLAudioElement3 = (obj = _HTMLAudioElement2) && obj.__esModule ? obj : {default: obj},
            _util = __webpack_require__(8);

        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call
        }

        var HAVE_NOTHING = 0, HAVE_METADATA = 1, HAVE_CURRENT_DATA = 2, HAVE_FUTURE_DATA = 3, HAVE_ENOUGH_DATA = 4,
            _innerAudioContext = new WeakMap, _src = new WeakMap,
            Audio = (new WeakMap, new WeakMap, function (_HTMLAudioElement) {
                function Audio(url) {
                    !function (instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                    }(this, Audio);
                    var _this = _possibleConstructorReturn(this, (Audio.__proto__ || Object.getPrototypeOf(Audio)).call(this));
                    if (_this.HAVE_NOTHING = HAVE_NOTHING, _this.HAVE_METADATA = HAVE_METADATA, _this.HAVE_CURRENT_DATA = HAVE_CURRENT_DATA, _this.HAVE_FUTURE_DATA = HAVE_FUTURE_DATA, _this.HAVE_ENOUGH_DATA = HAVE_ENOUGH_DATA, _this.readyState = HAVE_NOTHING, (0, _util.isSubContext)()) return console.warn("HTMLAudioElement is not supported in SubContext."), _possibleConstructorReturn(_this);
                    _src.set(_this, "");
                    var innerAudioContext = wx.createInnerAudioContext();
                    return _innerAudioContext.set(_this, innerAudioContext), innerAudioContext.onCanplay(function () {
                        _this.dispatchEvent({type: "load"}), _this.dispatchEvent({type: "loadend"}), _this.dispatchEvent({type: "canplay"}), _this.dispatchEvent({type: "canplaythrough"}), _this.dispatchEvent({type: "loadedmetadata"}), _this.readyState = HAVE_CURRENT_DATA
                    }), innerAudioContext.onPlay(function () {
                        _this.dispatchEvent({type: "play"})
                    }), innerAudioContext.onPause(function () {
                        _this.dispatchEvent({type: "pause"})
                    }), innerAudioContext.onEnded(function () {
                        _this.dispatchEvent({type: "ended"}), _this.readyState = HAVE_ENOUGH_DATA
                    }), innerAudioContext.onError(function () {
                        _this.dispatchEvent({type: "error"})
                    }), url && (_innerAudioContext.get(_this).src = url), _this
                }

                return function (subClass, superClass) {
                    if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass)
                }(Audio, _HTMLAudioElement3.default), _createClass(Audio, [{
                    key: "load", value: function () {
                        console.warn("HTMLAudioElement.load() is not implemented.")
                    }
                }, {
                    key: "play", value: function () {
                        (0, _util.isSubContext)() || _innerAudioContext.get(this).play()
                    }
                }, {
                    key: "pause", value: function () {
                        (0, _util.isSubContext)() || _innerAudioContext.get(this).pause()
                    }
                }, {
                    key: "canPlayType", value: function () {
                        var mediaType = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return "string" != typeof mediaType ? "" : mediaType.indexOf("audio/mpeg") > -1 || mediaType.indexOf("audio/mp4") ? "probably" : ""
                    }
                }, {
                    key: "cloneNode", value: function () {
                        var newAudio = new Audio;
                        return (0, _util.isSubContext)() || (newAudio.loop = _innerAudioContext.get(this).loop, newAudio.autoplay = _innerAudioContext.get(this).loop, newAudio.src = this.src), newAudio
                    }
                }, {
                    key: "currentTime", get: function () {
                        return (0, _util.isSubContext)() ? 0 : _innerAudioContext.get(this).currentTime
                    }, set: function (value) {
                        (0, _util.isSubContext)() || _innerAudioContext.get(this).seek(value)
                    }
                }, {
                    key: "src", get: function () {
                        return _src.get(this)
                    }, set: function (value) {
                        _src.set(this, value), (0, _util.isSubContext)() || (_innerAudioContext.get(this).src = value)
                    }
                }, {
                    key: "loop", get: function () {
                        return !(0, _util.isSubContext)() && _innerAudioContext.get(this).loop
                    }, set: function (value) {
                        (0, _util.isSubContext)() || (_innerAudioContext.get(this).loop = value)
                    }
                }, {
                    key: "autoplay", get: function () {
                        return !(0, _util.isSubContext)() && _innerAudioContext.get(this).autoplay
                    }, set: function (value) {
                        (0, _util.isSubContext)() || (_innerAudioContext.get(this).autoplay = value)
                    }
                }, {
                    key: "paused", get: function () {
                        return !(0, _util.isSubContext)() && _innerAudioContext.get(this).paused
                    }
                }]), Audio
            }());
        exports.default = Audio
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var obj, _HTMLMediaElement2 = __webpack_require__(14),
            _HTMLMediaElement3 = (obj = _HTMLMediaElement2) && obj.__esModule ? obj : {default: obj};
        var HTMLAudioElement = function (_HTMLMediaElement) {
            function HTMLAudioElement() {
                return function (instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                }(this, HTMLAudioElement), function (self, call) {
                    if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !call || "object" != typeof call && "function" != typeof call ? self : call
                }(this, (HTMLAudioElement.__proto__ || Object.getPrototypeOf(HTMLAudioElement)).call(this, "audio"))
            }

            return function (subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass)
            }(HTMLAudioElement, _HTMLMediaElement3.default), HTMLAudioElement
        }();
        exports.default = HTMLAudioElement
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var obj, _createClass = function () {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                    }
                }

                return function (Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
                }
            }(), _HTMLElement2 = __webpack_require__(4),
            _HTMLElement3 = (obj = _HTMLElement2) && obj.__esModule ? obj : {default: obj};
        var HTMLMediaElement = function (_HTMLElement) {
            function HTMLMediaElement(type) {
                return function (instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                }(this, HTMLMediaElement), function (self, call) {
                    if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !call || "object" != typeof call && "function" != typeof call ? self : call
                }(this, (HTMLMediaElement.__proto__ || Object.getPrototypeOf(HTMLMediaElement)).call(this, type))
            }

            return function (subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass)
            }(HTMLMediaElement, _HTMLElement3.default), _createClass(HTMLMediaElement, [{
                key: "addTextTrack",
                value: function () {
                }
            }, {
                key: "captureStream", value: function () {
                }
            }, {
                key: "fastSeek", value: function () {
                }
            }, {
                key: "load", value: function () {
                }
            }, {
                key: "pause", value: function () {
                }
            }, {
                key: "play", value: function () {
                }
            }]), HTMLMediaElement
        }();
        exports.default = HTMLMediaElement
    }, function (module, exports, __webpack_require__) {
        "use strict";
        __webpack_require__(16)
    }, function (module, exports, __webpack_require__) {
        "use strict";
        var obj, window = function (obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                return newObj.default = obj, newObj
            }(__webpack_require__(1)), _document = __webpack_require__(10),
            _document2 = (obj = _document) && obj.__esModule ? obj : {default: obj}, _util = __webpack_require__(8);
        var TouchEvent = function TouchEvent(type) {
            !function (instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
            }(this, TouchEvent), this.target = window.canvas, this.currentTarget = window.canvas, this.touches = [], this.targetTouches = [], this.changedTouches = [], this.preventDefault = _util.noop, this.stopPropagation = _util.noop, this.type = type
        };

        function touchEventHandlerFactory(type) {
            return function (event) {
                var touchEvent = new TouchEvent(type);
                touchEvent.touches = event.touches, touchEvent.targetTouches = Array.prototype.slice.call(event.touches), touchEvent.changedTouches = event.changedTouches, touchEvent.timeStamp = event.timeStamp, _document2.default.dispatchEvent(touchEvent)
            }
        }

        wx.onTouchStart(touchEventHandlerFactory("touchstart")), wx.onTouchMove(touchEventHandlerFactory("touchmove")), wx.onTouchEnd(touchEventHandlerFactory("touchend")), wx.onTouchCancel(touchEventHandlerFactory("touchcancel"))
    }, function (module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0}), exports.noop = function () {
        }, exports.isSubContext = function () {
            return "undefined" != typeof GameGlobal && !0 === GameGlobal.__isSubContext
        }
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var _util = __webpack_require__(8), navigator = {
            platform: wx.getSystemInfoSync().platform,
            language: "zh-cn",
            appVersion: "5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1",
            userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E8301 MicroMessenger/6.6.0 MiniGame NetType/WIFI Language/zh_CN",
            onLine: !0,
            geolocation: {getCurrentPosition: _util.noop, watchPosition: _util.noop, clearWatch: _util.noop}
        };
        exports.default = navigator
    }, function (module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var _createClass = function () {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                }
            }

            return function (Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
            }
        }();
        var _url = new WeakMap, _method = new WeakMap, _requestHeader = new WeakMap, _responseHeader = new WeakMap,
            _requestTask = new WeakMap;

        function _triggerEvent(type) {
            if ("function" == typeof this["on" + type]) {
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                this["on" + type].apply(this, args)
            }
        }

        function _changeReadyState(readyState) {
            this.readyState = readyState, _triggerEvent.call(this, "readystatechange")
        }

        var XMLHttpRequest = function () {
            function XMLHttpRequest() {
                !function (instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                }(this, XMLHttpRequest), this.onabort = null, this.onerror = null, this.onload = null, this.onloadstart = null, this.onprogress = null, this.ontimeout = null, this.onloadend = null, this.onreadystatechange = null, this.readyState = 0, this.response = null, this.responseText = null, this.responseType = "", this.responseXML = null, this.status = 0, this.statusText = "", this.upload = {}, this.withCredentials = !1, _requestHeader.set(this, {"content-type": "application/x-www-form-urlencoded"}), _responseHeader.set(this, {})
            }

            return _createClass(XMLHttpRequest, [{
                key: "abort", value: function () {
                    var myRequestTask = _requestTask.get(this);
                    myRequestTask && myRequestTask.abort()
                }
            }, {
                key: "getAllResponseHeaders", value: function () {
                    var responseHeader = _responseHeader.get(this);
                    return Object.keys(responseHeader).map(function (header) {
                        return header + ": " + responseHeader[header]
                    }).join("\n")
                }
            }, {
                key: "getResponseHeader", value: function (header) {
                    return _responseHeader.get(this)[header]
                }
            }, {
                key: "open", value: function (method, url) {
                    _method.set(this, method), _url.set(this, url), _changeReadyState.call(this, XMLHttpRequest.OPENED)
                }
            }, {
                key: "overrideMimeType", value: function () {
                }
            }, {
                key: "send", value: function () {
                    var _this = this, data = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                    if (this.readyState !== XMLHttpRequest.OPENED) throw new Error("Failed to execute 'send' on 'XMLHttpRequest': The object's state must be OPENED.");
                    wx.request({
                        data: data,
                        url: _url.get(this),
                        method: _method.get(this),
                        header: _requestHeader.get(this),
                        responseType: this.responseType,
                        success: function (_ref) {
                            var data = _ref.data, statusCode = _ref.statusCode, header = _ref.header;
                            if ("string" != typeof data && !(data instanceof ArrayBuffer)) try {
                                data = JSON.stringify(data)
                            } catch (e) {
                                data = data
                            }
                            if (_this.status = statusCode, _responseHeader.set(_this, header), _triggerEvent.call(_this, "loadstart"), _changeReadyState.call(_this, XMLHttpRequest.HEADERS_RECEIVED), _changeReadyState.call(_this, XMLHttpRequest.LOADING), _this.response = data, data instanceof ArrayBuffer) {
                                _this.responseText = "";
                                for (var bytes = new Uint8Array(data), len = bytes.byteLength, i = 0; i < len; i++) _this.responseText += String.fromCharCode(bytes[i])
                            } else _this.responseText = data;
                            _changeReadyState.call(_this, XMLHttpRequest.DONE), _triggerEvent.call(_this, "load"), _triggerEvent.call(_this, "loadend")
                        },
                        fail: function (_ref2) {
                            var errMsg = _ref2.errMsg;
                            -1 !== errMsg.indexOf("abort") ? _triggerEvent.call(_this, "abort") : _triggerEvent.call(_this, "error", errMsg), _triggerEvent.call(_this, "loadend")
                        }
                    })
                }
            }, {
                key: "setRequestHeader", value: function (header, value) {
                    var myHeader = _requestHeader.get(this);
                    myHeader[header] = value, _requestHeader.set(this, myHeader)
                }
            }]), XMLHttpRequest
        }();
        XMLHttpRequest.UNSEND = 0, XMLHttpRequest.OPENED = 1, XMLHttpRequest.HEADERS_RECEIVED = 2, XMLHttpRequest.LOADING = 3, XMLHttpRequest.DONE = 4, exports.default = XMLHttpRequest
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var _createClass = function () {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                }
            }

            return function (Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
            }
        }(), _util = __webpack_require__(8);
        var _socketTask = new WeakMap, WebSocket = function () {
            function WebSocket(url) {
                var _this = this, protocols = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                if (function (instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                }(this, WebSocket), this.binaryType = "", this.bufferedAmount = 0, this.extensions = "", this.onclose = null, this.onerror = null, this.onmessage = null, this.onopen = null, this.protocol = "", this.readyState = 3, (0, _util.isSubContext)()) throw new Error("WebSocket is not supported in SubContext.");
                if ("string" != typeof url || !/(^ws:\/\/)|(^wss:\/\/)/.test(url)) throw new TypeError("Failed to construct 'WebSocket': The URL '" + url + "' is invalid");
                this.url = url, this.readyState = WebSocket.CONNECTING;
                var socketTask = wx.connectSocket({
                    url: url,
                    protocols: Array.isArray(protocols) ? protocols : [protocols]
                });
                return _socketTask.set(this, socketTask), socketTask.onClose(function (res) {
                    _this.readyState = WebSocket.CLOSED, "function" == typeof _this.onclose && _this.onclose(res)
                }), socketTask.onMessage(function (res) {
                    "function" == typeof _this.onmessage && _this.onmessage(res)
                }), socketTask.onOpen(function () {
                    _this.readyState = WebSocket.OPEN, "function" == typeof _this.onopen && _this.onopen()
                }), socketTask.onError(function (res) {
                    "function" == typeof _this.onerror && _this.onerror(new Error(res.errMsg))
                }), this
            }

            return _createClass(WebSocket, [{
                key: "close", value: function (code, reason) {
                    this.readyState = WebSocket.CLOSING, _socketTask.get(this).close({code: code, reason: reason})
                }
            }, {
                key: "send", value: function (data) {
                    if ("string" != typeof data && !(data instanceof ArrayBuffer)) throw new TypeError("Failed to send message: The data " + data + " is invalid");
                    _socketTask.get(this).send({data: data})
                }
            }]), WebSocket
        }();
        WebSocket.CONNECTING = 0, WebSocket.OPEN = 1, WebSocket.CLOSING = 2, WebSocket.CLOSED = 3, exports.default = WebSocket
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var _createClass = function () {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                }
            }

            return function (Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
            }
        }(), _util = __webpack_require__(8);
        var FileReader = function () {
            function FileReader() {
                !function (instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                }(this, FileReader)
            }

            return _createClass(FileReader, [{
                key: "construct", value: function () {
                    if ((0, _util.isSubContext)()) throw new Error("FileReader is not supported in SubContext.")
                }
            }]), FileReader
        }();
        exports.default = FileReader
    }, function (module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        var _util = __webpack_require__(8), mainContext = {
            get length() {
                return wx.getStorageInfoSync().keys.length
            }, key: function (n) {
                return wx.getStorageInfoSync().keys[n]
            }, getItem: function (key) {
                return wx.getStorageSync(key)
            }, setItem: function (key, value) {
                return wx.setStorageSync(key, value)
            }, removeItem: function (key) {
                wx.removeStorageSync(key)
            }, clear: function () {
                wx.clearStorageSync()
            }
        }, memLocalStorage = {}, subContext = {
            get length() {
                return Object.keys(memLocalStorage).length
            }, key: function (n) {
                return Object.keys(memLocalStorage)[n]
            }, getItem: function (key) {
                return memLocalStorage[key]
            }, setItem: function (key, value) {
                memLocalStorage[key] = value
            }, removeItem: function (key) {
                delete memLocalStorage[key]
            }, clear: function () {
                memLocalStorage = {}
            }
        }, localStorage = (0, _util.isSubContext)() ? subContext : mainContext;
        exports.default = localStorage
    }, function (module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {value: !0});
        exports.default = {
            href: "game.js", reload: function () {
            }
        }
    }]);
});
var global = (function () {
    return this
})();
var pluginInfoMap = {};
;global.requirePlugin = global.requirePlugin || function (path) {
    var position = path.indexOf('/');
    var alias = '';
    var pagePath = '';
    if (position !== -1) {
        alias = path.substr(0, position);
        pagePath = path.substr(position + 1, path.length);
    } else {
        alias = path;
    }
    if (pluginInfoMap.hasOwnProperty(alias)) {
        var realPath = '';
        if (pagePath.length === 0) {
            realPath = '__plugin__/' + pluginInfoMap[alias].appid;
            return require(realPath);
        } else {
            realPath = '__plugin__/' + pluginInfoMap[alias].appid + '/' + pagePath;
            return require(realPath);
        }
    } else {
        console.error('not found alias: ', alias);
        throw new Error('Plugin ' + alias + ' is not defined.')
    }
};
define("game.js", function (require, module, exports) {
    "undefined" != typeof swan && "undefined" != typeof swanGlobal ? (require("swan-game-adapter.js"), require("libs/laya.bdmini.js")) : "undefined" != typeof wx && (require("weapp-adapter.js"), require("libs/laya.wxmini.js")), window.loadLib = require, require("index.js");
});
require("game.js");
 	